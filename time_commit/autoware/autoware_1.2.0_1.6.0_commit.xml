<?xml version="1.0" encoding="utf-8"?>
<Root>
	<commit hash="39a5250fc663475af8bb1f1cb69894fa6303f729" fix_time="1,59593">
		<msg>Fixes for GPU Euclidean clustering</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/euclidean_cluster/includes/gpu_euclidean_clustering.h" new_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/euclidean_cluster/includes/gpu_euclidean_clustering.h">
				<diff>@@ -24,8 +24,8 @@ public:
 	void setThreshold(double threshold);
 	void setMinClusterPts(int min_cluster_pts);
 	void setMaxClusterPts(int max_cluster_pts);
+	void extractClustersOld();
 	void extractClusters();
-	void extractClusters2();
 	std::vector&lt;GClusterIndex&gt; getOutput();
 
 	SamplePointListXYZ generateSample();
</diff>
				<old_file>#ifndef GPU_EUCLIDEAN_H_
#define GPU_EUCLIDEAN_H_

#include &lt;iostream&gt;
#include &lt;vector&gt;

class GpuEuclideanCluster {
public:
	typedef struct {
		int index_value;
		std::vector&lt;int&gt; points_in_cluster;
	} GClusterIndex;

	typedef struct {
		float *x;
		float *y;
		float *z;
		int size;
	} SamplePointListXYZ;

	GpuEuclideanCluster();

	void setInputPoints(float *x, float *y, float *z, int size);
	void setThreshold(double threshold);
	void setMinClusterPts(int min_cluster_pts);
	void setMaxClusterPts(int max_cluster_pts);
	void extractClusters();
	void extractClusters2();
	std::vector&lt;GClusterIndex&gt; getOutput();

	SamplePointListXYZ generateSample();

	~GpuEuclideanCluster();

private:
	float *x_, *y_, *z_;
	int size_;
	double threshold_;
	int *cluster_indices_;
	int *cluster_indices_host_;
	int min_cluster_pts_;
	int max_cluster_pts_;
	int cluster_num_;


	void exclusiveScan(int *input, int ele_num, int *sum);
};

#endif
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="0fccd8175a9d42fa9d626ce29d44e964767ac1b4" fix_time="0,0">
		<msg>Add roi_extractor.launch to make handling parameter easy

And fixed small bug to get parameter from ROS private parameter server</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/roi_extractor/roi_extractor.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/roi_extractor/roi_extractor.cpp">
				<diff>@@ -179,7 +179,7 @@ int main (int argc, char *argv[]) {
   ros::init(argc, argv, &quot;roi_extractor&quot;);
 
   // Get source topic name of image from ROS private parameter
-  ros::NodeHandle private_node_handler;
+  ros::NodeHandle private_node_handler(&quot;~&quot;);
   std::string image_topic_name;
   std::string target_directory_name = std::string(getenv(&quot;HOME&quot;)) + &quot;/.autoware&quot;;
   int minimum_height = 32;
</diff>
				<old_file>#include &quot;roi_extractor.h&quot;

#include &lt;sys/stat.h&gt;
#include &lt;dirent.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;opencv2/opencv.hpp&gt;


#include &quot;Context.h&quot;
#include &quot;road_wizard/Signals.h&quot;


void RoiExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
  // Acquire frame image from ros topic
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
  frame_ = cv_image-&gt;image.clone();

  // Save this topic's time stamp so that same image will not be processed more than twice
  frame_timestamp_ = image.header.stamp;
} // void RoiExtractor::ImageRawCallback()


void RoiExtractor::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
  // If frame image has not been updated, do nothing
  if (frame_timestamp_ == previous_timestamp_) {
    return;
  }

  // Aquire signal positions from ros topic
  std::vector&lt;Context&gt; signal_positions;
  Context::SetContexts(signal_positions, extracted_pos, frame_.rows, frame_.cols);

  if (signal_positions.size() == 0) {
    // If signal_positions is empty, no ROI images should be saved
    return;
  }

  // Extract ROI for top signal in vector (top signal has largest estimated radius in every signals projected in a image)
  cv::Mat roi = frame_(cv::Rect(signal_positions.at(0).topLeft, signal_positions.at(0).botRight));
  std::string file_name = target_directory_ + std::to_string(file_count_) + &quot;.png&quot;;

  // Reject image if its height is smaller than threshold
  if (roi.size().height &lt; k_minimum_height_) {
    return;
  }

  // Reject image if its similarity level with previous saved ROI is higher than threshold 
  if (k_similarity_threshold_ &lt; CalculateSimilarity(roi, previous_saved_frame_)) {
    return;
  }

  cv::imwrite(file_name.c_str(), roi);
  file_count_++;
  
  previous_timestamp_ = frame_timestamp_;
  previous_saved_frame_ = roi.clone();
} // void RoiExtractor::RoiSignalCallback()


void RoiExtractor::CreateTargetDirectory(std::string base_name) {
  // Extracted ROI's images will be saved in &quot;[base_name]/tlr_TrainingDataSet/Images&quot;
  std::string target_directory_name = base_name + &quot;/tlr_TrainingDataSet/Images/&quot;;
  
  // Create target directory newly if it doesn't exist
  struct stat directory_info;
  if (stat(target_directory_name.c_str(), &amp;directory_info) != 0) {
    MakeDirectoryTree(target_directory_name, base_name, 0755);
  }

  // Count the number of files contained in the target directory
  // so that saved file is named in continuous number
  file_count_ = CountFileNum(target_directory_name);


  // Save directory name into class member
  target_directory_ = target_directory_name;

} // void RoiExtractor::CreateTargetDirectory


int RoiExtractor::CountFileNum(std::string directory_name) {
  int file_num = 0;
  struct dirent *entry;
  DIR *directory_handler = opendir(directory_name.c_str());

  // Count the number of files contained in the specified directory
  while ((entry = readdir(directory_handler)) != NULL) {
    struct stat status;
    std::string absolute_path = directory_name + std::string(entry-&gt;d_name);
    if (stat(absolute_path.c_str(), &amp;status) == 0 &amp;&amp;
        S_ISREG(status.st_mode)) {
      file_num++;
    }
  }

  closedir(directory_handler);

  return file_num;
} //int RoiExtractor::CountFileNum()


void RoiExtractor::MakeDirectoryTree(const std::string &amp;target,
                                     const std::string &amp;base,
                                     const mode_t &amp;mode) {
  // Extract directory subtree structure
  std::string sub_tree = target.substr(base.size());

  // Create directory tree one by one
  size_t separator_start = sub_tree.find(&quot;/&quot;);
  size_t separator_end = sub_tree.find(&quot;/&quot;, separator_start + 1);
  std::string path = base;
  while (separator_end != std::string::npos) {
    std::string sub_directory = sub_tree.substr(separator_start, separator_end);
    path = path + sub_directory;
    mkdir(path.c_str(), mode);
    separator_start = separator_end;
    separator_end = sub_tree.find(&quot;/&quot;, separator_start + 1);
  }
} // void RoiExtractor::MakeDirectoryTree()


// calculae similarity of specified two images
// by comparing their histogram, which is sensitive filter for color
double RoiExtractor::CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;image2) {
  if (image1.empty() || image2.empty()) {
    return 0.0;
  }

  // Compare by histogram
  cv::Mat image1_hsv, image2_hsv;
  cv::cvtColor(image1, image1_hsv, CV_BGR2HSV);
  cv::cvtColor(image2, image2_hsv, CV_BGR2HSV);

  const int channel[] = {0};

  // Hue range in OpenCV is 0 to 180
  const float hue_ranges[] = {0, 180};
  const float* ranges[] = {hue_ranges};

  // Quantize hue value into 6
  int hist_size[] = {6};

  cv::Mat histogram1;
  cv::calcHist(&amp;image1_hsv,
               1,               // Use this image only to create histogram
               channel,
               cv::Mat(),       // No mask is used
               histogram1,
               1,               // The dimension of histogram is 1
               hist_size,
               ranges);

   cv::Mat histogram2;
   cv::calcHist(&amp;image2_hsv,
                1,              // Use this image only to create histogram
                channel,
                cv::Mat(),      // No mask is used
                histogram2,
                1,              // The dimension of histogram is 1
                hist_size,
                ranges);

   double similarity = cv::compareHist(histogram1, histogram2, CV_COMP_CORREL);

   return similarity;
} // void RoiExtractor::CalculateSimilarity()


// Entry Point of this node
int main (int argc, char *argv[]) {
  // Initialize ROS node
  ros::init(argc, argv, &quot;roi_extractor&quot;);

  // Get source topic name of image from ROS private parameter
  ros::NodeHandle private_node_handler;
  std::string image_topic_name;
  std::string target_directory_name = std::string(getenv(&quot;HOME&quot;)) + &quot;/.autoware&quot;;
  int minimum_height = 32;
  double similarity_threshold = 0.9;
  private_node_handler.param&lt;std::string&gt;(&quot;image_raw_topic&quot;, image_topic_name, &quot;/image_raw&quot;);
  private_node_handler.param&lt;std::string&gt;(&quot;target_directory&quot;, target_directory_name, target_directory_name);
  private_node_handler.param&lt;int&gt;(&quot;minimum_height&quot;, minimum_height, 32); // The default minimum height is 32
  private_node_handler.param&lt;double&gt;(&quot;similarity_threshold&quot;, similarity_threshold, 0.9); // The default similarity threshold is 0.9

  // Get directory name which roi images will be saved
  RoiExtractor extractor(minimum_height, similarity_threshold);
  extractor.CreateTargetDirectory(target_directory_name);

  // Launch callback function to subscribe images and signal position
  ros::NodeHandle node_handler;
  ros::Subscriber image_subscriber = node_handler.subscribe(image_topic_name,
                                                            1,
                                                            &amp;RoiExtractor::ImageRawCallback,
                                                            &amp;extractor);

  ros::Subscriber roi_signal_subscriber = node_handler.subscribe(&quot;/roi_signal&quot;,
                                                                 1,
                                                                 &amp;RoiExtractor::RoiSignalCallback,
                                                                 &amp;extractor);
  
  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="bd68ddf18e2e171b5c4bf12e6ef7fcd275733c04" fix_time="0,1">
		<msg>Modify State Transition Matrix of TLR for more precise recognition

* w.r.t `region_tlr`, just fixed comment
* w.r.t `region_tlr_ssd`, applied manner of erring on the side of caution</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr/TrafficLightDetector.h" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr/TrafficLightDetector.h">
				<diff>@@ -16,7 +16,7 @@
 #define MY_COLOR_WHITE	cv::Scalar(255,255,255)
 
 const LightState STATE_TRANSITION_MATRIX[4][8] = {
-	/* current RYG: 000, 001, 010, 011, 100, 101, 110, 111 */
+	/* current GYR: 000, 001, 010, 011, 100, 101, 110, 111 */
 	{ GREEN,     UNDEFINED, YELLOW,    YELLOW, GREEN,     GREEN,     YELLOW, UNDEFINED }, /* pre = GREEN  */
 	{ YELLOW,    RED,       YELLOW,    RED,    UNDEFINED, UNDEFINED, YELLOW, UNDEFINED }, /* pre = YELLOW */
 	{ RED,       RED,       UNDEFINED, RED,    GREEN,     RED,       GREEN,  UNDEFINED }, /* pre = RED */
</diff>
				<old_file>#ifndef TRAFFIC_LIGHT_DETECTOR_H
#define TRAFFIC_LIGHT_DETECTOR_H

#include &lt;vector&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/features2d/features2d.hpp&gt;
#include &quot;Context.h&quot;

#define MY_COLOR_PURPLE	cv::Scalar(255,0,255)
#define MY_COLOR_RED	cv::Scalar(0,0,255)
#define MY_COLOR_GREEN	cv::Scalar(0,255,0)
#define MY_COLOR_YELLOW	cv::Scalar(60,255,255)
#define MY_COLOR_BLUE	cv::Scalar(255,0,0)
#define MY_COLOR_WHITE	cv::Scalar(255,255,255)

const LightState STATE_TRANSITION_MATRIX[4][8] = {
	/* current RYG: 000, 001, 010, 011, 100, 101, 110, 111 */
	{ GREEN,     UNDEFINED, YELLOW,    YELLOW, GREEN,     GREEN,     YELLOW, UNDEFINED }, /* pre = GREEN  */
	{ YELLOW,    RED,       YELLOW,    RED,    UNDEFINED, UNDEFINED, YELLOW, UNDEFINED }, /* pre = YELLOW */
	{ RED,       RED,       UNDEFINED, RED,    GREEN,     RED,       GREEN,  UNDEFINED }, /* pre = RED */
	{ UNDEFINED, RED,       YELLOW,    RED,    GREEN,     RED,       YELLOW, UNDEFINED }  /* pre = UNDEFINED */
};

double getBrightnessRatioInCircle(const cv::Mat &amp;input, const cv::Point center, const int radius);
int getCurrentLightsCode(bool display_red, bool display_yellow, bool display_green);
LightState determineState(LightState previousState, int currentLightsCode, int* stateJudgeCount);

class TrafficLightDetector {
public:
	TrafficLightDetector();
	void brightnessDetect(const cv::Mat &amp;input);
	void colorDetect(const cv::Mat &amp;input, cv::Mat &amp;output, const cv::Rect coords, int Hmin, int Hmax);
	std::vector&lt;Context&gt; contexts;
};

enum daytime_Hue_threshold {
    DAYTIME_RED_LOWER    = 340,
    DAYTIME_RED_UPPER    = 50,
    DAYTIME_YELLOW_LOWER = 50,
    DAYTIME_YELLOW_UPPER = 70,
    DAYTIME_GREEN_LOWER  = 80,//120,//140,
    DAYTIME_GREEN_UPPER  = 190,//180,
};

#define DAYTIME_S_SIGNAL_THRESHOLD ((double)0.37)//((double)0.27)
#define DAYTIME_V_SIGNAL_THRESHOLD ((double)140/255) //((double)90/255) //((double)110/255)

#define NOISE_REDUCTION_TIME 1

#define CIRCLE_LEVEL_THRESHOLD 0.75 //0.65
#define CIRCLE_AREA_THRESHOLD 0.5 //1 //5

#define CHANGE_STATE_THRESHOLD 10

/* utility functions to convert HSV value range from OpenCV to definition */
static inline double Actual_Hue(uchar hue_opencv)
{
    return ((double)2 * hue_opencv);
} /* static inline double Actual_Hue() */

static inline double Actual_Sat(uchar sat_opencv)
{
    return ((double)sat_opencv / 255);
} /* static inline double Actual_Sat() */


static inline double Actual_Val(uchar val_opencv)
{
    return ((double)val_opencv / 255);
} /* static inline double Actual_Val() */

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr_ssd/region_tlr_ssd.h" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr_ssd/region_tlr_ssd.h">
				<diff>@@ -29,12 +29,12 @@ class RegionTlrSsdRosNode {
   /* Light state transition probably happen in Japanese traffic light */
   const LightState kStateTransitionMatrix[4][4] = {
     /* current: */
-    /* GREEN   , YELLOW    , RED       , UNDEFINED  */
+    /* GREEN   , YELLOW    , RED    , UNDEFINED  */
     /* -------------------------------------------  */
-    {GREEN     , YELLOW    , UNDEFINED , GREEN}  ,  /* | previous = GREEN */
-    {UNDEFINED , YELLOW    , RED       , YELLOW} ,  /* | previous = YELLOW */
-    {GREEN     , UNDEFINED , RED       , RED}    ,  /* | previous = RED */
-    {GREEN     , YELLOW    , RED       , UNDEFINED} /* | previous = UNDEFINED */
+    {GREEN     , YELLOW    , YELLOW , GREEN}  ,  /* | previous = GREEN */
+    {UNDEFINED , YELLOW    , RED    , YELLOW} ,  /* | previous = YELLOW */
+    {GREEN     , RED       , RED    , RED}    ,  /* | previous = RED */
+    {GREEN     , YELLOW    , RED    , UNDEFINED} /* | previous = UNDEFINED */
   };
 
 
</diff>
				<old_file>#ifndef REGION_TLR_SSD_H
#define REGION_TLR_SSD_H

#include &lt;string&gt;

#include &lt;opencv2/opencv.hpp&gt;
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;

#include &quot;Context.h&quot;
#include &quot;road_wizard/Signals.h&quot;
#include &quot;traffic_light_recognizer.h&quot;

class RegionTlrSsdRosNode {
 public:
  RegionTlrSsdRosNode();
  ~RegionTlrSsdRosNode();

  void RunRecognition();
  void ImageRawCallback(const sensor_msgs::Image &amp;image);
  void RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos);

  // The vector of data structure to save traffic light state, position, ...etc
  std::vector&lt;Context&gt; contexts_;

 private:
  /* Light state transition probably happen in Japanese traffic light */
  const LightState kStateTransitionMatrix[4][4] = {
    /* current: */
    /* GREEN   , YELLOW    , RED       , UNDEFINED  */
    /* -------------------------------------------  */
    {GREEN     , YELLOW    , UNDEFINED , GREEN}  ,  /* | previous = GREEN */
    {UNDEFINED , YELLOW    , RED       , YELLOW} ,  /* | previous = YELLOW */
    {GREEN     , UNDEFINED , RED       , RED}    ,  /* | previous = RED */
    {GREEN     , YELLOW    , RED       , UNDEFINED} /* | previous = UNDEFINED */
  };


  void GetRosParam();
  void StartSubscribersAndPublishers();
  LightState DetermineState(LightState previous_state, LightState current_state, int* state_judge_count);
  void PublishTrafficLight(std::vector&lt;Context&gt; contexts);
  void PublishString(std::vector&lt;Context&gt; contexts);
  void PublishMarkerArray(std::vector&lt;Context&gt; contexts);
  void PublishImage(std::vector&lt;Context&gt; contexts);

  // Execution parameter
  std::string image_topic_name_;
  std::string network_definition_file_name_;
  std::string pretrained_model_file_name_;
  bool use_gpu_;
  int gpu_id_;

  // Subscribers
  ros::Subscriber image_subscriber;
  ros::Subscriber roi_signal_subscriber;

  // Publishers
  ros::Publisher signal_state_publisher;
  ros::Publisher signal_state_string_publisher;
  ros::Publisher marker_publisher;
  ros::Publisher superimpose_image_publisher;

  // Flag to show topic will be published in latch manner
  bool kAdvertiseInLatch_;

  // A frame image acquired from topic
  cv::Mat frame_;

  // Timestamp of a frame in process
  std_msgs::Header frame_header_;

  // The instance of the core class of traffic light recognition by SSD
  TrafficLightRecognizer recognizer;

  // The threshold of state detected times to accept the state change
  const int kChangeStateThreshold = 10;

  // constant values to pass recognition states to other nodes
  const int32_t kTrafficLightRed;
  const int32_t kTrafficLightGreen;
  const int32_t kTrafficLightUnknown;
  const std::string kStringRed;
  const std::string kStringGreen;
  const std::string kStringUnknown;
};

#endif  // REGION_TLR_SSD_H
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="ea03a1e0ad34d5771af9e67d40829b82d1e1d1f2" fix_time="0,1">
		<msg>Fix usage of std::string::substr</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/roi_extractor/roi_extractor.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/roi_extractor/roi_extractor.cpp">
				<diff>@@ -117,7 +117,7 @@ void RoiExtractor::MakeDirectoryTree(const std::string &amp;target,
   size_t separator_end = sub_tree.find(&quot;/&quot;, separator_start + 1);
   std::string path = base;
   while (separator_end != std::string::npos) {
-    std::string sub_directory = sub_tree.substr(separator_start, separator_end);
+    std::string sub_directory = sub_tree.substr(separator_start, separator_end - separator_start);
     path = path + sub_directory;
     mkdir(path.c_str(), mode);
     separator_start = separator_end;
</diff>
				<old_file>#include &quot;roi_extractor.h&quot;

#include &lt;sys/stat.h&gt;
#include &lt;dirent.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;opencv2/opencv.hpp&gt;


#include &quot;Context.h&quot;
#include &quot;road_wizard/Signals.h&quot;


void RoiExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
  // Acquire frame image from ros topic
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
  frame_ = cv_image-&gt;image.clone();

  // Save this topic's time stamp so that same image will not be processed more than twice
  frame_timestamp_ = image.header.stamp;
} // void RoiExtractor::ImageRawCallback()


void RoiExtractor::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
  // If frame image has not been updated, do nothing
  if (frame_timestamp_ == previous_timestamp_) {
    return;
  }

  // Aquire signal positions from ros topic
  std::vector&lt;Context&gt; signal_positions;
  Context::SetContexts(signal_positions, extracted_pos, frame_.rows, frame_.cols);

  if (signal_positions.size() == 0) {
    // If signal_positions is empty, no ROI images should be saved
    return;
  }

  // Extract ROI for top signal in vector (top signal has largest estimated radius in every signals projected in a image)
  cv::Mat roi = frame_(cv::Rect(signal_positions.at(0).topLeft, signal_positions.at(0).botRight));
  std::string file_name = target_directory_ + std::to_string(file_count_) + &quot;.png&quot;;

  // Reject image if its height is smaller than threshold
  if (roi.size().height &lt; k_minimum_height_) {
    return;
  }

  // Reject image if its similarity level with previous saved ROI is higher than threshold 
  if (k_similarity_threshold_ &lt; CalculateSimilarity(roi, previous_saved_frame_)) {
    return;
  }

  cv::imwrite(file_name.c_str(), roi);
  file_count_++;
  
  previous_timestamp_ = frame_timestamp_;
  previous_saved_frame_ = roi.clone();
} // void RoiExtractor::RoiSignalCallback()


void RoiExtractor::CreateTargetDirectory(std::string base_name) {
  // Extracted ROI's images will be saved in &quot;[base_name]/tlr_TrainingDataSet/Images&quot;
  std::string target_directory_name = base_name + &quot;/tlr_TrainingDataSet/Images/&quot;;
  
  // Create target directory newly if it doesn't exist
  struct stat directory_info;
  if (stat(target_directory_name.c_str(), &amp;directory_info) != 0) {
    MakeDirectoryTree(target_directory_name, base_name, 0755);
  }

  // Count the number of files contained in the target directory
  // so that saved file is named in continuous number
  file_count_ = CountFileNum(target_directory_name);


  // Save directory name into class member
  target_directory_ = target_directory_name;

} // void RoiExtractor::CreateTargetDirectory


int RoiExtractor::CountFileNum(std::string directory_name) {
  int file_num = 0;
  struct dirent *entry;
  DIR *directory_handler = opendir(directory_name.c_str());

  // Count the number of files contained in the specified directory
  while ((entry = readdir(directory_handler)) != NULL) {
    struct stat status;
    std::string absolute_path = directory_name + std::string(entry-&gt;d_name);
    if (stat(absolute_path.c_str(), &amp;status) == 0 &amp;&amp;
        S_ISREG(status.st_mode)) {
      file_num++;
    }
  }

  closedir(directory_handler);

  return file_num;
} //int RoiExtractor::CountFileNum()


void RoiExtractor::MakeDirectoryTree(const std::string &amp;target,
                                     const std::string &amp;base,
                                     const mode_t &amp;mode) {
  // Extract directory subtree structure
  std::string sub_tree = target.substr(base.size());

  // Create directory tree one by one
  size_t separator_start = sub_tree.find(&quot;/&quot;);
  size_t separator_end = sub_tree.find(&quot;/&quot;, separator_start + 1);
  std::string path = base;
  while (separator_end != std::string::npos) {
    std::string sub_directory = sub_tree.substr(separator_start, separator_end);
    path = path + sub_directory;
    mkdir(path.c_str(), mode);
    separator_start = separator_end;
    separator_end = sub_tree.find(&quot;/&quot;, separator_start + 1);
  }
} // void RoiExtractor::MakeDirectoryTree()


// calculae similarity of specified two images
// by comparing their histogram, which is sensitive filter for color
double RoiExtractor::CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;image2) {
  if (image1.empty() || image2.empty()) {
    return 0.0;
  }

  // Compare by histogram
  cv::Mat image1_hsv, image2_hsv;
  cv::cvtColor(image1, image1_hsv, CV_BGR2HSV);
  cv::cvtColor(image2, image2_hsv, CV_BGR2HSV);

  const int channel[] = {0};

  // Hue range in OpenCV is 0 to 180
  const float hue_ranges[] = {0, 180};
  const float* ranges[] = {hue_ranges};

  // Quantize hue value into 6
  int hist_size[] = {6};

  cv::Mat histogram1;
  cv::calcHist(&amp;image1_hsv,
               1,               // Use this image only to create histogram
               channel,
               cv::Mat(),       // No mask is used
               histogram1,
               1,               // The dimension of histogram is 1
               hist_size,
               ranges);

   cv::Mat histogram2;
   cv::calcHist(&amp;image2_hsv,
                1,              // Use this image only to create histogram
                channel,
                cv::Mat(),      // No mask is used
                histogram2,
                1,              // The dimension of histogram is 1
                hist_size,
                ranges);

   double similarity = cv::compareHist(histogram1, histogram2, CV_COMP_CORREL);

   return similarity;
} // void RoiExtractor::CalculateSimilarity()


// Entry Point of this node
int main (int argc, char *argv[]) {
  // Initialize ROS node
  ros::init(argc, argv, &quot;roi_extractor&quot;);

  // Get source topic name of image from ROS private parameter
  ros::NodeHandle private_node_handler(&quot;~&quot;);
  std::string image_topic_name;
  std::string target_directory_name = std::string(getenv(&quot;HOME&quot;)) + &quot;/.autoware&quot;;
  int minimum_height = 32;
  double similarity_threshold = 0.9;
  private_node_handler.param&lt;std::string&gt;(&quot;image_raw_topic&quot;, image_topic_name, &quot;/image_raw&quot;);
  private_node_handler.param&lt;std::string&gt;(&quot;target_directory&quot;, target_directory_name, target_directory_name);
  private_node_handler.param&lt;int&gt;(&quot;minimum_height&quot;, minimum_height, 32); // The default minimum height is 32
  private_node_handler.param&lt;double&gt;(&quot;similarity_threshold&quot;, similarity_threshold, 0.9); // The default similarity threshold is 0.9

  // Get directory name which roi images will be saved
  RoiExtractor extractor(minimum_height, similarity_threshold);
  extractor.CreateTargetDirectory(target_directory_name);

  // Launch callback function to subscribe images and signal position
  ros::NodeHandle node_handler;
  ros::Subscriber image_subscriber = node_handler.subscribe(image_topic_name,
                                                            1,
                                                            &amp;RoiExtractor::ImageRawCallback,
                                                            &amp;extractor);

  ros::Subscriber roi_signal_subscriber = node_handler.subscribe(&quot;/roi_signal&quot;,
                                                                 1,
                                                                 &amp;RoiExtractor::RoiSignalCallback,
                                                                 &amp;extractor);
  
  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="c86373f03bcd290a713513901af828dd196662c3" fix_time="0,0">
		<msg>Fix bug of vector_map_server usage</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp">
				<diff>@@ -409,10 +409,12 @@ int main (int argc, char *argv[])
 
   ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
   ros::Subscriber adjust_xySubscriber  = rosnode.subscribe(&quot;/config/adjust_xy&quot;, 100, adjust_xyCallback);
+  ros::Subscriber current_pose_subscriber;
+  ros::Subscriber waypoint_subscriber;
   if (g_use_vector_map_server) {
     /* Create subscribers which deliver informations requested by server */
-    ros::Subscriber current_pose_subscriber = rosnode.subscribe(&quot;/current_pose&quot;, 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
-    ros::Subscriber waypoint_subscriber     = rosnode.subscribe(&quot;/final_waypoints&quot;, 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);
+    current_pose_subscriber = rosnode.subscribe(&quot;/current_pose&quot;, 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
+    waypoint_subscriber     = rosnode.subscribe(&quot;/final_waypoints&quot;, 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);
 
     /* Create ros client to use Server-Client communication */
     g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;(&quot;vector_map_server/get_signal&quot;);
</diff>
				<old_file>/*
 * signals.cpp
 *
 *  Created on: Apr 9, 2015
 *      Author: sujiwo
 */


#include &lt;iostream&gt;
#include &lt;ros/ros.h&gt;
#include &quot;Rate.h&quot;
#include &quot;vector_map.h&quot;
#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;signal.h&gt;
#include &lt;cstdio&gt;
#include &quot;Math.h&quot;
#include &lt;Eigen/Eigen&gt;
#include &quot;road_wizard/Signals.h&quot;
#include &lt;runtime_manager/adjust_xy.h&gt;
#include &lt;vector_map/vector_map.h&gt;
#include &lt;vector_map_server/GetSignal.h&gt;
#include &lt;waypoint_follower/lane.h&gt;

static std::string camera_id_str;

static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 1000;

static int adjust_proj_x = 0;
static int adjust_proj_y = 0;

typedef struct {
  double thiX;
  double thiY;
  double thiZ;
} Angle;

static VectorMap vmap;
static Angle cameraOrientation; // camera orientation = car's orientation

static Eigen::Vector3f position;
static Eigen::Quaternionf orientation;
static  float fx,
  fy,
  imageWidth,
  imageHeight,
  cx,
  cy;
static tf::StampedTransform trf;

static bool g_use_vector_map_server; // Switch flag whether vecter-map-server function will be used
static ros::ServiceClient g_ros_client;

#define SignalLampRadius 0.3

/* Define utility class to use vector map server */
namespace
{
  class VectorMapClient
  {
  private:
    geometry_msgs::PoseStamped pose_;
    waypoint_follower::lane waypoints_;

  public:
    VectorMapClient()
    {}

    ~VectorMapClient()
    {}

    geometry_msgs::PoseStamped pose() const
    {
      return pose_;
    }

    waypoint_follower::lane waypoints() const
    {
      return waypoints_;
    }

    void set_pose(const geometry_msgs::PoseStamped&amp; pose)
    {
      pose_ = pose;
    }

    void set_waypoints(const waypoint_follower::lane&amp; waypoints)
    {
      waypoints_ = waypoints;
    }
  }; // Class VectorMapClient
} // namespace
static VectorMapClient g_vector_map_client;


/* Callback function to shift projection result */
void adjust_xyCallback (const runtime_manager::adjust_xy::ConstPtr&amp; config_msg)
{
  adjust_proj_x = config_msg-&gt;x;
  adjust_proj_y = config_msg-&gt;y;
}

void cameraInfoCallback (const sensor_msgs::CameraInfo::ConstPtr camInfoMsg)
{
  fx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[0]);
  fy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[5]);
  imageWidth = camInfoMsg-&gt;width;
  imageHeight = camInfoMsg-&gt;height;
  cx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[2]);
  cy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[6]);
}


/* convert degree value into 0 to 360 range */
static double setDegree0to360(double val)
{
  if (val &lt; 0.0f) {
    return (val + 360.0f);
  }
  else if (360.0f &lt; val) {
    return (val - 360.0f);
  }

  return val;
}


static void get_cameraRollPitchYaw(double* roll,
                                   double* pitch,
                                   double* yaw)
{
  geometry_msgs::Pose cameraPose;
  cameraPose.position.x    = (double)(position.x());
  cameraPose.position.y    = (double)(position.y());
  cameraPose.position.z    = (double)(position.z());
  cameraPose.orientation.x = (double)(orientation.x());
  cameraPose.orientation.y = (double)(orientation.y());
  cameraPose.orientation.z = (double)(orientation.z());
  cameraPose.orientation.w = (double)(orientation.w());

  tf::Quaternion quat;

  tf::quaternionMsgToTF(cameraPose.orientation, quat);
  tf::Matrix3x3(quat).getRPY(*roll, *pitch, *yaw);

  /* convert from radian to degree */
  *roll  = setDegree0to360(*roll  * 180.0f / M_PI);
  *pitch = setDegree0to360(*pitch * 180.0f / M_PI);
  *yaw   = setDegree0to360(*yaw   * 180.0f / M_PI);
}


/*
  check if lower &lt; val &lt; upper
  This function also considers circulation
*/
static bool isRange(const double lower, const double upper, const double val)
{
  if (lower &lt;= upper) {
    if (lower &lt; val &amp;&amp; val &lt; upper) {
      return true;
    }
  }
  else {
    if (val &lt; upper || lower &lt; val) {
      return true;
    }
  }

  return false;
}


void getTransform (Eigen::Quaternionf &amp;ori, Point3 &amp;pos)
{
  static tf::TransformListener listener;

  // target_frame    source_frame
  ros::Time now = ros::Time();
  listener.waitForTransform (camera_id_str, &quot;map&quot;, now, ros::Duration(10.0));
  listener.lookupTransform (camera_id_str, &quot;map&quot;, now, trf);

  tf::Vector3 &amp;p = trf.getOrigin();
  tf::Quaternion o = trf.getRotation();
  pos.x()=p.x(); pos.y()=p.y(); pos.z()=p.z();
  ori.w()=o.w(); ori.x()=o.x(); ori.y()=o.y(); ori.z()=o.z();
}


Point3 transform (const Point3 &amp;psrc, tf::StampedTransform &amp;tfsource)
{
  tf::Vector3 pt3 (psrc.x(), psrc.y(), psrc.z());
  tf::Vector3 pt3s = tfsource * pt3;
  return Point3 (pt3s.x(), pt3s.y(), pt3s.z());
}


/*
 * Project a point from world coordinate to image plane
 */
bool project2 (const Point3 &amp;pt, int &amp;u, int &amp;v, bool useOpenGLCoord=false)
{
  float nearPlane = 1.0;
  float farPlane = 200.0;
  Point3 _pt = transform (pt, trf);
  float _u = _pt.x()*fx/_pt.z() + cx;
  float _v = _pt.y()*fy/_pt.z() + cy;

  u = static_cast&lt;int&gt;(_u);
  v = static_cast&lt;int&gt;(_v);
  if ( u &lt; 0 || imageWidth &lt; u || v &lt; 0 || imageHeight &lt; v || _pt.z() &lt; nearPlane || farPlane &lt; _pt.z() ) {
    u = -1, v = -1;
    return false;
  }

  if (useOpenGLCoord) {
    v = imageHeight - v;
  }

  return true;
}

double ConvertDegreeToRadian(double degree)
{
  return degree * M_PI / 180.0f;
}


double ConvertRadianToDegree(double radian)
{
  return radian * 180.0f / M_PI;
}


double GetSignalAngleInCameraSystem(double hang, double vang)
{
  // Fit the vector map format into ROS style
  double signal_pitch_in_map = ConvertDegreeToRadian(vang - 90);
  double signal_yaw_in_map   = ConvertDegreeToRadian(-hang + 90);

  tf::Quaternion signal_orientation_in_map_system;
  signal_orientation_in_map_system.setRPY(0, signal_pitch_in_map, signal_yaw_in_map);

  tf::Quaternion signal_orientation_in_cam_system = trf * signal_orientation_in_map_system;
  double signal_roll_in_cam;
  double signal_pitch_in_cam;
  double signal_yaw_in_cam;
  tf::Matrix3x3(signal_orientation_in_cam_system).getRPY(signal_roll_in_cam,
                                                         signal_pitch_in_cam,
                                                         signal_yaw_in_cam);

  return ConvertRadianToDegree(signal_pitch_in_cam);   // holizontal angle of camera is represented by pitch
}  // double GetSignalAngleInCameraSystem()


void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
{
  int countPoint = 0;
  road_wizard::Signals signalsInFrame;

  /* Get signals on the path if vecter_map_server is enabled */
  if (g_use_vector_map_server) {
    vector_map_server::GetSignal service;
    /* Set server's request */
    service.request.pose = g_vector_map_client.pose();
    service.request.waypoints = g_vector_map_client.waypoints();

    /* Get server's response*/
    if (g_ros_client.call(service)) {
      /* Reset signal data container */
      vmap.signals.clear();

      /* Newle insert signal data on the path */
      for (const auto&amp; response: service.response.objects.data) {
        if (response.id == 0)
          continue;

        Signal signal;
        signal.id = response.id;
        signal.vid = response.vid;
        signal.plid = response.plid;
        signal.type = response.type;
        signal.linkid = response.linkid;

        vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
      }
    }
  }

  for (unsigned int i=1; i&lt;=vmap.signals.size(); i++) {
    Signal signal = vmap.signals[i];
    int pid = vmap.vectors[signal.vid].pid;

    Point3 signalcenter = vmap.getPoint(pid);
    Point3 signalcenterx (signalcenter.x(), signalcenter.y(), signalcenter.z()+SignalLampRadius);

    int u, v;
    if (project2 (signalcenter, u, v, useOpenGLCoord) == true) {
      countPoint++;
      // std::cout &lt;&lt; u &lt;&lt; &quot;, &quot; &lt;&lt; v &lt;&lt; &quot;, &quot; &lt;&lt; std::endl;

      int radius;
      int ux, vx;
      project2 (signalcenterx, ux, vx, useOpenGLCoord);
      radius = (int)distance (ux, vx, u, v);

      road_wizard::ExtractedPosition sign;
      sign.signalId = signal.id;

      sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
      sign.v = v + adjust_proj_y; // shift project position by configuration value from runtime manager

      sign.radius = radius;
      sign.x = signalcenter.x(), sign.y = signalcenter.y(), sign.z = signalcenter.z();
      sign.hang = vmap.vectors[signal.vid].hang; // hang is expressed in [0, 360] degree
      sign.type = signal.type, sign.linkId = signal.linkid;
      sign.plId = signal.plid;

      // Get holizontal angle of signal in camera corrdinate system
      double signal_angle = GetSignalAngleInCameraSystem(vmap.vectors[signal.vid].hang + 180.0f,
                                                         vmap.vectors[signal.vid].vang + 180.0f);

      // signal_angle will be zero if signal faces to x-axis
      // Target signal should be face to -50 &lt;= z-axis (= 90 degree) &lt;= +50
      if (isRange(-50, 50, signal_angle - 90)) {
        signalsInFrame.Signals.push_back (sign);
      }
    }
  }

  signalsInFrame.header.stamp = ros::Time::now();
  pub.publish (signalsInFrame);

  // printf (&quot;There are %d out of %u signals in frame\n&quot;, countPoint, static_cast&lt;unsigned int&gt;(vmap.signals.size()));
}


void interrupt (int s)
{
  ros::shutdown();
  exit(1);
}


int main (int argc, char *argv[])
{

  ros::init(argc, argv, &quot;feat_proj&quot;, ros::init_options::NoSigintHandler);
  ros::NodeHandle rosnode;
  ros::NodeHandle private_nh(&quot;~&quot;);
  std::string cameraInfo_topic_name;
  private_nh.param&lt;std::string&gt;(&quot;camera_info_topic&quot;, cameraInfo_topic_name, &quot;/camera/camera_info&quot;);

  /* get camera ID */
  camera_id_str = cameraInfo_topic_name;
  camera_id_str.erase(camera_id_str.find(&quot;/camera/camera_info&quot;));
  if (camera_id_str == &quot;/&quot;) {
    camera_id_str = &quot;camera&quot;;
  }
  
  /* Get Flag wheter vecter_map_server function will be used  */
  private_nh.param&lt;bool&gt;(&quot;use_path_info&quot;, g_use_vector_map_server, false);

  /* load vector map */
  ros::Subscriber sub_point     = rosnode.subscribe(&quot;vector_map_info/point&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_points,
                                                    &amp;vmap);
  ros::Subscriber sub_line      = rosnode.subscribe(&quot;vector_map_info/line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lines,
                                                    &amp;vmap);
  ros::Subscriber sub_lane      = rosnode.subscribe(&quot;vector_map_info/lane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lanes,
                                                    &amp;vmap);
  ros::Subscriber sub_vector    = rosnode.subscribe(&quot;vector_map_info/vector&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_vectors,
                                                    &amp;vmap);
  ros::Subscriber sub_signal    = rosnode.subscribe(&quot;vector_map_info/signal&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_signals,
                                                    &amp;vmap);
  ros::Subscriber sub_whiteline = rosnode.subscribe(&quot;vector_map_info/white_line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_whitelines,
                                                    &amp;vmap);
  ros::Subscriber sub_dtlane    = rosnode.subscribe(&quot;vector_map_info/dtlane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_dtlanes,
                                                    &amp;vmap);

  /* wait until loading all vector map is completed */
  ros::Rate wait_rate(1);
  while(vmap.points.empty() || vmap.lines.empty() || vmap.whitelines.empty() ||
        vmap.lanes.empty() || vmap.dtlanes.empty() || vmap.vectors.empty() || vmap.signals.empty())
    {
      ros::spinOnce();
      wait_rate.sleep();
    }

  vmap.loaded = true;
  std::cout &lt;&lt; &quot;all vector map loaded.&quot; &lt;&lt; std::endl;

  ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
  ros::Subscriber adjust_xySubscriber  = rosnode.subscribe(&quot;/config/adjust_xy&quot;, 100, adjust_xyCallback);
  if (g_use_vector_map_server) {
    /* Create subscribers which deliver informations requested by server */
    ros::Subscriber current_pose_subscriber = rosnode.subscribe(&quot;/current_pose&quot;, 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
    ros::Subscriber waypoint_subscriber     = rosnode.subscribe(&quot;/final_waypoints&quot;, 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);

    /* Create ros client to use Server-Client communication */
    g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;(&quot;vector_map_server/get_signal&quot;);
  }

  ros::Publisher  signalPublisher      = rosnode.advertise &lt;road_wizard::Signals&gt; (&quot;roi_signal&quot;, 100);
  signal (SIGINT, interrupt);

  Rate loop (25);
  while (true) {

    ros::spinOnce();

    try {
      getTransform (orientation, position);
    } catch (tf::TransformException &amp;exc) {
    }

    echoSignals2 (signalPublisher, false);
    loop.sleep();
  }


}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="7b561d154bf1d7ec3a1bd41a6068fabdc0a73a4a" fix_time="0,44">
		<msg>Prepare for merge

* Fix assumed SSD path in CMakeLists.txt
* Change default path of trained model into package-internal directory
* Remove `std::cerr` statements for debug
* Add UI to boot `traffic_light_recognition_ssd.launch` from runtime-manager</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr_ssd/region_tlr_ssd.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr_ssd/region_tlr_ssd.cpp">
				<diff>@@ -95,54 +95,12 @@ void RegionTlrSsdRosNode::RoiSignalCallback(const road_wizard::Signals::ConstPtr
     // Get current state of traffic light from current frame
     LightState current_state = recognizer.RecognizeLightState(roi);
 
-    std::cerr &lt;&lt; &quot;current_state: &quot;;
-    switch(current_state) {
-    case GREEN:
-      std::cerr &lt;&lt; &quot;GREEN&quot;;
-      break;
-    case YELLOW:
-      std::cerr &lt;&lt; &quot;YELLOW&quot;;
-      break;
-    case RED:
-      std::cerr &lt;&lt; &quot;RED&quot;;
-      break;
-    case UNDEFINED:
-      std::cerr &lt;&lt; &quot;UNDEFINED&quot;;
-      break;
-    default:
-      std::cerr &lt;&lt; &quot;なにこれ？&quot;;
-      break;
-    }
-
-    std::cerr &lt;&lt; &quot;(saved: &quot; &lt;&lt; context.lightState &lt;&lt; &quot;)&quot;;
-
     // Determine the final state by referring previous state
     context.lightState = DetermineState(context.lightState, // previous state
                                         current_state,      // current state
                                         &amp;(context.stateJudgeCount)); // counter to record how many times does state recognized
-
-    std::cerr &lt;&lt; &quot;, determined: &quot;;
-    switch(context.lightState) {
-    case GREEN:
-      std::cerr &lt;&lt; &quot;GREEN | &quot;;
-      break;
-    case YELLOW:
-      std::cerr &lt;&lt; &quot;YELLOW | &quot;;
-      break;
-    case RED:
-      std::cerr &lt;&lt; &quot;RED | &quot;;
-      break;
-    case UNDEFINED:
-      std::cerr &lt;&lt; &quot;UNDEFINED | &quot;;
-      break;
-    default:
-      std::cerr &lt;&lt; &quot;なにこれ？ | &quot;;
-      break;
-    }
   }
 
-  std::cerr &lt;&lt; std::endl;
-
   // Publish recognition result as some topic format
   PublishTrafficLight(contexts_);
   PublishString(contexts_);
@@ -213,14 +171,6 @@ LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
   // Get a candidate which considering state transition of traffic light
   LightState transition_candidate = kStateTransitionMatrix[previous_state][current_state];
 
-  std::cerr &lt;&lt; &quot; [count:&quot; &lt;&lt; *(state_judge_count) &lt;&lt; &quot;/&quot; &lt;&lt; kChangeStateThreshold
-            &lt;&lt; &quot;, pre:&quot; &lt;&lt; previous_state &lt;&lt; &quot;, cur:&quot; &lt;&lt; current_state &lt;&lt; &quot;, tra:&quot; &lt;&lt; transition_candidate &lt;&lt; &quot;]&quot;;
-
-  // if (transition_candidate == UNDEFINED) {
-  //   // If candidate is UNDEFINED, return previous state tentatively
-  //   return previous_state;
-  // }
-
   // If state change happens more than threshold times, accept that change
   if (*state_judge_count &gt; kChangeStateThreshold) {
     *state_judge_count = 0;
</diff>
				<old_file>#include &quot;region_tlr_ssd.h&quot;

#include &lt;string&gt;

#include &lt;runtime_manager/traffic_light.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;

#include &quot;Context.h&quot;

// ========================================
// Constructor of RegionTlrSsdRosNode class
// ========================================
RegionTlrSsdRosNode::RegionTlrSsdRosNode():
  image_topic_name_(&quot;/image_raw&quot;),
  network_definition_file_name_(&quot;&quot;),
  pretrained_model_file_name_(&quot;&quot;),
  use_gpu_(false),
  gpu_id_(0),
  kAdvertiseInLatch_(true),
  kTrafficLightRed(0),
  kTrafficLightGreen(1),
  kTrafficLightUnknown(2),
  kStringRed(&quot;red signal&quot;),
  kStringGreen(&quot;green signal&quot;),
  kStringUnknown(&quot;&quot;) {

} // RegionTlrSsdRosNode::RegionTlrSsdRosNode()


// ========================================
// Destructor of RegionTlrSsdRosNode class
// ========================================
RegionTlrSsdRosNode::~RegionTlrSsdRosNode() {
} // RegionTlrSsdRosNode::~RegionTlrSsdRosNode()


// =========================
// Start recognition process
// =========================
void RegionTlrSsdRosNode::RunRecognition() {
  // Get execution parameters from ROS parameter server
  GetRosParam();

  // Initialize recognizer
  recognizer.Init(network_definition_file_name_,
                  pretrained_model_file_name_,
                  use_gpu_,
                  gpu_id_);

  // Start subscribing and publishing
  StartSubscribersAndPublishers();
  ros::spin();
} // RegionTlrSsdRosNode::RunRecognition()


// ==================================
// Callback function to acquire image
// ==================================
void RegionTlrSsdRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
  frame_ = cv_image-&gt;image.clone();

  // Save header information of this topic
  frame_header_ = image.header;

}

// ==========================================
// Callback function to acquire extracted_pos
// ==========================================
void RegionTlrSsdRosNode::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
  static ros::Time previous_timestamp;
  // If frame has not been prepared, abort this callback
  if (frame_.empty() ||
      frame_header_.stamp == previous_timestamp) {
    return;
  }

  // Acquire signal posotion on the image
  Context::SetContexts(contexts_, extracted_pos, frame_.rows, frame_.cols);

  // Recognize the color of the traffic light
  for (Context&amp; context: contexts_) {
  // for (unsigned int i = 0; i &lt; contexts_.size(); i++) {
  //   Context&amp; context = contexts_.at(i);
    if (context.topLeft.x &gt; context.botRight.x) {
      continue;
    }

    // extract region of interest from input image
    cv::Mat roi  = frame_(cv::Rect(context.topLeft, context.botRight)).clone();

    // Get current state of traffic light from current frame
    LightState current_state = recognizer.RecognizeLightState(roi);

    std::cerr &lt;&lt; &quot;current_state: &quot;;
    switch(current_state) {
    case GREEN:
      std::cerr &lt;&lt; &quot;GREEN&quot;;
      break;
    case YELLOW:
      std::cerr &lt;&lt; &quot;YELLOW&quot;;
      break;
    case RED:
      std::cerr &lt;&lt; &quot;RED&quot;;
      break;
    case UNDEFINED:
      std::cerr &lt;&lt; &quot;UNDEFINED&quot;;
      break;
    default:
      std::cerr &lt;&lt; &quot;なにこれ？&quot;;
      break;
    }

    std::cerr &lt;&lt; &quot;(saved: &quot; &lt;&lt; context.lightState &lt;&lt; &quot;)&quot;;

    // Determine the final state by referring previous state
    context.lightState = DetermineState(context.lightState, // previous state
                                        current_state,      // current state
                                        &amp;(context.stateJudgeCount)); // counter to record how many times does state recognized

    std::cerr &lt;&lt; &quot;, determined: &quot;;
    switch(context.lightState) {
    case GREEN:
      std::cerr &lt;&lt; &quot;GREEN | &quot;;
      break;
    case YELLOW:
      std::cerr &lt;&lt; &quot;YELLOW | &quot;;
      break;
    case RED:
      std::cerr &lt;&lt; &quot;RED | &quot;;
      break;
    case UNDEFINED:
      std::cerr &lt;&lt; &quot;UNDEFINED | &quot;;
      break;
    default:
      std::cerr &lt;&lt; &quot;なにこれ？ | &quot;;
      break;
    }
  }

  std::cerr &lt;&lt; std::endl;

  // Publish recognition result as some topic format
  PublishTrafficLight(contexts_);
  PublishString(contexts_);
  PublishMarkerArray(contexts_);
  PublishImage(contexts_);

  // Save timestamp of this frame so that same frame has never been process again
  previous_timestamp = frame_header_.stamp;
}

// =======================================
// Get parameter from ROS parameter server
// =======================================
void RegionTlrSsdRosNode::GetRosParam() {
  ros::NodeHandle private_node_handle(&quot;~&quot;);

  private_node_handle.param&lt;std::string&gt;(&quot;image_raw_topic&quot;, image_topic_name_, &quot;/image_raw&quot;);
  private_node_handle.param&lt;std::string&gt;(&quot;network_definition_file&quot;, network_definition_file_name_, &quot;&quot;);
  private_node_handle.param&lt;std::string&gt;(&quot;pretrained_model_file&quot;, pretrained_model_file_name_, &quot;&quot;);
  private_node_handle.param&lt;bool&gt;(&quot;use_gpu&quot;, use_gpu_, false);
  private_node_handle.param&lt;int&gt;(&quot;gpu_id&quot;, gpu_id_, 0);

  // If network-definition-file or pretrained-model-file are not specified,
  // terminate program with error status
  if (network_definition_file_name_.empty()){
    ROS_FATAL(&quot;No Network Definition File was specified. Terminate program... &quot;);
    exit(EXIT_FAILURE);
  }

  if (pretrained_model_file_name_.empty()){
    ROS_FATAL(&quot;No Pretrained Model File was specified. Terminate program... &quot;);
    exit(EXIT_FAILURE);
  }
} // RegionTlrSsdRosNode::ProcessRosParam()


// ============================================================
// Register subscriber and publisher of this node in ROS Master
// ============================================================
void RegionTlrSsdRosNode::StartSubscribersAndPublishers() {
  ros::NodeHandle node_handle;
  
  // Register subscribers
  image_subscriber      = node_handle.subscribe(image_topic_name_,
                                                1,
                                                &amp;RegionTlrSsdRosNode::ImageRawCallback,
                                                this);
  roi_signal_subscriber = node_handle.subscribe(&quot;/roi_signal&quot;,
                                                1,
                                                &amp;RegionTlrSsdRosNode::RoiSignalCallback,
                                                this);

  // Register publishers
  signal_state_publisher        = node_handle.advertise&lt;runtime_manager::traffic_light&gt;(&quot;light_color&quot;, 1);
  signal_state_string_publisher = node_handle.advertise&lt;std_msgs::String&gt;(&quot;/sound_player&quot;, 1);
  marker_publisher              = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;tlr_result&quot;, 1, kAdvertiseInLatch_);
  superimpose_image_publisher   = node_handle.advertise&lt;sensor_msgs::Image&gt;(&quot;tlr_superimpose_image&quot;, 1);

} // RegionTlrSsdRosNode::StartSubscribersAndPublishers()


// ===============================================================================
// Determine the final recognition result by comparing previous recognition result
// ===============================================================================
LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
                                               LightState current_state,
                                               int* state_judge_count) {
  // Get a candidate which considering state transition of traffic light
  LightState transition_candidate = kStateTransitionMatrix[previous_state][current_state];

  std::cerr &lt;&lt; &quot; [count:&quot; &lt;&lt; *(state_judge_count) &lt;&lt; &quot;/&quot; &lt;&lt; kChangeStateThreshold
            &lt;&lt; &quot;, pre:&quot; &lt;&lt; previous_state &lt;&lt; &quot;, cur:&quot; &lt;&lt; current_state &lt;&lt; &quot;, tra:&quot; &lt;&lt; transition_candidate &lt;&lt; &quot;]&quot;;

  // if (transition_candidate == UNDEFINED) {
  //   // If candidate is UNDEFINED, return previous state tentatively
  //   return previous_state;
  // }

  // If state change happens more than threshold times, accept that change
  if (*state_judge_count &gt; kChangeStateThreshold) {
    *state_judge_count = 0;
    return transition_candidate;
  } else {
    if (transition_candidate != previous_state) {
      (*state_judge_count)++;
    }
    return previous_state;
  }

} // LightState RegionTlrSsdRosNode::DetermineState()


// =================================================================
// Publish recognition result as runtime_manager::traffic_light type
// =================================================================
void RegionTlrSsdRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
  runtime_manager::traffic_light topic;
  static int32_t previous_state = kTrafficLightUnknown;
  topic.traffic_light = kTrafficLightUnknown;
  for (const auto ctx: contexts) {
    switch(ctx.lightState) {
    case GREEN:
      topic.traffic_light = kTrafficLightGreen;
      break;
    case YELLOW:
    case RED:
      topic.traffic_light = kTrafficLightRed;
      break;
    case UNDEFINED:
      topic.traffic_light = kTrafficLightUnknown;
      break;
    }

    // Publish the first state in contexts,
    // which has largest estimated radius of signal.
    // This program assume that the signal which has the largest estimated radius
    // equal the nearest one from camera.
    if (topic.traffic_light != kTrafficLightUnknown) {
      break;
    }
  }

  // If state changes from previous one, publish it
  if (topic.traffic_light != previous_state) {
    signal_state_publisher.publish(topic);
    previous_state = topic.traffic_light;
  }
} // void RegionTlrSsdRosNode::PublishTrafficLight()


// =================================================================
// Publish recognition result as std_msgs::String
// =================================================================
void RegionTlrSsdRosNode::PublishString(std::vector&lt;Context&gt; contexts) {
  std_msgs::String topic;
  static std::string previous_state = kStringUnknown;
  topic.data = kStringUnknown;
  for (const auto ctx: contexts) {
    switch(ctx.lightState) {
    case GREEN:
      topic.data = kStringGreen;
      break;
    case YELLOW:
    case RED:
      topic.data = kStringRed;
      break;
    case UNDEFINED:
      topic.data = kStringUnknown;
      break;
    }

    // Publish the first state in contexts,
    // which has largest estimated radius of signal.
    // This program assume that the signal which has the largest estimated radius
    // equal the nearest one from camera.
    if (topic.data != kStringUnknown) {
      break;
    }
  }

  // If state changes from previous one, publish it
  if (topic.data != previous_state) {
    signal_state_string_publisher.publish(topic);
    previous_state = topic.data;
  }
} // void RegionTlrSsdRosNode::PublishString()


// =================================================================
// Publish recognition result as visualization_msgs::MarkerArray
// =================================================================
void RegionTlrSsdRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
  // Define color constants
  std_msgs::ColorRGBA color_black;
  color_black.r = 0.0f;
  color_black.g = 0.0f;
  color_black.b = 0.0f;
  color_black.a = 1.0f;

  std_msgs::ColorRGBA color_red;
  color_red.r = 1.0f;
  color_red.g = 0.0f;
  color_red.b = 0.0f;
  color_red.a = 1.0f;

  std_msgs::ColorRGBA color_yellow;
  color_yellow.r = 1.0f;
  color_yellow.g = 1.0f;
  color_yellow.b = 0.0f;
  color_yellow.a = 1.0f;

  std_msgs::ColorRGBA color_green;
  color_green.r = 0.0f;
  color_green.g = 1.0f;
  color_green.b = 0.0f;
  color_green.a = 1.0f;

  // publish all result as ROS MarkerArray
  for (const auto ctx: contexts) {
    visualization_msgs::MarkerArray signal_set;
    visualization_msgs::Marker red_light, yellow_light, green_light;

    // Set the frame ID
    red_light.header.frame_id    = &quot;map&quot;;
    yellow_light.header.frame_id = &quot;map&quot;;
    green_light.header.frame_id  = &quot;map&quot;;

    // Set the namespace and ID for this markers
    red_light.ns    = &quot;tlr_result_red&quot;;
    red_light.id    = ctx.signalID;

    yellow_light.ns = &quot;tlr_result_yellow&quot;;
    yellow_light.id = ctx.signalID;

    green_light.ns  = &quot;tlr_result_green&quot;;
    green_light.id  = ctx.signalID;

    // Set the markers type
    red_light.type    = visualization_msgs::Marker::SPHERE;
    yellow_light.type = visualization_msgs::Marker::SPHERE;
    green_light.type  = visualization_msgs::Marker::SPHERE;

    // Set the pose of the markers
    red_light.pose.position.x = ctx.redCenter3d.x;
    red_light.pose.position.y = ctx.redCenter3d.y;
    red_light.pose.position.z = ctx.redCenter3d.z;
    red_light.pose.orientation.x = 0.0;
    red_light.pose.orientation.y = 0.0;
    red_light.pose.orientation.z = 0.0;
    red_light.pose.orientation.w = 0.0;

    yellow_light.pose.position.x = ctx.yellowCenter3d.x;
    yellow_light.pose.position.y = ctx.yellowCenter3d.y;
    yellow_light.pose.position.z = ctx.yellowCenter3d.z;
    yellow_light.pose.orientation.x = 0.0;
    yellow_light.pose.orientation.y = 0.0;
    yellow_light.pose.orientation.z = 0.0;
    yellow_light.pose.orientation.w = 0.0;

    green_light.pose.position.x = ctx.greenCenter3d.x;
    green_light.pose.position.y = ctx.greenCenter3d.y;
    green_light.pose.position.z = ctx.greenCenter3d.z;
    green_light.pose.orientation.x = 0.0;
    green_light.pose.orientation.y = 0.0;
    green_light.pose.orientation.z = 0.0;
    green_light.pose.orientation.w = 0.0;

    // Set the scale of the markers. We assume lamp radius is 30cm in real world
    red_light.scale.x = 0.3;
    red_light.scale.y = 0.3;
    red_light.scale.z = 0.3;

    yellow_light.scale.x = 0.3;
    yellow_light.scale.y = 0.3;
    yellow_light.scale.z = 0.3;

    green_light.scale.x = 0.3;
    green_light.scale.y = 0.3;
    green_light.scale.z = 0.3;

    // Set the color for each marker
    switch(ctx.lightState) {
    case GREEN:
      red_light.color = color_black;
      yellow_light.color = color_black;
      green_light.color = color_green;
      break;
    case YELLOW:
      red_light.color = color_black;
      yellow_light.color = color_yellow;
      green_light.color = color_black;
      break;
    case RED:
      red_light.color = color_red;
      yellow_light.color = color_black;
      green_light.color = color_black;
      break;
    case UNDEFINED:
      red_light.color = color_black;
      yellow_light.color = color_black;
      green_light.color = color_black;
      break;
    }

    red_light.lifetime = ros::Duration(0.1);
    yellow_light.lifetime = ros::Duration(0.1);
    green_light.lifetime = ros::Duration(0.1);

    // Pack each light marker into one
    signal_set.markers.push_back(red_light);
    signal_set.markers.push_back(yellow_light);
    signal_set.markers.push_back(green_light);

    // Publish
    marker_publisher.publish(signal_set);
  }

} // void RegionTlrSsdRosNode::PublishMarkerArray()


// ================================================================
// Publish superimpose and recognition result as sensor_msgs::Image
// ================================================================
void RegionTlrSsdRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
  // Copy the frame image for output
  cv::Mat result_image = frame_.clone();

  // Define information for written label
  std::string  label;
  const int    kFontFace      = cv::FONT_HERSHEY_COMPLEX_SMALL;
  const double kFontScale     = 1.0;
  int          font_baseline  = 0;
  CvScalar     label_color;

  for (const auto ctx: contexts_) {
    // Draw superimpose result on image
    circle(result_image, ctx.redCenter, ctx.lampRadius, CV_RGB(255, 0, 0), 1, 0);
    circle(result_image, ctx.yellowCenter, ctx.lampRadius, CV_RGB(255, 255, 0), 1, 0);
    circle(result_image, ctx.greenCenter, ctx.lampRadius, CV_RGB(0, 255, 0), 1, 0);

    // Draw recognition result on image
    switch(ctx.lightState) {
    case GREEN:
      label = &quot;GREEN&quot;;
      label_color = CV_RGB(0, 255, 0);
      break;
    case YELLOW:
      label = &quot;YELLOW&quot;;
      label_color = CV_RGB(255, 255, 0);
      break;
    case RED:
      label = &quot;RED&quot;;
      label_color = CV_RGB(255, 0, 0);
      break;
    case UNDEFINED:
      label = &quot;UNKNOWN&quot;;
      label_color = CV_RGB(0, 0, 0);
    }

    cv::Point label_origin = cv::Point(ctx.topLeft.x, ctx.botRight.y + font_baseline);

    cv::putText(result_image, label, label_origin, kFontFace, kFontScale, label_color);
  }

  // Publish superimpose result image
  cv_bridge::CvImage converter;
  converter.header = frame_header_;
  converter.encoding = sensor_msgs::image_encodings::BGR8;
  converter.image = result_image;
  superimpose_image_publisher.publish(converter.toImageMsg());

} // void RegionTlrSsdRosNode::PublishImage()

// ========================
// Entry point of this node
// ========================
int main (int argc, char *argv[]) {
  // Initialize ros node
  ros::init(argc, argv, &quot;region_tlr_ssd&quot;);

  // Create RegionTlrRosNode class object and do initialization
  RegionTlrSsdRosNode region_tlr_ssd_ros_node;

  // Start recognition process
  region_tlr_ssd_ros_node.RunRecognition();

  return 0;
} // main()
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="22ba82fa89521ef3097e5d2f35e32f744ac9f01d" fix_time="4,79434">
		<msg>Fix for latest specification</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp">
				<diff>@@ -24,7 +24,7 @@
 #include &lt;runtime_manager/adjust_xy.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 #include &lt;vector_map_server/GetSignal.h&gt;
-#include &lt;waypoint_follower/lane.h&gt;
+#include &lt;waypoint_follower_msgs/lane.h&gt;
 
 static std::string camera_id_str;
 
@@ -64,7 +64,7 @@ namespace
   {
   private:
     geometry_msgs::PoseStamped pose_;
-    waypoint_follower::lane waypoints_;
+    waypoint_follower_msgs::lane waypoints_;
 
   public:
     VectorMapClient()
@@ -78,7 +78,7 @@ namespace
       return pose_;
     }
 
-    waypoint_follower::lane waypoints() const
+    waypoint_follower_msgs::lane waypoints() const
     {
       return waypoints_;
     }
@@ -88,7 +88,7 @@ namespace
       pose_ = pose;
     }
 
-    void set_waypoints(const waypoint_follower::lane&amp; waypoints)
+    void set_waypoints(const waypoint_follower_msgs::lane&amp; waypoints)
     {
       waypoints_ = waypoints;
     }
</diff>
				<old_file>/*
 * signals.cpp
 *
 *  Created on: Apr 9, 2015
 *      Author: sujiwo
 */


#include &lt;iostream&gt;
#include &lt;ros/ros.h&gt;
#include &quot;Rate.h&quot;
#include &quot;vector_map.h&quot;
#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;signal.h&gt;
#include &lt;cstdio&gt;
#include &quot;Math.h&quot;
#include &lt;Eigen/Eigen&gt;
#include &quot;road_wizard/Signals.h&quot;
#include &lt;runtime_manager/adjust_xy.h&gt;
#include &lt;vector_map/vector_map.h&gt;
#include &lt;vector_map_server/GetSignal.h&gt;
#include &lt;waypoint_follower/lane.h&gt;

static std::string camera_id_str;

static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 1000;

static int adjust_proj_x = 0;
static int adjust_proj_y = 0;

typedef struct {
  double thiX;
  double thiY;
  double thiZ;
} Angle;

static VectorMap vmap;
static Angle cameraOrientation; // camera orientation = car's orientation

static Eigen::Vector3f position;
static Eigen::Quaternionf orientation;
static  float fx,
  fy,
  imageWidth,
  imageHeight,
  cx,
  cy;
static tf::StampedTransform trf;

static bool g_use_vector_map_server; // Switch flag whether vecter-map-server function will be used
static ros::ServiceClient g_ros_client;

#define SignalLampRadius 0.3

/* Define utility class to use vector map server */
namespace
{
  class VectorMapClient
  {
  private:
    geometry_msgs::PoseStamped pose_;
    waypoint_follower::lane waypoints_;

  public:
    VectorMapClient()
    {}

    ~VectorMapClient()
    {}

    geometry_msgs::PoseStamped pose() const
    {
      return pose_;
    }

    waypoint_follower::lane waypoints() const
    {
      return waypoints_;
    }

    void set_pose(const geometry_msgs::PoseStamped&amp; pose)
    {
      pose_ = pose;
    }

    void set_waypoints(const waypoint_follower::lane&amp; waypoints)
    {
      waypoints_ = waypoints;
    }
  }; // Class VectorMapClient
} // namespace
static VectorMapClient g_vector_map_client;


/* Callback function to shift projection result */
void adjust_xyCallback (const runtime_manager::adjust_xy::ConstPtr&amp; config_msg)
{
  adjust_proj_x = config_msg-&gt;x;
  adjust_proj_y = config_msg-&gt;y;
}

void cameraInfoCallback (const sensor_msgs::CameraInfo::ConstPtr camInfoMsg)
{
  fx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[0]);
  fy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[5]);
  imageWidth = camInfoMsg-&gt;width;
  imageHeight = camInfoMsg-&gt;height;
  cx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[2]);
  cy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[6]);
}


/* convert degree value into 0 to 360 range */
static double setDegree0to360(double val)
{
  if (val &lt; 0.0f) {
    return (val + 360.0f);
  }
  else if (360.0f &lt; val) {
    return (val - 360.0f);
  }

  return val;
}


static void get_cameraRollPitchYaw(double* roll,
                                   double* pitch,
                                   double* yaw)
{
  geometry_msgs::Pose cameraPose;
  cameraPose.position.x    = (double)(position.x());
  cameraPose.position.y    = (double)(position.y());
  cameraPose.position.z    = (double)(position.z());
  cameraPose.orientation.x = (double)(orientation.x());
  cameraPose.orientation.y = (double)(orientation.y());
  cameraPose.orientation.z = (double)(orientation.z());
  cameraPose.orientation.w = (double)(orientation.w());

  tf::Quaternion quat;

  tf::quaternionMsgToTF(cameraPose.orientation, quat);
  tf::Matrix3x3(quat).getRPY(*roll, *pitch, *yaw);

  /* convert from radian to degree */
  *roll  = setDegree0to360(*roll  * 180.0f / M_PI);
  *pitch = setDegree0to360(*pitch * 180.0f / M_PI);
  *yaw   = setDegree0to360(*yaw   * 180.0f / M_PI);
}


/*
  check if lower &lt; val &lt; upper
  This function also considers circulation
*/
static bool isRange(const double lower, const double upper, const double val)
{
  if (lower &lt;= upper) {
    if (lower &lt; val &amp;&amp; val &lt; upper) {
      return true;
    }
  }
  else {
    if (val &lt; upper || lower &lt; val) {
      return true;
    }
  }

  return false;
}


void getTransform (Eigen::Quaternionf &amp;ori, Point3 &amp;pos)
{
  static tf::TransformListener listener;

  // target_frame    source_frame
  ros::Time now = ros::Time();
  listener.waitForTransform (camera_id_str, &quot;map&quot;, now, ros::Duration(10.0));
  listener.lookupTransform (camera_id_str, &quot;map&quot;, now, trf);

  tf::Vector3 &amp;p = trf.getOrigin();
  tf::Quaternion o = trf.getRotation();
  pos.x()=p.x(); pos.y()=p.y(); pos.z()=p.z();
  ori.w()=o.w(); ori.x()=o.x(); ori.y()=o.y(); ori.z()=o.z();
}


Point3 transform (const Point3 &amp;psrc, tf::StampedTransform &amp;tfsource)
{
  tf::Vector3 pt3 (psrc.x(), psrc.y(), psrc.z());
  tf::Vector3 pt3s = tfsource * pt3;
  return Point3 (pt3s.x(), pt3s.y(), pt3s.z());
}


/*
 * Project a point from world coordinate to image plane
 */
bool project2 (const Point3 &amp;pt, int &amp;u, int &amp;v, bool useOpenGLCoord=false)
{
  float nearPlane = 1.0;
  float farPlane = 200.0;
  Point3 _pt = transform (pt, trf);
  float _u = _pt.x()*fx/_pt.z() + cx;
  float _v = _pt.y()*fy/_pt.z() + cy;

  u = static_cast&lt;int&gt;(_u);
  v = static_cast&lt;int&gt;(_v);
  if ( u &lt; 0 || imageWidth &lt; u || v &lt; 0 || imageHeight &lt; v || _pt.z() &lt; nearPlane || farPlane &lt; _pt.z() ) {
    u = -1, v = -1;
    return false;
  }

  if (useOpenGLCoord) {
    v = imageHeight - v;
  }

  return true;
}

double ConvertDegreeToRadian(double degree)
{
  return degree * M_PI / 180.0f;
}


double ConvertRadianToDegree(double radian)
{
  return radian * 180.0f / M_PI;
}


double GetSignalAngleInCameraSystem(double hang, double vang)
{
  // Fit the vector map format into ROS style
  double signal_pitch_in_map = ConvertDegreeToRadian(vang - 90);
  double signal_yaw_in_map   = ConvertDegreeToRadian(-hang + 90);

  tf::Quaternion signal_orientation_in_map_system;
  signal_orientation_in_map_system.setRPY(0, signal_pitch_in_map, signal_yaw_in_map);

  tf::Quaternion signal_orientation_in_cam_system = trf * signal_orientation_in_map_system;
  double signal_roll_in_cam;
  double signal_pitch_in_cam;
  double signal_yaw_in_cam;
  tf::Matrix3x3(signal_orientation_in_cam_system).getRPY(signal_roll_in_cam,
                                                         signal_pitch_in_cam,
                                                         signal_yaw_in_cam);

  return ConvertRadianToDegree(signal_pitch_in_cam);   // holizontal angle of camera is represented by pitch
}  // double GetSignalAngleInCameraSystem()


void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
{
  int countPoint = 0;
  road_wizard::Signals signalsInFrame;

  /* Get signals on the path if vecter_map_server is enabled */
  if (g_use_vector_map_server) {
    vector_map_server::GetSignal service;
    /* Set server's request */
    service.request.pose = g_vector_map_client.pose();
    service.request.waypoints = g_vector_map_client.waypoints();

    /* Get server's response*/
    if (g_ros_client.call(service)) {
      /* Reset signal data container */
      vmap.signals.clear();

      /* Newle insert signal data on the path */
      for (const auto&amp; response: service.response.objects.data) {
        if (response.id == 0)
          continue;

        Signal signal;
        signal.id = response.id;
        signal.vid = response.vid;
        signal.plid = response.plid;
        signal.type = response.type;
        signal.linkid = response.linkid;

        vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
      }
    }
  }

  for (unsigned int i=1; i&lt;=vmap.signals.size(); i++) {
    Signal signal = vmap.signals[i];
    int pid = vmap.vectors[signal.vid].pid;

    Point3 signalcenter = vmap.getPoint(pid);
    Point3 signalcenterx (signalcenter.x(), signalcenter.y(), signalcenter.z()+SignalLampRadius);

    int u, v;
    if (project2 (signalcenter, u, v, useOpenGLCoord) == true) {
      countPoint++;
      // std::cout &lt;&lt; u &lt;&lt; &quot;, &quot; &lt;&lt; v &lt;&lt; &quot;, &quot; &lt;&lt; std::endl;

      int radius;
      int ux, vx;
      project2 (signalcenterx, ux, vx, useOpenGLCoord);
      radius = (int)distance (ux, vx, u, v);

      road_wizard::ExtractedPosition sign;
      sign.signalId = signal.id;

      sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
      sign.v = v + adjust_proj_y; // shift project position by configuration value from runtime manager

      sign.radius = radius;
      sign.x = signalcenter.x(), sign.y = signalcenter.y(), sign.z = signalcenter.z();
      sign.hang = vmap.vectors[signal.vid].hang; // hang is expressed in [0, 360] degree
      sign.type = signal.type, sign.linkId = signal.linkid;
      sign.plId = signal.plid;

      // Get holizontal angle of signal in camera corrdinate system
      double signal_angle = GetSignalAngleInCameraSystem(vmap.vectors[signal.vid].hang + 180.0f,
                                                         vmap.vectors[signal.vid].vang + 180.0f);

      // signal_angle will be zero if signal faces to x-axis
      // Target signal should be face to -50 &lt;= z-axis (= 90 degree) &lt;= +50
      if (isRange(-50, 50, signal_angle - 90)) {
        signalsInFrame.Signals.push_back (sign);
      }
    }
  }

  signalsInFrame.header.stamp = ros::Time::now();
  pub.publish (signalsInFrame);

  // printf (&quot;There are %d out of %u signals in frame\n&quot;, countPoint, static_cast&lt;unsigned int&gt;(vmap.signals.size()));
}


void interrupt (int s)
{
  ros::shutdown();
  exit(1);
}


int main (int argc, char *argv[])
{

  ros::init(argc, argv, &quot;feat_proj&quot;, ros::init_options::NoSigintHandler);
  ros::NodeHandle rosnode;
  ros::NodeHandle private_nh(&quot;~&quot;);
  std::string cameraInfo_topic_name;
  private_nh.param&lt;std::string&gt;(&quot;camera_info_topic&quot;, cameraInfo_topic_name, &quot;/camera/camera_info&quot;);

  /* get camera ID */
  camera_id_str = cameraInfo_topic_name;
  camera_id_str.erase(camera_id_str.find(&quot;/camera/camera_info&quot;));
  if (camera_id_str == &quot;/&quot;) {
    camera_id_str = &quot;camera&quot;;
  }
  
  /* Get Flag wheter vecter_map_server function will be used  */
  private_nh.param&lt;bool&gt;(&quot;use_path_info&quot;, g_use_vector_map_server, false);

  /* load vector map */
  ros::Subscriber sub_point     = rosnode.subscribe(&quot;vector_map_info/point&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_points,
                                                    &amp;vmap);
  ros::Subscriber sub_line      = rosnode.subscribe(&quot;vector_map_info/line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lines,
                                                    &amp;vmap);
  ros::Subscriber sub_lane      = rosnode.subscribe(&quot;vector_map_info/lane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lanes,
                                                    &amp;vmap);
  ros::Subscriber sub_vector    = rosnode.subscribe(&quot;vector_map_info/vector&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_vectors,
                                                    &amp;vmap);
  ros::Subscriber sub_signal    = rosnode.subscribe(&quot;vector_map_info/signal&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_signals,
                                                    &amp;vmap);
  ros::Subscriber sub_whiteline = rosnode.subscribe(&quot;vector_map_info/white_line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_whitelines,
                                                    &amp;vmap);
  ros::Subscriber sub_dtlane    = rosnode.subscribe(&quot;vector_map_info/dtlane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_dtlanes,
                                                    &amp;vmap);

  /* wait until loading all vector map is completed */
  ros::Rate wait_rate(1);
  while(vmap.points.empty() || vmap.lines.empty() || vmap.whitelines.empty() ||
        vmap.lanes.empty() || vmap.dtlanes.empty() || vmap.vectors.empty() || vmap.signals.empty())
    {
      ros::spinOnce();
      wait_rate.sleep();
    }

  vmap.loaded = true;
  std::cout &lt;&lt; &quot;all vector map loaded.&quot; &lt;&lt; std::endl;

  ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
  ros::Subscriber adjust_xySubscriber  = rosnode.subscribe(&quot;/config/adjust_xy&quot;, 100, adjust_xyCallback);
  ros::Subscriber current_pose_subscriber;
  ros::Subscriber waypoint_subscriber;
  if (g_use_vector_map_server) {
    /* Create subscribers which deliver informations requested by server */
    current_pose_subscriber = rosnode.subscribe(&quot;/current_pose&quot;, 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
    waypoint_subscriber     = rosnode.subscribe(&quot;/final_waypoints&quot;, 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);

    /* Create ros client to use Server-Client communication */
    g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;(&quot;vector_map_server/get_signal&quot;);
  }

  ros::Publisher  signalPublisher      = rosnode.advertise &lt;road_wizard::Signals&gt; (&quot;roi_signal&quot;, 100);
  signal (SIGINT, interrupt);

  Rate loop (25);
  while (true) {

    ros::spinOnce();

    try {
      getTransform (orientation, position);
    } catch (tf::TransformException &amp;exc) {
    }

    echoSignals2 (signalPublisher, false);
    loop.sleep();
  }


}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="b2015f6d5535fd507f118b909b2795d2e0223fb3" fix_time="62,18138">
		<msg>Localization problem patch
https://github.com/CPFL/Autoware/issues/693</msg>
		<modified_files>
			<file old_path="ros/src/sensing/filters/packages/points_downsampler/include/points_downsampler.h" new_path="ros/src/sensing/filters/packages/points_downsampler/include/points_downsampler.h">
				<diff>@@ -11,19 +11,22 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
 
   for(pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator iter = scan.begin(); iter != scan.end(); ++iter)
   {
-    pcl::PointXYZI p;
-    p.x = iter-&gt;x;
-    p.y = iter-&gt;y;
-    p.z = iter-&gt;z;
-    p.intensity = iter-&gt;intensity;
+    const pcl::PointXYZI &amp;p = *iter;
+//    p.x = iter-&gt;x;
+//    p.y = iter-&gt;y;
+//    p.z = iter-&gt;z;
+//    p.intensity = iter-&gt;intensity;
     double square_distance = p.x * p.x + p.y * p.y;
 
     if(square_min_range &lt;= square_distance &amp;&amp; square_distance &lt;= square_max_range){
       narrowed_scan.points.push_back(p);
     }
   }
-
+#if 1
   return narrowed_scan;
+#else
+  return scan;    //  This is a only tempolary patch for Localization problem.
+#endif
 }
 
 #endif // POINTS_DOWNSAMPLER_H
</diff>
				<old_file>#ifndef POINTS_DOWNSAMPLER_H
#define POINTS_DOWNSAMPLER_H

static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::PointXYZI&gt; scan, double min_range, double max_range)
{
  pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
  narrowed_scan.header = scan.header;

  double square_min_range = min_range * min_range;
  double square_max_range = max_range * max_range;

  for(pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator iter = scan.begin(); iter != scan.end(); ++iter)
  {
    pcl::PointXYZI p;
    p.x = iter-&gt;x;
    p.y = iter-&gt;y;
    p.z = iter-&gt;z;
    p.intensity = iter-&gt;intensity;
    double square_distance = p.x * p.x + p.y * p.y;

    if(square_min_range &lt;= square_distance &amp;&amp; square_distance &lt;= square_max_range){
      narrowed_scan.points.push_back(p);
    }
  }

  return narrowed_scan;
}

#endif // POINTS_DOWNSAMPLER_H
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="92ff7941f87ab89942986e77dd08d3d7828b0f0c" fix_time="36,84179">
		<msg>ndt_mapping ndt_matching, fix typo</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_mapping/ndt_mapping.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_mapping/ndt_mapping.cpp">
				<diff>@@ -515,7 +515,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
   if (_use_imu == true &amp;&amp; _use_odom == true)
     imu_odom_calc(current_scan_time);
-  if(_use_imu == true &amp;&amp; _use_odom == true)
+  if (_use_imu == true &amp;&amp; _use_odom == false)
     imu_calc(current_scan_time);
   if (_use_imu == false &amp;&amp; _use_odom == true)
     odom_calc(current_scan_time);
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization and mapping program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#define OUTPUT  // If you want to output &quot;position_log.txt&quot;, &quot;#define OUTPUT&quot;.

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#ifdef USE_FAST_PCL
#include &lt;fast_pcl/registration/ndt.h&gt;
#include &lt;fast_pcl/filters/voxel_grid.h&gt;
#else
#include &lt;pcl/registration/ndt.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#endif

#include &lt;runtime_manager/ConfigNdtMapping.h&gt;
#include &lt;runtime_manager/ConfigNdtMappingOutput.h&gt;

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

// global variables
static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom,current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw; // current_pose - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;

static double current_velocity_x = 0.0;
static double current_velocity_y = 0.0;
static double current_velocity_z = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;

static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
// Default values
static int max_iter = 30;            // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

// Leaf size of VoxelGrid filter.
static double voxel_leaf_size = 2.0;

static ros::Time callback_start, callback_end, t1_start, t1_end, t2_start, t2_end, t3_start, t3_end, t4_start, t4_end,
    t5_start, t5_end;
static ros::Duration d_callback, d1, d2, d3, d4, d5;

static ros::Publisher ndt_map_pub;
static ros::Publisher current_pose_pub;
static ros::Publisher guess_pose_linaer_pub;
static geometry_msgs::PoseStamped current_pose_msg, guess_pose_msg;

static ros::Publisher ndt_stat_pub;
static std_msgs::Bool ndt_stat_msg;

static int initial_scan_loaded = 0;

static Eigen::Matrix4f gnss_transform = Eigen::Matrix4f::Identity();

static double min_scan_range = 5.0;
static double min_add_scan_shift = 1.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol, tf_ltob;

static bool isMapUpdate = true;
static bool _use_openmp = false;
static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;


static double fitness_score;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;

static void param_callback(const runtime_manager::ConfigNdtMapping::ConstPtr&amp; input)
{

  ndt_res = input-&gt;resolution;
  step_size = input-&gt;step_size;
  trans_eps = input-&gt;trans_epsilon;
  max_iter = input-&gt;max_iterations;
  voxel_leaf_size = input-&gt;leaf_size;
  min_scan_range = input-&gt;min_scan_range;
  min_add_scan_shift = input-&gt;min_add_scan_shift;

  std::cout &lt;&lt; &quot;param_callback&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;ndt_res: &quot; &lt;&lt; ndt_res &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;step_size: &quot; &lt;&lt; step_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;trans_epsilon: &quot; &lt;&lt; trans_eps &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;max_iter: &quot; &lt;&lt; max_iter &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;voxel_leaf_size: &quot; &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;min_scan_range: &quot; &lt;&lt; min_scan_range &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;min_add_scan_shift: &quot; &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
}

static void output_callback(const runtime_manager::ConfigNdtMappingOutput::ConstPtr&amp; input)
{
  double filter_res = input-&gt;filter_res;
  std::string filename = input-&gt;filename;
  std::cout &lt;&lt; &quot;output_callback&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;filter_res: &quot; &lt;&lt; filter_res &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;filename: &quot; &lt;&lt; filename &lt;&lt; std::endl;

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_filtered(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  map_ptr-&gt;header.frame_id = &quot;map&quot;;
  map_filtered-&gt;header.frame_id = &quot;map&quot;;
  sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);

  // Apply voxelgrid filter
  if (filter_res == 0.0)
  {
    std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    pcl::toROSMsg(*map_ptr, *map_msg_ptr);
  }
  else
  {
    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
    voxel_grid_filter.setLeafSize(filter_res, filter_res, filter_res);
    voxel_grid_filter.setInputCloud(map_ptr);
    voxel_grid_filter.filter(*map_filtered);
    std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Filtered: &quot; &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    pcl::toROSMsg(*map_filtered, *map_msg_ptr);
  }

  ndt_map_pub.publish(*map_msg_ptr);

  // Writing Point Cloud data to PCD file
  if (filter_res == 0.0)
  {
    pcl::io::savePCDFileASCII(filename, *map_ptr);
    std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; data points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
  }
  else
  {
    pcl::io::savePCDFileASCII(filename, *map_filtered);
    std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; &quot; data points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
  }
}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll  += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw   += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance*cos(-current_pose_imu_odom.pitch)*cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance*cos(-current_pose_imu_odom.pitch)*sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance*sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll  += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw   += diff_imu_yaw;

  guess_pose_imu_odom.x     = previous_pose.x     + offset_imu_odom_x;
  guess_pose_imu_odom.y     = previous_pose.y     + offset_imu_odom_y;
  guess_pose_imu_odom.z     = previous_pose.z     + offset_imu_odom_z;
  guess_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
  guess_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  guess_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
 
  previous_time = current_time;
}


static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll  = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw   = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll  += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw   += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);

  offset_odom_roll  += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw   += diff_odom_yaw;

  guess_pose_odom.x     = previous_pose.x     + offset_odom_x;
  guess_pose_odom.y     = previous_pose.y     + offset_odom_y;
  guess_pose_odom.z     = previous_pose.z     + offset_odom_z;
  guess_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
  guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  guess_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
 
  previous_time = current_time;
}

static void imu_calc(ros::Time current_time)
{

  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y
                -std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y
                +std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll  += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw   += diff_imu_yaw;

  guess_pose_imu.x     = previous_pose.x     + offset_imu_x;
  guess_pose_imu.y     = previous_pose.y     + offset_imu_y;
  guess_pose_imu.z     = previous_pose.z     + offset_imu_z;
  guess_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
  guess_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  guess_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;  

  previous_time = current_time;
}


static double wrapToPm(double a_num, const double a_max)
{
    if (a_num &gt;= a_max)
    {
        a_num -= 2.0 * a_max;
    }
    return a_num;
}

static double wrapToPmPi(double a_angle_rad)
{
    return wrapToPm(a_angle_rad, M_PI);
}

static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}


static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll  *= -1;
  input_pitch *= -1;
  input_yaw   *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}


static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if(_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time =  (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll  = imu_roll  - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if(fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if(imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI*2;
    else
      diff_imu_yaw = -M_PI*2 - (imu_yaw - previous_imu_yaw);
  }
  else
  diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  //imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  //imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if(diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll  / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw   / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll  = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw   = imu_yaw;
}


static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  double r;
  pcl::PointXYZI p;
  pcl::PointCloud&lt;pcl::PointXYZI&gt; tmp, scan;
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  tf::Quaternion q;

  Eigen::Matrix4f t_localizer(Eigen::Matrix4f::Identity());
  Eigen::Matrix4f t_base_link(Eigen::Matrix4f::Identity());
  tf::TransformBroadcaster br;
  tf::Transform transform;

  current_scan_time = input-&gt;header.stamp;

  pcl::fromROSMsg(*input, tmp);

  for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++)
  {
    p.x = (double)item-&gt;x;
    p.y = (double)item-&gt;y;
    p.z = (double)item-&gt;z;
    p.intensity = (double)item-&gt;intensity;

    r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
    if (r &gt; min_scan_range)
    {
      scan.push_back(p);
    }
  }

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));

  // Add initial point cloud to velodyne_map
  if (initial_scan_loaded == 0)
  {
    pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, tf_btol);
    map += *transformed_scan_ptr;
    initial_scan_loaded = 1;
  }

  // Apply voxelgrid filter
  pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
  voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
  voxel_grid_filter.setInputCloud(scan_ptr);
  voxel_grid_filter.filter(*filtered_scan_ptr);

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
  
  ndt.setTransformationEpsilon(trans_eps);
  ndt.setStepSize(step_size);
  ndt.setResolution(ndt_res);
  ndt.setMaximumIterations(max_iter);
  ndt.setInputSource(filtered_scan_ptr);

  if (isMapUpdate == true)
  {
    ndt.setInputTarget(map_ptr);
    isMapUpdate = false;
  }

  guess_pose.x = previous_pose.x + diff_x;
  guess_pose.y = previous_pose.y + diff_y;
  guess_pose.z = previous_pose.z + diff_z;
  guess_pose.roll = previous_pose.roll;
  guess_pose.pitch = previous_pose.pitch;
  guess_pose.yaw = previous_pose.yaw + diff_yaw;


  if (_use_imu == true &amp;&amp; _use_odom == true)
    imu_odom_calc(current_scan_time);
  if(_use_imu == true &amp;&amp; _use_odom == true)
    imu_calc(current_scan_time);
  if (_use_imu == false &amp;&amp; _use_odom == true)
    odom_calc(current_scan_time);

  pose guess_pose_for_ndt;
  if(_use_imu == true &amp;&amp; _use_odom == true)
    guess_pose_for_ndt = guess_pose_imu_odom;
  else if(_use_imu == true &amp;&amp; _use_odom == false)
    guess_pose_for_ndt = guess_pose_imu;
  else if(_use_imu == false &amp;&amp; _use_odom == true)
    guess_pose_for_ndt = guess_pose_odom;
  else
    guess_pose_for_ndt = guess_pose;


  Eigen::AngleAxisf init_rotation_x(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
  Eigen::AngleAxisf init_rotation_y(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf init_rotation_z(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());

  Eigen::Translation3f init_translation(guess_pose_for_ndt.x, guess_pose_for_ndt.y, guess_pose_for_ndt.z);

  Eigen::Matrix4f init_guess =
      (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;

  t3_end = ros::Time::now();
  d3 = t3_end - t3_start;

  t4_start = ros::Time::now();

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
#ifdef USE_FAST_PCL
  if (_use_openmp == true)
  {
    ndt.omp_align(*output_cloud, init_guess);
    fitness_score = ndt.omp_getFitnessScore();
  }
  else
  {
#endif
    ndt.align(*output_cloud, init_guess);
    fitness_score = ndt.getFitnessScore();
#ifdef USE_FAST_PCL
  }
#endif

  t_localizer = ndt.getFinalTransformation();
  t_base_link = t_localizer * tf_ltob;

  pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, t_localizer);

  tf::Matrix3x3 mat_l, mat_b;

  mat_l.setValue(static_cast&lt;double&gt;(t_localizer(0, 0)), static_cast&lt;double&gt;(t_localizer(0, 1)),
                 static_cast&lt;double&gt;(t_localizer(0, 2)), static_cast&lt;double&gt;(t_localizer(1, 0)),
                 static_cast&lt;double&gt;(t_localizer(1, 1)), static_cast&lt;double&gt;(t_localizer(1, 2)),
                 static_cast&lt;double&gt;(t_localizer(2, 0)), static_cast&lt;double&gt;(t_localizer(2, 1)),
                 static_cast&lt;double&gt;(t_localizer(2, 2)));

  mat_b.setValue(static_cast&lt;double&gt;(t_base_link(0, 0)), static_cast&lt;double&gt;(t_base_link(0, 1)),
                 static_cast&lt;double&gt;(t_base_link(0, 2)), static_cast&lt;double&gt;(t_base_link(1, 0)),
                 static_cast&lt;double&gt;(t_base_link(1, 1)), static_cast&lt;double&gt;(t_base_link(1, 2)),
                 static_cast&lt;double&gt;(t_base_link(2, 0)), static_cast&lt;double&gt;(t_base_link(2, 1)),
                 static_cast&lt;double&gt;(t_base_link(2, 2)));

  // Update localizer_pose.
  localizer_pose.x = t_localizer(0, 3);
  localizer_pose.y = t_localizer(1, 3);
  localizer_pose.z = t_localizer(2, 3);
  mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

  // Update ndt_pose.
  ndt_pose.x = t_base_link(0, 3);
  ndt_pose.y = t_base_link(1, 3);
  ndt_pose.z = t_base_link(2, 3);
  mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

  current_pose.x = ndt_pose.x;
  current_pose.y = ndt_pose.y;
  current_pose.z = ndt_pose.z;
  current_pose.roll = ndt_pose.roll;
  current_pose.pitch = ndt_pose.pitch;
  current_pose.yaw = ndt_pose.yaw;

  transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
  q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
  transform.setRotation(q);

  br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;map&quot;, &quot;base_link&quot;));

  scan_duration = current_scan_time - previous_scan_time;
  double secs = scan_duration.toSec();

  // Calculate the offset (curren_pos - previous_pos)
  diff_x = current_pose.x - previous_pose.x;
  diff_y = current_pose.y - previous_pose.y;
  diff_z = current_pose.z - previous_pose.z;
  diff_yaw = current_pose.yaw - previous_pose.yaw;
  diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

  current_velocity_x = diff_x / secs;
  current_velocity_y = diff_y / secs;
  current_velocity_z = diff_z / secs;

  current_pose_imu.x = current_pose.x;
  current_pose_imu.y = current_pose.y;
  current_pose_imu.z = current_pose.z;
  current_pose_imu.roll = current_pose.roll;
  current_pose_imu.pitch = current_pose.pitch;
  current_pose_imu.yaw = current_pose.yaw;

  current_pose_odom.x = current_pose.x;
  current_pose_odom.y = current_pose.y;
  current_pose_odom.z = current_pose.z;
  current_pose_odom.roll = current_pose.roll;
  current_pose_odom.pitch = current_pose.pitch;
  current_pose_odom.yaw = current_pose.yaw;

  current_pose_imu_odom.x = current_pose.x;
  current_pose_imu_odom.y = current_pose.y;
  current_pose_imu_odom.z = current_pose.z;
  current_pose_imu_odom.roll = current_pose.roll;
  current_pose_imu_odom.pitch = current_pose.pitch;
  current_pose_imu_odom.yaw = current_pose.yaw;

  current_velocity_imu_x = current_velocity_x;
  current_velocity_imu_y = current_velocity_y;
  current_velocity_imu_z = current_velocity_z;

  // Update position and posture. current_pos -&gt; previous_pos
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  previous_scan_time.sec = current_scan_time.sec;
  previous_scan_time.nsec = current_scan_time.nsec;
  

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;
  
  // Calculate the shift between added_pos and current_pos
  double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
  if (shift &gt;= min_add_scan_shift)
  {
    map += *transformed_scan_ptr;
    added_pose.x = current_pose.x;
    added_pose.y = current_pose.y;
    added_pose.z = current_pose.z;
    added_pose.roll = current_pose.roll;
    added_pose.pitch = current_pose.pitch;
    added_pose.yaw = current_pose.yaw;
    isMapUpdate = true;
  }

  sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);
  pcl::toROSMsg(*map_ptr, *map_msg_ptr);
  ndt_map_pub.publish(*map_msg_ptr);

  q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
  current_pose_msg.header.frame_id = &quot;map&quot;;
  current_pose_msg.header.stamp = current_scan_time;
  current_pose_msg.pose.position.x = current_pose.x;
  current_pose_msg.pose.position.y = current_pose.y;
  current_pose_msg.pose.position.z = current_pose.z;
  current_pose_msg.pose.orientation.x = q.x();
  current_pose_msg.pose.orientation.y = q.y();
  current_pose_msg.pose.orientation.z = q.z();
  current_pose_msg.pose.orientation.w = q.w();

  current_pose_pub.publish(current_pose_msg);


  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Sequence number: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of scan points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of filtered scan points: &quot; &lt;&lt; filtered_scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;transformed_scan_ptr: &quot; &lt;&lt; transformed_scan_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;map: &quot; &lt;&lt; map.points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; ndt.hasConverged() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Fitness score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of iteration: &quot; &lt;&lt; ndt.getFinalNumIteration() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw):&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
            &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Transformation Matrix:&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; t_localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;shift: &quot; &lt;&lt; shift &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
}

int main(int argc, char** argv)
{
  previous_pose.x = 0.0;
  previous_pose.y = 0.0;
  previous_pose.z = 0.0;
  previous_pose.roll = 0.0;
  previous_pose.pitch = 0.0;
  previous_pose.yaw = 0.0;

  ndt_pose.x = 0.0;
  ndt_pose.y = 0.0;
  ndt_pose.z = 0.0;
  ndt_pose.roll = 0.0;
  ndt_pose.pitch = 0.0;
  ndt_pose.yaw = 0.0;

  current_pose.x = 0.0;
  current_pose.y = 0.0;
  current_pose.z = 0.0;
  current_pose.roll = 0.0;
  current_pose.pitch = 0.0;
  current_pose.yaw = 0.0;

  current_pose_imu.x = 0.0;
  current_pose_imu.y = 0.0;
  current_pose_imu.z = 0.0;
  current_pose_imu.roll = 0.0;
  current_pose_imu.pitch = 0.0;
  current_pose_imu.yaw = 0.0;

  guess_pose.x = 0.0;
  guess_pose.y = 0.0;
  guess_pose.z = 0.0;
  guess_pose.roll = 0.0;
  guess_pose.pitch = 0.0;
  guess_pose.yaw = 0.0;

  added_pose.x = 0.0;
  added_pose.y = 0.0;
  added_pose.z = 0.0;
  added_pose.roll = 0.0;
  added_pose.pitch = 0.0;
  added_pose.yaw = 0.0;

  diff_x = 0.0;
  diff_y = 0.0;
  diff_z = 0.0;
  diff_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;

  ros::init(argc, argv, &quot;ndt_mapping&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  // setting parameters
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;

  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
  Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
  tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();

  map.header.frame_id = &quot;map&quot;;

  ndt_map_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/ndt_map&quot;, 1000);
  current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);

  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt_mapping&quot;, 10, param_callback);
  ros::Subscriber output_sub = nh.subscribe(&quot;config/ndt_mapping_output&quot;, 10, output_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;points_raw&quot;, 100000, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, 100000, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic, 100000, imu_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp">
				<diff>@@ -759,7 +759,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
     if (_use_imu == true &amp;&amp; _use_odom == true)
       imu_odom_calc(current_scan_time);
-    if(_use_imu == true &amp;&amp; _use_odom == true)
+    if (_use_imu == true &amp;&amp; _use_odom == false)
       imu_calc(current_scan_time);
     if (_use_imu == false &amp;&amp; _use_odom == true)
       odom_calc(current_scan_time);
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;chrono&gt;

#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;

#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;tf/transform_listener.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#ifdef USE_FAST_PCL
#include &lt;fast_pcl/registration/ndt.h&gt;
#else
#include &lt;pcl/registration/ndt.h&gt;
#endif

#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_ros/transforms.h&gt;

#include &lt;runtime_manager/ConfigNdt.h&gt;

#include &lt;ndt_localizer/ndt_stat.h&gt;

#define PREDICT_POSE_THRESHOLD 0.5

#define Wa 0.4
#define Wb 0.3
#define Wc 0.3

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose, ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose, previous_gnss_pose,
    current_gnss_pose;

static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw; 
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;

// Can't load if typed &quot;pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;&quot;
static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;

// If the map is loaded, map_loaded will be 1.
static int map_loaded = 0;
static int _use_gnss = 1;
static int init_pos_set = 0;

static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
// Default values
static int max_iter = 30;        // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

static ros::Publisher predict_pose_pub;
static geometry_msgs::PoseStamped predict_pose_msg;

static ros::Publisher predict_pose_imu_pub;
static geometry_msgs::PoseStamped predict_pose_imu_msg;

static ros::Publisher predict_pose_odom_pub;
static geometry_msgs::PoseStamped predict_pose_odom_msg;

static ros::Publisher predict_pose_imu_odom_pub;
static geometry_msgs::PoseStamped predict_pose_imu_odom_msg;

static ros::Publisher ndt_pose_pub;
static geometry_msgs::PoseStamped ndt_pose_msg;

// current_pose is published by vel_pose_mux
/*
static ros::Publisher current_pose_pub;
static geometry_msgs::PoseStamped current_pose_msg;
*/

static ros::Publisher localizer_pose_pub;
static geometry_msgs::PoseStamped localizer_pose_msg;

static ros::Publisher estimate_twist_pub;
static geometry_msgs::TwistStamped estimate_twist_msg;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double exe_time = 0.0;
static int iteration = 0;
static double fitness_score = 0.0;
static double trans_probability = 0.0;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;

static double current_velocity = 0.0, previous_velocity = 0.0, previous_previous_velocity = 0.0;  // [m/s]
static double current_velocity_x = 0.0, previous_velocity_x = 0.0;
static double current_velocity_y = 0.0, previous_velocity_y = 0.0;
static double current_velocity_z = 0.0, previous_velocity_z = 0.0;
// static double current_velocity_yaw = 0.0, previous_velocity_yaw = 0.0;
static double current_velocity_smooth = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static double current_accel = 0.0, previous_accel = 0.0;  // [m/s^2]
static double current_accel_x = 0.0;
static double current_accel_y = 0.0;
static double current_accel_z = 0.0;
// static double current_accel_yaw = 0.0;

static double angular_velocity = 0.0;

static int use_predict_pose = 0;

static ros::Publisher estimated_vel_mps_pub, estimated_vel_kmph_pub, estimated_vel_pub;
static std_msgs::Float32 estimated_vel_mps, estimated_vel_kmph, previous_estimated_vel_kmph;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; matching_start, matching_end;

static ros::Publisher time_ndt_matching_pub;
static std_msgs::Float32 time_ndt_matching;

static int _queue_size = 1000;

static ros::Publisher ndt_stat_pub;
static ndt_localizer::ndt_stat ndt_stat_msg;

static double predict_pose_error = 0.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol, tf_ltob;

static std::string _localizer = &quot;velodyne&quot;;
static std::string _offset = &quot;linear&quot;;  // linear, zero, quadratic

static ros::Publisher ndt_reliability_pub;
static std_msgs::Float32 ndt_reliability;

static bool _use_openmp = false;
static bool _get_height = false;
static bool _use_local_transform = false;
static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;

static std::ofstream ofs;
static std::string filename;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;


// static tf::TransformListener local_transform_listener;
static tf::StampedTransform local_transform;

static void param_callback(const runtime_manager::ConfigNdt::ConstPtr&amp; input)
{
  if (_use_gnss != input-&gt;init_pos_gnss)
  {
    init_pos_set = 0;
  }
  else if (_use_gnss == 0 &amp;&amp;
           (initial_pose.x != input-&gt;x || initial_pose.y != input-&gt;y || initial_pose.z != input-&gt;z ||
            initial_pose.roll != input-&gt;roll || initial_pose.pitch != input-&gt;pitch || initial_pose.yaw != input-&gt;yaw))
  {
    init_pos_set = 0;
  }

  _use_gnss = input-&gt;init_pos_gnss;

  // Setting parameters
  if (input-&gt;resolution != ndt_res)
  {
    ndt_res = input-&gt;resolution;
    ndt.setResolution(ndt_res);
  }
  if (input-&gt;step_size != step_size)
  {
    step_size = input-&gt;step_size;
    ndt.setStepSize(step_size);
  }
  if (input-&gt;trans_epsilon != trans_eps)
  {
    trans_eps = input-&gt;trans_epsilon;
    ndt.setTransformationEpsilon(trans_eps);
  }
  if (input-&gt;max_iterations != max_iter)
  {
    max_iter = input-&gt;max_iterations;
    ndt.setMaximumIterations(max_iter);
  }

  if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
  {
    initial_pose.x = input-&gt;x;
    initial_pose.y = input-&gt;y;
    initial_pose.z = input-&gt;z;
    initial_pose.roll = input-&gt;roll;
    initial_pose.pitch = input-&gt;pitch;
    initial_pose.yaw = input-&gt;yaw;

    if (_use_local_transform == true)
    {
      tf::Vector3 v(input-&gt;x, input-&gt;y, input-&gt;z);
      tf::Quaternion q;
      q.setRPY(input-&gt;roll, input-&gt;pitch, input-&gt;yaw);
      tf::Transform transform(q, v);
      initial_pose.x = (local_transform.inverse() * transform).getOrigin().getX();
      initial_pose.y = (local_transform.inverse() * transform).getOrigin().getY();
      initial_pose.z = (local_transform.inverse() * transform).getOrigin().getZ();

      tf::Matrix3x3 m(q);
      m.getRPY(initial_pose.roll, initial_pose.pitch, initial_pose.yaw);

      std::cout &lt;&lt; &quot;initial_pose.x: &quot; &lt;&lt; initial_pose.x &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.y: &quot; &lt;&lt; initial_pose.y &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.z: &quot; &lt;&lt; initial_pose.z &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.roll: &quot; &lt;&lt; initial_pose.roll &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.pitch: &quot; &lt;&lt; initial_pose.pitch &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.yaw: &quot; &lt;&lt; initial_pose.yaw &lt;&lt; std::endl;
    }

    // Setting position and posture for the first time.
    localizer_pose.x = initial_pose.x;
    localizer_pose.y = initial_pose.y;
    localizer_pose.z = initial_pose.z;
    localizer_pose.roll = initial_pose.roll;
    localizer_pose.pitch = initial_pose.pitch;
    localizer_pose.yaw = initial_pose.yaw;

    previous_pose.x = initial_pose.x;
    previous_pose.y = initial_pose.y;
    previous_pose.z = initial_pose.z;
    previous_pose.roll = initial_pose.roll;
    previous_pose.pitch = initial_pose.pitch;
    previous_pose.yaw = initial_pose.yaw;

    current_pose.x = initial_pose.x;
    current_pose.y = initial_pose.y;
    current_pose.z = initial_pose.z;
    current_pose.roll = initial_pose.roll;
    current_pose.pitch = initial_pose.pitch;
    current_pose.yaw = initial_pose.yaw;

    current_velocity = 0;
    current_velocity_x = 0;
    current_velocity_y = 0;
    current_velocity_z = 0;
    angular_velocity = 0;

    current_pose_imu.x = 0;
    current_pose_imu.y = 0;
    current_pose_imu.z = 0;
    current_pose_imu.roll = 0;
    current_pose_imu.pitch = 0;
    current_pose_imu.yaw = 0;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;
    init_pos_set = 1;
  }
}

static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 0)
  {
    // Convert the data type(from sensor_msgs to pcl).
    pcl::fromROSMsg(*input, map);

    if (_use_local_transform == true)
    {
      tf::TransformListener local_transform_listener;
      try
      {
        ros::Time now = ros::Time(0);
        local_transform_listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
        local_transform_listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, local_transform);
      }
      catch (tf::TransformException&amp; ex)
      {
        ROS_ERROR(&quot;%s&quot;, ex.what());
      }

      pcl_ros::transformPointCloud(map, map, local_transform.inverse());
    }

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
    // Setting point cloud to be aligned to.
    ndt.setInputTarget(map_ptr);

    // Setting NDT parameters to default values
    ndt.setMaximumIterations(max_iter);
    ndt.setResolution(ndt_res);
    ndt.setStepSize(step_size);
    ndt.setTransformationEpsilon(trans_eps);

    map_loaded = 1;
  }
}

static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
{
  tf::Quaternion gnss_q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z,
                        input-&gt;pose.orientation.w);
  tf::Matrix3x3 gnss_m(gnss_q);
  current_gnss_pose.x = input-&gt;pose.position.x;
  current_gnss_pose.y = input-&gt;pose.position.y;
  current_gnss_pose.z = input-&gt;pose.position.z;
  gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);

  if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= 500.0)
  {
    previous_pose.x = previous_gnss_pose.x;
    previous_pose.y = previous_gnss_pose.y;
    previous_pose.z = previous_gnss_pose.z;
    previous_pose.roll = previous_gnss_pose.roll;
    previous_pose.pitch = previous_gnss_pose.pitch;
    previous_pose.yaw = previous_gnss_pose.yaw;

    current_pose.x = current_gnss_pose.x;
    current_pose.y = current_gnss_pose.y;
    current_pose.z = current_gnss_pose.z;
    current_pose.roll = current_gnss_pose.roll;
    current_pose.pitch = current_gnss_pose.pitch;
    current_pose.yaw = current_gnss_pose.yaw;

    current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;

    offset_x = current_pose.x - previous_pose.x;
    offset_y = current_pose.y - previous_pose.y;
    offset_z = current_pose.z - previous_pose.z;
    offset_yaw = current_pose.yaw - previous_pose.yaw;

    init_pos_set = 1;
  }

  previous_gnss_pose.x = current_gnss_pose.x;
  previous_gnss_pose.y = current_gnss_pose.y;
  previous_gnss_pose.z = current_gnss_pose.z;
  previous_gnss_pose.roll = current_gnss_pose.roll;
  previous_gnss_pose.pitch = current_gnss_pose.pitch;
  previous_gnss_pose.yaw = current_gnss_pose.yaw;
}

static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
{
  tf::TransformListener listener;
  tf::StampedTransform transform;
  try
  {
    ros::Time now = ros::Time(0);
    listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
    listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, transform);
  }
  catch (tf::TransformException&amp; ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
  }

  tf::Quaternion q(input-&gt;pose.pose.orientation.x, input-&gt;pose.pose.orientation.y, input-&gt;pose.pose.orientation.z,
                   input-&gt;pose.pose.orientation.w);
  tf::Matrix3x3 m(q);

  if (_use_local_transform == true)
  {
    current_pose.x = input-&gt;pose.pose.position.x;
    current_pose.y = input-&gt;pose.pose.position.y;
    current_pose.z = input-&gt;pose.pose.position.z;
  }
  else
  {
    current_pose.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
    current_pose.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
    current_pose.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
  }
  m.getRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);

  if (_get_height == true &amp;&amp; map_loaded == 1)
  {
    double min_distance = DBL_MAX;
    double nearest_z = current_pose.z;
    for (const auto&amp; p : map)
    {
      double distance = hypot(current_pose.x - p.x, current_pose.y - p.y);
      if (distance &lt; min_distance)
      {
        min_distance = distance;
        nearest_z = p.z;
      }
    }
    current_pose.z = nearest_z;
  }
  
  current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  offset_x = 0.0;
  offset_y = 0.0;
  offset_z = 0.0;
  offset_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;

}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll  += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw   += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance*cos(-current_pose_imu_odom.pitch)*cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance*cos(-current_pose_imu_odom.pitch)*sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance*sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll  += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw   += diff_imu_yaw;

  predict_pose_imu_odom.x     = previous_pose.x     + offset_imu_odom_x;
  predict_pose_imu_odom.y     = previous_pose.y     + offset_imu_odom_y;
  predict_pose_imu_odom.z     = previous_pose.z     + offset_imu_odom_z;
  predict_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
  predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  predict_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
 
  previous_time = current_time;
}


static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll  = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw   = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll  += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw   += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);

  offset_odom_roll  += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw   += diff_odom_yaw;

  predict_pose_odom.x     = previous_pose.x     + offset_odom_x;
  predict_pose_odom.y     = previous_pose.y     + offset_odom_y;
  predict_pose_odom.z     = previous_pose.z     + offset_odom_z;
  predict_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
  predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  predict_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
 
  previous_time = current_time;

}

static void imu_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y
                -std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y
                +std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll  += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw   += diff_imu_yaw;

  predict_pose_imu.x     = previous_pose.x     + offset_imu_x;
  predict_pose_imu.y     = previous_pose.y     + offset_imu_y;
  predict_pose_imu.z     = previous_pose.z     + offset_imu_z;
  predict_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
  predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  predict_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;  

  previous_time = current_time;
}


static const double wrapToPm(double a_num, const double a_max)
{
    if (a_num &gt;= a_max)
    {
        a_num -= 2.0 * a_max;
    }
    return a_num;
}

static const double wrapToPmPi(double a_angle_rad)
{
    return wrapToPm(a_angle_rad, M_PI);
}


static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}

static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll  *= -1;
  input_pitch *= -1;
  input_yaw   *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}

static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if(_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time =  (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll  = imu_roll  - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if(fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if(imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI*2;
    else
      diff_imu_yaw = -M_PI*2 - (imu_yaw - previous_imu_yaw);
  }
  else
  diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  //imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  //imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if(diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll  / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw   / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll  = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw   = imu_yaw;
}

static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
  {
    matching_start = std::chrono::system_clock::now();

    static tf::TransformBroadcaster br;
    tf::Transform transform;
    tf::Quaternion predict_q, ndt_q, current_q, localizer_q;

    pcl::PointXYZ p;
    pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;

    current_scan_time = input-&gt;header.stamp;

    pcl::fromROSMsg(*input, filtered_scan);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan));
    int scan_points_num = filtered_scan_ptr-&gt;size();

    Eigen::Matrix4f t(Eigen::Matrix4f::Identity());   // base_link
    Eigen::Matrix4f t2(Eigen::Matrix4f::Identity());  // localizer

    std::chrono::time_point&lt;std::chrono::system_clock&gt; align_start, align_end, getFitnessScore_start,
        getFitnessScore_end;
    static double align_time, getFitnessScore_time = 0.0;

    // Setting point cloud to be aligned.
    ndt.setInputSource(filtered_scan_ptr);

    // Guess the initial gross estimation of the transformation
    predict_pose.x = previous_pose.x + offset_x;
    predict_pose.y = previous_pose.y + offset_y;
    predict_pose.z = previous_pose.z + offset_z;
    predict_pose.roll = previous_pose.roll;
    predict_pose.pitch = previous_pose.pitch;
    predict_pose.yaw = previous_pose.yaw + offset_yaw;


    if (_use_imu == true &amp;&amp; _use_odom == true)
      imu_odom_calc(current_scan_time);
    if(_use_imu == true &amp;&amp; _use_odom == true)
      imu_calc(current_scan_time);
    if (_use_imu == false &amp;&amp; _use_odom == true)
      odom_calc(current_scan_time);
    
    pose predict_pose_for_ndt;
    if (_use_imu == true &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_imu_odom;
    else if (_use_imu == true &amp;&amp; _use_odom == false)
      predict_pose_for_ndt = predict_pose_imu;
    else if (_use_imu == false &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_odom;
    else
      predict_pose_for_ndt = predict_pose;

    Eigen::Translation3f init_translation(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z);
    Eigen::AngleAxisf init_rotation_x(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
    Eigen::AngleAxisf init_rotation_y(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
    Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;




    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
#ifdef USE_FAST_PCL
    if (_use_openmp == true)
    {
      align_start = std::chrono::system_clock::now();
      ndt.omp_align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();
    }
    else
    {
#endif
      align_start = std::chrono::system_clock::now();
      ndt.align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();
#ifdef USE_FAST_PCL
    }
#endif

    align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;


    t = ndt.getFinalTransformation();  // localizer
    t2 = t * tf_ltob;                  // base_link

    iteration = ndt.getFinalNumIteration();
#ifdef USE_FAST_PCL
    if (_use_openmp == true)
    {
      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.omp_getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();
    }
    else
    {
#endif
      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();
#ifdef USE_FAST_PCL
    }
#endif
    getFitnessScore_time =
        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() /
        1000.0;


    trans_probability = ndt.getTransformationProbability();

    tf::Matrix3x3 mat_l;  // localizer
    mat_l.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)),
                   static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)),
                   static_cast&lt;double&gt;(t(2, 0)), static_cast&lt;double&gt;(t(2, 1)), static_cast&lt;double&gt;(t(2, 2)));

    // Update localizer_pose
    localizer_pose.x = t(0, 3);
    localizer_pose.y = t(1, 3);
    localizer_pose.z = t(2, 3);
    mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

    tf::Matrix3x3 mat_b;  // base_link
    mat_b.setValue(static_cast&lt;double&gt;(t2(0, 0)), static_cast&lt;double&gt;(t2(0, 1)), static_cast&lt;double&gt;(t2(0, 2)),
                   static_cast&lt;double&gt;(t2(1, 0)), static_cast&lt;double&gt;(t2(1, 1)), static_cast&lt;double&gt;(t2(1, 2)),
                   static_cast&lt;double&gt;(t2(2, 0)), static_cast&lt;double&gt;(t2(2, 1)), static_cast&lt;double&gt;(t2(2, 2)));

    // Update ndt_pose
    ndt_pose.x = t2(0, 3);
    ndt_pose.y = t2(1, 3);
    ndt_pose.z = t2(2, 3);
    mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

    // Calculate the difference between ndt_pose and predict_pose
    predict_pose_error = sqrt((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) +
                              (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) +
                              (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));

    if (predict_pose_error &lt;= PREDICT_POSE_THRESHOLD)
    {
      use_predict_pose = 0;
    }
    else
    {
      use_predict_pose = 1;
    }
    use_predict_pose = 0;


    if (use_predict_pose == 0)
    {
      current_pose.x = ndt_pose.x;
      current_pose.y = ndt_pose.y;
      current_pose.z = ndt_pose.z;
      current_pose.roll = ndt_pose.roll;
      current_pose.pitch = ndt_pose.pitch;
      current_pose.yaw = ndt_pose.yaw;
    }
    else
    {
      current_pose.x = predict_pose_for_ndt.x;
      current_pose.y = predict_pose_for_ndt.y;
      current_pose.z = predict_pose_for_ndt.z;
      current_pose.roll = predict_pose_for_ndt.roll;
      current_pose.pitch = predict_pose_for_ndt.pitch;
      current_pose.yaw = predict_pose_for_ndt.yaw;
    }


    // Compute the velocity and acceleration
    scan_duration = current_scan_time - previous_scan_time;
    double secs = scan_duration.toSec();
    diff_x = current_pose.x - previous_pose.x;
    diff_y = current_pose.y - previous_pose.y;
    diff_z = current_pose.z - previous_pose.z;
    diff_yaw = current_pose.yaw - previous_pose.yaw;
    diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

    current_velocity = diff / secs;
    current_velocity_x = diff_x / secs;
    current_velocity_y = diff_y / secs;
    current_velocity_z = diff_z / secs;
    angular_velocity = diff_yaw / secs;

    current_pose_imu.x = current_pose.x;
    current_pose_imu.y = current_pose.y;
    current_pose_imu.z = current_pose.z;
    current_pose_imu.roll = current_pose.roll;
    current_pose_imu.pitch = current_pose.pitch;
    current_pose_imu.yaw = current_pose.yaw;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;


    current_pose_odom.x = current_pose.x;
    current_pose_odom.y = current_pose.y;
    current_pose_odom.z = current_pose.z;
    current_pose_odom.roll = current_pose.roll;
    current_pose_odom.pitch = current_pose.pitch;
    current_pose_odom.yaw = current_pose.yaw;

    current_pose_imu_odom.x = current_pose.x;
    current_pose_imu_odom.y = current_pose.y;
    current_pose_imu_odom.z = current_pose.z;
    current_pose_imu_odom.roll = current_pose.roll;
    current_pose_imu_odom.pitch = current_pose.pitch;
    current_pose_imu_odom.yaw = current_pose.yaw;

    current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
    if (current_velocity_smooth &lt; 0.2)
    {
      current_velocity_smooth = 0.0;
    }

    current_accel = (current_velocity - previous_velocity) / secs;
    current_accel_x = (current_velocity_x - previous_velocity_x) / secs;
    current_accel_y = (current_velocity_y - previous_velocity_y) / secs;
    current_accel_z = (current_velocity_z - previous_velocity_z) / secs;

    estimated_vel_mps.data = current_velocity;
    estimated_vel_kmph.data = current_velocity * 3.6;

    estimated_vel_mps_pub.publish(estimated_vel_mps);
    estimated_vel_kmph_pub.publish(estimated_vel_kmph);

    // Set values for publishing pose
    predict_q.setRPY(predict_pose.roll, predict_pose.pitch, predict_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(predict_pose.x, predict_pose.y, predict_pose.z);
      tf::Transform transform(predict_q, v);
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      predict_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      predict_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      predict_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      predict_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      predict_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      predict_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = predict_pose.x;
      predict_pose_msg.pose.position.y = predict_pose.y;
      predict_pose_msg.pose.position.z = predict_pose.z;
      predict_pose_msg.pose.orientation.x = predict_q.x();
      predict_pose_msg.pose.orientation.y = predict_q.y();
      predict_pose_msg.pose.orientation.z = predict_q.z();
      predict_pose_msg.pose.orientation.w = predict_q.w();
    }

    tf::Quaternion predict_q_imu;
    predict_q_imu.setRPY(predict_pose_imu.roll, predict_pose_imu.pitch, predict_pose_imu.yaw);
    predict_pose_imu_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_msg.pose.position.x = predict_pose_imu.x;
    predict_pose_imu_msg.pose.position.y = predict_pose_imu.y;
    predict_pose_imu_msg.pose.position.z = predict_pose_imu.z;
    predict_pose_imu_msg.pose.orientation.x = predict_q_imu.x();
    predict_pose_imu_msg.pose.orientation.y = predict_q_imu.y();
    predict_pose_imu_msg.pose.orientation.z = predict_q_imu.z();
    predict_pose_imu_msg.pose.orientation.w = predict_q_imu.w();
    predict_pose_imu_pub.publish(predict_pose_imu_msg);

    tf::Quaternion predict_q_odom;
    predict_q_odom.setRPY(predict_pose_odom.roll, predict_pose_odom.pitch, predict_pose_odom.yaw);
    predict_pose_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_odom_msg.pose.position.x = predict_pose_odom.x;
    predict_pose_odom_msg.pose.position.y = predict_pose_odom.y;
    predict_pose_odom_msg.pose.position.z = predict_pose_odom.z;
    predict_pose_odom_msg.pose.orientation.x = predict_q_odom.x();
    predict_pose_odom_msg.pose.orientation.y = predict_q_odom.y();
    predict_pose_odom_msg.pose.orientation.z = predict_q_odom.z();
    predict_pose_odom_msg.pose.orientation.w = predict_q_odom.w();
    predict_pose_odom_pub.publish(predict_pose_odom_msg);


    tf::Quaternion predict_q_imu_odom;
    predict_q_imu_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
    predict_pose_imu_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_odom_msg.pose.position.x = predict_pose_imu_odom.x;
    predict_pose_imu_odom_msg.pose.position.y = predict_pose_imu_odom.y;
    predict_pose_imu_odom_msg.pose.position.z = predict_pose_imu_odom.z;
    predict_pose_imu_odom_msg.pose.orientation.x = predict_q_imu_odom.x();
    predict_pose_imu_odom_msg.pose.orientation.y = predict_q_imu_odom.y();
    predict_pose_imu_odom_msg.pose.orientation.z = predict_q_imu_odom.z();
    predict_pose_imu_odom_msg.pose.orientation.w = predict_q_imu_odom.w();
    predict_pose_imu_odom_pub.publish(predict_pose_imu_odom_msg);

    ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(ndt_pose.x, ndt_pose.y, ndt_pose.z);
      tf::Transform transform(ndt_q, v);
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      ndt_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      ndt_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      ndt_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      ndt_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      ndt_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      ndt_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = ndt_pose.x;
      ndt_pose_msg.pose.position.y = ndt_pose.y;
      ndt_pose_msg.pose.position.z = ndt_pose.z;
      ndt_pose_msg.pose.orientation.x = ndt_q.x();
      ndt_pose_msg.pose.orientation.y = ndt_q.y();
      ndt_pose_msg.pose.orientation.z = ndt_q.z();
      ndt_pose_msg.pose.orientation.w = ndt_q.w();
    }

    current_q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
    // current_pose is published by vel_pose_mux
    /*
    current_pose_msg.header.frame_id = &quot;/map&quot;;
    current_pose_msg.header.stamp = current_scan_time;
    current_pose_msg.pose.position.x = current_pose.x;
    current_pose_msg.pose.position.y = current_pose.y;
    current_pose_msg.pose.position.z = current_pose.z;
    current_pose_msg.pose.orientation.x = current_q.x();
    current_pose_msg.pose.orientation.y = current_q.y();
    current_pose_msg.pose.orientation.z = current_q.z();
    current_pose_msg.pose.orientation.w = current_q.w();
    */

    localizer_q.setRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(localizer_pose.x, localizer_pose.y, localizer_pose.z);
      tf::Transform transform(localizer_q, v);
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      localizer_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      localizer_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      localizer_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      localizer_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      localizer_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      localizer_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = localizer_pose.x;
      localizer_pose_msg.pose.position.y = localizer_pose.y;
      localizer_pose_msg.pose.position.z = localizer_pose.z;
      localizer_pose_msg.pose.orientation.x = localizer_q.x();
      localizer_pose_msg.pose.orientation.y = localizer_q.y();
      localizer_pose_msg.pose.orientation.z = localizer_q.z();
      localizer_pose_msg.pose.orientation.w = localizer_q.w();
    }

    predict_pose_pub.publish(predict_pose_msg);
    ndt_pose_pub.publish(ndt_pose_msg);
    // current_pose is published by vel_pose_mux
    //    current_pose_pub.publish(current_pose_msg);
    localizer_pose_pub.publish(localizer_pose_msg);

    // Send TF &quot;/base_link&quot; to &quot;/map&quot;
    transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
    transform.setRotation(current_q);
    //    br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    if (_use_local_transform == true)
    {
      br.sendTransform(tf::StampedTransform(local_transform * transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }
    else
    {
      br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }

    matching_end = std::chrono::system_clock::now();
    exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
    time_ndt_matching.data = exe_time;
    time_ndt_matching_pub.publish(time_ndt_matching);

    // Set values for /estimate_twist
    estimate_twist_msg.header.stamp = current_scan_time;
    estimate_twist_msg.header.frame_id = &quot;/base_link&quot;;
    estimate_twist_msg.twist.linear.x = current_velocity;
    estimate_twist_msg.twist.linear.y = 0.0;
    estimate_twist_msg.twist.linear.z = 0.0;
    estimate_twist_msg.twist.angular.x = 0.0;
    estimate_twist_msg.twist.angular.y = 0.0;
    estimate_twist_msg.twist.angular.z = angular_velocity;

    estimate_twist_pub.publish(estimate_twist_msg);

    geometry_msgs::Vector3Stamped estimate_vel_msg;
    estimate_vel_msg.header.stamp = current_scan_time;
    estimate_vel_msg.vector.x = current_velocity;
    estimated_vel_pub.publish(estimate_vel_msg);

    // Set values for /ndt_stat
    ndt_stat_msg.header.stamp = current_scan_time;
    ndt_stat_msg.exe_time = time_ndt_matching.data;
    ndt_stat_msg.iteration = iteration;
    ndt_stat_msg.score = fitness_score;
    ndt_stat_msg.velocity = current_velocity;
    ndt_stat_msg.acceleration = current_accel;
    ndt_stat_msg.use_predict_pose = 0;

    ndt_stat_pub.publish(ndt_stat_msg);

    /* Compute NDT_Reliability */
    ndt_reliability.data = Wa * (exe_time / 100.0) * 100.0 + Wb * (iteration / 10.0) * 100.0 +
                           Wc * ((2.0 - trans_probability) / 2.0) * 100.0;
    ndt_reliability_pub.publish(ndt_reliability);


    // Write log
    if (!ofs)
    {
      std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      exit(1);
    }
    static ros::Time start_time = input-&gt;header.stamp;

    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; &quot;,&quot; &lt;&lt; scan_points_num &lt;&lt; &quot;,&quot; &lt;&lt; step_size &lt;&lt; &quot;,&quot; &lt;&lt; trans_eps &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed
        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.pitch
        &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.y &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.z &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose_error &lt;&lt; &quot;,&quot; &lt;&lt; iteration &lt;&lt; &quot;,&quot; &lt;&lt; fitness_score &lt;&lt; &quot;,&quot; &lt;&lt; trans_probability &lt;&lt; &quot;,&quot;
        &lt;&lt; ndt_reliability.data &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity_smooth &lt;&lt; &quot;,&quot; &lt;&lt; current_accel
        &lt;&lt; &quot;,&quot; &lt;&lt; angular_velocity &lt;&lt; &quot;,&quot; &lt;&lt; time_ndt_matching.data &lt;&lt; &quot;,&quot; &lt;&lt; align_time &lt;&lt; &quot;,&quot; &lt;&lt; getFitnessScore_time
        &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Sequence: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Timestamp: &quot; &lt;&lt; input-&gt;header.stamp &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Frame ID: &quot; &lt;&lt; input-&gt;header.frame_id &lt;&lt; std::endl;
    //		std::cout &lt;&lt; &quot;Number of Scan Points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Filtered Scan Points: &quot; &lt;&lt; scan_points_num &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; ndt.hasConverged() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Fitness Score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Probability: &quot; &lt;&lt; ndt.getTransformationProbability() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Execution Time: &quot; &lt;&lt; exe_time &lt;&lt; &quot; ms.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Iterations: &quot; &lt;&lt; ndt.getFinalNumIteration() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT Reliability: &quot; &lt;&lt; ndt_reliability.data &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw): &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
              &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Matrix: &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; t &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

    // Update offset
    if (_offset == &quot;linear&quot;)
    {
      offset_x = diff_x;
      offset_y = diff_y;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;quadratic&quot;)
    {
      offset_x = (current_velocity_x + current_accel_x * secs) * secs;
      offset_y = (current_velocity_y + current_accel_y * secs) * secs;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;zero&quot;)
    {
      offset_x = 0.0;
      offset_y = 0.0;
      offset_z = 0.0;
      offset_yaw = 0.0;
    }
   
    offset_imu_x = 0.0;
    offset_imu_y = 0.0;
    offset_imu_z = 0.0;
    offset_imu_roll = 0.0;
    offset_imu_pitch = 0.0;
    offset_imu_yaw = 0.0;

    offset_odom_x = 0.0;
    offset_odom_y = 0.0;
    offset_odom_z = 0.0;
    offset_odom_roll = 0.0;
    offset_odom_pitch = 0.0;
    offset_odom_yaw = 0.0;

    offset_imu_odom_x = 0.0;
    offset_imu_odom_y = 0.0;
    offset_imu_odom_z = 0.0;
    offset_imu_odom_roll = 0.0;
    offset_imu_odom_pitch = 0.0;
    offset_imu_odom_yaw = 0.0;

    // Update previous_***
    previous_pose.x = current_pose.x;
    previous_pose.y = current_pose.y;
    previous_pose.z = current_pose.z;
    previous_pose.roll = current_pose.roll;
    previous_pose.pitch = current_pose.pitch;
    previous_pose.yaw = current_pose.yaw;

    previous_scan_time.sec = current_scan_time.sec;
    previous_scan_time.nsec = current_scan_time.nsec;

    previous_previous_velocity = previous_velocity;
    previous_velocity = current_velocity;
    previous_velocity_x = current_velocity_x;
    previous_velocity_y = current_velocity_y;
    previous_velocity_z = current_velocity_z;
    previous_accel = current_accel;

    previous_estimated_vel_kmph.data = estimated_vel_kmph.data;
  }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;ndt_matching&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  // Set log file name.
  char buffer[80];
  std::time_t now = std::time(NULL);
  std::tm* pnow = std::localtime(&amp;now);
  std::strftime(buffer, 80, &quot;%Y%m%d_%H%M%S&quot;, pnow);
  filename = &quot;ndt_matching_&quot; + std::string(buffer) + &quot;.csv&quot;;
  ofs.open(filename.c_str(), std::ios::app);

  // Geting parameters
  private_nh.getParam(&quot;use_gnss&quot;, _use_gnss);
  private_nh.getParam(&quot;queue_size&quot;, _queue_size);
  private_nh.getParam(&quot;offset&quot;, _offset);
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
  private_nh.getParam(&quot;get_height&quot;, _get_height);
  private_nh.getParam(&quot;use_local_transform&quot;, _use_local_transform);
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

  if (nh.getParam(&quot;localizer&quot;, _localizer) == false)
  {
    std::cout &lt;&lt; &quot;localizer is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Log file: &quot; &lt;&lt; filename &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_gnss: &quot; &lt;&lt; _use_gnss &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;queue_size: &quot; &lt;&lt; _queue_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;offset: &quot; &lt;&lt; _offset &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;get_height: &quot; &lt;&lt; _get_height &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_local_transform: &quot; &lt;&lt; _use_local_transform &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;localizer: &quot; &lt;&lt; _localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
  Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
  tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();

  // Updated in initialpose_callback or gnss_callback
  initial_pose.x = 0.0;
  initial_pose.y = 0.0;
  initial_pose.z = 0.0;
  initial_pose.roll = 0.0;
  initial_pose.pitch = 0.0;
  initial_pose.yaw = 0.0;

  // Publishers
  predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose&quot;, 1000);
  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu&quot;, 1000);
  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_odom&quot;, 1000);
  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu_odom&quot;, 1000);
  ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/ndt_pose&quot;, 1000);
  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);
  localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/localizer_pose&quot;, 1000);
  estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;/estimate_twist&quot;, 1000);
  estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_mps&quot;, 1000);
  estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_kmph&quot;, 1000);
  estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;(&quot;/estimated_vel&quot;, 1000);
  time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/time_ndt_matching&quot;, 1000);
  ndt_stat_pub = nh.advertise&lt;ndt_localizer::ndt_stat&gt;(&quot;/ndt_stat&quot;, 1000);
  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/ndt_reliability&quot;, 1000);

  // Subscribers
  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt&quot;, 10, param_callback);
  ros::Subscriber gnss_sub = nh.subscribe(&quot;gnss_pose&quot;, 10, gnss_callback);
  ros::Subscriber map_sub = nh.subscribe(&quot;points_map&quot;, 10, map_callback);
  ros::Subscriber initialpose_sub = nh.subscribe(&quot;initialpose&quot;, 1000, initialpose_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;filtered_points&quot;, _queue_size, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, _queue_size*10, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size*10, imu_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="62aebd43dd53ce621c9504ebd4f01c2b90c44555" fix_time="658,82896">
		<msg>fix to free a NULL window</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr/region_tlr.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr/region_tlr.cpp">
				<diff>@@ -373,8 +373,11 @@ static void superimpose_cb(const std_msgs::Bool::ConstPtr&amp; config_msg)
   }
 
   if (!show_superimpose_result) {
-    cv::destroyWindow(window_name);
-    cv::waitKey(1);
+	  if (cvGetWindowHandle(window_name.c_str()) != NULL)
+	  {
+		  cv::destroyWindow(window_name);
+		  cv::waitKey(1);
+	  }
   }
 
 } /* static void superimpose_cb() */
</diff>
				<old_file>#include &lt;vector&gt;
#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &quot;TrafficLight.h&quot;
#include &lt;float.h&gt;
#include &lt;math.h&gt;
#include &lt;sstream&gt;
#include &lt;runtime_manager/traffic_light.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &quot;road_wizard/TunedResult.h&quot;
#include &lt;visualization_msgs/Marker.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;std_msgs/Bool.h&gt;

thresholdSet thSet;

static ros::Publisher signalState_pub;
static ros::Publisher signalStateString_pub;
static ros::Publisher marker_pub;
static ros::Publisher superimpose_image_pub;
static constexpr int32_t ADVERTISE_QUEUE_SIZE = 10;
static constexpr bool    ADVERTISE_LATCH      = true;
static uint32_t          shape                = visualization_msgs::Marker::SPHERE;

// Variables
static TrafficLightDetector detector;

static cv::Mat frame;

static bool              show_superimpose_result = false;
static const std::string window_name             = &quot;superimpose result&quot;;

static double cvtInt2Double_hue(int center, int range)
{
  /* convert value range from OpenCV to Definition */
  double converted = (center + range) * 2.0f;

  if (converted &lt; 0) {
    converted = 0.0f;
  } else if (360 &lt; converted) {
    converted = converted - 360.0f;
  }

  return converted;
} /* static double cvtInt2Double_hue() */


static double cvtInt2Double_sat(int center, int range)
{
  /* convert value range from OpenCV to Definition */
  double converted = (center + range) / 255.0f;
  if (converted &lt; 0) {
    converted = 0.0f;
  } else if (1.0f &lt; converted) {
    converted = 1.0f;
  }

  return converted;
} /* static double cvtInt2Double_sat() */


static double cvtInt2Double_val(int center, int range)
{
  /* convert value range from OpenCV to Definition */
  double converted = (center + range) / 255.0f;
  if (converted &lt; 0) {
    converted = 0;
  } else if (1.0f &lt; converted) {
    converted = 1.0f;
  }

  return converted;
} /* static double cvtInt2Double_val() */


static void putResult_inText(cv::Mat *image, const std::vector&lt;Context&gt; &amp;contexts)
{
  std::string label;
  const int fontFace = cv::FONT_HERSHEY_COMPLEX_SMALL;
  const float fontScale = 1.0f;
  const int fontThickness = 1;
  int baseline = 0;
  CvPoint textOrg;
  CvScalar textColor;

  for (unsigned int i=0; i&lt;contexts.size(); i++)
    {
      Context ctx = contexts.at(i);
//      if (ctx.lampRadius &lt; MINIMAM_RADIUS)
//        continue;

      switch(ctx.lightState) {
      case GREEN:
        label = &quot;GREEN&quot;;
        textColor = CV_RGB(0, 255, 0);
        break;
      case YELLOW:
        label = &quot;YELLOW&quot;;
        textColor = CV_RGB(255, 255, 0);
        break;
      case RED:
        label = &quot;RED&quot;;
        textColor = CV_RGB(255, 0, 0);
        break;
      case UNDEFINED:
        label = &quot;UNDEFINED&quot;;
        textColor = CV_RGB(0, 0, 0);
      }

      cv::getTextSize(label,
		      fontFace,
		      fontScale,
		      fontThickness,
		      &amp;baseline);

      textOrg = cv::Point(ctx.topLeft.x, ctx.botRight.y + baseline);

      putText(*image,
              label,
              textOrg,
              fontFace,
              fontScale,
              textColor,
              fontThickness,
              CV_AA);
    }
} /* static void putResult_inText() */


static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
{
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
  //  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source);
  frame = cv_image-&gt;image.clone();

  /* Draw superimpose result on image */
  cv::Mat targetScope = frame.clone();
  for (unsigned int i=0; i&lt;detector.contexts.size(); i++)
    {
      /* draw superimposed position of traffic lights */
      circle(targetScope, detector.contexts.at(i).redCenter, detector.contexts.at(i).lampRadius, CV_RGB(255, 0, 0), 1, 0);
      circle(targetScope, detector.contexts.at(i).yellowCenter, detector.contexts.at(i).lampRadius, CV_RGB(255, 255, 0), 1, 0);
      circle(targetScope, detector.contexts.at(i).greenCenter, detector.contexts.at(i).lampRadius, CV_RGB(0, 255, 0), 1, 0);
    }

  /* draw detection results */
  putResult_inText(&amp;targetScope, detector.contexts);


  /* Publish superimpose result image */
  cv_bridge::CvImage msg_converter;
  msg_converter.header = image_source.header;
  msg_converter.encoding = sensor_msgs::image_encodings::BGR8;
  msg_converter.image = targetScope;
  superimpose_image_pub.publish(msg_converter.toImageMsg());

  /* Display superimpose result image in separate window*/
  if (show_superimpose_result)
    {
      if (cvGetWindowHandle(window_name.c_str()) != NULL) // Guard not to write destroyed window by using close button on the window
        {
          imshow(window_name, targetScope);
          cv::waitKey(5);
        }
    }

} /* static void image_raw_cb() */


static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
{
  if (frame.empty())
    return;

  setContexts(detector, extractedPos);

  detector.brightnessDetect(frame);

  /* publish result */
  runtime_manager::traffic_light state_msg;
  std_msgs::String state_string_msg;
  const int32_t TRAFFIC_LIGHT_RED     = 0;
  const int32_t TRAFFIC_LIGHT_GREEN   = 1;
  const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;
  static int32_t prev_state = TRAFFIC_LIGHT_UNKNOWN;
  state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
  for (unsigned int i=0; i&lt;detector.contexts.size(); i++) {
	  switch (detector.contexts.at(i).lightState) {
	  case GREEN:
		  state_msg.traffic_light = TRAFFIC_LIGHT_GREEN;
          state_string_msg.data = &quot;green signal&quot;;
		  break;
	  case YELLOW:
	  case RED:
		  state_msg.traffic_light = TRAFFIC_LIGHT_RED;
          state_string_msg.data = &quot;red signal&quot;;
		  break;
	  case UNDEFINED:
		  state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
          state_string_msg.data = &quot;&quot;;
		  break;
	  }
	  if (state_msg.traffic_light != TRAFFIC_LIGHT_UNKNOWN)
		  break;  // publish the first state in detector.contexts
  }

  if (state_msg.traffic_light != prev_state) {
    signalState_pub.publish(state_msg);
    signalStateString_pub.publish(state_string_msg);
  } else {
    state_string_msg.data = &quot;&quot;;
    signalStateString_pub.publish(state_string_msg);
  }

  std_msgs::ColorRGBA color_black;
  color_black.r = 0.0f;
  color_black.g = 0.0f;
  color_black.b = 0.0f;
  color_black.a = 1.0f;

  std_msgs::ColorRGBA color_red;
  color_red.r = 1.0f;
  color_red.g = 0.0f;
  color_red.b = 0.0f;
  color_red.a = 1.0f;

  std_msgs::ColorRGBA color_yellow;
  color_yellow.r = 1.0f;
  color_yellow.g = 1.0f;
  color_yellow.b = 0.0f;
  color_yellow.a = 1.0f;

  std_msgs::ColorRGBA color_green;
  color_green.r = 0.0f;
  color_green.g = 1.0f;
  color_green.b = 0.0f;
  color_green.a = 1.0f;

  /* publish all detected result as ROS Marker */
  for (unsigned int i=0; i&lt;detector.contexts.size(); i++)
    {
      Context ctx = detector.contexts.at(i);
      visualization_msgs::MarkerArray signalSet;
      visualization_msgs::Marker mk_red, mk_yellow, mk_green;

      /* Set the frame ID */
      mk_red.header.frame_id    = &quot;map&quot;;
      mk_yellow.header.frame_id = &quot;map&quot;;
      mk_green.header.frame_id  = &quot;map&quot;;

      /* Set the namespace and id for this marker */
      mk_red.ns    = &quot;tlr_result_red&quot;;
      mk_yellow.ns = &quot;tlr_result_yellow&quot;;
      mk_green.ns  = &quot;tlr_result_green&quot;;
      mk_red.id    = ctx.signalID;
      mk_yellow.id = ctx.signalID;
      mk_green.id  = ctx.signalID;

      /* Set the marker type */
      mk_red.type    = shape;
      mk_yellow.type = shape;
      mk_green.type  = shape;

      /* Set the pose of the marker */
      mk_red.pose.position.x    = ctx.redCenter3d.x;
      mk_red.pose.position.y    = ctx.redCenter3d.y;
      mk_red.pose.position.z    = ctx.redCenter3d.z;
      mk_yellow.pose.position.x = ctx.yellowCenter3d.x;
      mk_yellow.pose.position.y = ctx.yellowCenter3d.y;
      mk_yellow.pose.position.z = ctx.yellowCenter3d.z;
      mk_green.pose.position.x  = ctx.greenCenter3d.x;
      mk_green.pose.position.y  = ctx.greenCenter3d.y;
      mk_green.pose.position.z  = ctx.greenCenter3d.z;

      mk_red.pose.orientation.x    = 0.0;
      mk_red.pose.orientation.y    = 0.0;
      mk_red.pose.orientation.y    = 0.0;
      mk_red.pose.orientation.w    = 0.0;
      mk_yellow.pose.orientation.x = 0.0;
      mk_yellow.pose.orientation.y = 0.0;
      mk_yellow.pose.orientation.y = 0.0;
      mk_yellow.pose.orientation.w = 0.0;
      mk_green.pose.orientation.x  = 0.0;
      mk_green.pose.orientation.y  = 0.0;
      mk_green.pose.orientation.y  = 0.0;
      mk_green.pose.orientation.w  = 0.0;

      /* Set the scale of the marker -- We assume lamp radius as 30cm */
      mk_red.scale.x    = (double)0.3;
      mk_red.scale.y    = (double)0.3;
      mk_red.scale.z    = (double)0.3;
      mk_yellow.scale.x = (double)0.3;
      mk_yellow.scale.y = (double)0.3;
      mk_yellow.scale.z = (double)0.3;
      mk_green.scale.x  = (double)0.3;
      mk_green.scale.y  = (double)0.3;
      mk_green.scale.z  = (double)0.3;

      /* Set the color */
      switch (ctx.lightState) {
      case GREEN:
        mk_red.color    = color_black;
        mk_yellow.color = color_black;
        mk_green.color  = color_green;
        break;
      case YELLOW:
        mk_red.color    = color_black;
        mk_yellow.color = color_yellow;
        mk_green.color  = color_black;
        break;
      case RED:
        mk_red.color    = color_red;
        mk_yellow.color = color_black;
        mk_green.color  = color_black;
        break;
      case UNDEFINED:
        mk_red.color    = color_black;
        mk_yellow.color = color_black;
        mk_green.color  = color_black;
        break;
      }

      mk_red.lifetime    = ros::Duration(0.1);
      mk_yellow.lifetime = ros::Duration(0.1);
      mk_green.lifetime  = ros::Duration(0.1);

      signalSet.markers.push_back(mk_red);
      signalSet.markers.push_back(mk_yellow);
      signalSet.markers.push_back(mk_green);

      marker_pub.publish(signalSet);
    }

  prev_state = state_msg.traffic_light;
} /* static void extractedPos_cb() */


static void tunedResult_cb(const road_wizard::TunedResult&amp; msg)
{
  thSet.Red.Hue.upper = cvtInt2Double_hue(msg.Red.Hue.center, msg.Red.Hue.range);
  thSet.Red.Hue.lower = cvtInt2Double_hue(msg.Red.Hue.center, -msg.Red.Hue.range);
  thSet.Red.Sat.upper = cvtInt2Double_sat(msg.Red.Sat.center, msg.Red.Sat.range);
  thSet.Red.Sat.lower = cvtInt2Double_sat(msg.Red.Sat.center, -msg.Red.Sat.range);
  thSet.Red.Val.upper = cvtInt2Double_val(msg.Red.Val.center, msg.Red.Val.range);
  thSet.Red.Val.lower = cvtInt2Double_val(msg.Red.Val.center, -msg.Red.Val.range);

  thSet.Yellow.Hue.upper = cvtInt2Double_hue(msg.Yellow.Hue.center, msg.Yellow.Hue.range);
  thSet.Yellow.Hue.lower = cvtInt2Double_hue(msg.Yellow.Hue.center, -msg.Yellow.Hue.range);
  thSet.Yellow.Sat.upper = cvtInt2Double_sat(msg.Yellow.Sat.center, msg.Yellow.Sat.range);
  thSet.Yellow.Sat.lower = cvtInt2Double_sat(msg.Yellow.Sat.center, -msg.Yellow.Sat.range);
  thSet.Yellow.Val.upper = cvtInt2Double_val(msg.Yellow.Val.center, msg.Yellow.Val.range);
  thSet.Yellow.Val.lower = cvtInt2Double_val(msg.Yellow.Val.center, -msg.Yellow.Val.range);

  thSet.Green.Hue.upper = cvtInt2Double_hue(msg.Green.Hue.center, msg.Green.Hue.range);
  thSet.Green.Hue.lower = cvtInt2Double_hue(msg.Green.Hue.center, -msg.Green.Hue.range);
  thSet.Green.Sat.upper = cvtInt2Double_sat(msg.Green.Sat.center, msg.Green.Sat.range);
  thSet.Green.Sat.lower = cvtInt2Double_sat(msg.Green.Sat.center, -msg.Green.Sat.range);
  thSet.Green.Val.upper = cvtInt2Double_val(msg.Green.Val.center, msg.Green.Val.range);
  thSet.Green.Val.lower = cvtInt2Double_val(msg.Green.Val.center, -msg.Green.Val.range);

} /* static void tunedResult_cb() */


static void superimpose_cb(const std_msgs::Bool::ConstPtr&amp; config_msg)
{
  show_superimpose_result = config_msg-&gt;data;

  if (show_superimpose_result) {
    cv::namedWindow(window_name, cv::WINDOW_NORMAL);
    cv::startWindowThread();
  }

  if (!show_superimpose_result) {
    cv::destroyWindow(window_name);
    cv::waitKey(1);
  }

} /* static void superimpose_cb() */

int main(int argc, char* argv[]) {

  //	printf(&quot;***** Traffic lights app *****\n&quot;);
#ifdef SHOW_DEBUG_INFO
  cv::namedWindow(&quot;tmpImage&quot;, cv::WINDOW_NORMAL);
  cv::namedWindow(&quot;bright_mask&quot;, cv::WINDOW_NORMAL);
  cv::startWindowThread();
#endif

  thSet.Red.Hue.upper = (double)DAYTIME_RED_UPPER;
  thSet.Red.Hue.lower = (double)DAYTIME_RED_LOWER;
  thSet.Red.Sat.upper = 1.0f;
  thSet.Red.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
  thSet.Red.Val.upper = 1.0f;
  thSet.Red.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;

  thSet.Yellow.Hue.upper = (double)DAYTIME_YELLOW_UPPER;
  thSet.Yellow.Hue.lower = (double)DAYTIME_YELLOW_LOWER;
  thSet.Yellow.Sat.upper = 1.0f;
  thSet.Yellow.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
  thSet.Yellow.Val.upper = 1.0f;
  thSet.Yellow.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;

  thSet.Green.Hue.upper = (double)DAYTIME_GREEN_UPPER;
  thSet.Green.Hue.lower = (double)DAYTIME_GREEN_LOWER;
  thSet.Green.Sat.upper = 1.0f;
  thSet.Green.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
  thSet.Green.Val.upper = 1.0f;
  thSet.Green.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;


  ros::init(argc, argv, &quot;region_tlr&quot;);

  ros::NodeHandle n;
  ros::NodeHandle private_nh(&quot;~&quot;);
  std::string image_topic_name;
  private_nh.param&lt;std::string&gt;(&quot;image_raw_topic&quot;, image_topic_name, &quot;/image_raw&quot;);

  ros::Subscriber image_sub       = n.subscribe(image_topic_name, 1, image_raw_cb);
  ros::Subscriber position_sub    = n.subscribe(&quot;/roi_signal&quot;, 1, extractedPos_cb);
  ros::Subscriber tunedResult_sub = n.subscribe(&quot;/tuned_result&quot;, 1, tunedResult_cb);
  ros::Subscriber superimpose_sub = n.subscribe(&quot;/config/superimpose&quot;, 1, superimpose_cb);

  signalState_pub       = n.advertise&lt;runtime_manager::traffic_light&gt;(&quot;/light_color&quot;, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
  signalStateString_pub = n.advertise&lt;std_msgs::String&gt;(&quot;/sound_player&quot;, ADVERTISE_QUEUE_SIZE);
  marker_pub            = n.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;tlr_result&quot;, ADVERTISE_QUEUE_SIZE);
  superimpose_image_pub= n.advertise&lt;sensor_msgs::Image&gt;(&quot;tlr_superimpose_image&quot;, ADVERTISE_QUEUE_SIZE);

  ros::spin();

  return 0;
} /* int main() */


/*
  define magnitude relationship of context
 */
static bool compareContext(const Context left, const Context right)
{
  /* if lampRadius is bigger, context is smaller */
  return left.lampRadius &gt;= right.lampRadius;
} /* static bool compareContext() */


void setContexts(TrafficLightDetector &amp;detector,
                 const road_wizard::Signals::ConstPtr&amp; extractedPos)
{

  /* copy parts of data to local variable */
  std::vector&lt;road_wizard::ExtractedPosition&gt; signals;
  std::vector&lt;road_wizard::ExtractedPosition&gt;::iterator sig_iterator;
  for (unsigned int i=0; i&lt;extractedPos-&gt;Signals.size(); i++ )
    {
      road_wizard::ExtractedPosition tmp;
      tmp.signalId = extractedPos-&gt;Signals.at(i).signalId;
      tmp.u        = extractedPos-&gt;Signals.at(i).u;
      tmp.v        = extractedPos-&gt;Signals.at(i).v;
      tmp.radius   = extractedPos-&gt;Signals.at(i).radius;
      tmp.x        = extractedPos-&gt;Signals.at(i).x;
      tmp.y        = extractedPos-&gt;Signals.at(i).y;
      tmp.z        = extractedPos-&gt;Signals.at(i).z;
      tmp.type     = extractedPos-&gt;Signals.at(i).type;
      tmp.linkId   = extractedPos-&gt;Signals.at(i).linkId;
      tmp.plId     = extractedPos-&gt;Signals.at(i).plId;
      signals.push_back(tmp);
    }

  std::vector&lt;int&gt; plid_vector;
  for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++) {
    plid_vector.push_back(sig_iterator-&gt;plId);
  }

  /* get array that has unique PLID values as its element */
  std::sort(plid_vector.begin(), plid_vector.end());
  std::vector&lt;int&gt;::iterator new_end = std::unique(plid_vector.begin(), plid_vector.end());
  plid_vector.erase(new_end, plid_vector.end());

  std::vector&lt;Context&gt; updatedSignals;

  /* assemble fragmented signal lamp in a context */
  for (unsigned int ctx_idx=0; ctx_idx&lt;plid_vector.size(); ctx_idx++)
    {
      Context ctx;
      int min_radius  = INT_MAX;
      int most_left   = frame.cols;
      int most_top    = frame.rows;
      int most_right  = 0;
      int most_bottom = 0;

      for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++)
        {
          int img_x = sig_iterator-&gt;u;
          int img_y = sig_iterator-&gt;v;
          double map_x = sig_iterator-&gt;x;
          double map_y = sig_iterator-&gt;y;
          double map_z = sig_iterator-&gt;z;
          int radius = sig_iterator-&gt;radius;
          if (sig_iterator-&gt;plId == plid_vector.at(ctx_idx) &amp;&amp;
              0 &lt; img_x - radius - 1.5 * radius &amp;&amp; img_x + radius + 1.5 * radius &lt; frame.cols &amp;&amp;
              0 &lt; img_y - radius - 1.5 * radius &amp;&amp; img_y + radius + 1.5 * radius &lt; frame.rows)
            {
              switch (sig_iterator-&gt;type) {
              case 1:           /* RED */
                ctx.redCenter   = cv::Point( img_x, img_y );
                ctx.redCenter3d = cv::Point3d( map_x, map_y, map_z );
                break;
              case 2:           /* GREEN */
                ctx.greenCenter   = cv::Point( img_x, img_y );
                ctx.greenCenter3d = cv::Point3d( map_x, map_y, map_z );
                break;
              case 3:           /* YELLOW */
                ctx.yellowCenter   = cv::Point( img_x, img_y );
                ctx.yellowCenter3d = cv::Point3d( map_x, map_y, map_z );
                ctx.signalID       = sig_iterator-&gt;signalId; // use yellow light signalID as this context's representative
                break;
              default:          /* this signal is not for cars (for pedestrian or something) */
                continue;
              }
              min_radius    = (min_radius &gt; radius) ? radius : min_radius;
              most_left     = (most_left &gt; img_x - radius -   1.5 * min_radius)  ? img_x - radius - 1.5 * min_radius : most_left;
              most_top      = (most_top &gt; img_y - radius -    1.5 * min_radius)  ? img_y - radius - 1.5 * min_radius : most_top;
              most_right    = (most_right &lt; img_x + radius +  1.5 * min_radius)  ? img_x + radius + 1.5 * min_radius : most_right;
              most_bottom   = (most_bottom &lt; img_y + radius + 1.5 * min_radius)  ? img_y + radius + 1.5 * min_radius : most_bottom;
            }
        }

      ctx.lampRadius = min_radius;
      ctx.topLeft    = cv::Point(most_left, most_top);
      ctx.botRight   = cv::Point(most_right, most_bottom);
      ctx.lightState = UNDEFINED;
      ctx.stateJudgeCount = 0;

      /* search whether this signal has already belonged in detector.contexts */
      bool isInserted = false;
      std::vector&lt;int&gt; eraseCandidate;
      for (unsigned int i=0; i&lt;detector.contexts.size(); i++) {
        if (ctx.signalID == detector.contexts.at(i).signalID &amp;&amp; ctx.lampRadius != INT_MAX)
          {
            /* update to new information except to lightState */
            updatedSignals.push_back(ctx);
            updatedSignals.back().lightState      = detector.contexts.at(i).lightState;
            updatedSignals.back().stateJudgeCount = detector.contexts.at(i).stateJudgeCount;
            isInserted = true;
            break;
          }

      }

      if (isInserted == false &amp;&amp; ctx.lampRadius != INT_MAX)
        updatedSignals.push_back(ctx); // this ctx is new in detector.contexts

    }

  /* reset detector.contexts */
  detector.contexts.clear();
  detector.contexts.resize(updatedSignals.size());
  std::sort(updatedSignals.begin(), updatedSignals.end(), compareContext); // sort by lampRadius
  for (unsigned int i=0; i&lt;updatedSignals.size(); i++) {
    detector.contexts.at(i) = updatedSignals.at(i);
  }
} /* void setContexts() */
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="46ff1d116175f5586b4c1b904bc89f00e85dc41e" fix_time="58,71530">
		<msg>fix initializing measurement_range
https://github.com/CPFL/Autoware/issues/693</msg>
		<modified_files>
			<file old_path="ros/src/sensing/filters/packages/points_downsampler/include/points_downsampler.h" new_path="ros/src/sensing/filters/packages/points_downsampler/include/points_downsampler.h">
				<diff>@@ -5,8 +5,6 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
 {
   pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
   narrowed_scan.header = scan.header;
-
-  max_range = 100.0;    //  This is a only tempolary patch for Localization problem.
   double square_min_range = min_range * min_range;
   double square_max_range = max_range * max_range;
 
</diff>
				<old_file>#ifndef POINTS_DOWNSAMPLER_H
#define POINTS_DOWNSAMPLER_H

static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::PointXYZI&gt; scan, double min_range, double max_range)
{
  pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
  narrowed_scan.header = scan.header;

  max_range = 100.0;    //  This is a only tempolary patch for Localization problem.
  double square_min_range = min_range * min_range;
  double square_max_range = max_range * max_range;

  for(pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator iter = scan.begin(); iter != scan.end(); ++iter)
  {
    const pcl::PointXYZI &amp;p = *iter;
//    p.x = iter-&gt;x;
//    p.y = iter-&gt;y;
//    p.z = iter-&gt;z;
//    p.intensity = iter-&gt;intensity;
    double square_distance = p.x * p.x + p.y * p.y;

    if(square_min_range &lt;= square_distance &amp;&amp; square_distance &lt;= square_max_range){
      narrowed_scan.points.push_back(p);
    }
  }
#if 1
  return narrowed_scan;
#else
  return scan;    //  This is a only tempolary patch for Localization problem.
#endif
}

#endif // POINTS_DOWNSAMPLER_H
</old_file>
			</file>
			<file old_path="ros/src/sensing/filters/packages/points_downsampler/nodes/distance_filter/distance_filter.cpp" new_path="ros/src/sensing/filters/packages/points_downsampler/nodes/distance_filter/distance_filter.cpp">
				<diff>@@ -60,7 +60,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range;
+static double measurement_range=100.0;
 
 static void config_callback(const runtime_manager::ConfigDistanceFilter::ConstPtr&amp; input)
 {
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;

#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;

#include &lt;runtime_manager/ConfigDistanceFilter.h&gt;

#include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;

#include &lt;algorithm&gt; // For std::min()
#include &lt;chrono&gt;

#include &quot;points_downsampler.h&quot;

#define MAX_MEASUREMENT_RANGE 200.0

ros::Publisher filtered_points_pub;

static int sample_num = 1000;

static ros::Publisher points_downsampler_info_pub;
static points_downsampler::PointsDownsamplerInfo points_downsampler_info_msg;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; filter_start, filter_end;

static bool _output_log = false;
static std::ofstream ofs;
static std::string filename;

static std::string POINTS_TOPIC;
static double measurement_range;

static void config_callback(const runtime_manager::ConfigDistanceFilter::ConstPtr&amp; input)
{
  sample_num = input-&gt;sample_num;
  measurement_range = input-&gt;measurement_range;
}

static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  pcl::PointXYZI sampled_p;
  pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;

  pcl::fromROSMsg(*input, scan);

  if(measurement_range != MAX_MEASUREMENT_RANGE){
    scan = removePointsByRange(scan, 0, measurement_range);
  }

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  filtered_scan_ptr-&gt;header = scan.header;

  int points_num = scan.size();

  double w_total = 0.0;
  double w_step = 0.0;
  int m = 0;
  double c = 0.0;

  filter_start = std::chrono::system_clock::now();

  for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = scan.begin(); item != scan.end(); item++)
  {
    w_total += item-&gt;x * item-&gt;x + item-&gt;y * item-&gt;y + item-&gt;z * item-&gt;z;
  }
  w_step = w_total / sample_num;

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = scan.begin();
  for (m = 0; m &lt; sample_num; m++)
  {
    while (m * w_step &gt; c)
    {
      item++;
      c += item-&gt;x * item-&gt;x + item-&gt;y * item-&gt;y + item-&gt;z * item-&gt;z;
    }
    sampled_p.x = item-&gt;x;
    sampled_p.y = item-&gt;y;
    sampled_p.z = item-&gt;z;
    sampled_p.intensity = item-&gt;intensity;
    filtered_scan_ptr-&gt;points.push_back(sampled_p);
  }

  sensor_msgs::PointCloud2 filtered_msg;
  pcl::toROSMsg(*filtered_scan_ptr, filtered_msg);

  filter_end = std::chrono::system_clock::now();

  filtered_msg.header = input-&gt;header;
  filtered_points_pub.publish(filtered_msg);

  points_downsampler_info_msg.header = input-&gt;header;
  points_downsampler_info_msg.filter_name = &quot;distance_filter&quot;;
  points_downsampler_info_msg.measurement_range = measurement_range;
  points_downsampler_info_msg.original_points_size = points_num;
  points_downsampler_info_msg.filtered_points_size = std::min((int)filtered_scan_ptr-&gt;size(), points_num);
  points_downsampler_info_msg.original_ring_size = 0;
  points_downsampler_info_msg.original_ring_size = 0;
  points_downsampler_info_msg.exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(filter_end - filter_start).count() / 1000.0;
  points_downsampler_info_pub.publish(points_downsampler_info_msg);

  if(_output_log == true){
	  if(!ofs){
		  std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
		  exit(1);
	  }
	  ofs &lt;&lt; points_downsampler_info_msg.header.seq &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.header.stamp &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.header.frame_id &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filter_name &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.original_points_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filtered_points_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.original_ring_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filtered_ring_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.exe_time &lt;&lt; &quot;,&quot;
		  &lt;&lt; std::endl;
  }

}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;distance_filter&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  private_nh.getParam(&quot;points_topic&quot;, POINTS_TOPIC);
  private_nh.getParam(&quot;output_log&quot;, _output_log);
  if(_output_log == true){
	  char buffer[80];
	  std::time_t now = std::time(NULL);
	  std::tm *pnow = std::localtime(&amp;now);
	  std::strftime(buffer,80,&quot;%Y%m%d_%H%M%S&quot;,pnow);
	  filename = &quot;distance_filter_&quot; + std::string(buffer) + &quot;.csv&quot;;
	  ofs.open(filename.c_str(), std::ios::app);
  }

  // Publishers
  filtered_points_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/filtered_points&quot;, 10);
  points_downsampler_info_pub = nh.advertise&lt;points_downsampler::PointsDownsamplerInfo&gt;(&quot;/points_downsampler_info&quot;, 1000);

  // Subscribers
  ros::Subscriber config_sub = nh.subscribe(&quot;config/distance_filter&quot;, 10, config_callback);
  ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/sensing/filters/packages/points_downsampler/nodes/random_filter/random_filter.cpp" new_path="ros/src/sensing/filters/packages/points_downsampler/nodes/random_filter/random_filter.cpp">
				<diff>@@ -58,7 +58,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range;
+static double measurement_range=100.0;
 
 static void config_callback(const runtime_manager::ConfigRandomFilter::ConstPtr&amp; input)
 {
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;

#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#include &lt;runtime_manager/ConfigRandomFilter.h&gt;

#include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;

#include &lt;chrono&gt;

#include &quot;points_downsampler.h&quot;

#define MAX_MEASUREMENT_RANGE 200.0

ros::Publisher filtered_points_pub;

static int sample_num = 1000;

static ros::Publisher points_downsampler_info_pub;
static points_downsampler::PointsDownsamplerInfo points_downsampler_info_msg;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; filter_start, filter_end;

static bool _output_log = false;
static std::ofstream ofs;
static std::string filename;

static std::string POINTS_TOPIC;
static double measurement_range;

static void config_callback(const runtime_manager::ConfigRandomFilter::ConstPtr&amp; input)
{
  sample_num = input-&gt;sample_num;
  measurement_range = input-&gt;measurement_range;
}

static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  pcl::PointXYZI sampled_p;
  pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;

  pcl::fromROSMsg(*input, scan);

  if(measurement_range != MAX_MEASUREMENT_RANGE){
    scan = removePointsByRange(scan, 0, measurement_range);
  }

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  filtered_scan_ptr-&gt;header = scan.header;

  filter_start = std::chrono::system_clock::now();

  int points_num = scan.size();
  int step = points_num / sample_num;

  if(scan.points.size() &gt;= sample_num)
  {
    for (int i = 0; i &lt; points_num; i++)
    {
      if ((int)filtered_scan_ptr-&gt;size() &lt; sample_num &amp;&amp; i % step == 0)
      {
        filtered_scan_ptr-&gt;points.push_back(scan.at(i));
      }
    }
  }else{
    filtered_scan_ptr = scan.makeShared();
  }

  sensor_msgs::PointCloud2 filtered_msg;
  pcl::toROSMsg(*filtered_scan_ptr, filtered_msg);

  filter_end = std::chrono::system_clock::now();

  filtered_msg.header = input-&gt;header;
  filtered_points_pub.publish(filtered_msg);

  points_downsampler_info_msg.header = input-&gt;header;
  points_downsampler_info_msg.filter_name = &quot;random_filter&quot;;
  points_downsampler_info_msg.measurement_range = measurement_range;
  points_downsampler_info_msg.original_points_size = points_num;
  points_downsampler_info_msg.filtered_points_size = filtered_scan_ptr-&gt;size();
  points_downsampler_info_msg.original_ring_size = 0;
  points_downsampler_info_msg.filtered_ring_size = 0;
  points_downsampler_info_msg.exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(filter_end - filter_start).count() / 1000.0;
  points_downsampler_info_pub.publish(points_downsampler_info_msg);

  if(_output_log == true){
	  if(!ofs){
		  std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
		  exit(1);
	  }
	  ofs &lt;&lt; points_downsampler_info_msg.header.seq &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.header.stamp &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.header.frame_id &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filter_name &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.original_points_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filtered_points_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.original_ring_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filtered_ring_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.exe_time &lt;&lt; &quot;,&quot;
		  &lt;&lt; std::endl;
  }

}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;random_filter&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  private_nh.getParam(&quot;points_topic&quot;, POINTS_TOPIC);
  private_nh.getParam(&quot;output_log&quot;, _output_log);
  if(_output_log == true){
	  char buffer[80];
	  std::time_t now = std::time(NULL);
	  std::tm *pnow = std::localtime(&amp;now);
	  std::strftime(buffer,80,&quot;%Y%m%d_%H%M%S&quot;,pnow);
	  filename = &quot;random_filter_&quot; + std::string(buffer) + &quot;.csv&quot;;
	  ofs.open(filename.c_str(), std::ios::app);
  }

  // Publishers
  filtered_points_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/filtered_points&quot;, 10);
  points_downsampler_info_pub = nh.advertise&lt;points_downsampler::PointsDownsamplerInfo&gt;(&quot;/points_downsampler_info&quot;, 1000);

  // Subscribers
  ros::Subscriber config_sub = nh.subscribe(&quot;config/random_filter&quot;, 10, config_callback);
  ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/sensing/filters/packages/points_downsampler/nodes/ring_filter/ring_filter.cpp" new_path="ros/src/sensing/filters/packages/points_downsampler/nodes/ring_filter/ring_filter.cpp">
				<diff>@@ -61,7 +61,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range;
+static double measurement_range=100.0;
 
 static void config_callback(const runtime_manager::ConfigRingFilter::ConstPtr&amp; input)
 {
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;

#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;

#include &lt;velodyne_pointcloud/point_types.h&gt;

#include &lt;runtime_manager/ConfigRingFilter.h&gt;

#include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;

#include &lt;chrono&gt;

ros::Publisher filtered_points_pub;

// Leaf size of VoxelGrid filter.
static double voxel_leaf_size = 2.0;

int ring_max = 0;
int ring_div = 3;

static ros::Publisher points_downsampler_info_pub;
static points_downsampler::PointsDownsamplerInfo points_downsampler_info_msg;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; filter_start, filter_end;

static bool _output_log = false;
static std::ofstream ofs;
static std::string filename;

static std::string POINTS_TOPIC;
static double measurement_range;

static void config_callback(const runtime_manager::ConfigRingFilter::ConstPtr&amp; input)
{
  ring_div = input-&gt;ring_div;
  voxel_leaf_size = input-&gt;voxel_leaf_size;
  measurement_range = input-&gt;measurement_range;
}

static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
  pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; tmp;
  sensor_msgs::PointCloud2 filtered_msg;

  pcl::fromROSMsg(*input, scan);
  pcl::fromROSMsg(*input, tmp);

  filter_start = std::chrono::system_clock::now();

  scan.points.clear();

  for (pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++)
  {
    pcl::PointXYZI p;
    p.x = item-&gt;x;
    p.y = item-&gt;y;
    p.z = item-&gt;z;
    p.intensity = item-&gt;intensity;

    double distance = sqrt(p.x * p.x + p.y * p.y);

    if (item-&gt;ring % ring_div == 0 &amp;&amp; distance &lt;= measurement_range)
    {
      scan.points.push_back(p);
    }
    if (item-&gt;ring &gt; ring_max)
    {
      ring_max = item-&gt;ring;
    }
  }

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());

  // if voxel_leaf_size &lt; 0.1 voxel_grid_filter cannot down sample (It is specification in PCL)
  if (voxel_leaf_size &gt;= 0.1)
  {
    // Downsampling the velodyne scan using VoxelGrid filter
    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
    voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
    voxel_grid_filter.setInputCloud(scan_ptr);
    voxel_grid_filter.filter(*filtered_scan_ptr);

    pcl::toROSMsg(*filtered_scan_ptr, filtered_msg);
  }
  else
  {
    pcl::toROSMsg(*scan_ptr, filtered_msg);
  }

  filter_end = std::chrono::system_clock::now();

  filtered_msg.header = input-&gt;header;
  filtered_points_pub.publish(filtered_msg);

  points_downsampler_info_msg.header = input-&gt;header;
  points_downsampler_info_msg.filter_name = &quot;ring_filter&quot;;
  points_downsampler_info_msg.measurement_range = measurement_range;
  points_downsampler_info_msg.original_points_size = scan.size();
  if (voxel_leaf_size &gt;= 0.1)
  {
    points_downsampler_info_msg.filtered_points_size = filtered_scan_ptr-&gt;size();
  }
  else
  {
    points_downsampler_info_msg.filtered_points_size = scan_ptr-&gt;size();
  }
  points_downsampler_info_msg.original_ring_size = ring_max;
  points_downsampler_info_msg.filtered_ring_size = ring_max / ring_div;
  points_downsampler_info_msg.exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(filter_end - filter_start).count() / 1000.0;
  points_downsampler_info_pub.publish(points_downsampler_info_msg);

  if(_output_log == true){
	  if(!ofs){
		  std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
		  exit(1);
	  }
	  ofs &lt;&lt; points_downsampler_info_msg.header.seq &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.header.stamp &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.header.frame_id &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filter_name &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.original_points_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filtered_points_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.original_ring_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filtered_ring_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.exe_time &lt;&lt; &quot;,&quot;
		  &lt;&lt; std::endl;
  }

}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;ring_filter&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  private_nh.getParam(&quot;points_topic&quot;, POINTS_TOPIC);
  private_nh.getParam(&quot;output_log&quot;, _output_log);
  if(_output_log == true){
	  char buffer[80];
	  std::time_t now = std::time(NULL);
	  std::tm *pnow = std::localtime(&amp;now);
	  std::strftime(buffer,80,&quot;%Y%m%d_%H%M%S&quot;,pnow);
	  filename = &quot;ring_filter_&quot; + std::string(buffer) + &quot;.csv&quot;;
	  ofs.open(filename.c_str(), std::ios::app);
  }

  // Publishers
  filtered_points_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/filtered_points&quot;, 10);
  points_downsampler_info_pub = nh.advertise&lt;points_downsampler::PointsDownsamplerInfo&gt;(&quot;/points_downsampler_info&quot;, 1000);

  // Subscribers
  ros::Subscriber config_sub = nh.subscribe(&quot;config/ring_filter&quot;, 10, config_callback);
  ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/sensing/filters/packages/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.cpp" new_path="ros/src/sensing/filters/packages/points_downsampler/nodes/voxel_grid_filter/voxel_grid_filter.cpp">
				<diff>@@ -60,7 +60,7 @@ static std::ofstream ofs;
 static std::string filename;
 
 static std::string POINTS_TOPIC;
-static double measurement_range;
+static double measurement_range=100.0;
 
 static void config_callback(const runtime_manager::ConfigVoxelGridFilter::ConstPtr&amp; input)
 {
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;

#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;

#include &lt;runtime_manager/ConfigVoxelGridFilter.h&gt;

#include &lt;points_downsampler/PointsDownsamplerInfo.h&gt;

#include &lt;chrono&gt;

#include &quot;points_downsampler.h&quot;

#define MAX_MEASUREMENT_RANGE 200.0

ros::Publisher filtered_points_pub;

// Leaf size of VoxelGrid filter.
static double voxel_leaf_size = 2.0;

static ros::Publisher points_downsampler_info_pub;
static points_downsampler::PointsDownsamplerInfo points_downsampler_info_msg;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; filter_start, filter_end;

static bool _output_log = false;
static std::ofstream ofs;
static std::string filename;

static std::string POINTS_TOPIC;
static double measurement_range;

static void config_callback(const runtime_manager::ConfigVoxelGridFilter::ConstPtr&amp; input)
{
  voxel_leaf_size = input-&gt;voxel_leaf_size;
  measurement_range = input-&gt;measurement_range;
}

static void scan_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  pcl::PointCloud&lt;pcl::PointXYZI&gt; scan;
  pcl::fromROSMsg(*input, scan);

  if(measurement_range != MAX_MEASUREMENT_RANGE){
    scan = removePointsByRange(scan, 0, measurement_range);
  }

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());

  sensor_msgs::PointCloud2 filtered_msg;

  filter_start = std::chrono::system_clock::now();

  // if voxel_leaf_size &lt; 0.1 voxel_grid_filter cannot down sample (It is specification in PCL)
  if (voxel_leaf_size &gt;= 0.1)
  {
    // Downsampling the velodyne scan using VoxelGrid filter
    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
    voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
    voxel_grid_filter.setInputCloud(scan_ptr);
    voxel_grid_filter.filter(*filtered_scan_ptr);
    pcl::toROSMsg(*filtered_scan_ptr, filtered_msg);
  }
  else
  {
    pcl::toROSMsg(*scan_ptr, filtered_msg);
  }

  filter_end = std::chrono::system_clock::now();

  filtered_msg.header = input-&gt;header;
  filtered_points_pub.publish(filtered_msg);

  points_downsampler_info_msg.header = input-&gt;header;
  points_downsampler_info_msg.filter_name = &quot;voxel_grid_filter&quot;;
  points_downsampler_info_msg.measurement_range = measurement_range;
  points_downsampler_info_msg.original_points_size = scan.size();
  if (voxel_leaf_size &gt;= 0.1)
  {
    points_downsampler_info_msg.filtered_points_size = filtered_scan_ptr-&gt;size();
  }
  else
  {
    points_downsampler_info_msg.filtered_points_size = scan_ptr-&gt;size();
  }
  points_downsampler_info_msg.original_ring_size = 0;
  points_downsampler_info_msg.filtered_ring_size = 0;
  points_downsampler_info_msg.exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(filter_end - filter_start).count() / 1000.0;
  points_downsampler_info_pub.publish(points_downsampler_info_msg);

  if(_output_log == true){
	  if(!ofs){
		  std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
		  exit(1);
	  }
	  ofs &lt;&lt; points_downsampler_info_msg.header.seq &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.header.stamp &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.header.frame_id &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filter_name &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.original_points_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filtered_points_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.original_ring_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.filtered_ring_size &lt;&lt; &quot;,&quot;
		  &lt;&lt; points_downsampler_info_msg.exe_time &lt;&lt; &quot;,&quot;
		  &lt;&lt; std::endl;
  }

}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;voxel_grid_filter&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  private_nh.getParam(&quot;points_topic&quot;, POINTS_TOPIC);
  private_nh.getParam(&quot;output_log&quot;, _output_log);
  if(_output_log == true){
	  char buffer[80];
	  std::time_t now = std::time(NULL);
	  std::tm *pnow = std::localtime(&amp;now);
	  std::strftime(buffer,80,&quot;%Y%m%d_%H%M%S&quot;,pnow);
	  filename = &quot;voxel_grid_filter_&quot; + std::string(buffer) + &quot;.csv&quot;;
	  ofs.open(filename.c_str(), std::ios::app);
  }

  // Publishers
  filtered_points_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/filtered_points&quot;, 10);
  points_downsampler_info_pub = nh.advertise&lt;points_downsampler::PointsDownsamplerInfo&gt;(&quot;/points_downsampler_info&quot;, 1000);

  // Subscribers
  ros::Subscriber config_sub = nh.subscribe(&quot;config/voxel_grid_filter&quot;, 10, config_callback);
  ros::Subscriber scan_sub = nh.subscribe(POINTS_TOPIC, 10, scan_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="8a1bfeac01a2a0b93544d46f229c6716457b4af5" fix_time="11,52163">
		<msg>Add Error handring to removePointsByRange()</msg>
		<modified_files>
			<file old_path="ros/src/sensing/filters/packages/points_downsampler/include/points_downsampler.h" new_path="ros/src/sensing/filters/packages/points_downsampler/include/points_downsampler.h">
				<diff>@@ -5,6 +5,14 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
 {
   pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
   narrowed_scan.header = scan.header;
+
+#if 1     //  This error handling should be detemind.
+  if( min_range&gt;=max_range ) {
+    ROS_ERROR_ONCE(&quot;min_range&gt;=max_range @(%lf, %lf)&quot;, min_range, max_range );
+    return scan;
+  }
+#endif
+
   double square_min_range = min_range * min_range;
   double square_max_range = max_range * max_range;
 
@@ -21,11 +29,8 @@ static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::
       narrowed_scan.points.push_back(p);
     }
   }
-#if 1
+
   return narrowed_scan;
-#else
-  return scan;    //  This is a only tempolary patch for Localization problem.
-#endif
 }
 
 #endif // POINTS_DOWNSAMPLER_H
</diff>
				<old_file>#ifndef POINTS_DOWNSAMPLER_H
#define POINTS_DOWNSAMPLER_H

static pcl::PointCloud&lt;pcl::PointXYZI&gt; removePointsByRange(pcl::PointCloud&lt;pcl::PointXYZI&gt; scan, double min_range, double max_range)
{
  pcl::PointCloud&lt;pcl::PointXYZI&gt; narrowed_scan;
  narrowed_scan.header = scan.header;
  double square_min_range = min_range * min_range;
  double square_max_range = max_range * max_range;

  for(pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator iter = scan.begin(); iter != scan.end(); ++iter)
  {
    const pcl::PointXYZI &amp;p = *iter;
//    p.x = iter-&gt;x;
//    p.y = iter-&gt;y;
//    p.z = iter-&gt;z;
//    p.intensity = iter-&gt;intensity;
    double square_distance = p.x * p.x + p.y * p.y;

    if(square_min_range &lt;= square_distance &amp;&amp; square_distance &lt;= square_max_range){
      narrowed_scan.points.push_back(p);
    }
  }
#if 1
  return narrowed_scan;
#else
  return scan;    //  This is a only tempolary patch for Localization problem.
#endif
}

#endif // POINTS_DOWNSAMPLER_H
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="f51ad58499d70f7e8e26f9f758aba8d926df3ffc" fix_time="213,45342">
		<msg>fix build issues due to autoware_msgs</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/cv_tracker/nodes/yolo2/src/darknet/yolo2.cpp" new_path="ros/src/computing/perception/detection/packages/cv_tracker/nodes/yolo2/src/darknet/yolo2.cpp">
				<diff>@@ -2,7 +2,6 @@
 
 #include &lt;image_transport/image_transport.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
 
 #include &lt;cstdint&gt;
 #include &lt;cstdlib&gt;
</diff>
				<old_file>#include &quot;darknet/yolo2.h&quot;

#include &lt;image_transport/image_transport.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;cv_tracker_msgs/image_obj.h&gt;

#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;rect_class_score.h&gt;

extern &quot;C&quot;
{
	#undef __cplusplus
		#include &quot;detection_layer.h&quot;
		#include &quot;parser.h&quot;
		#include &quot;region_layer.h&quot;
		#include &quot;utils.h&quot;
		#include &quot;image.h&quot;
	#define __cplusplus
}

namespace darknet
{
	uint32_t Yolo2Detector::get_network_height()
	{
		return darknet_network_.h;
	}
	uint32_t Yolo2Detector::get_network_width()
	{
		return darknet_network_.w;
	}
	void Yolo2Detector::load(std::string&amp; in_model_file, std::string&amp; in_trained_file, double in_min_confidence, double in_nms_threshold)
	{
		min_confidence_ = in_min_confidence;
		nms_threshold_ = in_nms_threshold;
		darknet_network_ = parse_network_cfg(&amp;in_model_file[0]);
		load_weights(&amp;darknet_network_, &amp;in_trained_file[0]);
		set_batch_network(&amp;darknet_network_, 1);

		layer output_layer = darknet_network_.layers[darknet_network_.n - 1];
		darknet_boxes_.resize(output_layer.w * output_layer.h * output_layer.n);
		darknet_box_scores_.resize(output_layer.w * output_layer.h * output_layer.n);
		float *probs_mem = static_cast&lt;float *&gt;(calloc(darknet_box_scores_.size() * output_layer.classes, sizeof(float)));
		for (auto&amp; i : darknet_box_scores_)
		{
			i = probs_mem;
			probs_mem += output_layer.classes;
		}
	}

	Yolo2Detector::~Yolo2Detector()
	{
		free(darknet_box_scores_[0]);
		free_network(darknet_network_);
	}

	std::vector&lt; RectClassScore&lt;float&gt; &gt; Yolo2Detector::detect(image&amp; in_darknet_image)
	{
		return forward(in_darknet_image);
	}

	image Yolo2Detector::convert_image(const sensor_msgs::ImageConstPtr&amp; msg)
	{
		if (msg-&gt;encoding != sensor_msgs::image_encodings::BGR8)
		{
			ROS_ERROR(&quot;Unsupported encoding&quot;);
			exit(-1);
		}

		auto data = msg-&gt;data;
		uint32_t height = msg-&gt;height, width = msg-&gt;width, offset = msg-&gt;step - 3 * width;
		uint32_t i = 0, j = 0;
		image im = make_image(width, height, 3);

		for (uint32_t line = height; line; line--)
		{
			for (uint32_t column = width; column; column--)
			{
				for (uint32_t channel = 0; channel &lt; 3; channel++)
					im.data[i + width * height * channel] = data[j++] / 255.;
				i++;
			}
			j += offset;
		}

		if (darknet_network_.w == (int) width &amp;&amp; darknet_network_.h == (int) height)
		{
			return im;
		}
		image resized = resize_image(im, darknet_network_.w, darknet_network_.h);
		free_image(im);
		return resized;
	}

	std::vector&lt; RectClassScore&lt;float&gt; &gt; Yolo2Detector::forward(image&amp; in_darknet_image)
	{
		float * in_data = in_darknet_image.data;
		float *prediction = network_predict(darknet_network_, in_data);
		layer output_layer = darknet_network_.layers[darknet_network_.n - 1];

		output_layer.output = prediction;
		if (output_layer.type == DETECTION)
			get_detection_boxes(output_layer, 1, 1, min_confidence_, darknet_box_scores_.data(), darknet_boxes_.data(), 0);
		else if (output_layer.type == REGION)
		{
			get_region_boxes(output_layer, in_darknet_image.w, in_darknet_image.h,
							darknet_network_.w, darknet_network_.h,
							min_confidence_, darknet_box_scores_.data(), darknet_boxes_.data(),
							0, 0, 0.5, 1);
		}
		else
			error(&quot;Last layer must produce detections\n&quot;);

		int num_classes = output_layer.classes;
		do_nms(darknet_boxes_.data(), darknet_box_scores_.data(), output_layer.w * output_layer.h * output_layer.n, num_classes, nms_threshold_);
		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;

		for (unsigned i = 0; i &lt; darknet_box_scores_.size(); i++)
		{
			int class_id = max_index(darknet_box_scores_[i], num_classes);
			float prob = darknet_box_scores_[i][class_id];
			//if (prob &gt; 0.3)
			{
				RectClassScore&lt;float&gt; detection;
				box b = darknet_boxes_[i];

				detection.x = b.x - b.w/2.;
				detection.y = b.y - b.h/2.;
				detection.w = b.w;
				detection.h = b.h;
				detection.score = prob;
				detection.class_type = class_id;
				//std::cout &lt;&lt; &quot;Box:&quot;  &lt;&lt;detection.toString() &lt;&lt; std::endl;

				detections.push_back(detection);
			}
		}
		return detections;
	}
}  // namespace darknet
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/cv_tracker/nodes/yolo2/src/yolo2_node.cpp" new_path="ros/src/computing/perception/detection/packages/cv_tracker/nodes/yolo2/src/yolo2_node.cpp">
				<diff>@@ -1,11 +1,12 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;image_transport/image_transport.h&gt;
-#include &lt;autoware_msgs/ConfigSsd.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
+#include &lt;autoware_msgs/ConfigSsd.h&gt;
 #include &lt;autoware_msgs/image_obj.h&gt;
 
+#include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;opencv2/opencv.hpp&gt;
 
 #if (CV_MAJOR_VERSION != 3)
@@ -13,7 +14,6 @@
 #endif
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 
-#include &lt;cv_bridge/cv_bridge.h&gt;
 
 #include &lt;string&gt;
 #include &lt;vector&gt;
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;image_transport/image_transport.h&gt;
#include &lt;autoware_msgs/ConfigSsd.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;

#include &lt;autoware_msgs/image_obj.h&gt;

#include &lt;opencv2/opencv.hpp&gt;

#if (CV_MAJOR_VERSION != 3)
#include &lt;opencv2/contrib/contrib.hpp&gt;
#endif
#include &lt;opencv2/highgui/highgui.hpp&gt;

#include &lt;cv_bridge/cv_bridge.h&gt;

#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;rect_class_score.h&gt;

#include &quot;darknet/yolo2.h&quot;

namespace Yolo2
{
	enum YoloDetectorClasses//using coco for default cfg and weights
	{
		PERSON, BICYCLE, CAR, MOTORBIKE, AEROPLANE, BUS, TRAIN, TRUCK, BOAT, TRAFFIC_LIGHT,
		FIRE_HYDRANT, STOP_SIGN, PARKING_METER, BENCH, BIRD, CAT, DOG, HORSE, SHEEP, COW,
		ELEPHANT, BEAR, ZEBRA, GIRAFFE, BACKPACK, UMBRELLA, HANDBAG, TIE, SUITCASE, FRISBEE,
		SKIS, SNOWBOARD, SPORTS_BALL, KITE, BASEBALL_BAT, BASEBALL_GLOVE, SKATEBOARD, SURFBOARD, TENNIS_RACKET, BOTTLE,
		WINE_GLASS, CUP, FORK, KNIFE, SPOON, BOWL, BANANA, APPLE, SANDWICH, ORANGE,
		BROCCOLI, CARROT, HOT_DOG, PIZZA, DONUT, CAKE, CHAIR, SOFA, POTTEDPLANT, BED,
		DININGTABLE, TOILET, TVMONITOR, LAPTOP, MOUSE, REMOTE, KEYBOARD, CELL_PHONE, MICROWAVE, OVEN,
		TOASTER, SINK, REFRIGERATOR, BOOK, CLOCK, VASE, SCISSORS, TEDDY_BEAR, HAIR_DRIER, TOOTHBRUSH,
	};
}

class Yolo2DetectorNode
{
	ros::Subscriber subscriber_image_raw_;
	ros::Subscriber subscriber_yolo_config_;
	ros::Publisher publisher_car_objects_;
	ros::Publisher publisher_person_objects_;
	ros::NodeHandle node_handle_;

	darknet::Yolo2Detector yolo_detector_;

	image darknet_image = {};

	float score_threshold_;
	float nms_threshold_;
	double image_ratio_;//resdize ratio used to fit input image to network input size
	uint32_t image_top_bottom_border_;//black strips added to the input image to maintain aspect ratio while resizing it to fit the network input size
	uint32_t image_left_right_border_;

	void convert_rect_to_image_obj(std::vector&lt; RectClassScore&lt;float&gt; &gt;&amp; in_objects, autoware_msgs::image_obj&amp; out_message, std::string in_class)
	{
		for (unsigned int i = 0; i &lt; in_objects.size(); ++i)
		{
			if ( (in_objects[i].score &gt; score_threshold_)
				&amp;&amp; (	(in_class == &quot;car&quot;
							&amp;&amp; (in_objects[i].class_type == Yolo2::CAR
								|| in_objects[i].class_type == Yolo2::BUS
								|| in_objects[i].class_type == Yolo2::TRUCK
								|| in_objects[i].class_type == Yolo2::MOTORBIKE
								)
						)
					|| (in_class == &quot;person&quot;
							&amp;&amp; (in_objects[i].class_type == Yolo2::PERSON
								|| in_objects[i].class_type == Yolo2::BICYCLE
								|| in_objects[i].class_type == Yolo2::DOG
								|| in_objects[i].class_type == Yolo2::CAT
								|| in_objects[i].class_type == Yolo2::HORSE
								)
						)
					)
				)//check if the score is larger than minimum required
			{
				autoware_msgs::image_rect rect;

				rect.x = (in_objects[i].x * darknet_image.w /image_ratio_) - image_left_right_border_/image_ratio_;
				rect.y = (in_objects[i].y * darknet_image.h /image_ratio_) - image_top_bottom_border_/image_ratio_;
				rect.width = in_objects[i].w * darknet_image.w/image_ratio_;
				rect.height = in_objects[i].h * darknet_image.h/image_ratio_;
				if (in_objects[i].x &lt; 0)
					rect.x = 0;
				if (in_objects[i].y &lt; 0)
					rect.y = 0;
				if (in_objects[i].w &lt; 0)
					rect.width = 0;
				if (in_objects[i].h &lt; 0)
					rect.height = 0;

				rect.score = in_objects[i].score;

				//std::cout &lt;&lt; &quot;x &quot;&lt;&lt; rect.x&lt;&lt; &quot; y &quot; &lt;&lt; rect.y &lt;&lt; &quot; w &quot;&lt;&lt; rect.width &lt;&lt; &quot; h &quot;&lt;&lt; rect.height&lt;&lt; &quot; s &quot; &lt;&lt; rect.score &lt;&lt; &quot; c &quot; &lt;&lt; in_objects[i].class_type &lt;&lt; std::endl;

				out_message.obj.push_back(rect);

			}
		}
	}

	void rgbgr_image(image&amp; im)
	{
		int i;
		for(i = 0; i &lt; im.w*im.h; ++i)
		{
			float swap = im.data[i];
			im.data[i] = im.data[i+im.w*im.h*2];
			im.data[i+im.w*im.h*2] = swap;
		}
	}

	image convert_ipl_to_image(const sensor_msgs::ImageConstPtr&amp; msg)
	{
		cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(msg, &quot;bgr8&quot;);//toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
		cv::Mat mat_image = cv_image-&gt;image;

		uint32_t network_input_width = yolo_detector_.get_network_width();
		uint32_t network_input_height = yolo_detector_.get_network_height();

		uint32_t image_height = msg-&gt;height,
						image_width = msg-&gt;width;

		IplImage ipl_image;
		cv::Mat final_mat;

		//ROS_INFO(&quot;Before Network (%d,%d), Image (%d,%d)&quot;, network_input_width, network_input_height, image_width, image_height);
		if (network_input_width!=image_width
				|| network_input_height != image_height)
		{
			//final_mat = cv::Mat(network_input_width, network_input_height, CV_8UC3, cv::Scalar(0,0,0));
			image_ratio_ = (double ) network_input_width /  (double)mat_image.cols;
			//std::cout &lt;&lt; &quot;Ratio:&quot; &lt;&lt; image_ratio_ &lt;&lt; std::endl;

			cv::resize(mat_image, final_mat, cv::Size(), image_ratio_, image_ratio_);
			image_top_bottom_border_ = abs(final_mat.rows-network_input_height)/2;
			image_left_right_border_ = abs(final_mat.cols-network_input_width)/2;
			cv::copyMakeBorder(final_mat, final_mat,
								image_top_bottom_border_, image_top_bottom_border_,
								image_left_right_border_, image_left_right_border_,
								cv::BORDER_CONSTANT, cv::Scalar(0,0,0));

			/*
			 //CROP CENTER
			 * uint32_t crop_x, crop_y;
			crop_x = (image_width-network_input_width)/2;
			crop_y = (image_height-network_input_height)/2;
			cv::Rect center_crop(crop_x, crop_y, network_input_width, network_input_height);
			std::cout &lt;&lt; mat_image.cols &lt;&lt; &quot;, &quot; &lt;&lt; mat_image.rows &lt;&lt; std::endl;
			cv::Mat cropped_mat = mat_image(center_crop);
			cropped_mat.copyTo(final_mat);
			*/

			//VILE RESIZE
			//cv::resize(mat_image, final_mat, cv::Size(network_input_width, network_input_height));
		}
		else
			final_mat = mat_image;

		//ROS_INFO(&quot;After Network (%d,%d), Image (%d,%d)&quot;, network_input_width, network_input_height, final_mat.cols, final_mat.rows);

		ipl_image = final_mat;

		unsigned char *data = (unsigned char *)ipl_image.imageData;
		int h = ipl_image.height;
		int w = ipl_image.width;
		int c = ipl_image.nChannels;
		int step = ipl_image.widthStep;
		int i, j, k;

		image darknet_image = make_image(w, h, c);

		for(i = 0; i &lt; h; ++i){
			for(k= 0; k &lt; c; ++k){
				for(j = 0; j &lt; w; ++j){
					darknet_image.data[k*w*h + i*w + j] = data[i*step + j*c + k]/255.;
				}
			}
		}
		rgbgr_image(darknet_image);
		return darknet_image;
	}

	void image_callback(const sensor_msgs::ImageConstPtr&amp; in_image_message)
	{
		std::vector&lt; RectClassScore&lt;float&gt; &gt; detections;
		//darknet_image = yolo_detector_.convert_image(in_image_message);

		darknet_image = convert_ipl_to_image(in_image_message);

		detections = yolo_detector_.detect(darknet_image);

		//ROS_INFO(&quot;Detections: %ud&quot;, (unsigned int)detections.size());

		//Prepare Output message
		autoware_msgs::image_obj output_car_message;
		autoware_msgs::image_obj output_person_message;
		output_car_message.header = in_image_message-&gt;header;
		output_car_message.type = &quot;car&quot;;

		output_person_message.header = in_image_message-&gt;header;
		output_person_message.type = &quot;person&quot;;

		convert_rect_to_image_obj(detections, output_car_message, &quot;car&quot;);
		convert_rect_to_image_obj(detections, output_person_message, &quot;person&quot;);

		publisher_car_objects_.publish(output_car_message);
		publisher_person_objects_.publish(output_person_message);

		free(darknet_image.data);
	}

	void config_cb(const autoware_msgs::ConfigSsd::ConstPtr&amp; param)
	{
		score_threshold_ 	= param-&gt;score_threshold;
	}

public:
	void Run()
	{
		//ROS STUFF
		ros::NodeHandle private_node_handle(&quot;~&quot;);//to receive args

		//RECEIVE IMAGE TOPIC NAME
		std::string image_raw_topic_str;
		if (private_node_handle.getParam(&quot;image_raw_node&quot;, image_raw_topic_str))
		{
			ROS_INFO(&quot;Setting image node to %s&quot;, image_raw_topic_str.c_str());
		}
		else
		{
			ROS_INFO(&quot;No image node received, defaulting to /image_raw, you can use _image_raw_node:=YOUR_TOPIC&quot;);
			image_raw_topic_str = &quot;/image_raw&quot;;
		}

		std::string network_definition_file;
		std::string pretrained_model_file;
		if (private_node_handle.getParam(&quot;network_definition_file&quot;, network_definition_file))
		{
			ROS_INFO(&quot;Network Definition File (Config): %s&quot;, network_definition_file.c_str());
		}
		else
		{
			ROS_INFO(&quot;No Network Definition File was received. Finishing execution.&quot;);
			return;
		}
		if (private_node_handle.getParam(&quot;pretrained_model_file&quot;, pretrained_model_file))
		{
			ROS_INFO(&quot;Pretrained Model File (Weights): %s&quot;, pretrained_model_file.c_str());
		}
		else
		{
			ROS_INFO(&quot;No Pretrained Model File was received. Finishing execution.&quot;);
			return;
		}

		if (private_node_handle.getParam(&quot;score_threshold&quot;, score_threshold_))
		{
			ROS_INFO(&quot;Score Threshold: %f&quot;, score_threshold_);
		}
		if (private_node_handle.getParam(&quot;nms_threshold&quot;, nms_threshold_))
		{
			ROS_INFO(&quot;NMS Threshold: %f&quot;, nms_threshold_);
		}

		ROS_INFO(&quot;Initializing Yolo2 on Darknet...&quot;);
		yolo_detector_.load(network_definition_file, pretrained_model_file, score_threshold_, nms_threshold_);
		ROS_INFO(&quot;Initialization complete.&quot;);

		publisher_car_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;(&quot;/obj_car/image_obj&quot;, 1);
		publisher_person_objects_ = node_handle_.advertise&lt;autoware_msgs::image_obj&gt;(&quot;/obj_person/image_obj&quot;, 1);

		ROS_INFO(&quot;Subscribing to... %s&quot;, image_raw_topic_str.c_str());
		subscriber_image_raw_ = node_handle_.subscribe(image_raw_topic_str, 1, &amp;Yolo2DetectorNode::image_callback, this);

		std::string config_topic(&quot;/config&quot;);
		config_topic += &quot;/yolo2&quot;;
		subscriber_yolo_config_ = node_handle_.subscribe(config_topic, 1, &amp;Yolo2DetectorNode::config_cb, this);

		ros::spin();
		ROS_INFO(&quot;END Yolo2&quot;);

	}
};

int main(int argc, char **argv)
{
	ros::init(argc, argv, &quot;ssd_unc&quot;);

	Yolo2DetectorNode app;

	app.Run();

	return 0;
}

</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/euclidean_cluster/euclidean_cluster.cpp" new_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/euclidean_cluster/euclidean_cluster.cpp">
				<diff>@@ -300,7 +300,7 @@ void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 											pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
 											jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
-											lidar_tracker::centroids&amp; in_out_centroids,
+											autoware_msgs::centroids&amp; in_out_centroids,
 											double in_max_cluster_distance=0.5)
 {
 	std::vector&lt;ClusterPtr&gt; clusters;
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/PCLPointCloud2.h&gt;
#include &lt;pcl/conversions.h&gt;
#include &lt;pcl_ros/transforms.h&gt;
#include &lt;pcl_ros/point_cloud.h&gt;

#include &lt;pcl/ModelCoefficients.h&gt;
#include &lt;pcl/point_types.h&gt;

#include &lt;pcl/filters/extract_indices.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;pcl/filters/conditional_removal.h&gt;

#include &lt;pcl/features/normal_3d.h&gt;
#include &lt;pcl/features/normal_3d_omp.h&gt;
#include &lt;pcl/features/don.h&gt;
#include &lt;pcl/features/fpfh_omp.h&gt;

#include &lt;pcl/kdtree/kdtree.h&gt;

#include &lt;pcl/sample_consensus/method_types.h&gt;
#include &lt;pcl/sample_consensus/model_types.h&gt;

#include &lt;pcl/segmentation/sac_segmentation.h&gt;
#include &lt;pcl/segmentation/extract_clusters.h&gt;
#include &lt;pcl/segmentation/conditional_euclidean_clustering.h&gt;

#include &lt;pcl/common/common.h&gt;

#include &lt;pcl/search/organized.h&gt;
#include &lt;pcl/search/kdtree.h&gt;

#include &lt;pcl/segmentation/extract_clusters.h&gt;

#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;

#include &lt;std_msgs/Float32MultiArray.h&gt;
#include &lt;std_msgs/MultiArrayLayout.h&gt;
#include &lt;std_msgs/MultiArrayDimension.h&gt;

#include &quot;autoware_msgs/centroids.h&quot;
#include &quot;autoware_msgs/CloudCluster.h&quot;
#include &quot;autoware_msgs/CloudClusterArray.h&quot;

#include &lt;vector_map_server/PositionState.h&gt;

#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;jsk_rviz_plugins/Pictogram.h&gt;
#include &lt;jsk_rviz_plugins/PictogramArray.h&gt;

#include &lt;tf/tf.h&gt;

#include &lt;limits&gt;
#include &lt;cmath&gt;

#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv2/core/version.hpp&gt;
#if (CV_MAJOR_VERSION == 3)
#include &quot;gencolors.cpp&quot;
#else
#include &lt;opencv2/contrib/contrib.hpp&gt;
#endif

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

#include &quot;Cluster.h&quot;

//#include &lt;vector_map/vector_map.h&gt;
//#include &lt;vector_map_server/GetSignal.h&gt;

#ifdef GPU_CLUSTERING
	#include &quot;gpu_euclidean_clustering.h&quot;
#endif

using namespace cv;

std::vector&lt;cv::Scalar&gt; _colors;
ros::Publisher _pub_cluster_cloud;
ros::Publisher _pub_ground_cloud;
ros::Publisher _centroid_pub;
ros::Publisher _marker_pub;
ros::Publisher _pub_clusters_message;
ros::Publisher _pub_text_pictogram;
visualization_msgs::Marker _visualization_marker;

ros::Publisher _pub_points_lanes_cloud;
ros::Publisher _pub_jsk_boundingboxes;
ros::Publisher _pub_jsk_hulls;

ros::ServiceClient _vectormap_server;

std_msgs::Header _velodyne_header;

pcl::PointCloud&lt;pcl::PointXYZ&gt; _sensor_cloud;

std::vector&lt;double&gt; _clustering_thresholds;
std::vector&lt;double&gt; _clustering_distances;

tf::StampedTransform* _transform;
tf::StampedTransform* _velodyne_output_transform;
tf::TransformListener* _transform_listener;

std::string _output_frame;
std::string _vectormap_frame;
static bool _velodyne_transform_available;
static bool _downsample_cloud;
static bool _pose_estimation;
static double _leaf_size;
static int _cluster_size_min;
static int _cluster_size_max;

static bool _remove_ground;	//only ground

static bool _using_sensor_cloud;
static bool _use_diffnormals;
static bool _use_vector_map;

static double _clip_min_height;
static double _clip_max_height;

static bool _keep_lanes;
static double _keep_lane_left_distance;
static double _keep_lane_right_distance;

static double _max_boundingbox_side;
static double _remove_points_upto;
static double _cluster_merge_threshold;

static bool _use_gpu;
static std::chrono::system_clock::time_point _start, _end;

void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbox, jsk_recognition_msgs::BoundingBox&amp; out_boundingbox, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
{
	geometry_msgs::PoseStamped pose_in, pose_out;
	pose_in.header = in_header;
	pose_in.pose = in_boundingbox.pose;
	try
	{
		_transform_listener-&gt;transformPose(in_target_frame, ros::Time(), pose_in, in_header.frame_id,  pose_out);
	}
	catch (tf::TransformException &amp;ex)
	{
		ROS_ERROR(&quot;transformBoundingBox: %s&quot;,ex.what());
	}
	out_boundingbox.pose = pose_out.pose;
	out_boundingbox.header = in_header;
	out_boundingbox.header.frame_id = in_target_frame;
	out_boundingbox.dimensions = in_boundingbox.dimensions;
	out_boundingbox.value = in_boundingbox.value;
	out_boundingbox.label = in_boundingbox.label;
}

void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msgs::CloudClusterArray&amp; in_clusters, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
{
	if (in_target_frame!=in_header.frame_id)
	{
		autoware_msgs::CloudClusterArray clusters_transformed;
		clusters_transformed.header = in_header;
		clusters_transformed.header.frame_id = in_target_frame;
		for (auto i=in_clusters.clusters.begin(); i!= in_clusters.clusters.end(); i++)
		{
			autoware_msgs::CloudCluster cluster_transformed;
			cluster_transformed.header = in_header;
			try
			{
				_transform_listener-&gt;lookupTransform(in_target_frame, _velodyne_header.frame_id,
										ros::Time(), *_transform);
				pcl_ros::transformPointCloud(in_target_frame, *_transform, i-&gt;cloud, cluster_transformed.cloud);
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;min_point, in_header.frame_id, cluster_transformed.min_point);
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;max_point, in_header.frame_id, cluster_transformed.max_point);
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;avg_point, in_header.frame_id, cluster_transformed.avg_point);
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;centroid_point, in_header.frame_id, cluster_transformed.centroid_point);

				cluster_transformed.dimensions = i-&gt;dimensions;
				cluster_transformed.eigen_values = i-&gt;eigen_values;
				cluster_transformed.eigen_vectors = i-&gt;eigen_vectors;

				transformBoundingBox(i-&gt;bounding_box, cluster_transformed.bounding_box, in_target_frame, in_header);

				clusters_transformed.clusters.push_back(cluster_transformed);
			}
			catch (tf::TransformException &amp;ex)
			{
				ROS_ERROR(&quot;publishCloudClusters: %s&quot;,ex.what());
			}
		}
		in_publisher-&gt;publish(clusters_transformed);
	}
	else
	{
		in_publisher-&gt;publish(in_clusters);
	}
}

void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::centroids&amp; in_centroids, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
{
	if (in_target_frame!=in_header.frame_id)
	{
		autoware_msgs::centroids centroids_transformed;
		centroids_transformed.header = in_header;
		centroids_transformed.header.frame_id = in_target_frame;
		for (auto i=centroids_transformed.points.begin(); i!= centroids_transformed.points.end(); i++)
		{
			geometry_msgs::PointStamped centroid_in, centroid_out;
			centroid_in.header = in_header;
			centroid_in.point = *i;
			try
			{
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), centroid_in, in_header.frame_id, centroid_out);

				centroids_transformed.points.push_back(centroid_out.point);
			}
			catch (tf::TransformException &amp;ex)
			{
				ROS_ERROR(&quot;publishCentroids: %s&quot;,ex.what());
			}
		}
		in_publisher-&gt;publish(centroids_transformed);
	}
	else
	{
		in_publisher-&gt;publish(in_centroids);
	}
}

void publishBoundingBoxArray(const ros::Publisher* in_publisher, const jsk_recognition_msgs::BoundingBoxArray&amp; in_boundingbox_array, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
{
	if (in_target_frame!=in_header.frame_id)
	{
		jsk_recognition_msgs::BoundingBoxArray boundingboxes_transformed;
		boundingboxes_transformed.header = in_header;
		boundingboxes_transformed.header.frame_id = in_target_frame;
		for (auto i=in_boundingbox_array.boxes.begin(); i!= in_boundingbox_array.boxes.end(); i++)
		{
			jsk_recognition_msgs::BoundingBox boundingbox_transformed;
			transformBoundingBox(*i, boundingbox_transformed, in_target_frame, in_header);
			boundingboxes_transformed.boxes.push_back(boundingbox_transformed);
		}
		in_publisher-&gt;publish(boundingboxes_transformed);
	}
	else
	{
		in_publisher-&gt;publish(in_boundingbox_array);
	}
}

void publishCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_to_publish_ptr)
{
	sensor_msgs::PointCloud2 cloud_msg;
	pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
	cloud_msg.header=_velodyne_header;
	in_publisher-&gt;publish(cloud_msg);
}

void publishColorCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr in_cloud_to_publish_ptr)
{
	sensor_msgs::PointCloud2 cloud_msg;
	pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
	cloud_msg.header=_velodyne_header;
	in_publisher-&gt;publish(cloud_msg);
}

void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
					pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr,
					float in_left_lane_threshold = 1.5,
					float in_right_lane_threshold = 1.5)
{
	pcl::PointIndices::Ptr far_indices (new pcl::PointIndices);
	for(unsigned int i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
	{
		pcl::PointXYZ current_point;
		current_point.x=in_cloud_ptr-&gt;points[i].x;
		current_point.y=in_cloud_ptr-&gt;points[i].y;
		current_point.z=in_cloud_ptr-&gt;points[i].z;

		if (
				current_point.y &gt; (in_left_lane_threshold) || current_point.y &lt; -1.0*in_right_lane_threshold
			)
		{
			far_indices-&gt;indices.push_back(i);
		}
	}
	out_cloud_ptr-&gt;points.clear();
	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
	extract.setInputCloud (in_cloud_ptr);
	extract.setIndices(far_indices);
	extract.setNegative(true);//true removes the indices, false leaves only the indices
	extract.filter(*out_cloud_ptr);
}

#ifdef GPU_CLUSTERING
std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
											pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
											jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
											lidar_tracker::centroids&amp; in_out_centroids,
											double in_max_cluster_distance=0.5)
{
	std::vector&lt;ClusterPtr&gt; clusters;

	//Convert input point cloud to vectors of x, y, and z

	int size = in_cloud_ptr-&gt;points.size();

	if (size == 0)
		return clusters;

	float *tmp_x, *tmp_y, *tmp_z;

	tmp_x = (float *)malloc(sizeof(float) * size);
	tmp_y = (float *)malloc(sizeof(float) * size);
	tmp_z = (float *)malloc(sizeof(float) * size);

	for (int i = 0; i &lt; size; i++) {
		pcl::PointXYZ tmp_point = in_cloud_ptr-&gt;at(i);

		tmp_x[i] = tmp_point.x;
		tmp_y[i] = tmp_point.y;
		tmp_z[i] = tmp_point.z;
	}

	GpuEuclideanCluster gecl_cluster;

	gecl_cluster.setInputPoints(tmp_x, tmp_y, tmp_z, size);
	gecl_cluster.setThreshold(in_max_cluster_distance);
	gecl_cluster.setMinClusterPts (_cluster_size_min);
	gecl_cluster.setMaxClusterPts (_cluster_size_max);
	gecl_cluster.extractClusters();
	std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; cluster_indices = gecl_cluster.getOutput();

	unsigned int k = 0;

	for (auto it = cluster_indices.begin(); it != cluster_indices.end(); it++)
	{
		ClusterPtr cluster(new Cluster());
		cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], &quot;&quot;, _pose_estimation);
		clusters.push_back(cluster);

		k++;
	}

	free(tmp_x);
	free(tmp_y);
	free(tmp_z);

	return clusters;
}
#endif

std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
		autoware_msgs::centroids&amp; in_out_centroids,
		double in_max_cluster_distance=0.5)
{
	pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);

	//create 2d pc
	pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_2d(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
	pcl::copyPointCloud(*in_cloud_ptr, *cloud_2d);
	//make it flat
	for (size_t i=0; i&lt;cloud_2d-&gt;points.size(); i++)
	{
		cloud_2d-&gt;points[i].z = 0;
	}

	if (cloud_2d-&gt;points.size() &gt; 0)
		tree-&gt;setInputCloud (cloud_2d);

	std::vector&lt;pcl::PointIndices&gt; cluster_indices;

	//perform clustering on 2d cloud
	pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
	ec.setClusterTolerance (in_max_cluster_distance); //
	ec.setMinClusterSize (_cluster_size_min);
	ec.setMaxClusterSize (_cluster_size_max);
	ec.setSearchMethod(tree);
	ec.setInputCloud (cloud_2d);
	ec.extract (cluster_indices);
	//use indices on 3d cloud

	/*pcl::ConditionalEuclideanClustering&lt;pcl::PointXYZ&gt; cec (true);
	cec.setInputCloud (in_cloud_ptr);
	cec.setConditionFunction (&amp;independentDistance);
	cec.setMinClusterSize (cluster_size_min);
	cec.setMaxClusterSize (cluster_size_max);
	cec.setClusterTolerance (_distance*2.0f);
	cec.segment (cluster_indices);*/

	/////////////////////////////////
	//---	3. Color clustered points
	/////////////////////////////////
	unsigned int k = 0;
	//pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr final_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);

	std::vector&lt;ClusterPtr&gt; clusters;
	//pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);//coord + color cluster
	for (auto it = cluster_indices.begin(); it != cluster_indices.end(); ++it)
	{
		ClusterPtr cluster(new Cluster());
		cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], &quot;&quot;, _pose_estimation);
		clusters.push_back(cluster);

		k++;
	}
	//std::cout &lt;&lt; &quot;Clusters: &quot; &lt;&lt; k &lt;&lt; std::endl;
	return clusters;

}

void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;bool&gt;&amp; in_out_visited_clusters, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold)
{
	//std::cout &lt;&lt; &quot;checkClusterMerge&quot; &lt;&lt; std::endl;
	pcl::PointXYZ point_a = in_clusters[in_cluster_id]-&gt;GetCentroid();
	for(size_t i=0; i&lt; in_clusters.size(); i++)
	{
		if (i != in_cluster_id &amp;&amp; !in_out_visited_clusters[i])
		{
			pcl::PointXYZ point_b = in_clusters[i]-&gt;GetCentroid();
			double distance = sqrt( pow(point_b.x - point_a.x,2) + pow(point_b.y - point_a.y,2) );
			if (distance &lt;= in_merge_threshold)
			{
				in_out_visited_clusters[i] = true;
				out_merge_indices.push_back(i);
				//std::cout &lt;&lt; &quot;Merging &quot; &lt;&lt; in_cluster_id &lt;&lt; &quot; with &quot; &lt;&lt; i &lt;&lt; &quot; dist:&quot; &lt;&lt; distance &lt;&lt; std::endl;
				checkClusterMerge(i, in_clusters, in_out_visited_clusters, out_merge_indices, in_merge_threshold);
			}
		}
	}
}

void mergeClusters(const std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_clusters)
{
	//std::cout &lt;&lt; &quot;mergeClusters:&quot; &lt;&lt; in_merge_indices.size() &lt;&lt; std::endl;
	pcl::PointCloud&lt;pcl::PointXYZRGB&gt; sum_cloud;
	pcl::PointCloud&lt;pcl::PointXYZ&gt; mono_cloud;
	ClusterPtr merged_cluster(new Cluster());
	for (size_t i=0; i&lt;in_merge_indices.size(); i++)
	{
		sum_cloud += *(in_clusters[in_merge_indices[i]]-&gt;GetCloud());
		in_out_merged_clusters[in_merge_indices[i]] = true;
	}
	std::vector&lt;int&gt; indices(sum_cloud.points.size(), 0);
	for (size_t i=0; i&lt;sum_cloud.points.size(); i++)
	{
		indices[i]=i;
	}

	if (sum_cloud.points.size() &gt; 0)
	{
		pcl::copyPointCloud(sum_cloud, mono_cloud);
		//std::cout &lt;&lt; &quot;mergedClusters &quot; &lt;&lt; sum_cloud.points.size() &lt;&lt; &quot; mono:&quot; &lt;&lt; mono_cloud.points.size() &lt;&lt; std::endl;
		//cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], &quot;&quot;, _pose_estimation);
		merged_cluster-&gt;SetCloud(mono_cloud.makeShared(), indices, _velodyne_header, current_index,(int)_colors[current_index].val[0], (int)_colors[current_index].val[1], (int)_colors[current_index].val[2], &quot;&quot;, _pose_estimation);
		out_clusters.push_back(merged_cluster);
	}
}

void checkAllForMerge(std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters, float in_merge_threshold)
{
	//std::cout &lt;&lt; &quot;checkAllForMerge&quot; &lt;&lt; std::endl;
	std::vector&lt;bool&gt; visited_clusters(in_clusters.size(), false);
	std::vector&lt;bool&gt; merged_clusters(in_clusters.size(), false);
	size_t current_index=0;
	for (size_t i = 0; i&lt; in_clusters.size(); i++)
	{
		if (!visited_clusters[i])
		{
			visited_clusters[i] = true;
			std::vector&lt;size_t&gt; merge_indices;
			checkClusterMerge(i, in_clusters, visited_clusters, merge_indices, in_merge_threshold);
			mergeClusters(in_clusters, out_clusters, merge_indices, current_index++, merged_clusters);
		}
	}
	for(size_t i =0; i&lt; in_clusters.size(); i++)
	{
		//check for clusters not merged, add them to the output
		if (!merged_clusters[i])
		{
			out_clusters.push_back(in_clusters[i]);
		}
	}

	//ClusterPtr cluster(new Cluster());
}

void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
		autoware_msgs::centroids&amp; in_out_centroids,
		autoware_msgs::CloudClusterArray&amp; in_out_clusters,
		jsk_recognition_msgs::PolygonArray&amp; in_out_polygon_array,
		jsk_rviz_plugins::PictogramArray&amp; in_out_pictogram_array)
{
	//cluster the pointcloud according to the distance of the points using different thresholds (not only one for the entire pc)
	//in this way, the points farther in the pc will also be clustered

	//0 =&gt; 0-15m d=0.5
	//1 =&gt; 15-30 d=1
	//2 =&gt; 30-45 d=1.6
	//3 =&gt; 45-60 d=2.1
	//4 =&gt; &gt;60   d=2.6

	std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&gt; cloud_segments_array(5);

	for(unsigned int i=0; i&lt;cloud_segments_array.size(); i++)
	{
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr tmp_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		cloud_segments_array[i] = tmp_cloud;
	}

	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
	{
		pcl::PointXYZ current_point;
		current_point.x = in_cloud_ptr-&gt;points[i].x;
		current_point.y = in_cloud_ptr-&gt;points[i].y;
		current_point.z = in_cloud_ptr-&gt;points[i].z;

		float origin_distance = sqrt( pow(current_point.x,2) + pow(current_point.y,2) );

		if 		(origin_distance &lt; _clustering_distances[0] )	{cloud_segments_array[0]-&gt;points.push_back (current_point);}
		else if(origin_distance &lt; _clustering_distances[1])		{cloud_segments_array[1]-&gt;points.push_back (current_point);}
		else if(origin_distance &lt; _clustering_distances[2])		{cloud_segments_array[2]-&gt;points.push_back (current_point);}
		else if(origin_distance &lt; _clustering_distances[3])		{cloud_segments_array[3]-&gt;points.push_back (current_point);}
		else													{cloud_segments_array[4]-&gt;points.push_back (current_point);}
	}

	std::vector &lt;ClusterPtr&gt; all_clusters;
	for(unsigned int i=0; i&lt;cloud_segments_array.size(); i++)
	{
#ifdef GPU_CLUSTERING
    std::vector&lt;ClusterPtr&gt; local_clusters;
		if (_use_gpu) {
			local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
		} else {
			local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
		}
#else
		std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
#endif
		all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
	}

	//Clusters can be merged or checked in here
	//....
	//check for mergable clusters
	std::vector&lt;ClusterPtr&gt; mid_clusters;
	std::vector&lt;ClusterPtr&gt; final_clusters;

	if (all_clusters.size() &gt; 0)
		checkAllForMerge(all_clusters, mid_clusters, _cluster_merge_threshold);
	else
		mid_clusters = all_clusters;

	if (mid_clusters.size() &gt; 0)
			checkAllForMerge(mid_clusters, final_clusters, _cluster_merge_threshold);
	else
		final_clusters = mid_clusters;

	tf::StampedTransform vectormap_transform;
	if (_use_vector_map)
	{
		cv::TickMeter timer;

		try
		{
			//if the frame of the vectormap is different than the input, obtain transform
			if (_vectormap_frame != _velodyne_header.frame_id)
			{
				_transform_listener-&gt;lookupTransform(_vectormap_frame, _velodyne_header.frame_id, ros::Time(), vectormap_transform);
			}

			timer.reset();timer.start();

			//check if centroids are inside the drivable area
			for(unsigned int i=0; i&lt;final_clusters.size(); i++)
			{
				//transform centroid points to vectormap frame
				pcl::PointXYZ pcl_centroid = final_clusters[i]-&gt;GetCentroid();
				tf::Vector3 vector_centroid (pcl_centroid.x, pcl_centroid.y, pcl_centroid.z);
				tf::Vector3 transformed_centroid;

				if (_vectormap_frame != _velodyne_header.frame_id)
					transformed_centroid = vectormap_transform*vector_centroid;
				else
					transformed_centroid = vector_centroid;

				vector_map_server::PositionState position_state;
				position_state.request.position.x = transformed_centroid.getX();
				position_state.request.position.y = transformed_centroid.getY();
				position_state.request.position.z = transformed_centroid.getZ();


				if (_vectormap_server.call(position_state))
				{
					final_clusters[i]-&gt;SetValidity(position_state.response.state);
					/*std::cout &lt;&lt; &quot;Original:&quot; &lt;&lt; pcl_centroid.x &lt;&lt; &quot;,&quot; &lt;&lt; pcl_centroid.y &lt;&lt; &quot;,&quot; &lt;&lt; pcl_centroid.z &lt;&lt;
							&quot; Transformed:&quot; &lt;&lt; transformed_centroid.x() &lt;&lt; &quot;,&quot; &lt;&lt; transformed_centroid.y() &lt;&lt; &quot;,&quot; &lt;&lt; transformed_centroid.z() &lt;&lt;
							&quot; Validity:&quot; &lt;&lt; position_state.response.state &lt;&lt; std::endl;*/
				}
				else
				{
					ROS_INFO(&quot;vectormap_filtering: VectorMap Server Call failed. Make sure vectormap_server is running. No filtering performed.&quot;);
					final_clusters[i]-&gt;SetValidity(true);
				}
			}
			timer.stop();
			//std::cout &lt;&lt; &quot;vm server took &quot; &lt;&lt; timer.getTimeMilli() &lt;&lt; &quot; ms to check &quot; &lt;&lt; final_clusters.size() &lt;&lt; std::endl;
		}
		catch(tf::TransformException &amp;ex)
		{
			ROS_INFO(&quot;vectormap_filtering: %s&quot;, ex.what());
		}
	}
	//Get final PointCloud to be published
	in_out_polygon_array.header = _velodyne_header;
	in_out_pictogram_array.header = _velodyne_header;
	for(unsigned int i=0; i&lt;final_clusters.size(); i++)
	{
		*out_cloud_ptr = *out_cloud_ptr + *(final_clusters[i]-&gt;GetCloud());

		jsk_recognition_msgs::BoundingBox bounding_box = final_clusters[i]-&gt;GetBoundingBox();
		geometry_msgs::PolygonStamped polygon = final_clusters[i]-&gt;GetPolygon();
		jsk_rviz_plugins::Pictogram pictogram_cluster;
		pictogram_cluster.header = _velodyne_header;

		//PICTO
		pictogram_cluster.mode = pictogram_cluster.STRING_MODE;
		pictogram_cluster.pose.position.x = final_clusters[i]-&gt;GetMaxPoint().x;
		pictogram_cluster.pose.position.y = final_clusters[i]-&gt;GetMaxPoint().y;
		pictogram_cluster.pose.position.z = final_clusters[i]-&gt;GetMaxPoint().z;
		tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
		tf::quaternionTFToMsg(quat, pictogram_cluster.pose.orientation);
		pictogram_cluster.size = 4;
		std_msgs::ColorRGBA color;
		color.a = 1; color.r = 1; color.g = 1; color.b = 1;
		pictogram_cluster.color = color;
		pictogram_cluster.character = std::to_string( i );
		//PICTO

		//pcl::PointXYZ min_point = final_clusters[i]-&gt;GetMinPoint();
		//pcl::PointXYZ max_point = final_clusters[i]-&gt;GetMaxPoint();
		pcl::PointXYZ center_point = final_clusters[i]-&gt;GetCentroid();
		geometry_msgs::Point centroid;
		centroid.x = center_point.x; centroid.y = center_point.y; centroid.z = center_point.z;
		bounding_box.header = _velodyne_header;
		polygon.header = _velodyne_header;

		if (	final_clusters[i]-&gt;IsValid()
				//&amp;&amp; bounding_box.dimensions.x &gt;0 &amp;&amp; bounding_box.dimensions.y &gt;0 &amp;&amp; bounding_box.dimensions.z &gt; 0
				//&amp;&amp;	bounding_box.dimensions.x &lt; _max_boundingbox_side &amp;&amp; bounding_box.dimensions.y &lt; _max_boundingbox_side
				)
		{
			in_out_boundingbox_array.boxes.push_back(bounding_box);
			in_out_centroids.points.push_back(centroid);
			_visualization_marker.points.push_back(centroid);

			in_out_polygon_array.polygons.push_back(polygon);
			in_out_pictogram_array.pictograms.push_back(pictogram_cluster);

			autoware_msgs::CloudCluster cloud_cluster;
			final_clusters[i]-&gt;ToRosMessage(_velodyne_header, cloud_cluster);
			in_out_clusters.clusters.push_back(cloud_cluster);
		}
	}

	for(size_t i=0; i&lt; in_out_polygon_array.polygons.size();i++)
	{
		in_out_polygon_array.labels.push_back(i);
	}

}

void removeFloor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_nofloor_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_onlyfloor_cloud_ptr, float in_max_height=0.2, float in_floor_max_angle=0.1)
{
	/*pcl::PointIndicesPtr ground (new pcl::PointIndices);
	// Create the filtering object
	pcl::ProgressiveMorphologicalFilter&lt;pcl::PointXYZ&gt; pmf;
	pmf.setInputCloud (in_cloud_ptr);
	pmf.setMaxWindowSize (20);
	pmf.setSlope (1.0f);
	pmf.setInitialDistance (0.5f);
	pmf.setMaxDistance (3.0f);
	pmf.extract (ground-&gt;indices);

	// Create the filtering object
	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
	extract.setInputCloud (in_cloud_ptr);
	extract.setIndices (ground);
	extract.setNegative(true);//true removes the indices, false leaves only the indices
	extract.filter(*out_nofloor_cloud_ptr);

	//EXTRACT THE FLOOR FROM THE CLOUD
	extract.setNegative(false);//true removes the indices, false leaves only the indices
	extract.filter(*out_onlyfloor_cloud_ptr);*/

	pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
	pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
	pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);

	seg.setOptimizeCoefficients (true);
	seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
	seg.setMethodType(pcl::SAC_RANSAC);
	seg.setMaxIterations(100);
	seg.setAxis(Eigen::Vector3f(0,0,1));
	seg.setEpsAngle(in_floor_max_angle);

	seg.setDistanceThreshold (in_max_height);//floor distance
	seg.setOptimizeCoefficients(true);
	seg.setInputCloud(in_cloud_ptr);
	seg.segment(*inliers, *coefficients);
	if (inliers-&gt;indices.size () == 0)
	{
		std::cout &lt;&lt; &quot;Could not estimate a planar model for the given dataset.&quot; &lt;&lt; std::endl;
	}

	//REMOVE THE FLOOR FROM THE CLOUD
	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
	extract.setInputCloud (in_cloud_ptr);
	extract.setIndices(inliers);
	extract.setNegative(true);//true removes the indices, false leaves only the indices
	extract.filter(*out_nofloor_cloud_ptr);

	//EXTRACT THE FLOOR FROM THE CLOUD
	extract.setNegative(false);//true removes the indices, false leaves only the indices
	extract.filter(*out_onlyfloor_cloud_ptr);
}

void downsampleCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_leaf_size=0.2)
{
	pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
	sor.setInputCloud(in_cloud_ptr);
	sor.setLeafSize((float)in_leaf_size, (float)in_leaf_size, (float)in_leaf_size);
	sor.filter(*out_cloud_ptr);
}

void clipCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_min_height=-1.3, float in_max_height=0.5)
{
	out_cloud_ptr-&gt;points.clear();
	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
	{
		if (in_cloud_ptr-&gt;points[i].z &gt;= in_min_height &amp;&amp;
				in_cloud_ptr-&gt;points[i].z &lt;= in_max_height)
		{
			out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
		}
	}
}

void differenceNormalsSegmentation(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr)
{
	float small_scale=0.5;
	float large_scale=2.0;
	float angle_threshold=0.5;
	pcl::search::Search&lt;pcl::PointXYZ&gt;::Ptr tree;
	if (in_cloud_ptr-&gt;isOrganized ())
	{
		tree.reset (new pcl::search::OrganizedNeighbor&lt;pcl::PointXYZ&gt; ());
	}
	else
	{
		tree.reset (new pcl::search::KdTree&lt;pcl::PointXYZ&gt; (false));
	}

	// Set the input pointcloud for the search tree
	tree-&gt;setInputCloud (in_cloud_ptr);

	pcl::NormalEstimationOMP&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
	//pcl::gpu::NormalEstimation&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
	normal_estimation.setInputCloud (in_cloud_ptr);
	normal_estimation.setSearchMethod (tree);

	normal_estimation.setViewPoint (std::numeric_limits&lt;float&gt;::max (), std::numeric_limits&lt;float&gt;::max (), std::numeric_limits&lt;float&gt;::max ());

	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_small_scale (new pcl::PointCloud&lt;pcl::PointNormal&gt;);
	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_large_scale (new pcl::PointCloud&lt;pcl::PointNormal&gt;);

	normal_estimation.setRadiusSearch (small_scale);
	normal_estimation.compute (*normals_small_scale);

	normal_estimation.setRadiusSearch (large_scale);
	normal_estimation.compute (*normals_large_scale);

	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud (new pcl::PointCloud&lt;pcl::PointNormal&gt;);
	pcl::copyPointCloud&lt;pcl::PointXYZ, pcl::PointNormal&gt;(*in_cloud_ptr, *diffnormals_cloud);

	// Create DoN operator
	pcl::DifferenceOfNormalsEstimation&lt;pcl::PointXYZ, pcl::PointNormal, pcl::PointNormal&gt; diffnormals_estimator;
	diffnormals_estimator.setInputCloud (in_cloud_ptr);
	diffnormals_estimator.setNormalScaleLarge (normals_large_scale);
	diffnormals_estimator.setNormalScaleSmall (normals_small_scale);

	diffnormals_estimator.initCompute();

	diffnormals_estimator.computeFeature(*diffnormals_cloud);

	pcl::ConditionOr&lt;pcl::PointNormal&gt;::Ptr range_cond (new pcl::ConditionOr&lt;pcl::PointNormal&gt;() );
	range_cond-&gt;addComparison (pcl::FieldComparison&lt;pcl::PointNormal&gt;::ConstPtr (
			new pcl::FieldComparison&lt;pcl::PointNormal&gt; (&quot;curvature&quot;, pcl::ComparisonOps::GT, angle_threshold) )
			);
	// Build the filter
	pcl::ConditionalRemoval&lt;pcl::PointNormal&gt; cond_removal;
	cond_removal.setCondition(range_cond);
	cond_removal.setInputCloud (diffnormals_cloud);

	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud_filtered (new pcl::PointCloud&lt;pcl::PointNormal&gt;);

	// Apply filter
	cond_removal.filter (*diffnormals_cloud_filtered);

	pcl::copyPointCloud&lt;pcl::PointNormal, pcl::PointXYZ&gt;(*diffnormals_cloud, *out_cloud_ptr);
}

void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, const double in_distance)
{
	out_cloud_ptr-&gt;points.clear();
	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
	{
		float origin_distance = sqrt( pow(in_cloud_ptr-&gt;points[i].x,2) + pow(in_cloud_ptr-&gt;points[i].y,2) );
		if (origin_distance &gt; in_distance)
		{
			out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
		}
	}
}

void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
{
	_start = std::chrono::system_clock::now(); // 計測開始時間

	if (!_using_sensor_cloud)
	{
		_using_sensor_cloud = true;

		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_sensor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr removed_points_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr downsampled_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr inlanes_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr nofloor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr onlyfloor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr diffnormals_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr clipped_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr colored_clustered_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);

		autoware_msgs::centroids centroids;
		autoware_msgs::CloudClusterArray cloud_clusters;
		jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
		jsk_recognition_msgs::PolygonArray polygon_array;
		jsk_rviz_plugins::PictogramArray pictograms_array;

		pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);

		_velodyne_header = in_sensor_cloud-&gt;header;

		if (_remove_points_upto &gt; 0.0)
		{
			removePointsUpTo(current_sensor_cloud_ptr, removed_points_cloud_ptr, _remove_points_upto);
		}
		else
			removed_points_cloud_ptr = current_sensor_cloud_ptr;

		if (_downsample_cloud)
			downsampleCloud(removed_points_cloud_ptr, downsampled_cloud_ptr, _leaf_size);
		else
			downsampled_cloud_ptr =removed_points_cloud_ptr;

		clipCloud(downsampled_cloud_ptr, clipped_cloud_ptr, _clip_min_height, _clip_max_height);

		if(_keep_lanes)
			keepLanePoints(clipped_cloud_ptr, inlanes_cloud_ptr, _keep_lane_left_distance, _keep_lane_right_distance);
		else
			inlanes_cloud_ptr = clipped_cloud_ptr;

		if(_remove_ground)
		{
			removeFloor(inlanes_cloud_ptr, nofloor_cloud_ptr, onlyfloor_cloud_ptr);
			publishCloud(&amp;_pub_ground_cloud, onlyfloor_cloud_ptr);
		}
		else
			nofloor_cloud_ptr = inlanes_cloud_ptr;

		publishCloud(&amp;_pub_points_lanes_cloud, nofloor_cloud_ptr);

		if (_use_diffnormals)
			differenceNormalsSegmentation(nofloor_cloud_ptr, diffnormals_cloud_ptr);
		else
			diffnormals_cloud_ptr = nofloor_cloud_ptr;

		segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, boundingbox_array, centroids, cloud_clusters, polygon_array, pictograms_array);

		publishColorCloud(&amp;_pub_cluster_cloud, colored_clustered_cloud_ptr);

		// Publish BB
		boundingbox_array.header = _velodyne_header;

		_pub_jsk_hulls.publish(polygon_array);//publish convex hulls
		_pub_text_pictogram.publish(pictograms_array);//publish_ids

		publishBoundingBoxArray(&amp;_pub_jsk_boundingboxes, boundingbox_array, _output_frame, _velodyne_header);
		centroids.header = _velodyne_header;

		publishCentroids(&amp;_centroid_pub, centroids, _output_frame, _velodyne_header);

		_marker_pub.publish(_visualization_marker);
		_visualization_marker.points.clear();//transform? is it used?
		cloud_clusters.header = _velodyne_header;

		publishCloudClusters(&amp;_pub_clusters_message, cloud_clusters, _output_frame, _velodyne_header);

		_using_sensor_cloud = false;
	}
	_end = std::chrono::system_clock::now();  // 計測終了時間
  double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count(); //処理に要した時間をミリ秒に変換
  ROS_INFO(&quot;Euclidean Clustering : %f&quot;, elapsed);
}

/*
void vectormap_callback(const visualization_msgs::MarkerArray::Ptr in_vectormap_markers)
{
	float min_x=std::numeric_limits&lt;float&gt;::max();float max_x=-std::numeric_limits&lt;float&gt;::max();
	float min_y=std::numeric_limits&lt;float&gt;::max();float max_y=-std::numeric_limits&lt;float&gt;::max();
	pcl::PointXYZ min_point;
	pcl::PointXYZ max_point;
	std::vector&lt;geometry_msgs::Point&gt; vectormap_points;
	std::string marker_frame;
	double map_scale = -10.0;
	for(auto i=in_vectormap_markers-&gt;markers.begin(); i!= in_vectormap_markers-&gt;markers.end(); i++)
	{
		visualization_msgs::Marker current_marker = *i;
		marker_frame = current_marker.header.frame_id;
		if (current_marker.ns == &quot;road_edge&quot;)
		{
			for (unsigned int j=0; j&lt; current_marker.points.size(); j++)
			{
				geometry_msgs::Point p = current_marker.points[j];
				p.x*=map_scale;
				p.y*=map_scale;
				if(p.x&lt;min_x)	min_x = p.x;
				if(p.y&lt;min_y)	min_y = p.y;
				if(p.x&gt;max_x)	max_x = p.x;
				if(p.y&gt;max_y)	max_y = p.y;
				vectormap_points.push_back(p);
			}
		}
	}
	min_point.x = min_x;	min_point.y = min_y;
	max_point.x = max_x;	max_point.y = max_y;

	min_point.x*=-1.0;
	min_point.y*=-1.0;
	//translate the points to the minimum point
	for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
	{
		(*i).x+=min_point.x;
		(*i).y+=min_point.y;
	}
	max_point.x+=min_point.x;
	max_point.y+=min_point.y;
	//get world tf
	std::string error_transform_msg;
	tf::Vector3 map_origin_point;
	if(_transform_listener-&gt;waitForTransform(&quot;/map&quot;, marker_frame, ros::Time(0), ros::Duration(5), ros::Duration(0.1), &amp;error_transform_msg))
	{
		_transform_listener-&gt;lookupTransform(&quot;/map&quot;, marker_frame, ros::Time(0), *_transform);
		map_origin_point = _transform-&gt;getOrigin();
		map_origin_point.setX( map_origin_point.x() - min_point.x);
		map_origin_point.setY( map_origin_point.y() - min_point.y);
	}
	else
	{
		ROS_INFO(&quot;Euclidean Cluster (vectormap_callback): %s&quot;, error_transform_msg.c_str());
	}

	cv::Mat map_image = cv::Mat::zeros(max_point.y, max_point.x, CV_8UC3);

	std::cout &lt;&lt; &quot;W,H:&quot; &lt;&lt; max_point &lt;&lt; std::endl;

	cv::Point image_start_point (vectormap_points[0].x, vectormap_points[0].y);
	cv::Point prev_point = image_start_point;
	for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
	{
		cv::line(map_image, prev_point, cv::Point((int)(i-&gt;x), (int)(i-&gt;y)), cv::Scalar::all(255));

		prev_point.x = (int)(i-&gt;x);
		prev_point.y = (int)(i-&gt;y);
	}
	cv::circle(map_image, image_start_point, 3, cv::Scalar(255,0,0));
	cv::imshow(&quot;vectormap&quot;, map_image);
	cv::waitKey(0);
}*/

int main (int argc, char** argv)
{
	// Initialize ROS
	ros::init (argc, argv, &quot;euclidean_cluster&quot;);

	ros::NodeHandle h;
	ros::NodeHandle private_nh(&quot;~&quot;);

	tf::StampedTransform transform;
	tf::TransformListener listener;

	_transform = &amp;transform;
	_transform_listener = &amp;listener;

#if (CV_MAJOR_VERSION == 3)
	generateColors(_colors, 100);
#else
	cv::generateColors(_colors, 100);
#endif

	_pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/points_cluster&quot;,1);
	_pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/points_ground&quot;,1);
	_centroid_pub = h.advertise&lt;autoware_msgs::centroids&gt;(&quot;/cluster_centroids&quot;,1);
	_marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;(&quot;centroid_marker&quot;,1);

	_pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/points_lanes&quot;,1);
	_pub_jsk_boundingboxes = h.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;/bounding_boxes&quot;,1);
	_pub_jsk_hulls = h.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;(&quot;/cluster_hulls&quot;,1);
	_pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;(&quot;/cloud_clusters&quot;,1);
	_pub_text_pictogram = h.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;(&quot;cluster_ids&quot;, 10); ROS_INFO(&quot;output pictograms topic: %s&quot;, &quot;cluster_id&quot;);

	std::string points_topic;

	_using_sensor_cloud = false;

	if (private_nh.getParam(&quot;points_node&quot;, points_topic))
	{
		ROS_INFO(&quot;euclidean_cluster &gt; Setting points node to %s&quot;, points_topic.c_str());
	}
	else
	{
		ROS_INFO(&quot;euclidean_cluster &gt; No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC&quot;);
		points_topic = &quot;/points_raw&quot;;
	}

	_use_diffnormals = false;
	if (private_nh.getParam(&quot;use_diffnormals&quot;, _use_diffnormals))
	{
		if (_use_diffnormals)
			ROS_INFO(&quot;Euclidean Clustering: Applying difference of normals on clustering pipeline&quot;);
		else
			ROS_INFO(&quot;Euclidean Clustering: Difference of Normals will not be used.&quot;);
	}

	/* Initialize tuning parameter */
	private_nh.param(&quot;downsample_cloud&quot;, _downsample_cloud, false);	ROS_INFO(&quot;downsample_cloud: %d&quot;, _downsample_cloud);
	private_nh.param(&quot;remove_ground&quot;, _remove_ground, true);		ROS_INFO(&quot;remove_ground: %d&quot;, _remove_ground);
	private_nh.param(&quot;leaf_size&quot;, _leaf_size, 0.1);					ROS_INFO(&quot;leaf_size: %f&quot;, _leaf_size);
	private_nh.param(&quot;cluster_size_min&quot;, _cluster_size_min, 20);	ROS_INFO(&quot;cluster_size_min %d&quot;, _cluster_size_min);
	private_nh.param(&quot;cluster_size_max&quot;, _cluster_size_max, 100000);ROS_INFO(&quot;cluster_size_max: %d&quot;, _cluster_size_max);
	private_nh.param(&quot;pose_estimation&quot;, _pose_estimation, false);	ROS_INFO(&quot;pose_estimation: %d&quot;, _pose_estimation);
	private_nh.param(&quot;clip_min_height&quot;, _clip_min_height, -1.3);	ROS_INFO(&quot;clip_min_height: %f&quot;, _clip_min_height);
	private_nh.param(&quot;clip_max_height&quot;, _clip_max_height, 0.5);		ROS_INFO(&quot;clip_max_height: %f&quot;, _clip_max_height);
	private_nh.param(&quot;keep_lanes&quot;, _keep_lanes, false);				ROS_INFO(&quot;keep_lanes: %d&quot;, _keep_lanes);
	private_nh.param(&quot;keep_lane_left_distance&quot;, _keep_lane_left_distance, 5.0);		ROS_INFO(&quot;keep_lane_left_distance: %f&quot;, _keep_lane_left_distance);
	private_nh.param(&quot;keep_lane_right_distance&quot;, _keep_lane_right_distance, 5.0);	ROS_INFO(&quot;keep_lane_right_distance: %f&quot;, _keep_lane_right_distance);
	private_nh.param(&quot;clustering_thresholds&quot;, _clustering_thresholds);
	private_nh.param(&quot;clustering_distances&quot;, _clustering_distances);
	private_nh.param(&quot;max_boundingbox_side&quot;, _max_boundingbox_side, 10.0);				ROS_INFO(&quot;max_boundingbox_side: %f&quot;, _max_boundingbox_side);
	private_nh.param(&quot;cluster_merge_threshold&quot;, _cluster_merge_threshold, 1.5);			ROS_INFO(&quot;cluster_merge_threshold: %f&quot;, _cluster_merge_threshold);
	private_nh.param&lt;std::string&gt;(&quot;output_frame&quot;, _output_frame, &quot;velodyne&quot;);			ROS_INFO(&quot;output_frame: %s&quot;, _output_frame.c_str());

	private_nh.param(&quot;use_vector_map&quot;, _use_vector_map, false);							ROS_INFO(&quot;use_vector_map: %d&quot;, _use_vector_map);
	private_nh.param&lt;std::string&gt;(&quot;vectormap_frame&quot;, _vectormap_frame, &quot;map&quot;);			ROS_INFO(&quot;vectormap_frame: %s&quot;, _output_frame.c_str());

	private_nh.param(&quot;remove_points_upto&quot;, _remove_points_upto, 0.0);		ROS_INFO(&quot;remove_points_upto: %f&quot;, _remove_points_upto);

	private_nh.param(&quot;use_gpu&quot;, _use_gpu, false);				ROS_INFO(&quot;use_gpu: %d&quot;, _use_gpu);

	_velodyne_transform_available = false;

	if (_clustering_distances.size()!=4)
	{
		_clustering_distances = {15, 30, 45, 60};//maximum distance from sensor origin to separate segments
	}
	if (_clustering_thresholds.size()!=5)
	{
		_clustering_thresholds = {0.5, 1.1, 1.6, 2.1, 2.6};//Nearest neighbor distance threshold for each segment
	}

	std::cout &lt;&lt; &quot;_clustering_thresholds: &quot;; for (auto i = _clustering_thresholds.begin(); i != _clustering_thresholds.end(); ++i)  std::cout &lt;&lt; *i &lt;&lt; ' '; std::cout &lt;&lt; std::endl;
	std::cout &lt;&lt; &quot;_clustering_distances: &quot;;for (auto i = _clustering_distances.begin(); i != _clustering_distances.end(); ++i)  std::cout &lt;&lt; *i &lt;&lt; ' '; std::cout &lt;&lt;std::endl;

	// Create a ROS subscriber for the input point cloud
	ros::Subscriber sub = h.subscribe (points_topic, 1, velodyne_callback);
	//ros::Subscriber sub_vectormap = h.subscribe (&quot;vector_map&quot;, 1, vectormap_callback);
	_vectormap_server = h.serviceClient&lt;vector_map_server::PositionState&gt;(&quot;vector_map_server/is_way_area&quot;);

	_visualization_marker.header.frame_id = &quot;velodyne&quot;;
	_visualization_marker.header.stamp = ros::Time();
	_visualization_marker.ns = &quot;my_namespace&quot;;
	_visualization_marker.id = 0;
	_visualization_marker.type = visualization_msgs::Marker::SPHERE_LIST;
	_visualization_marker.action = visualization_msgs::Marker::ADD;
	_visualization_marker.scale.x = 1.0;
	_visualization_marker.scale.y = 1.0;
	_visualization_marker.scale.z = 1.0;
	_visualization_marker.color.a = 1.0;
	_visualization_marker.color.r = 0.0;
	_visualization_marker.color.g = 0.0;
	_visualization_marker.color.b = 1.0;
	// marker.lifetime = ros::Duration(0.1);
	_visualization_marker.frame_locked = true;

	// Spin
	ros::spin ();
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/include/Context.h" new_path="ros/src/computing/perception/detection/packages/road_wizard/include/Context.h">
				<diff>@@ -3,7 +3,7 @@
 
 #include &lt;vector&gt;
 #include &lt;opencv2/core/core.hpp&gt;
-#include &quot;road_wizard/Signals.h&quot;
+#include &lt;autoware_msgs/Signals.h&gt;
 
 enum LightState { GREEN, YELLOW, RED, UNDEFINED };
 
@@ -13,7 +13,7 @@ public:
 	Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreenCenter,
 		int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight);
         static void SetContexts(std::vector&lt;Context&gt; &amp;contexts, 
-                                const road_wizard::Signals::ConstPtr &amp;extracted_pos,
+                                const autoware_msgs::Signals::ConstPtr &amp;extracted_pos,
                                 const int frame_row,
                                 const int frame_colmuns);
 
</diff>
				<old_file>#ifndef CONTEXT_H
#define CONTEXT_H

#include &lt;vector&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &quot;road_wizard/Signals.h&quot;

enum LightState { GREEN, YELLOW, RED, UNDEFINED };

class Context {
public:
	Context(){};
	Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreenCenter,
		int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight);
        static void SetContexts(std::vector&lt;Context&gt; &amp;contexts, 
                                const road_wizard::Signals::ConstPtr &amp;extracted_pos,
                                const int frame_row,
                                const int frame_colmuns);

	cv::Point redCenter;
	cv::Point yellowCenter;
	cv::Point greenCenter;
	cv::Point3d redCenter3d;
	cv::Point3d yellowCenter3d;
	cv::Point3d greenCenter3d;
	int lampRadius;
	cv::Point topLeft;
	cv::Point botRight;
	LightState lightState;
	int signalID;
	int stateJudgeCount;

 private:
        static bool CompareContext(const Context left, const Context right);
};

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/lib/Context.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/lib/Context.cpp">
				<diff>@@ -23,15 +23,15 @@ bool Context::CompareContext(const Context left, const Context right)
 
 
 void Context::SetContexts(std::vector&lt;Context&gt; &amp;contexts,
-                          const road_wizard::Signals::ConstPtr &amp;extracted_pos,
+                          const autoware_msgs::Signals::ConstPtr &amp;extracted_pos,
                           const int frame_row,
                           const int frame_column) {
   /* copy parts of data to local variable */
-  std::vector&lt;road_wizard::ExtractedPosition&gt; signals;
-  std::vector&lt;road_wizard::ExtractedPosition&gt;::iterator sig_iterator;
+  std::vector&lt;autoware_msgs::ExtractedPosition&gt; signals;
+  std::vector&lt;autoware_msgs::ExtractedPosition&gt;::iterator sig_iterator;
   for (unsigned int i=0; i&lt;extracted_pos-&gt;Signals.size(); i++ )
     {
-      road_wizard::ExtractedPosition tmp;
+      autoware_msgs::ExtractedPosition tmp;
       tmp.signalId = extracted_pos-&gt;Signals.at(i).signalId;
       tmp.u        = extracted_pos-&gt;Signals.at(i).u;
       tmp.v        = extracted_pos-&gt;Signals.at(i).v;
</diff>
				<old_file>#include &quot;Context.h&quot;

Context::Context(cv::Point aRedCenter, cv::Point aYellowCenter, cv::Point aGreenCenter,
		 int aLampRadius, cv::Point aTopLeft, cv::Point aBotRight)
{
	redCenter = aRedCenter;
	yellowCenter = aYellowCenter;
	greenCenter = aGreenCenter;
	lampRadius = aLampRadius;
	topLeft = aTopLeft;
	botRight = aBotRight;
}


/*
  define magnitude relationship of context
 */
bool Context::CompareContext(const Context left, const Context right)
{
  /* if lampRadius is bigger, context is smaller */
  return left.lampRadius &gt;= right.lampRadius;
} /* static bool compareContext() */


void Context::SetContexts(std::vector&lt;Context&gt; &amp;contexts,
                          const road_wizard::Signals::ConstPtr &amp;extracted_pos,
                          const int frame_row,
                          const int frame_column) {
  /* copy parts of data to local variable */
  std::vector&lt;road_wizard::ExtractedPosition&gt; signals;
  std::vector&lt;road_wizard::ExtractedPosition&gt;::iterator sig_iterator;
  for (unsigned int i=0; i&lt;extracted_pos-&gt;Signals.size(); i++ )
    {
      road_wizard::ExtractedPosition tmp;
      tmp.signalId = extracted_pos-&gt;Signals.at(i).signalId;
      tmp.u        = extracted_pos-&gt;Signals.at(i).u;
      tmp.v        = extracted_pos-&gt;Signals.at(i).v;
      tmp.radius   = extracted_pos-&gt;Signals.at(i).radius;
      tmp.x        = extracted_pos-&gt;Signals.at(i).x;
      tmp.y        = extracted_pos-&gt;Signals.at(i).y;
      tmp.z        = extracted_pos-&gt;Signals.at(i).z;
      tmp.type     = extracted_pos-&gt;Signals.at(i).type;
      tmp.linkId   = extracted_pos-&gt;Signals.at(i).linkId;
      tmp.plId     = extracted_pos-&gt;Signals.at(i).plId;
      signals.push_back(tmp);
    }

  std::vector&lt;int&gt; plid_vector;
  for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++) {
    plid_vector.push_back(sig_iterator-&gt;plId);
  }

  /* get array that has unique PLID values as its element */
  std::sort(plid_vector.begin(), plid_vector.end());
  std::vector&lt;int&gt;::iterator new_end = std::unique(plid_vector.begin(), plid_vector.end());
  plid_vector.erase(new_end, plid_vector.end());

  std::vector&lt;Context&gt; updatedSignals;

  /* assemble fragmented signal lamp in a context */
  for (unsigned int ctx_idx=0; ctx_idx&lt;plid_vector.size(); ctx_idx++)
    {
      Context ctx;
      int min_radius  = INT_MAX;
      int most_left   = frame_column;
      int most_top    = frame_row;
      int most_right  = 0;
      int most_bottom = 0;

      for (sig_iterator=signals.begin(); sig_iterator&lt;signals.end(); sig_iterator++)
        {
          int img_x = sig_iterator-&gt;u;
          int img_y = sig_iterator-&gt;v;
          double map_x = sig_iterator-&gt;x;
          double map_y = sig_iterator-&gt;y;
          double map_z = sig_iterator-&gt;z;
          int radius = sig_iterator-&gt;radius;
          if (sig_iterator-&gt;plId == plid_vector.at(ctx_idx) &amp;&amp;
              0 &lt; img_x - radius - 1.5 * radius &amp;&amp; img_x + radius + 1.5 * radius &lt; frame_column &amp;&amp;
              0 &lt; img_y - radius - 1.5 * radius &amp;&amp; img_y + radius + 1.5 * radius &lt; frame_row)
            {
              switch (sig_iterator-&gt;type) {
              case 1:           /* RED */
                ctx.redCenter   = cv::Point( img_x, img_y );
                ctx.redCenter3d = cv::Point3d( map_x, map_y, map_z );
                break;
              case 2:           /* GREEN */
                ctx.greenCenter   = cv::Point( img_x, img_y );
                ctx.greenCenter3d = cv::Point3d( map_x, map_y, map_z );
                break;
              case 3:           /* YELLOW */
                ctx.yellowCenter   = cv::Point( img_x, img_y );
                ctx.yellowCenter3d = cv::Point3d( map_x, map_y, map_z );
                ctx.signalID       = sig_iterator-&gt;signalId; // use yellow light signalID as this context's representative
                break;
              default:          /* this signal is not for cars (for pedestrian or something) */
                continue;
              }
              min_radius    = (min_radius &gt; radius) ? radius : min_radius;
              most_left     = (most_left &gt; img_x - radius -   1.5 * min_radius)  ? img_x - radius - 1.5 * min_radius : most_left;
              most_top      = (most_top &gt; img_y - radius -    1.5 * min_radius)  ? img_y - radius - 1.5 * min_radius : most_top;
              most_right    = (most_right &lt; img_x + radius +  1.5 * min_radius)  ? img_x + radius + 1.5 * min_radius : most_right;
              most_bottom   = (most_bottom &lt; img_y + radius + 1.5 * min_radius)  ? img_y + radius + 1.5 * min_radius : most_bottom;
            }
        }

      ctx.lampRadius = min_radius;
      ctx.topLeft    = cv::Point(most_left, most_top);
      ctx.botRight   = cv::Point(most_right, most_bottom);
      ctx.lightState = UNDEFINED;
      ctx.stateJudgeCount = 0;

      /* search whether this signal has already belonged in detector.contexts */
      bool isInserted = false;
      std::vector&lt;int&gt; eraseCandidate;
      for (unsigned int i = 0; i &lt; contexts.size(); i++) {
        if (ctx.signalID == contexts.at(i).signalID &amp;&amp; ctx.lampRadius != INT_MAX)
          {
            /* update to new information except to lightState */
            updatedSignals.push_back(ctx);
            updatedSignals.back().lightState      = contexts.at(i).lightState;
            updatedSignals.back().stateJudgeCount = contexts.at(i).stateJudgeCount;
            isInserted = true;
            break;
          }

      }

      if (isInserted == false &amp;&amp; ctx.lampRadius != INT_MAX)
        updatedSignals.push_back(ctx); // this ctx is new in detector.contexts

    }

  /* sort by lampRadius */
  std::sort(updatedSignals.begin(), updatedSignals.end(), CompareContext);

  /* reset detector.contexts */
  contexts.clear();
  contexts.resize(updatedSignals.size());
  for (unsigned int i=0; i&lt;updatedSignals.size(); i++) {
    contexts.at(i) = updatedSignals.at(i);
  }

} /* std::vector&lt;Context&gt; Context::SetContexts() */
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp">
				<diff>@@ -20,11 +20,11 @@
 #include &lt;cstdio&gt;
 #include &quot;Math.h&quot;
 #include &lt;Eigen/Eigen&gt;
-#include &quot;road_wizard/Signals.h&quot;
-#include &lt;runtime_manager/adjust_xy.h&gt;
+#include &lt;autoware_msgs/Signals.h&gt;
+#include &lt;autoware_msgs/adjust_xy.h&gt;
 #include &lt;vector_map/vector_map.h&gt;
 #include &lt;vector_map_server/GetSignal.h&gt;
-#include &lt;waypoint_follower_msgs/lane.h&gt;
+#include &lt;autoware_msgs/lane.h&gt;
 
 static std::string camera_id_str;
 
@@ -64,7 +64,7 @@ namespace
   {
   private:
     geometry_msgs::PoseStamped pose_;
-    waypoint_follower_msgs::lane waypoints_;
+    autoware_msgs::lane waypoints_;
 
   public:
     VectorMapClient()
@@ -78,7 +78,7 @@ namespace
       return pose_;
     }
 
-    waypoint_follower_msgs::lane waypoints() const
+    autoware_msgs::lane waypoints() const
     {
       return waypoints_;
     }
@@ -88,7 +88,7 @@ namespace
       pose_ = pose;
     }
 
-    void set_waypoints(const waypoint_follower_msgs::lane&amp; waypoints)
+    void set_waypoints(const autoware_msgs::lane&amp; waypoints)
     {
       waypoints_ = waypoints;
     }
@@ -98,7 +98,7 @@ static VectorMapClient g_vector_map_client;
 
 
 /* Callback function to shift projection result */
-void adjust_xyCallback (const runtime_manager::adjust_xy::ConstPtr&amp; config_msg)
+void adjust_xyCallback (const autoware_msgs::adjust_xy::ConstPtr&amp; config_msg)
 {
   adjust_proj_x = config_msg-&gt;x;
   adjust_proj_y = config_msg-&gt;y;
@@ -260,7 +260,7 @@ double GetSignalAngleInCameraSystem(double hang, double vang)
 void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
 {
   int countPoint = 0;
-  road_wizard::Signals signalsInFrame;
+  autoware_msgs::Signals signalsInFrame;
 
   /* Get signals on the path if vecter_map_server is enabled */
   if (g_use_vector_map_server) {
@@ -308,7 +308,7 @@ void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
       project2 (signalcenterx, ux, vx, useOpenGLCoord);
       radius = (int)distance (ux, vx, u, v);
 
-      road_wizard::ExtractedPosition sign;
+      autoware_msgs::ExtractedPosition sign;
       sign.signalId = signal.id;
 
       sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
@@ -420,7 +420,7 @@ int main (int argc, char *argv[])
     g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;(&quot;vector_map_server/get_signal&quot;);
   }
 
-  ros::Publisher  signalPublisher      = rosnode.advertise &lt;road_wizard::Signals&gt; (&quot;roi_signal&quot;, 100);
+  ros::Publisher  signalPublisher      = rosnode.advertise &lt;autoware_msgs::Signals&gt; (&quot;roi_signal&quot;, 100);
   signal (SIGINT, interrupt);
 
   Rate loop (25);
</diff>
				<old_file>/*
 * signals.cpp
 *
 *  Created on: Apr 9, 2015
 *      Author: sujiwo
 */


#include &lt;iostream&gt;
#include &lt;ros/ros.h&gt;
#include &quot;Rate.h&quot;
#include &quot;vector_map.h&quot;
#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;signal.h&gt;
#include &lt;cstdio&gt;
#include &quot;Math.h&quot;
#include &lt;Eigen/Eigen&gt;
#include &quot;road_wizard/Signals.h&quot;
#include &lt;runtime_manager/adjust_xy.h&gt;
#include &lt;vector_map/vector_map.h&gt;
#include &lt;vector_map_server/GetSignal.h&gt;
#include &lt;waypoint_follower_msgs/lane.h&gt;

static std::string camera_id_str;

static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 1000;

static int adjust_proj_x = 0;
static int adjust_proj_y = 0;

typedef struct {
  double thiX;
  double thiY;
  double thiZ;
} Angle;

static VectorMap vmap;
static Angle cameraOrientation; // camera orientation = car's orientation

static Eigen::Vector3f position;
static Eigen::Quaternionf orientation;
static  float fx,
  fy,
  imageWidth,
  imageHeight,
  cx,
  cy;
static tf::StampedTransform trf;

static bool g_use_vector_map_server; // Switch flag whether vecter-map-server function will be used
static ros::ServiceClient g_ros_client;

#define SignalLampRadius 0.3

/* Define utility class to use vector map server */
namespace
{
  class VectorMapClient
  {
  private:
    geometry_msgs::PoseStamped pose_;
    waypoint_follower_msgs::lane waypoints_;

  public:
    VectorMapClient()
    {}

    ~VectorMapClient()
    {}

    geometry_msgs::PoseStamped pose() const
    {
      return pose_;
    }

    waypoint_follower_msgs::lane waypoints() const
    {
      return waypoints_;
    }

    void set_pose(const geometry_msgs::PoseStamped&amp; pose)
    {
      pose_ = pose;
    }

    void set_waypoints(const waypoint_follower_msgs::lane&amp; waypoints)
    {
      waypoints_ = waypoints;
    }
  }; // Class VectorMapClient
} // namespace
static VectorMapClient g_vector_map_client;


/* Callback function to shift projection result */
void adjust_xyCallback (const runtime_manager::adjust_xy::ConstPtr&amp; config_msg)
{
  adjust_proj_x = config_msg-&gt;x;
  adjust_proj_y = config_msg-&gt;y;
}

void cameraInfoCallback (const sensor_msgs::CameraInfo::ConstPtr camInfoMsg)
{
  fx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[0]);
  fy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[5]);
  imageWidth = camInfoMsg-&gt;width;
  imageHeight = camInfoMsg-&gt;height;
  cx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[2]);
  cy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[6]);
}


/* convert degree value into 0 to 360 range */
static double setDegree0to360(double val)
{
  if (val &lt; 0.0f) {
    return (val + 360.0f);
  }
  else if (360.0f &lt; val) {
    return (val - 360.0f);
  }

  return val;
}


static void get_cameraRollPitchYaw(double* roll,
                                   double* pitch,
                                   double* yaw)
{
  geometry_msgs::Pose cameraPose;
  cameraPose.position.x    = (double)(position.x());
  cameraPose.position.y    = (double)(position.y());
  cameraPose.position.z    = (double)(position.z());
  cameraPose.orientation.x = (double)(orientation.x());
  cameraPose.orientation.y = (double)(orientation.y());
  cameraPose.orientation.z = (double)(orientation.z());
  cameraPose.orientation.w = (double)(orientation.w());

  tf::Quaternion quat;

  tf::quaternionMsgToTF(cameraPose.orientation, quat);
  tf::Matrix3x3(quat).getRPY(*roll, *pitch, *yaw);

  /* convert from radian to degree */
  *roll  = setDegree0to360(*roll  * 180.0f / M_PI);
  *pitch = setDegree0to360(*pitch * 180.0f / M_PI);
  *yaw   = setDegree0to360(*yaw   * 180.0f / M_PI);
}


/*
  check if lower &lt; val &lt; upper
  This function also considers circulation
*/
static bool isRange(const double lower, const double upper, const double val)
{
  if (lower &lt;= upper) {
    if (lower &lt; val &amp;&amp; val &lt; upper) {
      return true;
    }
  }
  else {
    if (val &lt; upper || lower &lt; val) {
      return true;
    }
  }

  return false;
}


void getTransform (Eigen::Quaternionf &amp;ori, Point3 &amp;pos)
{
  static tf::TransformListener listener;

  // target_frame    source_frame
  ros::Time now = ros::Time();
  listener.waitForTransform (camera_id_str, &quot;map&quot;, now, ros::Duration(10.0));
  listener.lookupTransform (camera_id_str, &quot;map&quot;, now, trf);

  tf::Vector3 &amp;p = trf.getOrigin();
  tf::Quaternion o = trf.getRotation();
  pos.x()=p.x(); pos.y()=p.y(); pos.z()=p.z();
  ori.w()=o.w(); ori.x()=o.x(); ori.y()=o.y(); ori.z()=o.z();
}


Point3 transform (const Point3 &amp;psrc, tf::StampedTransform &amp;tfsource)
{
  tf::Vector3 pt3 (psrc.x(), psrc.y(), psrc.z());
  tf::Vector3 pt3s = tfsource * pt3;
  return Point3 (pt3s.x(), pt3s.y(), pt3s.z());
}


/*
 * Project a point from world coordinate to image plane
 */
bool project2 (const Point3 &amp;pt, int &amp;u, int &amp;v, bool useOpenGLCoord=false)
{
  float nearPlane = 1.0;
  float farPlane = 200.0;
  Point3 _pt = transform (pt, trf);
  float _u = _pt.x()*fx/_pt.z() + cx;
  float _v = _pt.y()*fy/_pt.z() + cy;

  u = static_cast&lt;int&gt;(_u);
  v = static_cast&lt;int&gt;(_v);
  if ( u &lt; 0 || imageWidth &lt; u || v &lt; 0 || imageHeight &lt; v || _pt.z() &lt; nearPlane || farPlane &lt; _pt.z() ) {
    u = -1, v = -1;
    return false;
  }

  if (useOpenGLCoord) {
    v = imageHeight - v;
  }

  return true;
}

double ConvertDegreeToRadian(double degree)
{
  return degree * M_PI / 180.0f;
}


double ConvertRadianToDegree(double radian)
{
  return radian * 180.0f / M_PI;
}


double GetSignalAngleInCameraSystem(double hang, double vang)
{
  // Fit the vector map format into ROS style
  double signal_pitch_in_map = ConvertDegreeToRadian(vang - 90);
  double signal_yaw_in_map   = ConvertDegreeToRadian(-hang + 90);

  tf::Quaternion signal_orientation_in_map_system;
  signal_orientation_in_map_system.setRPY(0, signal_pitch_in_map, signal_yaw_in_map);

  tf::Quaternion signal_orientation_in_cam_system = trf * signal_orientation_in_map_system;
  double signal_roll_in_cam;
  double signal_pitch_in_cam;
  double signal_yaw_in_cam;
  tf::Matrix3x3(signal_orientation_in_cam_system).getRPY(signal_roll_in_cam,
                                                         signal_pitch_in_cam,
                                                         signal_yaw_in_cam);

  return ConvertRadianToDegree(signal_pitch_in_cam);   // holizontal angle of camera is represented by pitch
}  // double GetSignalAngleInCameraSystem()


void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
{
  int countPoint = 0;
  road_wizard::Signals signalsInFrame;

  /* Get signals on the path if vecter_map_server is enabled */
  if (g_use_vector_map_server) {
    vector_map_server::GetSignal service;
    /* Set server's request */
    service.request.pose = g_vector_map_client.pose();
    service.request.waypoints = g_vector_map_client.waypoints();

    /* Get server's response*/
    if (g_ros_client.call(service)) {
      /* Reset signal data container */
      vmap.signals.clear();

      /* Newle insert signal data on the path */
      for (const auto&amp; response: service.response.objects.data) {
        if (response.id == 0)
          continue;

        Signal signal;
        signal.id = response.id;
        signal.vid = response.vid;
        signal.plid = response.plid;
        signal.type = response.type;
        signal.linkid = response.linkid;

        vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
      }
    }
  }

  for (unsigned int i=1; i&lt;=vmap.signals.size(); i++) {
    Signal signal = vmap.signals[i];
    int pid = vmap.vectors[signal.vid].pid;

    Point3 signalcenter = vmap.getPoint(pid);
    Point3 signalcenterx (signalcenter.x(), signalcenter.y(), signalcenter.z()+SignalLampRadius);

    int u, v;
    if (project2 (signalcenter, u, v, useOpenGLCoord) == true) {
      countPoint++;
      // std::cout &lt;&lt; u &lt;&lt; &quot;, &quot; &lt;&lt; v &lt;&lt; &quot;, &quot; &lt;&lt; std::endl;

      int radius;
      int ux, vx;
      project2 (signalcenterx, ux, vx, useOpenGLCoord);
      radius = (int)distance (ux, vx, u, v);

      road_wizard::ExtractedPosition sign;
      sign.signalId = signal.id;

      sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
      sign.v = v + adjust_proj_y; // shift project position by configuration value from runtime manager

      sign.radius = radius;
      sign.x = signalcenter.x(), sign.y = signalcenter.y(), sign.z = signalcenter.z();
      sign.hang = vmap.vectors[signal.vid].hang; // hang is expressed in [0, 360] degree
      sign.type = signal.type, sign.linkId = signal.linkid;
      sign.plId = signal.plid;

      // Get holizontal angle of signal in camera corrdinate system
      double signal_angle = GetSignalAngleInCameraSystem(vmap.vectors[signal.vid].hang + 180.0f,
                                                         vmap.vectors[signal.vid].vang + 180.0f);

      // signal_angle will be zero if signal faces to x-axis
      // Target signal should be face to -50 &lt;= z-axis (= 90 degree) &lt;= +50
      if (isRange(-50, 50, signal_angle - 90)) {
        signalsInFrame.Signals.push_back (sign);
      }
    }
  }

  signalsInFrame.header.stamp = ros::Time::now();
  pub.publish (signalsInFrame);

  // printf (&quot;There are %d out of %u signals in frame\n&quot;, countPoint, static_cast&lt;unsigned int&gt;(vmap.signals.size()));
}


void interrupt (int s)
{
  ros::shutdown();
  exit(1);
}


int main (int argc, char *argv[])
{

  ros::init(argc, argv, &quot;feat_proj&quot;, ros::init_options::NoSigintHandler);
  ros::NodeHandle rosnode;
  ros::NodeHandle private_nh(&quot;~&quot;);
  std::string cameraInfo_topic_name;
  private_nh.param&lt;std::string&gt;(&quot;camera_info_topic&quot;, cameraInfo_topic_name, &quot;/camera/camera_info&quot;);

  /* get camera ID */
  camera_id_str = cameraInfo_topic_name;
  camera_id_str.erase(camera_id_str.find(&quot;/camera/camera_info&quot;));
  if (camera_id_str == &quot;/&quot;) {
    camera_id_str = &quot;camera&quot;;
  }
  
  /* Get Flag wheter vecter_map_server function will be used  */
  private_nh.param&lt;bool&gt;(&quot;use_path_info&quot;, g_use_vector_map_server, false);

  /* load vector map */
  ros::Subscriber sub_point     = rosnode.subscribe(&quot;vector_map_info/point&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_points,
                                                    &amp;vmap);
  ros::Subscriber sub_line      = rosnode.subscribe(&quot;vector_map_info/line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lines,
                                                    &amp;vmap);
  ros::Subscriber sub_lane      = rosnode.subscribe(&quot;vector_map_info/lane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lanes,
                                                    &amp;vmap);
  ros::Subscriber sub_vector    = rosnode.subscribe(&quot;vector_map_info/vector&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_vectors,
                                                    &amp;vmap);
  ros::Subscriber sub_signal    = rosnode.subscribe(&quot;vector_map_info/signal&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_signals,
                                                    &amp;vmap);
  ros::Subscriber sub_whiteline = rosnode.subscribe(&quot;vector_map_info/white_line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_whitelines,
                                                    &amp;vmap);
  ros::Subscriber sub_dtlane    = rosnode.subscribe(&quot;vector_map_info/dtlane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_dtlanes,
                                                    &amp;vmap);

  /* wait until loading all vector map is completed */
  ros::Rate wait_rate(1);
  while(vmap.points.empty() || vmap.lines.empty() || vmap.whitelines.empty() ||
        vmap.lanes.empty() || vmap.dtlanes.empty() || vmap.vectors.empty() || vmap.signals.empty())
    {
      ros::spinOnce();
      wait_rate.sleep();
    }

  vmap.loaded = true;
  std::cout &lt;&lt; &quot;all vector map loaded.&quot; &lt;&lt; std::endl;

  ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
  ros::Subscriber adjust_xySubscriber  = rosnode.subscribe(&quot;/config/adjust_xy&quot;, 100, adjust_xyCallback);
  ros::Subscriber current_pose_subscriber;
  ros::Subscriber waypoint_subscriber;
  if (g_use_vector_map_server) {
    /* Create subscribers which deliver informations requested by server */
    current_pose_subscriber = rosnode.subscribe(&quot;/current_pose&quot;, 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
    waypoint_subscriber     = rosnode.subscribe(&quot;/final_waypoints&quot;, 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);

    /* Create ros client to use Server-Client communication */
    g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;(&quot;vector_map_server/get_signal&quot;);
  }

  ros::Publisher  signalPublisher      = rosnode.advertise &lt;road_wizard::Signals&gt; (&quot;roi_signal&quot;, 100);
  signal (SIGINT, interrupt);

  Rate loop (25);
  while (true) {

    ros::spinOnce();

    try {
      getTransform (orientation, position);
    } catch (tf::TransformException &amp;exc) {
    }

    echoSignals2 (signalPublisher, false);
    loop.sleep();
  }


}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr/TrafficLight.h" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr/TrafficLight.h">
				<diff>@@ -8,13 +8,13 @@
 #include &quot;TrafficLightDetector.h&quot;
 
 /* Extra includes */
-#include &quot;road_wizard/Signals.h&quot;
+#include &quot;autoware_msgs/Signals.h&quot;
 
 #define MAIN_WINDOW_NAME &quot;Main&quot;
 #define SETTINGS_WINDOW_NAME &quot;Settings&quot;
 
 /* Functions declarations */
-void setContexts(TrafficLightDetector &amp;detector, const road_wizard::Signals::ConstPtr&amp; extractedPos);
+void setContexts(TrafficLightDetector &amp;detector, const autoware_msgs::Signals::ConstPtr&amp; extractedPos);
 
 #define MINIMAM_RADIUS 3
 #define ROI_MARGINE 20
</diff>
				<old_file>#ifndef TRAFFIC_LIGHT_H
#define TRAFFIC_LIGHT_H

/* External includes */
#include &lt;cmath&gt;

/* Internal includes */
#include &quot;TrafficLightDetector.h&quot;

/* Extra includes */
#include &quot;road_wizard/Signals.h&quot;

#define MAIN_WINDOW_NAME &quot;Main&quot;
#define SETTINGS_WINDOW_NAME &quot;Settings&quot;

/* Functions declarations */
void setContexts(TrafficLightDetector &amp;detector, const road_wizard::Signals::ConstPtr&amp; extractedPos);

#define MINIMAM_RADIUS 3
#define ROI_MARGINE 20

static inline bool IsNearlyZero(double x)
{
  double abs_x = fabs(x);
  int scale = 100;
  return(abs_x &lt; DBL_MIN*scale);
}

struct valueSet {
    double upper;
    double lower;
};

struct hsvSet {
    valueSet Hue;
    valueSet Sat;
    valueSet Val;
};

struct thresholdSet {
    hsvSet Red;
    hsvSet Yellow;
    hsvSet Green;
};

//#define SHOW_DEBUG_INFO

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr/region_tlr.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr/region_tlr.cpp">
				<diff>@@ -7,10 +7,10 @@
 #include &lt;float.h&gt;
 #include &lt;math.h&gt;
 #include &lt;sstream&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
 #include &lt;std_msgs/String.h&gt;
-#include &quot;road_wizard/Signals.h&quot;
-#include &quot;road_wizard/TunedResult.h&quot;
+#include &lt;autoware_msgs/traffic_light.h&gt;
+#include &lt;autoware_msgs/Signals.h&gt;
+#include &lt;autoware_msgs/TunedResult.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
@@ -170,7 +170,7 @@ static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
 } /* static void image_raw_cb() */
 
 
-static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
+static void extractedPos_cb(const autoware_msgs::Signals::ConstPtr&amp; extractedPos)
 {
   if (frame.empty())
     return;
@@ -181,7 +181,7 @@ static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
   detector.brightnessDetect(frame);
 
   /* publish result */
-  runtime_manager::traffic_light state_msg;
+  autoware_msgs::traffic_light state_msg;
   std_msgs::String state_string_msg;
   const int32_t TRAFFIC_LIGHT_RED     = 0;
   const int32_t TRAFFIC_LIGHT_GREEN   = 1;
@@ -339,7 +339,7 @@ static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
 } /* static void extractedPos_cb() */
 
 
-static void tunedResult_cb(const road_wizard::TunedResult&amp; msg)
+static void tunedResult_cb(const autoware_msgs::TunedResult&amp; msg)
 {
   thSet.Red.Hue.upper = cvtInt2Double_hue(msg.Red.Hue.center, msg.Red.Hue.range);
   thSet.Red.Hue.lower = cvtInt2Double_hue(msg.Red.Hue.center, -msg.Red.Hue.range);
@@ -427,7 +427,7 @@ int main(int argc, char* argv[]) {
   ros::Subscriber tunedResult_sub = n.subscribe(&quot;/tuned_result&quot;, 1, tunedResult_cb);
   ros::Subscriber superimpose_sub = n.subscribe(&quot;/config/superimpose&quot;, 1, superimpose_cb);
 
-  signalState_pub       = n.advertise&lt;runtime_manager::traffic_light&gt;(&quot;/light_color&quot;, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+  signalState_pub       = n.advertise&lt;autoware_msgs::traffic_light&gt;(&quot;/light_color&quot;, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
   signalStateString_pub = n.advertise&lt;std_msgs::String&gt;(&quot;/sound_player&quot;, ADVERTISE_QUEUE_SIZE);
   marker_pub            = n.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;tlr_result&quot;, ADVERTISE_QUEUE_SIZE);
   superimpose_image_pub= n.advertise&lt;sensor_msgs::Image&gt;(&quot;tlr_superimpose_image&quot;, ADVERTISE_QUEUE_SIZE);
</diff>
				<old_file>#include &lt;vector&gt;
#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &quot;TrafficLight.h&quot;
#include &lt;float.h&gt;
#include &lt;math.h&gt;
#include &lt;sstream&gt;
#include &lt;runtime_manager/traffic_light.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &quot;road_wizard/Signals.h&quot;
#include &quot;road_wizard/TunedResult.h&quot;
#include &lt;visualization_msgs/Marker.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;std_msgs/Bool.h&gt;

thresholdSet thSet;

static ros::Publisher signalState_pub;
static ros::Publisher signalStateString_pub;
static ros::Publisher marker_pub;
static ros::Publisher superimpose_image_pub;
static constexpr int32_t ADVERTISE_QUEUE_SIZE = 10;
static constexpr bool    ADVERTISE_LATCH      = true;
static uint32_t          shape                = visualization_msgs::Marker::SPHERE;

// Variables
static TrafficLightDetector detector;

static cv::Mat frame;

static bool              show_superimpose_result = false;
static const std::string window_name             = &quot;superimpose result&quot;;

static double cvtInt2Double_hue(int center, int range)
{
  /* convert value range from OpenCV to Definition */
  double converted = (center + range) * 2.0f;

  if (converted &lt; 0) {
    converted = 0.0f;
  } else if (360 &lt; converted) {
    converted = converted - 360.0f;
  }

  return converted;
} /* static double cvtInt2Double_hue() */


static double cvtInt2Double_sat(int center, int range)
{
  /* convert value range from OpenCV to Definition */
  double converted = (center + range) / 255.0f;
  if (converted &lt; 0) {
    converted = 0.0f;
  } else if (1.0f &lt; converted) {
    converted = 1.0f;
  }

  return converted;
} /* static double cvtInt2Double_sat() */


static double cvtInt2Double_val(int center, int range)
{
  /* convert value range from OpenCV to Definition */
  double converted = (center + range) / 255.0f;
  if (converted &lt; 0) {
    converted = 0;
  } else if (1.0f &lt; converted) {
    converted = 1.0f;
  }

  return converted;
} /* static double cvtInt2Double_val() */


static void putResult_inText(cv::Mat *image, const std::vector&lt;Context&gt; &amp;contexts)
{
  std::string label;
  const int fontFace = cv::FONT_HERSHEY_COMPLEX_SMALL;
  const float fontScale = 1.0f;
  const int fontThickness = 1;
  int baseline = 0;
  CvPoint textOrg;
  CvScalar textColor;

  for (unsigned int i=0; i&lt;contexts.size(); i++)
    {
      Context ctx = contexts.at(i);
//      if (ctx.lampRadius &lt; MINIMAM_RADIUS)
//        continue;

      switch(ctx.lightState) {
      case GREEN:
        label = &quot;GREEN&quot;;
        textColor = CV_RGB(0, 255, 0);
        break;
      case YELLOW:
        label = &quot;YELLOW&quot;;
        textColor = CV_RGB(255, 255, 0);
        break;
      case RED:
        label = &quot;RED&quot;;
        textColor = CV_RGB(255, 0, 0);
        break;
      case UNDEFINED:
        label = &quot;UNDEFINED&quot;;
        textColor = CV_RGB(0, 0, 0);
      }

      cv::getTextSize(label,
		      fontFace,
		      fontScale,
		      fontThickness,
		      &amp;baseline);

      textOrg = cv::Point(ctx.topLeft.x, ctx.botRight.y + baseline);

      putText(*image,
              label,
              textOrg,
              fontFace,
              fontScale,
              textColor,
              fontThickness,
              CV_AA);
    }
} /* static void putResult_inText() */


static void image_raw_cb(const sensor_msgs::Image&amp; image_source)
{
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
  //  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source);
  frame = cv_image-&gt;image.clone();

  /* Draw superimpose result on image */
  cv::Mat targetScope = frame.clone();
  for (unsigned int i=0; i&lt;detector.contexts.size(); i++)
    {
      /* draw superimposed position of traffic lights */
      circle(targetScope, detector.contexts.at(i).redCenter, detector.contexts.at(i).lampRadius, CV_RGB(255, 0, 0), 1, 0);
      circle(targetScope, detector.contexts.at(i).yellowCenter, detector.contexts.at(i).lampRadius, CV_RGB(255, 255, 0), 1, 0);
      circle(targetScope, detector.contexts.at(i).greenCenter, detector.contexts.at(i).lampRadius, CV_RGB(0, 255, 0), 1, 0);
    }

  /* draw detection results */
  putResult_inText(&amp;targetScope, detector.contexts);


  /* Publish superimpose result image */
  cv_bridge::CvImage msg_converter;
  msg_converter.header = image_source.header;
  msg_converter.encoding = sensor_msgs::image_encodings::BGR8;
  msg_converter.image = targetScope;
  superimpose_image_pub.publish(msg_converter.toImageMsg());

  /* Display superimpose result image in separate window*/
  if (show_superimpose_result)
    {
      if (cvGetWindowHandle(window_name.c_str()) != NULL) // Guard not to write destroyed window by using close button on the window
        {
          imshow(window_name, targetScope);
          cv::waitKey(5);
        }
    }

} /* static void image_raw_cb() */


static void extractedPos_cb(const road_wizard::Signals::ConstPtr&amp; extractedPos)
{
  if (frame.empty())
    return;

  /* Set subscribed signal position into detector */
  Context::SetContexts(detector.contexts, extractedPos, frame.rows, frame.cols);

  detector.brightnessDetect(frame);

  /* publish result */
  runtime_manager::traffic_light state_msg;
  std_msgs::String state_string_msg;
  const int32_t TRAFFIC_LIGHT_RED     = 0;
  const int32_t TRAFFIC_LIGHT_GREEN   = 1;
  const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;
  static int32_t prev_state = TRAFFIC_LIGHT_UNKNOWN;
  state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
  for (unsigned int i=0; i&lt;detector.contexts.size(); i++) {
	  switch (detector.contexts.at(i).lightState) {
	  case GREEN:
		  state_msg.traffic_light = TRAFFIC_LIGHT_GREEN;
          state_string_msg.data = &quot;green signal&quot;;
		  break;
	  case YELLOW:
	  case RED:
		  state_msg.traffic_light = TRAFFIC_LIGHT_RED;
          state_string_msg.data = &quot;red signal&quot;;
		  break;
	  case UNDEFINED:
		  state_msg.traffic_light = TRAFFIC_LIGHT_UNKNOWN;
          state_string_msg.data = &quot;&quot;;
		  break;
	  }
	  if (state_msg.traffic_light != TRAFFIC_LIGHT_UNKNOWN)
		  break;  // publish the first state in detector.contexts
  }

  if (state_msg.traffic_light != prev_state) {
    signalState_pub.publish(state_msg);
    signalStateString_pub.publish(state_string_msg);
  } else {
    state_string_msg.data = &quot;&quot;;
    signalStateString_pub.publish(state_string_msg);
  }

  std_msgs::ColorRGBA color_black;
  color_black.r = 0.0f;
  color_black.g = 0.0f;
  color_black.b = 0.0f;
  color_black.a = 1.0f;

  std_msgs::ColorRGBA color_red;
  color_red.r = 1.0f;
  color_red.g = 0.0f;
  color_red.b = 0.0f;
  color_red.a = 1.0f;

  std_msgs::ColorRGBA color_yellow;
  color_yellow.r = 1.0f;
  color_yellow.g = 1.0f;
  color_yellow.b = 0.0f;
  color_yellow.a = 1.0f;

  std_msgs::ColorRGBA color_green;
  color_green.r = 0.0f;
  color_green.g = 1.0f;
  color_green.b = 0.0f;
  color_green.a = 1.0f;

  /* publish all detected result as ROS Marker */
  for (unsigned int i=0; i&lt;detector.contexts.size(); i++)
    {
      Context ctx = detector.contexts.at(i);
      visualization_msgs::MarkerArray signalSet;
      visualization_msgs::Marker mk_red, mk_yellow, mk_green;

      /* Set the frame ID */
      mk_red.header.frame_id    = &quot;map&quot;;
      mk_yellow.header.frame_id = &quot;map&quot;;
      mk_green.header.frame_id  = &quot;map&quot;;

      /* Set the namespace and id for this marker */
      mk_red.ns    = &quot;tlr_result_red&quot;;
      mk_yellow.ns = &quot;tlr_result_yellow&quot;;
      mk_green.ns  = &quot;tlr_result_green&quot;;
      mk_red.id    = ctx.signalID;
      mk_yellow.id = ctx.signalID;
      mk_green.id  = ctx.signalID;

      /* Set the marker type */
      mk_red.type    = shape;
      mk_yellow.type = shape;
      mk_green.type  = shape;

      /* Set the pose of the marker */
      mk_red.pose.position.x    = ctx.redCenter3d.x;
      mk_red.pose.position.y    = ctx.redCenter3d.y;
      mk_red.pose.position.z    = ctx.redCenter3d.z;
      mk_yellow.pose.position.x = ctx.yellowCenter3d.x;
      mk_yellow.pose.position.y = ctx.yellowCenter3d.y;
      mk_yellow.pose.position.z = ctx.yellowCenter3d.z;
      mk_green.pose.position.x  = ctx.greenCenter3d.x;
      mk_green.pose.position.y  = ctx.greenCenter3d.y;
      mk_green.pose.position.z  = ctx.greenCenter3d.z;

      mk_red.pose.orientation.x    = 0.0;
      mk_red.pose.orientation.y    = 0.0;
      mk_red.pose.orientation.y    = 0.0;
      mk_red.pose.orientation.w    = 0.0;
      mk_yellow.pose.orientation.x = 0.0;
      mk_yellow.pose.orientation.y = 0.0;
      mk_yellow.pose.orientation.y = 0.0;
      mk_yellow.pose.orientation.w = 0.0;
      mk_green.pose.orientation.x  = 0.0;
      mk_green.pose.orientation.y  = 0.0;
      mk_green.pose.orientation.y  = 0.0;
      mk_green.pose.orientation.w  = 0.0;

      /* Set the scale of the marker -- We assume lamp radius as 30cm */
      mk_red.scale.x    = (double)0.3;
      mk_red.scale.y    = (double)0.3;
      mk_red.scale.z    = (double)0.3;
      mk_yellow.scale.x = (double)0.3;
      mk_yellow.scale.y = (double)0.3;
      mk_yellow.scale.z = (double)0.3;
      mk_green.scale.x  = (double)0.3;
      mk_green.scale.y  = (double)0.3;
      mk_green.scale.z  = (double)0.3;

      /* Set the color */
      switch (ctx.lightState) {
      case GREEN:
        mk_red.color    = color_black;
        mk_yellow.color = color_black;
        mk_green.color  = color_green;
        break;
      case YELLOW:
        mk_red.color    = color_black;
        mk_yellow.color = color_yellow;
        mk_green.color  = color_black;
        break;
      case RED:
        mk_red.color    = color_red;
        mk_yellow.color = color_black;
        mk_green.color  = color_black;
        break;
      case UNDEFINED:
        mk_red.color    = color_black;
        mk_yellow.color = color_black;
        mk_green.color  = color_black;
        break;
      }

      mk_red.lifetime    = ros::Duration(0.1);
      mk_yellow.lifetime = ros::Duration(0.1);
      mk_green.lifetime  = ros::Duration(0.1);

      signalSet.markers.push_back(mk_red);
      signalSet.markers.push_back(mk_yellow);
      signalSet.markers.push_back(mk_green);

      marker_pub.publish(signalSet);
    }

  prev_state = state_msg.traffic_light;
} /* static void extractedPos_cb() */


static void tunedResult_cb(const road_wizard::TunedResult&amp; msg)
{
  thSet.Red.Hue.upper = cvtInt2Double_hue(msg.Red.Hue.center, msg.Red.Hue.range);
  thSet.Red.Hue.lower = cvtInt2Double_hue(msg.Red.Hue.center, -msg.Red.Hue.range);
  thSet.Red.Sat.upper = cvtInt2Double_sat(msg.Red.Sat.center, msg.Red.Sat.range);
  thSet.Red.Sat.lower = cvtInt2Double_sat(msg.Red.Sat.center, -msg.Red.Sat.range);
  thSet.Red.Val.upper = cvtInt2Double_val(msg.Red.Val.center, msg.Red.Val.range);
  thSet.Red.Val.lower = cvtInt2Double_val(msg.Red.Val.center, -msg.Red.Val.range);

  thSet.Yellow.Hue.upper = cvtInt2Double_hue(msg.Yellow.Hue.center, msg.Yellow.Hue.range);
  thSet.Yellow.Hue.lower = cvtInt2Double_hue(msg.Yellow.Hue.center, -msg.Yellow.Hue.range);
  thSet.Yellow.Sat.upper = cvtInt2Double_sat(msg.Yellow.Sat.center, msg.Yellow.Sat.range);
  thSet.Yellow.Sat.lower = cvtInt2Double_sat(msg.Yellow.Sat.center, -msg.Yellow.Sat.range);
  thSet.Yellow.Val.upper = cvtInt2Double_val(msg.Yellow.Val.center, msg.Yellow.Val.range);
  thSet.Yellow.Val.lower = cvtInt2Double_val(msg.Yellow.Val.center, -msg.Yellow.Val.range);

  thSet.Green.Hue.upper = cvtInt2Double_hue(msg.Green.Hue.center, msg.Green.Hue.range);
  thSet.Green.Hue.lower = cvtInt2Double_hue(msg.Green.Hue.center, -msg.Green.Hue.range);
  thSet.Green.Sat.upper = cvtInt2Double_sat(msg.Green.Sat.center, msg.Green.Sat.range);
  thSet.Green.Sat.lower = cvtInt2Double_sat(msg.Green.Sat.center, -msg.Green.Sat.range);
  thSet.Green.Val.upper = cvtInt2Double_val(msg.Green.Val.center, msg.Green.Val.range);
  thSet.Green.Val.lower = cvtInt2Double_val(msg.Green.Val.center, -msg.Green.Val.range);

} /* static void tunedResult_cb() */


static void superimpose_cb(const std_msgs::Bool::ConstPtr&amp; config_msg)
{
  show_superimpose_result = config_msg-&gt;data;

  if (show_superimpose_result) {
    cv::namedWindow(window_name, cv::WINDOW_NORMAL);
    cv::startWindowThread();
  }

  if (!show_superimpose_result) {
	  if (cvGetWindowHandle(window_name.c_str()) != NULL)
	  {
		  cv::destroyWindow(window_name);
		  cv::waitKey(1);
	  }
  }

} /* static void superimpose_cb() */

int main(int argc, char* argv[]) {

  //	printf(&quot;***** Traffic lights app *****\n&quot;);
#ifdef SHOW_DEBUG_INFO
  cv::namedWindow(&quot;tmpImage&quot;, cv::WINDOW_NORMAL);
  cv::namedWindow(&quot;bright_mask&quot;, cv::WINDOW_NORMAL);
  cv::startWindowThread();
#endif

  thSet.Red.Hue.upper = (double)DAYTIME_RED_UPPER;
  thSet.Red.Hue.lower = (double)DAYTIME_RED_LOWER;
  thSet.Red.Sat.upper = 1.0f;
  thSet.Red.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
  thSet.Red.Val.upper = 1.0f;
  thSet.Red.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;

  thSet.Yellow.Hue.upper = (double)DAYTIME_YELLOW_UPPER;
  thSet.Yellow.Hue.lower = (double)DAYTIME_YELLOW_LOWER;
  thSet.Yellow.Sat.upper = 1.0f;
  thSet.Yellow.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
  thSet.Yellow.Val.upper = 1.0f;
  thSet.Yellow.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;

  thSet.Green.Hue.upper = (double)DAYTIME_GREEN_UPPER;
  thSet.Green.Hue.lower = (double)DAYTIME_GREEN_LOWER;
  thSet.Green.Sat.upper = 1.0f;
  thSet.Green.Sat.lower = DAYTIME_S_SIGNAL_THRESHOLD;
  thSet.Green.Val.upper = 1.0f;
  thSet.Green.Val.lower = DAYTIME_V_SIGNAL_THRESHOLD;


  ros::init(argc, argv, &quot;region_tlr&quot;);

  ros::NodeHandle n;
  ros::NodeHandle private_nh(&quot;~&quot;);
  std::string image_topic_name;
  private_nh.param&lt;std::string&gt;(&quot;image_raw_topic&quot;, image_topic_name, &quot;/image_raw&quot;);

  ros::Subscriber image_sub       = n.subscribe(image_topic_name, 1, image_raw_cb);
  ros::Subscriber position_sub    = n.subscribe(&quot;/roi_signal&quot;, 1, extractedPos_cb);
  ros::Subscriber tunedResult_sub = n.subscribe(&quot;/tuned_result&quot;, 1, tunedResult_cb);
  ros::Subscriber superimpose_sub = n.subscribe(&quot;/config/superimpose&quot;, 1, superimpose_cb);

  signalState_pub       = n.advertise&lt;runtime_manager::traffic_light&gt;(&quot;/light_color&quot;, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
  signalStateString_pub = n.advertise&lt;std_msgs::String&gt;(&quot;/sound_player&quot;, ADVERTISE_QUEUE_SIZE);
  marker_pub            = n.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;tlr_result&quot;, ADVERTISE_QUEUE_SIZE);
  superimpose_image_pub= n.advertise&lt;sensor_msgs::Image&gt;(&quot;tlr_superimpose_image&quot;, ADVERTISE_QUEUE_SIZE);

  ros::spin();

  return 0;
} /* int main() */


</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr_ssd/region_tlr_ssd.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr_ssd/region_tlr_ssd.cpp">
				<diff>@@ -2,7 +2,7 @@
 
 #include &lt;string&gt;
 
-#include &lt;runtime_manager/traffic_light.h&gt;
+#include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;std_msgs/String.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
@@ -70,7 +70,7 @@ void RegionTlrSsdRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
 // ==========================================
 // Callback function to acquire extracted_pos
 // ==========================================
-void RegionTlrSsdRosNode::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
+void RegionTlrSsdRosNode::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   static ros::Time previous_timestamp;
   // If frame has not been prepared, abort this callback
   if (frame_.empty() ||
@@ -154,7 +154,7 @@ void RegionTlrSsdRosNode::StartSubscribersAndPublishers() {
                                                 this);
 
   // Register publishers
-  signal_state_publisher        = node_handle.advertise&lt;runtime_manager::traffic_light&gt;(&quot;light_color&quot;, 1);
+  signal_state_publisher        = node_handle.advertise&lt;autoware_msgs::traffic_light&gt;(&quot;light_color&quot;, 1);
   signal_state_string_publisher = node_handle.advertise&lt;std_msgs::String&gt;(&quot;/sound_player&quot;, 1);
   marker_publisher              = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;tlr_result&quot;, 1, kAdvertiseInLatch_);
   superimpose_image_publisher   = node_handle.advertise&lt;sensor_msgs::Image&gt;(&quot;tlr_superimpose_image&quot;, 1);
@@ -186,10 +186,10 @@ LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
 
 
 // =================================================================
-// Publish recognition result as runtime_manager::traffic_light type
+// Publish recognition result as autoware_msgs::traffic_light type
 // =================================================================
 void RegionTlrSsdRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
-  runtime_manager::traffic_light topic;
+  autoware_msgs::traffic_light topic;
   static int32_t previous_state = kTrafficLightUnknown;
   topic.traffic_light = kTrafficLightUnknown;
   for (const auto ctx: contexts) {
</diff>
				<old_file>#include &quot;region_tlr_ssd.h&quot;

#include &lt;string&gt;

#include &lt;runtime_manager/traffic_light.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;

#include &quot;Context.h&quot;

// ========================================
// Constructor of RegionTlrSsdRosNode class
// ========================================
RegionTlrSsdRosNode::RegionTlrSsdRosNode():
  image_topic_name_(&quot;/image_raw&quot;),
  network_definition_file_name_(&quot;&quot;),
  pretrained_model_file_name_(&quot;&quot;),
  use_gpu_(false),
  gpu_id_(0),
  kAdvertiseInLatch_(true),
  kTrafficLightRed(0),
  kTrafficLightGreen(1),
  kTrafficLightUnknown(2),
  kStringRed(&quot;red signal&quot;),
  kStringGreen(&quot;green signal&quot;),
  kStringUnknown(&quot;&quot;) {

} // RegionTlrSsdRosNode::RegionTlrSsdRosNode()


// ========================================
// Destructor of RegionTlrSsdRosNode class
// ========================================
RegionTlrSsdRosNode::~RegionTlrSsdRosNode() {
} // RegionTlrSsdRosNode::~RegionTlrSsdRosNode()


// =========================
// Start recognition process
// =========================
void RegionTlrSsdRosNode::RunRecognition() {
  // Get execution parameters from ROS parameter server
  GetRosParam();

  // Initialize recognizer
  recognizer.Init(network_definition_file_name_,
                  pretrained_model_file_name_,
                  use_gpu_,
                  gpu_id_);

  // Start subscribing and publishing
  StartSubscribersAndPublishers();
  ros::spin();
} // RegionTlrSsdRosNode::RunRecognition()


// ==================================
// Callback function to acquire image
// ==================================
void RegionTlrSsdRosNode::ImageRawCallback(const sensor_msgs::Image &amp;image) {
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
  frame_ = cv_image-&gt;image.clone();

  // Save header information of this topic
  frame_header_ = image.header;

}

// ==========================================
// Callback function to acquire extracted_pos
// ==========================================
void RegionTlrSsdRosNode::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
  static ros::Time previous_timestamp;
  // If frame has not been prepared, abort this callback
  if (frame_.empty() ||
      frame_header_.stamp == previous_timestamp) {
    return;
  }

  // Acquire signal posotion on the image
  Context::SetContexts(contexts_, extracted_pos, frame_.rows, frame_.cols);

  // Recognize the color of the traffic light
  for (Context&amp; context: contexts_) {
  // for (unsigned int i = 0; i &lt; contexts_.size(); i++) {
  //   Context&amp; context = contexts_.at(i);
    if (context.topLeft.x &gt; context.botRight.x) {
      continue;
    }

    // extract region of interest from input image
    cv::Mat roi  = frame_(cv::Rect(context.topLeft, context.botRight)).clone();

    // Get current state of traffic light from current frame
    LightState current_state = recognizer.RecognizeLightState(roi);

    // Determine the final state by referring previous state
    context.lightState = DetermineState(context.lightState, // previous state
                                        current_state,      // current state
                                        &amp;(context.stateJudgeCount)); // counter to record how many times does state recognized
  }

  // Publish recognition result as some topic format
  PublishTrafficLight(contexts_);
  PublishString(contexts_);
  PublishMarkerArray(contexts_);
  PublishImage(contexts_);

  // Save timestamp of this frame so that same frame has never been process again
  previous_timestamp = frame_header_.stamp;
}

// =======================================
// Get parameter from ROS parameter server
// =======================================
void RegionTlrSsdRosNode::GetRosParam() {
  ros::NodeHandle private_node_handle(&quot;~&quot;);

  private_node_handle.param&lt;std::string&gt;(&quot;image_raw_topic&quot;, image_topic_name_, &quot;/image_raw&quot;);
  private_node_handle.param&lt;std::string&gt;(&quot;network_definition_file&quot;, network_definition_file_name_, &quot;&quot;);
  private_node_handle.param&lt;std::string&gt;(&quot;pretrained_model_file&quot;, pretrained_model_file_name_, &quot;&quot;);
  private_node_handle.param&lt;bool&gt;(&quot;use_gpu&quot;, use_gpu_, false);
  private_node_handle.param&lt;int&gt;(&quot;gpu_id&quot;, gpu_id_, 0);

  // If network-definition-file or pretrained-model-file are not specified,
  // terminate program with error status
  if (network_definition_file_name_.empty()){
    ROS_FATAL(&quot;No Network Definition File was specified. Terminate program... &quot;);
    exit(EXIT_FAILURE);
  }

  if (pretrained_model_file_name_.empty()){
    ROS_FATAL(&quot;No Pretrained Model File was specified. Terminate program... &quot;);
    exit(EXIT_FAILURE);
  }
} // RegionTlrSsdRosNode::ProcessRosParam()


// ============================================================
// Register subscriber and publisher of this node in ROS Master
// ============================================================
void RegionTlrSsdRosNode::StartSubscribersAndPublishers() {
  ros::NodeHandle node_handle;
  
  // Register subscribers
  image_subscriber      = node_handle.subscribe(image_topic_name_,
                                                1,
                                                &amp;RegionTlrSsdRosNode::ImageRawCallback,
                                                this);
  roi_signal_subscriber = node_handle.subscribe(&quot;/roi_signal&quot;,
                                                1,
                                                &amp;RegionTlrSsdRosNode::RoiSignalCallback,
                                                this);

  // Register publishers
  signal_state_publisher        = node_handle.advertise&lt;runtime_manager::traffic_light&gt;(&quot;light_color&quot;, 1);
  signal_state_string_publisher = node_handle.advertise&lt;std_msgs::String&gt;(&quot;/sound_player&quot;, 1);
  marker_publisher              = node_handle.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;tlr_result&quot;, 1, kAdvertiseInLatch_);
  superimpose_image_publisher   = node_handle.advertise&lt;sensor_msgs::Image&gt;(&quot;tlr_superimpose_image&quot;, 1);

} // RegionTlrSsdRosNode::StartSubscribersAndPublishers()


// ===============================================================================
// Determine the final recognition result by comparing previous recognition result
// ===============================================================================
LightState RegionTlrSsdRosNode::DetermineState(LightState previous_state,
                                               LightState current_state,
                                               int* state_judge_count) {
  // Get a candidate which considering state transition of traffic light
  LightState transition_candidate = kStateTransitionMatrix[previous_state][current_state];

  // If state change happens more than threshold times, accept that change
  if (*state_judge_count &gt; kChangeStateThreshold) {
    *state_judge_count = 0;
    return transition_candidate;
  } else {
    if (transition_candidate != previous_state) {
      (*state_judge_count)++;
    }
    return previous_state;
  }

} // LightState RegionTlrSsdRosNode::DetermineState()


// =================================================================
// Publish recognition result as runtime_manager::traffic_light type
// =================================================================
void RegionTlrSsdRosNode::PublishTrafficLight(std::vector&lt;Context&gt; contexts) {
  runtime_manager::traffic_light topic;
  static int32_t previous_state = kTrafficLightUnknown;
  topic.traffic_light = kTrafficLightUnknown;
  for (const auto ctx: contexts) {
    switch(ctx.lightState) {
    case GREEN:
      topic.traffic_light = kTrafficLightGreen;
      break;
    case YELLOW:
    case RED:
      topic.traffic_light = kTrafficLightRed;
      break;
    case UNDEFINED:
      topic.traffic_light = kTrafficLightUnknown;
      break;
    }

    // Publish the first state in contexts,
    // which has largest estimated radius of signal.
    // This program assume that the signal which has the largest estimated radius
    // equal the nearest one from camera.
    if (topic.traffic_light != kTrafficLightUnknown) {
      break;
    }
  }

  // If state changes from previous one, publish it
  if (topic.traffic_light != previous_state) {
    signal_state_publisher.publish(topic);
    previous_state = topic.traffic_light;
  }
} // void RegionTlrSsdRosNode::PublishTrafficLight()


// =================================================================
// Publish recognition result as std_msgs::String
// =================================================================
void RegionTlrSsdRosNode::PublishString(std::vector&lt;Context&gt; contexts) {
  std_msgs::String topic;
  static std::string previous_state = kStringUnknown;
  topic.data = kStringUnknown;
  for (const auto ctx: contexts) {
    switch(ctx.lightState) {
    case GREEN:
      topic.data = kStringGreen;
      break;
    case YELLOW:
    case RED:
      topic.data = kStringRed;
      break;
    case UNDEFINED:
      topic.data = kStringUnknown;
      break;
    }

    // Publish the first state in contexts,
    // which has largest estimated radius of signal.
    // This program assume that the signal which has the largest estimated radius
    // equal the nearest one from camera.
    if (topic.data != kStringUnknown) {
      break;
    }
  }

  // If state changes from previous one, publish it
  if (topic.data != previous_state) {
    signal_state_string_publisher.publish(topic);
    previous_state = topic.data;
  }
} // void RegionTlrSsdRosNode::PublishString()


// =================================================================
// Publish recognition result as visualization_msgs::MarkerArray
// =================================================================
void RegionTlrSsdRosNode::PublishMarkerArray(std::vector&lt;Context&gt; contexts) {
  // Define color constants
  std_msgs::ColorRGBA color_black;
  color_black.r = 0.0f;
  color_black.g = 0.0f;
  color_black.b = 0.0f;
  color_black.a = 1.0f;

  std_msgs::ColorRGBA color_red;
  color_red.r = 1.0f;
  color_red.g = 0.0f;
  color_red.b = 0.0f;
  color_red.a = 1.0f;

  std_msgs::ColorRGBA color_yellow;
  color_yellow.r = 1.0f;
  color_yellow.g = 1.0f;
  color_yellow.b = 0.0f;
  color_yellow.a = 1.0f;

  std_msgs::ColorRGBA color_green;
  color_green.r = 0.0f;
  color_green.g = 1.0f;
  color_green.b = 0.0f;
  color_green.a = 1.0f;

  // publish all result as ROS MarkerArray
  for (const auto ctx: contexts) {
    visualization_msgs::MarkerArray signal_set;
    visualization_msgs::Marker red_light, yellow_light, green_light;

    // Set the frame ID
    red_light.header.frame_id    = &quot;map&quot;;
    yellow_light.header.frame_id = &quot;map&quot;;
    green_light.header.frame_id  = &quot;map&quot;;

    // Set the namespace and ID for this markers
    red_light.ns    = &quot;tlr_result_red&quot;;
    red_light.id    = ctx.signalID;

    yellow_light.ns = &quot;tlr_result_yellow&quot;;
    yellow_light.id = ctx.signalID;

    green_light.ns  = &quot;tlr_result_green&quot;;
    green_light.id  = ctx.signalID;

    // Set the markers type
    red_light.type    = visualization_msgs::Marker::SPHERE;
    yellow_light.type = visualization_msgs::Marker::SPHERE;
    green_light.type  = visualization_msgs::Marker::SPHERE;

    // Set the pose of the markers
    red_light.pose.position.x = ctx.redCenter3d.x;
    red_light.pose.position.y = ctx.redCenter3d.y;
    red_light.pose.position.z = ctx.redCenter3d.z;
    red_light.pose.orientation.x = 0.0;
    red_light.pose.orientation.y = 0.0;
    red_light.pose.orientation.z = 0.0;
    red_light.pose.orientation.w = 0.0;

    yellow_light.pose.position.x = ctx.yellowCenter3d.x;
    yellow_light.pose.position.y = ctx.yellowCenter3d.y;
    yellow_light.pose.position.z = ctx.yellowCenter3d.z;
    yellow_light.pose.orientation.x = 0.0;
    yellow_light.pose.orientation.y = 0.0;
    yellow_light.pose.orientation.z = 0.0;
    yellow_light.pose.orientation.w = 0.0;

    green_light.pose.position.x = ctx.greenCenter3d.x;
    green_light.pose.position.y = ctx.greenCenter3d.y;
    green_light.pose.position.z = ctx.greenCenter3d.z;
    green_light.pose.orientation.x = 0.0;
    green_light.pose.orientation.y = 0.0;
    green_light.pose.orientation.z = 0.0;
    green_light.pose.orientation.w = 0.0;

    // Set the scale of the markers. We assume lamp radius is 30cm in real world
    red_light.scale.x = 0.3;
    red_light.scale.y = 0.3;
    red_light.scale.z = 0.3;

    yellow_light.scale.x = 0.3;
    yellow_light.scale.y = 0.3;
    yellow_light.scale.z = 0.3;

    green_light.scale.x = 0.3;
    green_light.scale.y = 0.3;
    green_light.scale.z = 0.3;

    // Set the color for each marker
    switch(ctx.lightState) {
    case GREEN:
      red_light.color = color_black;
      yellow_light.color = color_black;
      green_light.color = color_green;
      break;
    case YELLOW:
      red_light.color = color_black;
      yellow_light.color = color_yellow;
      green_light.color = color_black;
      break;
    case RED:
      red_light.color = color_red;
      yellow_light.color = color_black;
      green_light.color = color_black;
      break;
    case UNDEFINED:
      red_light.color = color_black;
      yellow_light.color = color_black;
      green_light.color = color_black;
      break;
    }

    red_light.lifetime = ros::Duration(0.1);
    yellow_light.lifetime = ros::Duration(0.1);
    green_light.lifetime = ros::Duration(0.1);

    // Pack each light marker into one
    signal_set.markers.push_back(red_light);
    signal_set.markers.push_back(yellow_light);
    signal_set.markers.push_back(green_light);

    // Publish
    marker_publisher.publish(signal_set);
  }

} // void RegionTlrSsdRosNode::PublishMarkerArray()


// ================================================================
// Publish superimpose and recognition result as sensor_msgs::Image
// ================================================================
void RegionTlrSsdRosNode::PublishImage(std::vector&lt;Context&gt; contexts) {
  // Copy the frame image for output
  cv::Mat result_image = frame_.clone();

  // Define information for written label
  std::string  label;
  const int    kFontFace      = cv::FONT_HERSHEY_COMPLEX_SMALL;
  const double kFontScale     = 1.0;
  int          font_baseline  = 0;
  CvScalar     label_color;

  for (const auto ctx: contexts_) {
    // Draw superimpose result on image
    circle(result_image, ctx.redCenter, ctx.lampRadius, CV_RGB(255, 0, 0), 1, 0);
    circle(result_image, ctx.yellowCenter, ctx.lampRadius, CV_RGB(255, 255, 0), 1, 0);
    circle(result_image, ctx.greenCenter, ctx.lampRadius, CV_RGB(0, 255, 0), 1, 0);

    // Draw recognition result on image
    switch(ctx.lightState) {
    case GREEN:
      label = &quot;GREEN&quot;;
      label_color = CV_RGB(0, 255, 0);
      break;
    case YELLOW:
      label = &quot;YELLOW&quot;;
      label_color = CV_RGB(255, 255, 0);
      break;
    case RED:
      label = &quot;RED&quot;;
      label_color = CV_RGB(255, 0, 0);
      break;
    case UNDEFINED:
      label = &quot;UNKNOWN&quot;;
      label_color = CV_RGB(0, 0, 0);
    }

    cv::Point label_origin = cv::Point(ctx.topLeft.x, ctx.botRight.y + font_baseline);

    cv::putText(result_image, label, label_origin, kFontFace, kFontScale, label_color);
  }

  // Publish superimpose result image
  cv_bridge::CvImage converter;
  converter.header = frame_header_;
  converter.encoding = sensor_msgs::image_encodings::BGR8;
  converter.image = result_image;
  superimpose_image_publisher.publish(converter.toImageMsg());

} // void RegionTlrSsdRosNode::PublishImage()

// ========================
// Entry point of this node
// ========================
int main (int argc, char *argv[]) {
  // Initialize ros node
  ros::init(argc, argv, &quot;region_tlr_ssd&quot;);

  // Create RegionTlrRosNode class object and do initialization
  RegionTlrSsdRosNode region_tlr_ssd_ros_node;

  // Start recognition process
  region_tlr_ssd_ros_node.RunRecognition();

  return 0;
} // main()
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr_ssd/region_tlr_ssd.h" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/region_tlr_ssd/region_tlr_ssd.h">
				<diff>@@ -10,7 +10,7 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 
 #include &quot;Context.h&quot;
-#include &quot;road_wizard/Signals.h&quot;
+#include &quot;autoware_msgs/Signals.h&quot;
 #include &quot;traffic_light_recognizer.h&quot;
 
 class RegionTlrSsdRosNode {
@@ -20,7 +20,7 @@ class RegionTlrSsdRosNode {
 
   void RunRecognition();
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
-  void RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos);
+  void RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
 
   // The vector of data structure to save traffic light state, position, ...etc
   std::vector&lt;Context&gt; contexts_;
</diff>
				<old_file>#ifndef REGION_TLR_SSD_H
#define REGION_TLR_SSD_H

#include &lt;string&gt;

#include &lt;opencv2/opencv.hpp&gt;
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;

#include &quot;Context.h&quot;
#include &quot;road_wizard/Signals.h&quot;
#include &quot;traffic_light_recognizer.h&quot;

class RegionTlrSsdRosNode {
 public:
  RegionTlrSsdRosNode();
  ~RegionTlrSsdRosNode();

  void RunRecognition();
  void ImageRawCallback(const sensor_msgs::Image &amp;image);
  void RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos);

  // The vector of data structure to save traffic light state, position, ...etc
  std::vector&lt;Context&gt; contexts_;

 private:
  /* Light state transition probably happen in Japanese traffic light */
  const LightState kStateTransitionMatrix[4][4] = {
    /* current: */
    /* GREEN   , YELLOW    , RED    , UNDEFINED  */
    /* -------------------------------------------  */
    {GREEN     , YELLOW    , YELLOW    , GREEN}  ,  /* | previous = GREEN */
    {UNDEFINED , YELLOW    , RED       , YELLOW} ,  /* | previous = YELLOW */
    {GREEN     , RED       , RED       , RED}    ,  /* | previous = RED */
    {GREEN     , YELLOW    , RED       , UNDEFINED} /* | previous = UNDEFINED */
  };


  void GetRosParam();
  void StartSubscribersAndPublishers();
  LightState DetermineState(LightState previous_state, LightState current_state, int* state_judge_count);
  void PublishTrafficLight(std::vector&lt;Context&gt; contexts);
  void PublishString(std::vector&lt;Context&gt; contexts);
  void PublishMarkerArray(std::vector&lt;Context&gt; contexts);
  void PublishImage(std::vector&lt;Context&gt; contexts);

  // Execution parameter
  std::string image_topic_name_;
  std::string network_definition_file_name_;
  std::string pretrained_model_file_name_;
  bool use_gpu_;
  int gpu_id_;

  // Subscribers
  ros::Subscriber image_subscriber;
  ros::Subscriber roi_signal_subscriber;

  // Publishers
  ros::Publisher signal_state_publisher;
  ros::Publisher signal_state_string_publisher;
  ros::Publisher marker_publisher;
  ros::Publisher superimpose_image_publisher;

  // Flag to show topic will be published in latch manner
  bool kAdvertiseInLatch_;

  // A frame image acquired from topic
  cv::Mat frame_;

  // Timestamp of a frame in process
  std_msgs::Header frame_header_;

  // The instance of the core class of traffic light recognition by SSD
  TrafficLightRecognizer recognizer;

  // The threshold of state detected times to accept the state change
  const int kChangeStateThreshold = 10;

  // constant values to pass recognition states to other nodes
  const int32_t kTrafficLightRed;
  const int32_t kTrafficLightGreen;
  const int32_t kTrafficLightUnknown;
  const std::string kStringRed;
  const std::string kStringGreen;
  const std::string kStringUnknown;
};

#endif  // REGION_TLR_SSD_H
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/roi_extractor/roi_extractor.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/roi_extractor/roi_extractor.cpp">
				<diff>@@ -14,7 +14,7 @@
 
 
 #include &quot;Context.h&quot;
-#include &quot;road_wizard/Signals.h&quot;
+#include &lt;autoware_msgs/Signals.h&gt;
 
 
 void RoiExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
@@ -27,7 +27,7 @@ void RoiExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
 } // void RoiExtractor::ImageRawCallback()
 
 
-void RoiExtractor::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
+void RoiExtractor::RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos) {
   // If frame image has not been updated, do nothing
   if (frame_timestamp_ == previous_timestamp_) {
     return;
</diff>
				<old_file>#include &quot;roi_extractor.h&quot;

#include &lt;sys/stat.h&gt;
#include &lt;dirent.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;opencv2/opencv.hpp&gt;


#include &quot;Context.h&quot;
#include &quot;road_wizard/Signals.h&quot;


void RoiExtractor::ImageRawCallback(const sensor_msgs::Image &amp;image) {
  // Acquire frame image from ros topic
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image, sensor_msgs::image_encodings::BGR8);
  frame_ = cv_image-&gt;image.clone();

  // Save this topic's time stamp so that same image will not be processed more than twice
  frame_timestamp_ = image.header.stamp;
} // void RoiExtractor::ImageRawCallback()


void RoiExtractor::RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos) {
  // If frame image has not been updated, do nothing
  if (frame_timestamp_ == previous_timestamp_) {
    return;
  }

  // Aquire signal positions from ros topic
  std::vector&lt;Context&gt; signal_positions;
  Context::SetContexts(signal_positions, extracted_pos, frame_.rows, frame_.cols);

  if (signal_positions.size() == 0) {
    // If signal_positions is empty, no ROI images should be saved
    return;
  }

  // Extract ROI for top signal in vector (top signal has largest estimated radius in every signals projected in a image)
  cv::Mat roi = frame_(cv::Rect(signal_positions.at(0).topLeft, signal_positions.at(0).botRight));
  std::string file_name = target_directory_ + std::to_string(file_count_) + &quot;.png&quot;;

  // Reject image if its height is smaller than threshold
  if (roi.size().height &lt; k_minimum_height_) {
    return;
  }

  // Reject image if its similarity level with previous saved ROI is higher than threshold 
  if (k_similarity_threshold_ &lt; CalculateSimilarity(roi, previous_saved_frame_)) {
    return;
  }

  cv::imwrite(file_name.c_str(), roi);
  file_count_++;
  
  previous_timestamp_ = frame_timestamp_;
  previous_saved_frame_ = roi.clone();
} // void RoiExtractor::RoiSignalCallback()


void RoiExtractor::CreateTargetDirectory(std::string base_name) {
  // Extracted ROI's images will be saved in &quot;[base_name]/tlr_TrainingDataSet/Images&quot;
  std::string target_directory_name = base_name + &quot;/tlr_TrainingDataSet/Images/&quot;;
  
  // Create target directory newly if it doesn't exist
  struct stat directory_info;
  if (stat(target_directory_name.c_str(), &amp;directory_info) != 0) {
    MakeDirectoryTree(target_directory_name, base_name, 0755);
  }

  // Count the number of files contained in the target directory
  // so that saved file is named in continuous number
  file_count_ = CountFileNum(target_directory_name);


  // Save directory name into class member
  target_directory_ = target_directory_name;

} // void RoiExtractor::CreateTargetDirectory


int RoiExtractor::CountFileNum(std::string directory_name) {
  int file_num = 0;
  struct dirent *entry;
  DIR *directory_handler = opendir(directory_name.c_str());

  // Count the number of files contained in the specified directory
  while ((entry = readdir(directory_handler)) != NULL) {
    struct stat status;
    std::string absolute_path = directory_name + std::string(entry-&gt;d_name);
    if (stat(absolute_path.c_str(), &amp;status) == 0 &amp;&amp;
        S_ISREG(status.st_mode)) {
      file_num++;
    }
  }

  closedir(directory_handler);

  return file_num;
} //int RoiExtractor::CountFileNum()


void RoiExtractor::MakeDirectoryTree(const std::string &amp;target,
                                     const std::string &amp;base,
                                     const mode_t &amp;mode) {
  // Extract directory subtree structure
  std::string sub_tree = target.substr(base.size());

  // Create directory tree one by one
  size_t separator_start = sub_tree.find(&quot;/&quot;);
  size_t separator_end = sub_tree.find(&quot;/&quot;, separator_start + 1);
  std::string path = base;
  while (separator_end != std::string::npos) {
    std::string sub_directory = sub_tree.substr(separator_start, separator_end - separator_start);
    path = path + sub_directory;
    mkdir(path.c_str(), mode);
    separator_start = separator_end;
    separator_end = sub_tree.find(&quot;/&quot;, separator_start + 1);
  }
} // void RoiExtractor::MakeDirectoryTree()


// calculae similarity of specified two images
// by comparing their histogram, which is sensitive filter for color
double RoiExtractor::CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;image2) {
  if (image1.empty() || image2.empty()) {
    return 0.0;
  }

  // Compare by histogram
  cv::Mat image1_hsv, image2_hsv;
  cv::cvtColor(image1, image1_hsv, CV_BGR2HSV);
  cv::cvtColor(image2, image2_hsv, CV_BGR2HSV);

  const int channel[] = {0};

  // Hue range in OpenCV is 0 to 180
  const float hue_ranges[] = {0, 180};
  const float* ranges[] = {hue_ranges};

  // Quantize hue value into 6
  int hist_size[] = {6};

  cv::Mat histogram1;
  cv::calcHist(&amp;image1_hsv,
               1,               // Use this image only to create histogram
               channel,
               cv::Mat(),       // No mask is used
               histogram1,
               1,               // The dimension of histogram is 1
               hist_size,
               ranges);

   cv::Mat histogram2;
   cv::calcHist(&amp;image2_hsv,
                1,              // Use this image only to create histogram
                channel,
                cv::Mat(),      // No mask is used
                histogram2,
                1,              // The dimension of histogram is 1
                hist_size,
                ranges);

   double similarity = cv::compareHist(histogram1, histogram2, CV_COMP_CORREL);

   return similarity;
} // void RoiExtractor::CalculateSimilarity()


// Entry Point of this node
int main (int argc, char *argv[]) {
  // Initialize ROS node
  ros::init(argc, argv, &quot;roi_extractor&quot;);

  // Get source topic name of image from ROS private parameter
  ros::NodeHandle private_node_handler(&quot;~&quot;);
  std::string image_topic_name;
  std::string target_directory_name = std::string(getenv(&quot;HOME&quot;)) + &quot;/.autoware&quot;;
  int minimum_height = 32;
  double similarity_threshold = 0.9;
  private_node_handler.param&lt;std::string&gt;(&quot;image_raw_topic&quot;, image_topic_name, &quot;/image_raw&quot;);
  private_node_handler.param&lt;std::string&gt;(&quot;target_directory&quot;, target_directory_name, target_directory_name);
  private_node_handler.param&lt;int&gt;(&quot;minimum_height&quot;, minimum_height, 32); // The default minimum height is 32
  private_node_handler.param&lt;double&gt;(&quot;similarity_threshold&quot;, similarity_threshold, 0.9); // The default similarity threshold is 0.9

  // Get directory name which roi images will be saved
  RoiExtractor extractor(minimum_height, similarity_threshold);
  extractor.CreateTargetDirectory(target_directory_name);

  // Launch callback function to subscribe images and signal position
  ros::NodeHandle node_handler;
  ros::Subscriber image_subscriber = node_handler.subscribe(image_topic_name,
                                                            1,
                                                            &amp;RoiExtractor::ImageRawCallback,
                                                            &amp;extractor);

  ros::Subscriber roi_signal_subscriber = node_handler.subscribe(&quot;/roi_signal&quot;,
                                                                 1,
                                                                 &amp;RoiExtractor::RoiSignalCallback,
                                                                 &amp;extractor);
  
  ros::spin();

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/roi_extractor/roi_extractor.h" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/roi_extractor/roi_extractor.h">
				<diff>@@ -10,7 +10,7 @@
 #include &lt;opencv2/opencv.hpp&gt;
 
 #include &quot;Context.h&quot;
-#include &quot;road_wizard/Signals.h&quot;
+#include &quot;autoware_msgs/Signals.h&quot;
 
 class RoiExtractor {
  public:
@@ -24,7 +24,7 @@ class RoiExtractor {
 
   // Callback functions to obtain images and signal position
   void ImageRawCallback(const sensor_msgs::Image &amp;image);
-  void RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos);
+  void RoiSignalCallback(const autoware_msgs::Signals::ConstPtr &amp;extracted_pos);
   
   // Utility function to create directory which roi images will be saved
   void CreateTargetDirectory(std::string base_name);
</diff>
				<old_file>#ifndef ROI_EXTRACTOR_H
#define ROI_EXTRACTOR_H

#include &lt;string&gt;

#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;opencv2/opencv.hpp&gt;

#include &quot;Context.h&quot;
#include &quot;road_wizard/Signals.h&quot;

class RoiExtractor {
 public:
  explicit RoiExtractor(int minimum_height, double similarity_threshold):
    k_minimum_height_(minimum_height),
    k_similarity_threshold_(similarity_threshold),
    previous_saved_frame_(cv::Mat())
  {};

  ~RoiExtractor(){};

  // Callback functions to obtain images and signal position
  void ImageRawCallback(const sensor_msgs::Image &amp;image);
  void RoiSignalCallback(const road_wizard::Signals::ConstPtr &amp;extracted_pos);
  
  // Utility function to create directory which roi images will be saved
  void CreateTargetDirectory(std::string base_name);

 private:
  // Utility function to count the number of files contained in the specified directory
  int CountFileNum(std::string directory_name);

  // Utility function to create directory tree
  void MakeDirectoryTree(const std::string &amp;target, const std::string &amp;base, const mode_t &amp;mode);

  // The function to calculate similarity of two image
  double CalculateSimilarity(const cv::Mat &amp;image1, const cv::Mat &amp;image2);

  // Directory path that extracted ROI images will be saved
  std::string target_directory_;

  // One subscribed frame image
  cv::Mat frame_;

  // Time stamp value of subscribed value
  ros::Time frame_timestamp_;
  ros::Time previous_timestamp_;

  // The number of files contained in the target directory
  int file_count_;

  // The minimum height threshold of ROI image that will be saved
  const int k_minimum_height_;

  // The threshold of the level of similarity
  const double k_similarity_threshold_;

  // The image saved last time
  cv::Mat previous_saved_frame_;
};

#endif // ROI_EXTRACTOR_H
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/tlr_tuner/tunerBody.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/tlr_tuner/tunerBody.cpp">
				<diff>@@ -1,5 +1,5 @@
 #include &quot;tunerBody.h&quot;
-#include &quot;road_wizard/TunedResult.h&quot;
+#include &quot;autoware_msgs/TunedResult.h&quot;
 
 
 #include &lt;opencv2/core/version.hpp&gt;
@@ -152,7 +152,7 @@ void TunerBody::launch(void)
 
   ros::Subscriber image_sub = n.subscribe(image_topic_name, 1, image_raw_callBack);
 
-  ros::Publisher tunedResult_pub = n.advertise &lt;road_wizard::TunedResult&gt; (&quot;tuned_result&quot;, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
+  ros::Publisher tunedResult_pub = n.advertise &lt;autoware_msgs::TunedResult&gt; (&quot;tuned_result&quot;, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
 
   /* valiables to check status change */
   cv::Point prev_clicked = cv::Point(-1, -1);
@@ -275,7 +275,7 @@ void TunerBody::launch(void)
       prev_vw = vw;
 
       /* publish tuned result */
-      road_wizard::TunedResult res;
+      autoware_msgs::TunedResult res;
       res.Red.Hue.center = Red_set.hue.center;
       res.Red.Hue.range  = Red_set.hue.range;
       res.Red.Sat.center = Red_set.sat.center;
</diff>
				<old_file>#include &quot;tunerBody.h&quot;
#include &quot;road_wizard/TunedResult.h&quot;


#include &lt;opencv2/core/version.hpp&gt;
#if (CV_MAJOR_VERSION != 3)
#define CV cv
#else
#define CV cv::internal
#endif


static constexpr int32_t ADVERTISE_QUEUE_SIZE = 10;
static constexpr bool    ADVERTISE_LATCH      = true;

/* definition of class static private variables */
cv::Point       TunerBody::Clicked_point;
int             TunerBody::Signal_color;
cv::Mat         TunerBody::src_img;
cv::Mat         TunerBody::mask;
std::string     TunerBody::windowName;
thresholds_set  TunerBody::Red_set;
thresholds_set  TunerBody::Yellow_set;
thresholds_set  TunerBody::Green_set;
thresholds_set* TunerBody::Selected_set;
bool            TunerBody::updateImage;


/*============== Utility function ==============*/
static void onMouse(int event, int x, int y, int, void*)
{
  if (event != cv::EVENT_LBUTTONDOWN) {
    return;
  }

  TunerBody::setClickedPoint(cv::Point(x, y));

  return;
} /* void onMouse() */


/*============== Utility function ==============*/
static void colorTrack(const cv::Mat&amp; hsv_img,
                       const int hue,
                       const int sat,
                       const int val,
                       const int hw,
                       const int sw,
                       const int vw,
                       cv::Mat *dst)
{
  cv::Mat kernel = cv::Mat::ones(5, 5, CV_8U); /* kernel for dilation and erosion*/

  /* create mask image */
  cv::inRange(hsv_img, cv::Scalar(hue - hw, sat - sw, val - vw), cv::Scalar(hue + hw, sat + sw, val + vw), *dst);

  /* remove noise */
  dilate(*dst, *dst, kernel, cv::Point(-1, -1), 2);
  erode(*dst, *dst, kernel, cv::Point(-1, -1), 2);

} /* void colorTrack() */


/*============== Utility function ==============*/
static int index_max(std::vector&lt;std::vector&lt;cv::Point&gt; &gt; cnt)
{
  unsigned int max_elementNum = 0;
  int maxIdx = -1;

  for (unsigned int i=0; i&lt;cnt.size(); i++)
    {
      unsigned int elementNum = cnt[i].size();
      if (elementNum &gt; max_elementNum) {
        max_elementNum = elementNum;
        maxIdx = i;
      }
    }

  return maxIdx;

} /* int index_max() */


TunerBody::TunerBody()
{
  /* initialize private values */
  Clicked_point = cv::Point(-1, -1);
  Signal_color  = GREEN;
  H_slider_val  = 0;
  S_slider_val  = 0;
  V_slider_val  = 0;
  windowName    = &quot;Traffic Lignt Detector Tuner&quot;;

  Red_set.hue.center = 0;
  Red_set.hue.range  = 0;
  Red_set.sat.center = 0;
  Red_set.sat.range  = 0;
  Red_set.val.center = 0;
  Red_set.val.range  = 0;
  Red_set.isUpdated  = false;
  Yellow_set.hue.center = 0;
  Yellow_set.hue.range  = 0;
  Yellow_set.sat.center = 0;
  Yellow_set.sat.range  = 0;
  Yellow_set.val.center = 0;
  Yellow_set.val.range  = 0;
  Yellow_set.isUpdated  = false;
  Green_set.hue.center = 0;
  Green_set.hue.range  = 0;
  Green_set.sat.center = 0;
  Green_set.sat.range  = 0;
  Green_set.val.center = 0;
  Green_set.val.range  = 0;
  Green_set.isUpdated  = false;

  Selected_set = &amp;Green_set;

  updateImage = true;

  /* create track bars */
  cv::namedWindow(windowName);
  cv::createTrackbar(&quot;H&quot;, windowName, &amp;H_slider_val, 127, NULL, NULL);
  cv::createTrackbar(&quot;S&quot;, windowName, &amp;S_slider_val, 127, NULL, NULL);
  cv::createTrackbar(&quot;V&quot;, windowName, &amp;V_slider_val, 127, NULL, NULL);

} /* TunerBody::TunerBody() */


TunerBody::~TunerBody()
{
  cv::destroyAllWindows();
} /* TunerBody::~TunerBody() */


void TunerBody::image_raw_callBack(const sensor_msgs::Image&amp; image_msg)
{
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, sensor_msgs::image_encodings::BGR8);
  if (updateImage) {
    src_img       = cv_image-&gt;image.clone();
    updateImage   = false;
    Clicked_point = cv::Point(-1, -1); // if image is reloaded, reset clicked point to out of image
  }
} /* TunerBody::image_raw_callBack() */


void TunerBody::launch(void)
{
  ros::NodeHandle n;
  ros::NodeHandle private_nh(&quot;~&quot;);
  std::string image_topic_name;
  private_nh.param&lt;std::string&gt;(&quot;image_raw_topic&quot;, image_topic_name, &quot;/image_raw&quot;);

  ros::Subscriber image_sub = n.subscribe(image_topic_name, 1, image_raw_callBack);

  ros::Publisher tunedResult_pub = n.advertise &lt;road_wizard::TunedResult&gt; (&quot;tuned_result&quot;, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);

  /* valiables to check status change */
  cv::Point prev_clicked = cv::Point(-1, -1);
  int       prev_hw      = 0;
  int       prev_sw      = 0;
  int       prev_vw      = 0;

  while (ros::ok())
    {
      ros::spinOnce();

      if (src_img.empty())
        continue;

      base = cv::Mat::zeros(src_img.rows, src_img.cols * 2, CV_8UC3);
      mask = cv::Mat::zeros(src_img.rows, src_img.cols, CV_8UC1);

      cv::Mat result = src_img.clone();

      /* get clicked coordinates on the image */
      cv::Point targetPoint = Clicked_point;


      /* get current slider position */
      int hw = H_slider_val;
      int sw = S_slider_val;
      int vw = V_slider_val;

      cv::setMouseCallback(windowName, onMouse);

      /* convert input image to HSV color image */
      cv::Mat hsv_img;
      cv::cvtColor(src_img, hsv_img, cv::COLOR_BGR2HSV);

      if (targetPoint != prev_clicked &amp;&amp;
          targetPoint != cv::Point(-1, -1))
        {
          std::cerr &lt;&lt; &quot;Selected_set updated&quot; &lt;&lt; std::endl;
          int hue = (int)hsv_img.at&lt;cv::Vec3b&gt;(targetPoint.y, targetPoint.x)[0];
          int sat = (int)hsv_img.at&lt;cv::Vec3b&gt;(targetPoint.y, targetPoint.x)[1];
          int val = (int)hsv_img.at&lt;cv::Vec3b&gt;(targetPoint.y, targetPoint.x)[2];

          /* save HSV values into correspond variables */
          Selected_set-&gt;hue.center = hue;
          Selected_set-&gt;sat.center = sat;
          Selected_set-&gt;val.center = val;
          Selected_set-&gt;isUpdated  = true;
        }

      Selected_set-&gt;hue.range  = hw;
      Selected_set-&gt;sat.range  = sw;
      Selected_set-&gt;val.range  = vw;

      if (prev_hw != hw || prev_sw != sw || prev_vw != vw) {
        Selected_set-&gt;isUpdated = true;
      }

      colorTrack(hsv_img,
                 Selected_set-&gt;hue.center,
                 Selected_set-&gt;sat.center,
                 Selected_set-&gt;val.center,
                 Selected_set-&gt;hue.range,
                 Selected_set-&gt;sat.range,
                 Selected_set-&gt;val.range,
                 &amp;mask);

      std::vector&lt; std::vector&lt;cv::Point&gt; &gt; contours;
      std::vector&lt;cv::Vec4i&gt; hierarchy;

      cv::Mat mask_clone = mask.clone();
      cv::findContours(mask_clone,
                       contours,
                       hierarchy,
                       CV_RETR_TREE,
                       CV_CHAIN_APPROX_SIMPLE);

      int maxIndex = index_max(contours);

      std::vector&lt;cv::Point&gt; hull;
      if (maxIndex != -1)
        {
          convexHull(contours[maxIndex], hull); /*draw round detected area by line*/
          drawContours(result, std::vector&lt; std::vector&lt;cv::Point&gt; &gt;(1, hull), 0, CV_RGB(220, 30, 20), 3);
        }

      /* display result */
      cv::Mat roi_result = base(cv::Rect(0, 0, result.cols, result.rows));
      result.copyTo(roi_result);

      cv::Scalar mask_color;
      switch (Signal_color) {
      case GREEN:
        mask_color = CV_RGB(0, 255, 0);
        break;
      case YELLOW:
        mask_color = CV_RGB(255, 255, 0);
        break;
      case RED:
        mask_color = CV_RGB(255, 0, 0);
        break;
      }

      cv::Mat colorBack(mask.rows, mask.cols, CV_8UC3, mask_color);
      cv::Mat mask_colored;
      colorBack.copyTo(mask_colored, mask);

      cv::Mat roi_mask = base(cv::Rect(result.cols, 0, mask_colored.cols, mask_colored.rows));
      mask_colored.copyTo(roi_mask);

      cv::imshow(windowName, base);
      cv::waitKey(10);
      // if ( (cv::waitKey(10)) == '\x1b') { /* if 'ESC' key is typed, finish the program */
      //   break;
      // }

      /* save current status */
      prev_clicked = targetPoint;
      prev_hw = hw;
      prev_sw = sw;
      prev_vw = vw;

      /* publish tuned result */
      road_wizard::TunedResult res;
      res.Red.Hue.center = Red_set.hue.center;
      res.Red.Hue.range  = Red_set.hue.range;
      res.Red.Sat.center = Red_set.sat.center;
      res.Red.Sat.range  = Red_set.sat.range;
      res.Red.Val.center = Red_set.val.center;
      res.Red.Val.range  = Red_set.val.range;

      res.Yellow.Hue.center = Yellow_set.hue.center;
      res.Yellow.Hue.range  = Yellow_set.hue.range;
      res.Yellow.Sat.center = Yellow_set.sat.center;
      res.Yellow.Sat.range  = Yellow_set.sat.range;
      res.Yellow.Val.center = Yellow_set.val.center;
      res.Yellow.Val.range  = Yellow_set.val.range;

      res.Green.Hue.center = Green_set.hue.center;
      res.Green.Hue.range  = Green_set.hue.range;
      res.Green.Sat.center = Green_set.sat.center;
      res.Green.Sat.range  = Green_set.sat.range;
      res.Green.Val.center = Green_set.val.center;
      res.Green.Val.range  = Green_set.val.range;

      tunedResult_pub.publish(res);

    }

  cv::destroyAllWindows();

} /* void TunerBody::launch() */


void TunerBody::setColor(signal_state state)
{
  switch (state) {
  case GREEN:
    Selected_set = &amp;Green_set;
    break;
  case YELLOW:
    Selected_set = &amp;Yellow_set;
    break;
  case RED:
    Selected_set = &amp;Red_set;
    break;
  }

  Signal_color = state;

  /* update trackbar position according to current status */
  cv::setTrackbarPos(&quot;H&quot;, windowName, Selected_set-&gt;hue.range);
  cv::setTrackbarPos(&quot;S&quot;, windowName, Selected_set-&gt;sat.range);
  cv::setTrackbarPos(&quot;V&quot;, windowName, Selected_set-&gt;val.range);

  /* update mask image according to current status */
  cv::Mat hsv_img;
  cv::cvtColor(src_img, hsv_img, cv::COLOR_BGR2HSV);
  colorTrack(hsv_img,
             Selected_set-&gt;hue.center,
             Selected_set-&gt;sat.center,
             Selected_set-&gt;val.center,
             Selected_set-&gt;hue.range,
             Selected_set-&gt;sat.range,
             Selected_set-&gt;val.range,
             &amp;mask);

} /* void TunerBody::setColor() */


void TunerBody::setClickedPoint(cv::Point pt)
{
  Clicked_point = pt;
} /* void TunerBody::setClickedPoint() */



void TunerBody::saveResult(std::string fileName)
{

  if (Red_set.isUpdated == false) {
    /*
      ========== Red : Default values ==========
      340               &lt; Hue &lt; 50 (circled)
      DEFAULT_SAT_LOWER &lt; Sat &lt; DEFAULT_SAT_UPPER
      DEFAULT_VAL_LOWER &lt; Val &lt; DEFAULT_VAL_UPPER
    */
    Red_set.hue.center = ( (((360 + 50) - 340 ) / 2 ) + 340) % 360;
    Red_set.hue.range  = (((360 + 50) - 340 ) / 2 );
    Red_set.sat.center = ((DEFAULT_SAT_UPPER - DEFAULT_SAT_LOWER) / 2 ) + DEFAULT_SAT_LOWER;
    Red_set.sat.range  = (DEFAULT_SAT_UPPER - DEFAULT_SAT_LOWER) / 2;
    Red_set.val.center = ((DEFAULT_VAL_UPPER - DEFAULT_VAL_LOWER) / 2 ) + DEFAULT_VAL_LOWER;
    Red_set.val.range  = (DEFAULT_VAL_UPPER - DEFAULT_VAL_LOWER) / 2;
    std::cout &lt;&lt; &quot;Red is default setting&quot; &lt;&lt; std::endl;
  }

  if (Yellow_set.isUpdated == false) {
    /*
      ========== Yellow : Default values ==========
      50                &lt; Hue &lt; 70
      DEFAULT_SAT_LOWER &lt; Sat &lt; DEFAULT_SAT_UPPER
      DEFAULT_VAL_LOWER &lt; Val &lt; DEFAULT_VAL_UPPER
     */
    Yellow_set.hue.center = ( ((70 - 50 ) / 2 ) + 50) % 360;
    Yellow_set.hue.range  = ((70 - 50 ) / 2 );
    Yellow_set.sat.center = ((DEFAULT_SAT_UPPER - DEFAULT_SAT_LOWER) / 2 ) + DEFAULT_SAT_LOWER;
    Yellow_set.sat.range  = (DEFAULT_SAT_UPPER - DEFAULT_SAT_LOWER) / 2;
    Yellow_set.val.center = ((DEFAULT_VAL_UPPER - DEFAULT_VAL_LOWER) / 2 ) + DEFAULT_VAL_LOWER;
    Yellow_set.val.range  = (DEFAULT_VAL_UPPER - DEFAULT_VAL_LOWER) / 2;
    std::cout &lt;&lt; &quot;Yellow is default setting&quot; &lt;&lt; std::endl;
  }

  if (Green_set.isUpdated == false) {
    /*
      ========== Green : Default values ==========
      80                &lt; Hue &lt; 190
      DEFAULT_SAT_LOWER &lt; Sat &lt; DEFAULT_SAT_UPPER
      DEFAULT_VAL_LOWER &lt; Val &lt; DEFAULT_VAL_UPPER
     */
    Green_set.hue.center = ( ((190 - 80 ) / 2 ) + 80) % 360;
    Green_set.hue.range  = ((190 - 80 ) / 2 );
    Green_set.sat.center = ((DEFAULT_SAT_UPPER - DEFAULT_SAT_LOWER) / 2 ) + DEFAULT_SAT_LOWER;
    Green_set.sat.range  = (DEFAULT_SAT_UPPER - DEFAULT_SAT_LOWER) / 2;
    Green_set.val.center = ((DEFAULT_VAL_UPPER - DEFAULT_VAL_LOWER) / 2 ) + DEFAULT_VAL_LOWER;
    Green_set.val.range  = (DEFAULT_VAL_UPPER - DEFAULT_VAL_LOWER) / 2;
    std::cout &lt;&lt; &quot;Green is default setting&quot; &lt;&lt; std::endl;
  }

  /* open file strage */
  cv::FileStorage cvfs(fileName, CV_STORAGE_WRITE);

  /* write data to file */
  {
    CV::WriteStructContext st_red(cvfs, &quot;RED&quot;, CV_NODE_MAP);
    //cv::internal::WriteStructContext st_red(cvfs, &quot;RED&quot;, CV_NODE_MAP);
    {
      CV::WriteStructContext st_hue(cvfs, &quot;Hue&quot;, CV_NODE_MAP);
      //cv::internal::WriteStructContext st_hue(cvfs, &quot;Hue&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Red_set.hue.center);
      cv::write(cvfs, &quot;range&quot;, Red_set.hue.range);
    }

    {
      CV::WriteStructContext st_hue(cvfs, &quot;Saturation&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Red_set.sat.center);
      cv::write(cvfs, &quot;range&quot;, Red_set.sat.range);
    }

    {
      CV::WriteStructContext st_hue(cvfs, &quot;Value&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Red_set.val.center);
      cv::write(cvfs, &quot;range&quot;, Red_set.val.range);
    }
  }

  {
    CV::WriteStructContext st_yellow(cvfs, &quot;YELLOW&quot;, CV_NODE_MAP);
    //CV::WriteStructContext st_yellow(cvfs, &quot;YELLOW&quot;, CV_NODE_MAP);
    {
      CV::WriteStructContext st_hue(cvfs, &quot;Hue&quot;, CV_NODE_MAP);
      //CV::WriteStructContext st_hue(cvfs, &quot;Hue&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Yellow_set.hue.center);
      cv::write(cvfs, &quot;range&quot;, Yellow_set.hue.range);
    }

    {
      CV::WriteStructContext st_hue(cvfs, &quot;Saturation&quot;, CV_NODE_MAP);
      //CV::WriteStructContext st_hue(cvfs, &quot;Saturation&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Yellow_set.sat.center);
      cv::write(cvfs, &quot;range&quot;, Yellow_set.sat.range);
    }

    {
      CV::WriteStructContext st_hue(cvfs, &quot;Value&quot;, CV_NODE_MAP);
     // CV::WriteStructContext st_hue(cvfs, &quot;Value&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Yellow_set.val.center);
      cv::write(cvfs, &quot;range&quot;, Yellow_set.val.range);
    }
  }

  {
    CV::WriteStructContext st_green(cvfs, &quot;GREEN&quot;, CV_NODE_MAP);
    {
      CV::WriteStructContext st_hue(cvfs, &quot;Hue&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Green_set.hue.center);
      cv::write(cvfs, &quot;range&quot;, Green_set.hue.range);
    }

    {
      CV::WriteStructContext st_hue(cvfs, &quot;Saturation&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Green_set.sat.center);
      cv::write(cvfs, &quot;range&quot;, Green_set.sat.range);
    }

    {
      CV::WriteStructContext st_hue(cvfs, &quot;Value&quot;, CV_NODE_MAP);
      cv::write(cvfs, &quot;center&quot;, Green_set.val.center);
      cv::write(cvfs, &quot;range&quot;, Green_set.val.range);
    }
  }

} /* void TunerBody::saveResult() */


void TunerBody::openSetting(std::string fileName)
{
  /* open file strage */
  cv::FileStorage cvfs(fileName, CV_STORAGE_READ);

  /* read data from file */
  cv::FileNode topNode(cvfs.fs, NULL);
  {
    cv::FileNode nd_red = topNode[std::string(&quot;RED&quot;)];
    {
      cv::FileNode nd_hue = nd_red[&quot;Hue&quot;];
      Red_set.hue.center  = nd_hue[&quot;center&quot;];
      Red_set.hue.range   = nd_hue[&quot;range&quot;];
    }

    {
      cv::FileNode nd_sat = nd_red[&quot;Saturation&quot;];
      Red_set.sat.center  = nd_sat[&quot;center&quot;];
      Red_set.sat.range   = nd_sat[&quot;range&quot;];
    }

    {
      cv::FileNode nd_val = nd_red[&quot;Value&quot;];
      Red_set.val.center  = nd_val[&quot;center&quot;];
      Red_set.val.range   = nd_val[&quot;range&quot;];
    }

    Red_set.isUpdated = true;
  }

  {
    cv::FileNode nd_yellow = topNode[std::string(&quot;YELLOW&quot;)];
    {
      cv::FileNode nd_hue   = nd_yellow[&quot;Hue&quot;];
      Yellow_set.hue.center = nd_hue[&quot;center&quot;];
      Yellow_set.hue.range  = nd_hue[&quot;range&quot;];
    }

    {
      cv::FileNode nd_sat   = nd_yellow[&quot;Saturation&quot;];
      Yellow_set.sat.center = nd_sat[&quot;center&quot;];
      Yellow_set.sat.range  = nd_sat[&quot;range&quot;];
    }

    {
      cv::FileNode nd_val   = nd_yellow[&quot;Value&quot;];
      Yellow_set.val.center = nd_val[&quot;center&quot;];
      Yellow_set.val.range  = nd_val[&quot;range&quot;];
    }

    Yellow_set.isUpdated = true;
  }

  {
    cv::FileNode nd_green = topNode[std::string(&quot;GREEN&quot;)];
    {
      cv::FileNode nd_hue  = nd_green[&quot;Hue&quot;];
      Green_set.hue.center = nd_hue[&quot;center&quot;];
      Green_set.hue.range  = nd_hue[&quot;range&quot;];
    }

    {
      cv::FileNode nd_sat  = nd_green[&quot;Saturation&quot;];
      Green_set.sat.center = nd_sat[&quot;center&quot;];
      Green_set.sat.range  = nd_sat[&quot;range&quot;];
    }

    {
      cv::FileNode nd_val  = nd_green[&quot;Value&quot;];
      Green_set.val.center = nd_val[&quot;center&quot;];
      Green_set.val.range  = nd_val[&quot;range&quot;];
    }

    Green_set.isUpdated = true;
  }

  /* set trackbar position to current status */
  cv::setTrackbarPos(&quot;H&quot;, windowName, Selected_set-&gt;hue.range);
  cv::setTrackbarPos(&quot;S&quot;, windowName, Selected_set-&gt;sat.range);
  cv::setTrackbarPos(&quot;V&quot;, windowName, Selected_set-&gt;val.range);

  /* sat mask image to current status */
  cv::Mat hsv_img;
  cv::cvtColor(src_img, hsv_img, cv::COLOR_BGR2HSV);
  colorTrack(hsv_img,
             Selected_set-&gt;hue.center,
             Selected_set-&gt;sat.center,
             Selected_set-&gt;val.center,
             Selected_set-&gt;hue.range,
             Selected_set-&gt;sat.range,
             Selected_set-&gt;val.range,
             &amp;mask);

} /* void TunerBody::openSetting() */

void TunerBody::setUpdateImage(void)
{
  updateImage = true;
} /* void TunerBody::setUpdateImage() */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/obstacle_avoid/search_info_ros.cpp" new_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/obstacle_avoid/search_info_ros.cpp">
				<diff>@@ -58,7 +58,7 @@ SearchInfo::~SearchInfo()
 {
 }
 
-double SearchInfo::calcPathLength(const waypoint_follower_msgs::lane &amp;lane, const int start_waypoint_index,
+double SearchInfo::calcPathLength(const autoware_msgs::lane &amp;lane, const int start_waypoint_index,
                                   const int goal_waypoint_index) const
 {
   if (lane.waypoints.size() &lt;= 1)
@@ -172,7 +172,7 @@ void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
 }
 
 // get waypoints
-void SearchInfo::waypointsCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
+void SearchInfo::waypointsCallback(const autoware_msgs::laneConstPtr &amp;msg)
 {
   subscribed_waypoints_ = *msg;
 
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;search_info_ros.h&quot;

namespace astar_planner
{
SearchInfo::SearchInfo()
  : map_set_(false)
  , start_set_(false)
  , goal_set_(false)
  , path_set_(false)
  , closest_waypoint_index_(-1)
  , obstacle_waypoint_index_(-1)
  , start_waypoint_index_(-1)
  , goal_waypoint_index_(-1)
  , state_(&quot;&quot;)
  , upper_bound_distance_(-1)
{
  ros::NodeHandle private_nh_(&quot;~&quot;);
  private_nh_.param&lt;std::string&gt;(&quot;map_frame&quot;, map_frame_, &quot;map&quot;);
  private_nh_.param&lt;int&gt;(&quot;obstacle_detect_count&quot;, obstacle_detect_count_, 10);
  private_nh_.param&lt;int&gt;(&quot;avoid_distance&quot;, avoid_distance_, 13);
  private_nh_.param&lt;double&gt;(&quot;avoid_velocity_limit_mps&quot;, avoid_velocity_limit_mps_, 4.166);
  private_nh_.param&lt;double&gt;(&quot;upper_bound_ratio&quot;, upper_bound_ratio_, 1.04);
  private_nh_.param&lt;bool&gt;(&quot;avoidance&quot;, avoidance_, false);
  private_nh_.param&lt;bool&gt;(&quot;change_path&quot;, change_path_, true);
}

SearchInfo::~SearchInfo()
{
}

double SearchInfo::calcPathLength(const waypoint_follower_msgs::lane &amp;lane, const int start_waypoint_index,
                                  const int goal_waypoint_index) const
{
  if (lane.waypoints.size() &lt;= 1)
    return 0;

  // calulate the length of the path
  double dist_sum = 0;
  for (int i = start_waypoint_index; i &lt; goal_waypoint_index; i++)
  {
    geometry_msgs::Pose p1 = lane.waypoints[i].pose.pose;
    geometry_msgs::Pose p2 = lane.waypoints[i + 1].pose.pose;

    dist_sum += astar_planner::calcDistance(p1.position.x, p1.position.y, p2.position.x, p2.position.y);
  }

  // return the path lengh
  return dist_sum;
}

void SearchInfo::mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg)
{
  map_ = *msg;

  std::string map_frame = map_frame_;
  std::string ogm_frame = msg-&gt;header.frame_id;

  // Set transform between map frame and OccupancyGrid frame
  tf::StampedTransform map2ogm_frame;
  try
  {
    tf_listener_.lookupTransform(map_frame, ogm_frame, ros::Time(0), map2ogm_frame);
  }
  catch (tf::TransformException ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
    return;
  }

  // Set transform between map frame and the origin of OccupancyGrid
  tf::Transform map2ogm;
  geometry_msgs::Pose ogm_in_map = astar_planner::transformPose(map_.info.origin, map2ogm_frame);
  tf::poseMsgToTF(ogm_in_map, map2ogm);
  ogm2map_ = map2ogm.inverse();

  map_set_ = true;
}

void SearchInfo::currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
{
  current_pose_ = *msg;

  return;
}

void SearchInfo::currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg)
{
  current_velocity_mps_ = msg-&gt;twist.linear.x;
}

void SearchInfo::goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
{
  if (!map_set_)
    return;

  ROS_INFO(&quot;Subcscribed goal pose!&quot;);

  std::string map_frame = map_frame_;
  std::string goal_frame = msg-&gt;header.frame_id;

  // Get transform of map to the frame of goal pose
  tf::StampedTransform map2world;
  try
  {
    tf_listener_.lookupTransform(map_frame, goal_frame, ros::Time(0), map2world);
  }
  catch (tf::TransformException ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
    return;
  }

  // Set goal pose
  geometry_msgs::Pose pose_msg = msg-&gt;pose;
  goal_pose_global_.pose = astar_planner::transformPose(pose_msg, map2world);
  goal_pose_global_.header = msg-&gt;header;
  goal_pose_local_.pose = astar_planner::transformPose(goal_pose_global_.pose, ogm2map_);
  goal_pose_local_.header = goal_pose_global_.header;

  goal_set_ = true;

  // Get transform of map to the frame of start pose
  std::string start_frame = current_pose_.header.frame_id;
  tf::StampedTransform map2start_frame;
  try
  {
    tf_listener_.lookupTransform(map_frame_, start_frame, ros::Time(0), map2start_frame);
  }
  catch (tf::TransformException ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
    return;
  }

  // Set start pose
  start_pose_global_.pose = astar_planner::transformPose(current_pose_.pose, map2start_frame);
  start_pose_global_.header = current_pose_.header;
  start_pose_local_.pose = astar_planner::transformPose(start_pose_global_.pose, ogm2map_);
  start_pose_local_.header = start_pose_global_.header;

  start_set_ = true;
}

// get waypoints
void SearchInfo::waypointsCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg)
{
  subscribed_waypoints_ = *msg;

  if (!path_set_)
  {
    current_waypoints_ = *msg;
    path_set_ = true;
  }
}

void SearchInfo::closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
{
  closest_waypoint_index_ = msg-&gt;data;
}

void SearchInfo::obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg)
{
  // not always avoid AND current state is not avoidance
  if (!avoidance_ &amp;&amp; state_ != &quot;OBSTACLE_AVOIDANCE&quot;)
  {
    ROS_WARN(&quot;current state is not OBSTACLE_AVOIDANCE&quot;);
    return;
  }

  // there are no obstacles
  if (msg-&gt;data &lt; 0 || closest_waypoint_index_ &lt; 0 || current_waypoints_.waypoints.empty())
  {
    return;
  }

  // msg-&gt;data : local index
  // closest   : global index
  // Conver local index to global index
  obstacle_waypoint_index_ = msg-&gt;data + closest_waypoint_index_;

  // Handle when detecting sensor noise as an obstacle
  static int prev_obstacle_waypoint_index = -1;
  static int obstacle_count = 0;
  int same_obstacle_threshold = 2;
  if (obstacle_waypoint_index_ &gt;= prev_obstacle_waypoint_index - same_obstacle_threshold &amp;&amp;
      obstacle_waypoint_index_ &lt;= prev_obstacle_waypoint_index + same_obstacle_threshold)
  {
    obstacle_count++;
  }
  else
  {
    obstacle_count = 1;
  }

  prev_obstacle_waypoint_index = obstacle_waypoint_index_;

  if (obstacle_count &lt; obstacle_detect_count_)
    return;

  // not debug mode
  if (change_path_)
    obstacle_count = 0;

  // Decide start and goal waypoints for planning
  start_waypoint_index_ = obstacle_waypoint_index_ - avoid_distance_;
  goal_waypoint_index_ = obstacle_waypoint_index_ + avoid_distance_;

  // Handle out of range
  if (start_waypoint_index_ &lt; 0)
    start_waypoint_index_ = 0;

  // Handle out of range
  if (goal_waypoint_index_ &gt;= static_cast&lt;int&gt;(getCurrentWaypoints().waypoints.size()))
    goal_waypoint_index_ = getCurrentWaypoints().waypoints.size() - 1;

  double original_path_length = calcPathLength(current_waypoints_, start_waypoint_index_, goal_waypoint_index_);
  upper_bound_distance_ = original_path_length * upper_bound_ratio_;

  // Do not avoid if (the obstacle is too close || current velocity is too fast)
  if (closest_waypoint_index_ + 1 &gt; start_waypoint_index_)
  {
    ROS_WARN(&quot;The obstacle is too close!&quot;);
    return;
  }

  // apply velocity limit for avoiding
  if (current_velocity_mps_ &gt; avoid_velocity_limit_mps_)
  {
    ROS_WARN(&quot;Velocity of the vehicle exceeds the avoid velocity limit&quot;);
    return;
  }

  // Set start pose
  start_pose_global_ = current_waypoints_.waypoints[start_waypoint_index_].pose;
  start_pose_local_.pose = astar_planner::transformPose(start_pose_global_.pose, ogm2map_);
  start_set_ = true;

  // Set transit pose
  // TODO:
  double actual_car_width = 2.5;  // [m]
  geometry_msgs::Pose relative_transit_pose;
  // TODO: always right avoidance ???
  relative_transit_pose.position.y -= actual_car_width;
  relative_transit_pose.orientation = current_waypoints_.waypoints[obstacle_waypoint_index_].pose.pose.orientation;
  tf::Pose obstacle_pose_tf;
  tf::poseMsgToTF(current_waypoints_.waypoints[obstacle_waypoint_index_].pose.pose, obstacle_pose_tf);

  transit_pose_global_.pose = astar_planner::transformPose(relative_transit_pose, obstacle_pose_tf);
  transit_pose_local_.pose = astar_planner::transformPose(transit_pose_global_.pose, ogm2map_);

  // Set goal pose
  goal_pose_global_ = current_waypoints_.waypoints[goal_waypoint_index_].pose;
  goal_pose_local_.pose = astar_planner::transformPose(goal_pose_global_.pose, ogm2map_);

  goal_set_ = true;
}

void SearchInfo::stateCallback(const std_msgs::StringConstPtr &amp;msg)
{
  state_ = msg-&gt;data;
}

void SearchInfo::reset()
{
  map_set_ = false;
  start_set_ = false;
  goal_set_ = false;
  obstacle_waypoint_index_ = -1;
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/obstacle_avoid/search_info_ros.h" new_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/obstacle_avoid/search_info_ros.h">
				<diff>@@ -32,7 +32,7 @@
 #define SEARCH_INFO_ROS_H
 
 #include &quot;astar_util.h&quot;
-#include &quot;waypoint_follower_msgs/lane.h&quot;
+#include &quot;autoware_msgs/lane.h&quot;
 #include &quot;waypoint_follower/libwaypoint_follower.h&quot;
 
 #include &lt;nav_msgs/OccupancyGrid.h&gt;
@@ -55,7 +55,7 @@ public:
   void goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg);
-  void waypointsCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg);
+  void waypointsCallback(const autoware_msgs::laneConstPtr &amp;msg);
   void closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
   void obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
   void stateCallback(const std_msgs::StringConstPtr &amp;msg);
@@ -101,11 +101,11 @@ public:
   {
     return current_velocity_mps_;
   }
-  waypoint_follower_msgs::lane getSubscribedWaypoints() const
+  autoware_msgs::lane getSubscribedWaypoints() const
   {
     return subscribed_waypoints_;
   }
-  waypoint_follower_msgs::lane getCurrentWaypoints() const
+  autoware_msgs::lane getCurrentWaypoints() const
   {
     return current_waypoints_;
   }
@@ -143,7 +143,7 @@ public:
   }
 
   // set method
-  void setCurrentWaypoints(const waypoint_follower_msgs::lane &amp;waypoints)
+  void setCurrentWaypoints(const autoware_msgs::lane &amp;waypoints)
   {
     current_waypoints_ = waypoints;
   }
@@ -152,7 +152,7 @@ public:
   void reset();
 
 private:
-  double calcPathLength(const waypoint_follower_msgs::lane &amp;lane, const int start_waypoint_index,
+  double calcPathLength(const autoware_msgs::lane &amp;lane, const int start_waypoint_index,
                         const int goal_waypoint_index) const;
 
   nav_msgs::OccupancyGrid map_;
@@ -186,8 +186,8 @@ private:
   int obstacle_waypoint_index_;
   int start_waypoint_index_;
   int goal_waypoint_index_;
-  waypoint_follower_msgs::lane subscribed_waypoints_;
-  waypoint_follower_msgs::lane current_waypoints_;
+  autoware_msgs::lane subscribed_waypoints_;
+  autoware_msgs::lane current_waypoints_;
   geometry_msgs::PoseStamped current_pose_;
   double current_velocity_mps_;
   std::string state_;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef SEARCH_INFO_ROS_H
#define SEARCH_INFO_ROS_H

#include &quot;astar_util.h&quot;
#include &quot;waypoint_follower_msgs/lane.h&quot;
#include &quot;waypoint_follower/libwaypoint_follower.h&quot;

#include &lt;nav_msgs/OccupancyGrid.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;

namespace astar_planner
{
class SearchInfo
{
public:
  SearchInfo();
  ~SearchInfo();

  // ROS Callback
  void mapCallback(const nav_msgs::OccupancyGridConstPtr &amp;msg);
  // void startCallback(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg);
  void goalCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
  void currentPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
  void currentVelocityCallback(const geometry_msgs::TwistStampedConstPtr &amp;msg);
  void waypointsCallback(const waypoint_follower_msgs::laneConstPtr &amp;msg);
  void closestWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
  void obstacleWaypointCallback(const std_msgs::Int32ConstPtr &amp;msg);
  void stateCallback(const std_msgs::StringConstPtr &amp;msg);

  // get method
  bool getMapSet() const
  {
    return map_set_;
  }
  bool getStartSet() const
  {
    return start_set_;
  }
  bool getGoalSet() const
  {
    return goal_set_;
  }
  bool getPathSet() const
  {
    return path_set_;
  }
  nav_msgs::OccupancyGrid getMap() const
  {
    return map_;
  }
  geometry_msgs::PoseStamped getStartPose() const
  {
    return start_pose_local_;
  }
  geometry_msgs::PoseStamped getGoalPose() const
  {
    return goal_pose_local_;
  }
  geometry_msgs::PoseStamped getTransitPose() const
  {
    return transit_pose_local_;
  }
  geometry_msgs::PoseStamped getCurrentPose() const
  {
    return current_pose_;
  }
  double getCurrentVelocity() const
  {
    return current_velocity_mps_;
  }
  waypoint_follower_msgs::lane getSubscribedWaypoints() const
  {
    return subscribed_waypoints_;
  }
  waypoint_follower_msgs::lane getCurrentWaypoints() const
  {
    return current_waypoints_;
  }
  int getObstacleWaypointIndex() const
  {
    return obstacle_waypoint_index_;
  }
  int getClosestWaypointIndex() const
  {
    return closest_waypoint_index_;
  }
  int getStartWaypointIndex() const
  {
    return start_waypoint_index_;
  }
  int getGoalWaypointIndex() const
  {
    return goal_waypoint_index_;
  }
  double getUpperBoundDistance() const
  {
    return upper_bound_distance_;
  }
  double getAvoidVelocityLimitMPS() const
  {
    return avoid_velocity_limit_mps_;
  }
  bool getAvoidance() const
  {
    return avoidance_;
  }
  bool getChangePath() const
  {
    return change_path_;
  }

  // set method
  void setCurrentWaypoints(const waypoint_follower_msgs::lane &amp;waypoints)
  {
    current_waypoints_ = waypoints;
  }

  // Reset flag
  void reset();

private:
  double calcPathLength(const waypoint_follower_msgs::lane &amp;lane, const int start_waypoint_index,
                        const int goal_waypoint_index) const;

  nav_msgs::OccupancyGrid map_;
  geometry_msgs::PoseStamped start_pose_global_;
  geometry_msgs::PoseStamped goal_pose_global_;
  geometry_msgs::PoseStamped transit_pose_global_;
  geometry_msgs::PoseStamped start_pose_local_;
  geometry_msgs::PoseStamped goal_pose_local_;
  geometry_msgs::PoseStamped transit_pose_local_;
  // Transform which converts global frame (/map in Autoware) to OccupancyGrid frame
  tf::Transform ogm2map_;
  tf::TransformListener tf_listener_;

  // set data flag
  bool map_set_;
  bool start_set_;
  bool goal_set_;
  bool path_set_;

  // ROS param
  std::string map_frame_;
  int obstacle_detect_count_;        // 1 increment means 100ms
  int avoid_distance_;               // the number of waypoint
  double avoid_velocity_limit_mps_;  // m/s
  double upper_bound_ratio_;
  bool avoidance_;
  bool change_path_;

  // subscribed imformation
  int closest_waypoint_index_;
  int obstacle_waypoint_index_;
  int start_waypoint_index_;
  int goal_waypoint_index_;
  waypoint_follower_msgs::lane subscribed_waypoints_;
  waypoint_follower_msgs::lane current_waypoints_;
  geometry_msgs::PoseStamped current_pose_;
  double current_velocity_mps_;
  std::string state_;

  // for prunning
  double upper_bound_distance_;
};

}  // namespace astar_planner

#endif  // SEARCH_INFO_ROS_H
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/velocity_set/velocity_set_info.cpp" new_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/velocity_set/velocity_set_info.cpp">
				<diff>@@ -53,7 +53,7 @@ void VelocitySetInfo::clearPoints()
   points_.clear();
 }
 
-void VelocitySetInfo::configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;config)
+void VelocitySetInfo::configCallback(const autoware_msgs::ConfigVelocitySetConstPtr &amp;config)
 {
   stop_distance_ = config-&gt;others_distance;
   stop_range_ = config-&gt;detection_range;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include &quot;velocity_set_info.h&quot;

VelocitySetInfo::VelocitySetInfo()
  : stop_range_(1.3),
    deceleration_range_(0),
    points_threshold_(10),
    detection_height_top_(0.2),
    detection_height_bottom_(-1.7),
    stop_distance_(10),
    decel_(0.8),
    velocity_change_limit_(2.77),
    temporal_waypoints_size_(100),
    set_pose_(false)
{
}

VelocitySetInfo::~VelocitySetInfo()
{
}

void VelocitySetInfo::clearPoints()
{
  points_.clear();
}

void VelocitySetInfo::configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;config)
{
  stop_distance_ = config-&gt;others_distance;
  stop_range_ = config-&gt;detection_range;
  points_threshold_ = config-&gt;threshold_points;
  detection_height_top_ = config-&gt;detection_height_top;
  detection_height_bottom_ = config-&gt;detection_height_bottom;
  decel_ = config-&gt;deceleration;
  velocity_change_limit_ = config-&gt;velocity_change_limit / 3.6; // kmph -&gt; mps
  deceleration_range_ = config-&gt;deceleration_range;
  temporal_waypoints_size_ = config-&gt;temporal_waypoints_size;
}

void VelocitySetInfo::pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg)
{
  pcl::PointCloud&lt;pcl::PointXYZ&gt; sub_points;
  pcl::fromROSMsg(*msg, sub_points);

  points_.clear();
  for (const auto &amp;v : sub_points)
  {
    if (v.x == 0 &amp;&amp; v.y == 0)
      continue;

    if (v.z &gt; detection_height_top_ || v.z &lt; detection_height_bottom_)
      continue;

    points_.push_back(v);
  }
}

void VelocitySetInfo::controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
{
  control_pose_ = *msg;

  if (!set_pose_)
    set_pose_ = true;
}

void VelocitySetInfo::localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg)
{
  localizer_pose_ = *msg;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/velocity_set/velocity_set_info.h" new_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/velocity_set/velocity_set_info.h">
				<diff>@@ -36,7 +36,7 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;std_msgs/Int32.h&gt;
 
-#include &quot;runtime_manager/ConfigVelocitySet.h&quot;
+#include &quot;autoware_msgs/ConfigVelocitySet.h&quot;
 
 class VelocitySetInfo
 {
@@ -62,7 +62,7 @@ class VelocitySetInfo
   ~VelocitySetInfo();
 
   // ROS Callback
-  void configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;msg);
+  void configCallback(const autoware_msgs::ConfigVelocitySetConstPtr &amp;msg);
   void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
   void controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
   void localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef VELOCITY_SET_INFO_H
#define VELOCITY_SET_INFO_H

#include &lt;ros/ros.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;std_msgs/Int32.h&gt;

#include &quot;runtime_manager/ConfigVelocitySet.h&quot;

class VelocitySetInfo
{
 private:
  // parameters
  double stop_range_;               // if obstacle is in this range, stop
  double deceleration_range_;       // if obstacle is in this range, decelerate
  int points_threshold_;            // points threshold to find obstacles
  double detection_height_top_;     // from sensor
  double detection_height_bottom_;  // from sensor
  double stop_distance_;            // (meter) stopping distance from obstacles
  double decel_;                    // (m/s^2) deceleration
  double velocity_change_limit_;    // (m/s)
  double temporal_waypoints_size_;  // (meter)

  pcl::PointCloud&lt;pcl::PointXYZ&gt; points_;
  geometry_msgs::PoseStamped localizer_pose_;  // pose of sensor
  geometry_msgs::PoseStamped control_pose_;    // pose of base_link
  bool set_pose_;

 public:
  VelocitySetInfo();
  ~VelocitySetInfo();

  // ROS Callback
  void configCallback(const runtime_manager::ConfigVelocitySetConstPtr &amp;msg);
  void pointsCallback(const sensor_msgs::PointCloud2ConstPtr &amp;msg);
  void controlPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);
  void localizerPoseCallback(const geometry_msgs::PoseStampedConstPtr &amp;msg);

  void clearPoints();

  double getStopRange() const
  {
    return stop_range_;
  }

  double getDecelerationRange() const
  {
    return deceleration_range_;
  }

  int getPointsThreshold() const
  {
    return points_threshold_;
  }

  int getDetectionHeightTop() const
  {
    return detection_height_top_;
  }

  int getDetectionHeightBottom() const
  {
    return detection_height_bottom_;
  }

  int getStopDistance() const
  {
    return stop_distance_;
  }

  double getDeceleration() const
  {
    return decel_;
  }

  double getVelocityChangeLimit() const
  {
    return velocity_change_limit_;
  }

  double getTemporalWaypointsSize() const
  {
    return temporal_waypoints_size_;
  }

  pcl::PointCloud&lt;pcl::PointXYZ&gt; getPoints() const
  {
    return points_;
  }

  geometry_msgs::PoseStamped getControlPose() const
  {
    return control_pose_;
  }

  geometry_msgs::PoseStamped getLocalizerPose() const
  {
    return localizer_pose_;
  }

  bool getSetPose() const
  {
    return set_pose_;
  }
};

#endif // VELOCITY_SET_INFO_H
</old_file>
			</file>
			<file old_path="ros/src/system/sync/sync_drivers.cpp" new_path="ros/src/system/sync/sync_drivers.cpp">
				<diff>@@ -36,7 +36,7 @@
 /* user header */
 #include &quot;sensor_msgs/Image.h&quot;
 #include &quot;sensor_msgs/PointCloud2.h&quot;
-#include &quot;autoware_msgs/time_diff.h&quot;
+#include &quot;autoware_msgs/Sync_time_diff.h&quot;
 
 /* ----var---- */
 /* common var */
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
/* ----header---- */
/* common header */
#include &quot;ros/ros.h&quot;
#include &lt;sstream&gt;
#include &lt;boost/circular_buffer.hpp&gt;
#include &quot;std_msgs/Header.h&quot;
/* user header */
#include &quot;sensor_msgs/Image.h&quot;
#include &quot;sensor_msgs/PointCloud2.h&quot;
#include &quot;autoware_msgs/time_diff.h&quot;

/* ----var---- */
/* common var */
/* user var */
sensor_msgs::Image image_raw_buf;

ros::Publisher points_raw__pub;
ros::Publisher image_raw__pub;
ros::Publisher time_diff_pub;
bool is_sim;

double fabs_time_diff(const std_msgs::Header *timespec1, const std_msgs::Header *timespec2)
{
    double time1 = (double)timespec1-&gt;stamp.sec + (double)timespec1-&gt;stamp.nsec/1000000000L;
    double time2 = (double)timespec2-&gt;stamp.sec + (double)timespec2-&gt;stamp.nsec/1000000000L;
    return fabs(time1 - time2);
}

void image_raw_callback(sensor_msgs::Image image_raw_msg)
{
    image_raw_buf = image_raw_msg;
}

void points_raw_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; points_raw_msg)
{
    autoware_msgs::Sync_time_diff time_diff_msg;
    time_diff_msg.header.frame_id = &quot;0&quot;;
    time_diff_msg.header.stamp = points_raw_msg-&gt;header.stamp;
    time_diff_msg.time_diff = fabs_time_diff(&amp;(points_raw_msg-&gt;header), &amp;image_raw_buf.header)*1000.0; //msec
    time_diff_msg.camera = image_raw_buf.header.stamp;
    time_diff_msg.lidar = points_raw_msg-&gt;header.stamp;
    time_diff_pub.publish(time_diff_msg);

    image_raw_buf.header.stamp = points_raw_msg-&gt;header.stamp;
    image_raw__pub.publish(image_raw_buf);
    points_raw__pub.publish(points_raw_msg);
}



int main(int argc, char **argv)
{
  ros::init(argc, argv, &quot;sync_drivers&quot;);
  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  ros::Subscriber image_raw_sub = nh.subscribe(&quot;/image_raw&quot;, 1, image_raw_callback);
  ros::Subscriber points_raw_sub;
  points_raw_sub = nh.subscribe(&quot;/points_raw&quot;, 1, points_raw_callback);

  image_raw__pub = nh.advertise&lt;sensor_msgs::Image&gt;(&quot;image_raw&quot;, 1);
  points_raw__pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;points_raw&quot;, 1);
  time_diff_pub = nh.advertise&lt;autoware_msgs::Sync_time_diff&gt;(&quot;/time_difference&quot;, 1);

  ros::spin();


  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="955c5de6a572f7b6b6cd67171db4d36f2cced2ea" fix_time="450,56015">
		<msg>fix a build issue due to autoware_msgs on the Indigo</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/lib/image/kf/src/kf.cpp" new_path="ros/src/computing/perception/detection/lib/image/kf/src/kf.cpp">
				<diff>@@ -37,10 +37,10 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/Image.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;runtime_manager/ConfigCarKf.h&gt;
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
+#include &lt;autoware_msgs/ConfigCarKf.h&gt;
+#include &lt;autoware_msgs/image_obj_ranged.h&gt;
 
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
+#include &lt;autoware_msgs/image_obj_tracked.h&gt;
 #include &lt;std_msgs/Header.h&gt;
 
 //TRACKING STUFF
@@ -92,7 +92,7 @@ static bool 		USE_ORB;
 
 static bool 		track_ready_;
 static bool 		detect_ready_;
-static cv_tracker_msgs::image_obj_tracked kf_objects_msg_;
+static autoware_msgs::image_obj_tracked kf_objects_msg_;
 
 struct kstate
 {
@@ -819,7 +819,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 
 	//ROS
 	int num = tracked_detections.size();
-	std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; rect_ranged_array;
+	std::vector&lt;autoware_msgs::image_rect_ranged&gt; rect_ranged_array;
 	std::vector&lt;int&gt; real_data(num,0);
 	std::vector&lt;int&gt; obj_id(num, 0);
 	std::vector&lt;int&gt; lifespan(num, 0);
@@ -828,7 +828,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 	for (size_t i = 0; i &lt; tracked_detections.size(); i++)
 	{
 		kstate od = tracked_detections[i];
-		cv_tracker_msgs::image_rect_ranged rect_ranged_;
+		autoware_msgs::image_rect_ranged rect_ranged_;
 
 		//od.rect contains x,y, width, height
 		rectangle(image, od.pos, od.color, 3);
@@ -850,7 +850,7 @@ void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDete
 		//ENDROS
 	}
 	//more ros
-	cv_tracker_msgs::image_obj_tracked kf_objects_msg;
+	autoware_msgs::image_obj_tracked kf_objects_msg;
 
 	kf_objects_msg.type = object_type;
 	kf_objects_msg.total_num = num;
@@ -882,12 +882,12 @@ void image_callback(const sensor_msgs::Image&amp; image_source)
 	_counter++;
 }
 
-void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
+void detections_callback(autoware_msgs::image_obj_ranged image_objects_msg)
 {
 	if(!detect_ready_)
 	{
 		unsigned int num = image_objects_msg.obj.size();
-		std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
+		std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
 		object_type = image_objects_msg.type;
 		image_objects_header = image_objects_msg.header;
 		//points are X,Y,W,H and repeat for each instance
@@ -918,7 +918,7 @@ void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
 	publish_if_possible();
 }
 
-static void kf_config_cb(const runtime_manager::ConfigCarKf::ConstPtr&amp; param)
+static void kf_config_cb(const autoware_msgs::ConfigCarKf::ConstPtr&amp; param)
 {
 	if (param-&gt;initial_lifespan &gt; 0)
 		INITIAL_LIFESPAN	= param-&gt;initial_lifespan;
@@ -962,7 +962,7 @@ int kf_main(int argc, char* argv[])
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh(&quot;~&quot;);
 
-	image_objects = n.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;(&quot;image_obj_tracked&quot;, 1);
+	image_objects = n.advertise&lt;autoware_msgs::image_obj_tracked&gt;(&quot;image_obj_tracked&quot;, 1);
 
 #if (CV_MAJOR_VERSION == 3)
 	generateColors(_colors, 25);
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//ROS STUFF
#include &lt;ros/ros.h&gt;

#include &lt;message_filters/subscriber.h&gt;
#include &lt;message_filters/time_synchronizer.h&gt;

#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;runtime_manager/ConfigCarKf.h&gt;
#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;

#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
#include &lt;std_msgs/Header.h&gt;

//TRACKING STUFF
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/objdetect/objdetect.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/video/tracking.hpp&gt;
#include &lt;opencv2/calib3d/calib3d.hpp&gt;

#include &lt;iostream&gt;
#include &lt;stdio.h&gt;

#include &lt;sstream&gt;
#include &lt;algorithm&gt;
#include &lt;iterator&gt;

#define SSTR( x ) dynamic_cast&lt; std::ostringstream &amp; &gt;( \
        ( std::ostringstream() &lt;&lt; std::dec &lt;&lt; x ) ).str()

#include &lt;opencv2/core/version.hpp&gt;
#if (CV_MAJOR_VERSION == 3)
#include &quot;gencolors.cpp&quot;
#else
#include &lt;opencv2/contrib/contrib.hpp&gt;
#endif

struct ObjectDetection_
{
	//ObjectDetection_();
	//ObjectDetection_(const cv::Rect&amp; rect, float score, int classId=1);
	cv::Rect rect;
	float score;
	int classID;
};

ros::Publisher image_objects;//ROS

static int 			DEFAULT_LIFESPAN; //LIFESPAN of objects before stop being tracked, in frames
static int	 		INITIAL_LIFESPAN; //LIFESPAN of objects before stop being tracked, in frames
static int			ORB_NUM_FEATURES;
static unsigned int	ORB_MIN_MATCHES;
static float		ORB_KNN_RATIO;
static float 		NOISE_COV;
static float 		MEAS_NOISE_COV;
static float 		ERROR_ESTIMATE_COV;
static float 		OVERLAPPING_PERC;
static bool 		SHOW_PREDICTIONS;
static bool 		USE_ORB;

static bool 		track_ready_;
static bool 		detect_ready_;
static cv_tracker_msgs::image_obj_tracked kf_objects_msg_;

struct kstate
{
	cv::KalmanFilter	KF;//KalmanFilter for this object
	cv::Rect		pos;//position of the object centerx, centery, width, height
	float			score;//DPM score
	bool			active;//if too old (lifespan) don't use
	unsigned int		id;//id of this tracked object
	cv::Mat			image;//image containing the detected and tracked object
	int			lifespan;//remaining lifespan before deprecate
	//ObjectDetection_ obj;//currently not used
	cv::Scalar	color;
	int		real_data;
	//std::vector&lt;KeyPoint&gt; orbKeypoints;
	//cv::Mat				orbDescriptors;
	float range;//range to this object gotten by range_fusion
	float min_height;//minimum height detected by range_fusion
	float max_height;//maximum height detected by range_fusion
};

//tracking required code
std::vector&lt;kstate&gt; 	_kstates;
std::vector&lt;bool&gt; 	_active;
std::vector&lt;cv::Scalar&gt;	_colors;
std::vector&lt;ObjectDetection_&gt; _dpm_detections;

std::string object_type;
std::vector&lt;float&gt; _ranges;
std::vector&lt;float&gt; _min_heights;
std::vector&lt;float&gt; _max_heights;

std_msgs::Header    image_objects_header;

//static bool _ready;

long int _counter = 0;
//

void getRectFromPoints(std::vector&lt; cv::Point2f &gt; corners, cv::Rect&amp; outBoundingBox)
{
	int min_x=0, min_y=0, max_x=0, max_y=0;
	for (unsigned int i=0; i&lt;corners.size(); i++)
	{
		if (corners[i].x &gt; 0)
		{
			if (corners[i].x &lt; min_x)
				min_x = corners[i].x;
			if (corners[i].x&gt;max_x)
				max_x = corners[i].x;
		}
		if (corners[i].y &gt; 0)
		{
			if (corners[i].y &lt; min_y)
				min_y = corners[i].y;
			if (corners[i].y &gt; max_y)
				max_y = corners[i].y;
		}
	}
	outBoundingBox.x 		= min_x;
	outBoundingBox.y 		= min_y;
	outBoundingBox.width 	= max_x - min_x;
	outBoundingBox.height 	= max_y - min_y;

}

/*bool orbMatch(cv::Mat&amp; inImageScene, cv::Mat&amp; inImageObj, cv::Rect&amp; outBoundingBox, unsigned int inMinMatches=2, float inKnnRatio=0.7)
{
	//vector of keypoints
	std::vector&lt; cv::KeyPoint &gt; keypointsO;
	std::vector&lt; cv::KeyPoint &gt; keypointsS;

	cv::Mat descriptors_object, descriptors_scene;

	cv::Mat outImg;
	inImageScene.copyTo(outImg);

	//-- Step 1: Extract keypoints
	cv::OrbFeatureDetector orb(ORB_NUM_FEATURES);
	orb.detect(inImageScene, keypointsS);
	if (keypointsS.size() &lt; ORB_MIN_MATCHES)
	{
		//cout &lt;&lt; &quot;Not enough keypoints S, object not found&gt;&quot; &lt;&lt; keypointsS.size() &lt;&lt; endl;
		return false;
	}
	orb.detect(inImageObj, keypointsO);
	if (keypointsO.size() &lt; ORB_MIN_MATCHES)
	{
		//cout &lt;&lt; &quot;Not enough keypoints O, object not found&gt;&quot; &lt;&lt; keypointsO.size() &lt;&lt; endl;
		return false;
	}

	//Calculate descriptors (feature vectors)
	cv::OrbDescriptorExtractor extractor;
	extractor.compute(inImageScene, keypointsS, descriptors_scene);
	extractor.compute(inImageObj, keypointsO, descriptors_object);

	//Matching descriptor vectors using FLANN matcher
	cv::BFMatcher matcher;
	//descriptors_scene.size(), keypointsO.size(), keypointsS.size();
	std::vector&lt; std::vector&lt; cv::DMatch &gt;  &gt; matches;
	matcher.knnMatch(descriptors_object, descriptors_scene, matches, 2);
	std::vector&lt; cv::DMatch &gt; good_matches;
	good_matches.reserve(matches.size());

	for (size_t i = 0; i &lt; matches.size(); ++i)
	{
		if (matches[i].size() &lt; 3)
			continue;

		const cv::DMatch &amp;m1 = matches[i][0];
		const cv::DMatch &amp;m2 = matches[i][1];

		if (m1.distance &lt;= inKnnRatio * m2.distance)
			good_matches.push_back(m1);
	}

	if ((good_matches.size() &gt;= inMinMatches))
	{
		std::vector&lt; cv::Point2f &gt; obj;
		std::vector&lt; cv::Point2f &gt; scene;

		for (unsigned int i = 0; i &lt; good_matches.size(); i++)
		{
			// Get the keypoints from the good matches
			obj.push_back(keypointsO[good_matches[i].queryIdx].pt);
			scene.push_back(keypointsS[good_matches[i].trainIdx].pt);
		}

		cv::Mat H = findHomography(obj, scene, CV_RANSAC);

		// Get the corners from the image_1 ( the object to be &quot;detected&quot; )
		std::vector&lt; cv::Point2f &gt; obj_corners(4);
		obj_corners[0] = cvPoint(0, 0); obj_corners[1] = cvPoint(inImageObj.cols, 0);
		obj_corners[2] = cvPoint(inImageObj.cols, inImageObj.rows); obj_corners[3] = cvPoint(0, inImageObj.rows);
		std::vector&lt; cv::Point2f &gt; scene_corners(4);

		perspectiveTransform(obj_corners, scene_corners, H);

		// Draw lines between the corners (the mapped object in the scene - image_2 )
		line(outImg, scene_corners[0], scene_corners[1], cv::Scalar(255, 0, 0), 2); //TOP line
		line(outImg, scene_corners[1], scene_corners[2], cv::Scalar(255, 0, 0), 2);
		line(outImg, scene_corners[2], scene_corners[3], cv::Scalar(255, 0, 0), 2);
		line(outImg, scene_corners[3], scene_corners[0], cv::Scalar(255, 0, 0), 2);

		//imshow(&quot;Scene&quot;, outImg);
		//imshow(&quot;Obj&quot;, inImageObj);
		//cvWaitKey(5);

		return true;
	}

	return false;
}*/

///Returns true if an im1 is contained in im2 or viceversa
bool crossCorr(cv::Mat im1, cv::Mat im2)
{
	//im1 roi from the previous frame
	//im2 roi fromcurrent frame
	if (im1.rows &lt;= 0 || im1.cols &lt;= 0 || im2.rows &lt;= 0 || im2.cols &lt;= 0)
		return false;

	cv::Mat result, larger_im, smaller_im;

	/// Create the result matrix
	int result_cols;
	int result_rows;

	//select largest image
	if (im2.cols &gt; im1.cols)
	{
		larger_im = im2;
		smaller_im = im1;
	}
	else
	{
		larger_im = im1;
		smaller_im = im2;
	}
	//check rows to be also larger otherwise crop the smaller to remove extra rows
	if (larger_im.rows &lt; smaller_im.rows)
	{
		//add rows to match sizes
		cv::Mat rows = cv::Mat::ones(smaller_im.rows - larger_im.rows, larger_im.cols, larger_im.type());
		larger_im.push_back(rows);
	}

	result_cols = larger_im.cols - smaller_im.cols + 1;
	result_rows = larger_im.rows - smaller_im.rows + 1;
	result.create(result_cols, result_rows, CV_32FC1);

	/// Do the Matching and Normalize
	matchTemplate(larger_im, smaller_im, result, CV_TM_CCORR_NORMED);
	//normalize(result, result, 0, 1, NORM_MINMAX, -1, cv::Mat());

	/// Localizing the best match with minMaxLoc
	double minVal; double maxVal; cv::Point minLoc; cv::Point maxLoc;
	cv::Point matchLoc;

	minMaxLoc(result, &amp;minVal, &amp;maxVal, &amp;minLoc, &amp;maxLoc, cv::Mat());

	matchLoc = maxLoc;

	/// Show me what you got
	cv::Mat scene = larger_im.clone();
	rectangle(scene, matchLoc, cv::Point(matchLoc.x + smaller_im.cols, matchLoc.y + smaller_im.rows), cv::Scalar(0, 0, 255), 2, 8, 0);
	//imshow(image_window, scene);
	//imshow(result_window, result);

	//if (maxVal&gt;0.89 &amp;&amp; minVal &lt;0.3)
	bool ret;
	int thresWidth = (larger_im.cols)*.7;
	if ( (maxVal &gt; 0.5) &amp;&amp; (smaller_im.cols &gt; thresWidth) )//good threshold and consistent size
	{

		//std::cout &lt;&lt; &quot;matched&quot; &lt;&lt; endl;
		ret = true;
	}
	else
	{
		//std::cout &lt;&lt; &quot;non matched&quot; &lt;&lt; endl;
		ret = false;
	}
	//cv::imshow(&quot;match1&quot;, scene);
	//cv::imshow(&quot;match2&quot;, smaller_im);

	return ret;
}

void posScaleToBbox(std::vector&lt;kstate&gt; kstates, std::vector&lt;kstate&gt;&amp; trackedDetections)
{
	for (unsigned int i = 0; i &lt; kstates.size(); i++)
	{
		if (kstates[i].active)
		{
			kstate tmp;
			tmp.pos.x = kstates[i].pos.x;// -(kstates[i].pos.width / 2);
			tmp.pos.y = kstates[i].pos.y;// -(kstates[i].pos.height / 2);
			tmp.pos.width = kstates[i].pos.width;
			tmp.pos.height = kstates[i].pos.height;
			tmp.color = kstates[i].color;
			tmp.id = kstates[i].id;
			tmp.score = kstates[i].score;
			tmp.lifespan = kstates[i].lifespan;
			tmp.real_data = kstates[i].real_data;
			tmp.range = kstates[i].range;
			tmp.min_height = kstates[i].min_height;
			tmp.max_height = kstates[i].max_height;

			//fill in also LAtentSvm object
			//tmp.obj.rect = tmp.pos;
			//tmp.obj.score = tmp.score;

			if (tmp.pos.x &lt; 0)
				tmp.pos.x = 0;
			if (tmp.pos.y &lt; 0)
				tmp.pos.y = 0;

			trackedDetections.push_back(tmp);
		}
	}
}

int getAvailableIndex(std::vector&lt;kstate&gt;&amp; kstates)
{
	unsigned int cur_size = kstates.size();
	std::vector&lt;bool&gt; ids;

	ids.resize(cur_size, false);

	for (unsigned int i=0; i&lt;cur_size;i++)
	{
		ids[kstates[i].id]= true;
	}
	for (unsigned int i=0; i&lt;cur_size;i++)
	{
		if(ids[i] == false)
			return i;
	}
	return cur_size;
}

void initTracking(ObjectDetection_ object, std::vector&lt;kstate&gt;&amp; kstates,
		  ObjectDetection_ detection,
		  cv::Mat&amp; image, std::vector&lt;cv::Scalar&gt; colors, float range)
{
	kstate new_state;
	//cv::KalmanFilter KF(4, 2, 0);//XY Only
	cv::KalmanFilter KF(8, 4, 0);

	/*cv::Mat_&lt;float&gt; measurement = (cv::Mat_&lt;float&gt;(2, 1) &lt;&lt; object.rect.x,//XY Only
		object.rect.y);*/
	cv::Mat_&lt;float&gt; measurement = (cv::Mat_&lt;float&gt;(4, 1) &lt;&lt; object.rect.x,
		object.rect.y, object.rect.width, object.rect.height);

	/*KF.transitioncv::Matrix = (cv::Mat_&lt;float&gt;(4, 4) &lt;&lt; 1, 0, 1, 0,//XY Only
												0, 1, 0, 1,
												0, 0, 1, 0,
												0, 0, 0, 1);*/
	KF.transitionMatrix = (cv::Mat_&lt;float&gt;(8, 8)
	&lt;&lt;	1, 0, 0, 0, 1, 0, 0, 0,
		0, 1, 0, 0, 0, 1, 0, 0,
		0, 0, 1, 0, 0, 0, 1, 0,
		0, 0, 0, 1, 0, 0, 0, 1,
		0, 0, 0, 0, 1, 0, 0, 0,
		0, 0, 0, 0, 0, 1, 0, 0,
		0, 0, 0, 0, 0, 0, 1, 0,
		0, 0, 0, 0, 0, 0, 0, 1);

	//init pre
	KF.statePre.at&lt;float&gt;(0) = object.rect.x;
	KF.statePre.at&lt;float&gt;(1) = object.rect.y;
	KF.statePre.at&lt;float&gt;(2) = object.rect.width;//XY Only
	KF.statePre.at&lt;float&gt;(3) = object.rect.height;//XY Only
	//init post
	KF.statePost.at&lt;float&gt;(0) = object.rect.x;
	KF.statePost.at&lt;float&gt;(1) = object.rect.y;
	KF.statePost.at&lt;float&gt;(2) = object.rect.width;//XY Only
	KF.statePost.at&lt;float&gt;(3) = object.rect.height;//XY Only

	cv::setIdentity(KF.measurementMatrix);
	cv::setIdentity(KF.processNoiseCov, cv:: Scalar::all(NOISE_COV));//1e-4
	cv::setIdentity(KF.measurementNoiseCov, cv::Scalar::all(MEAS_NOISE_COV));//1e-3
	cv::setIdentity(KF.errorCovPost, cv::Scalar::all(ERROR_ESTIMATE_COV));//100

	//clip detection
	//check that predicted positions are inside the image
	if (detection.rect.x &lt; 0)
		detection.rect.x = 0;
	if (detection.rect.x &gt; image.cols)
		detection.rect.x = image.cols - 1;
	if (detection.rect.y &lt; 0)
		detection.rect.y = 0;
	if (detection.rect.height &gt; image.rows)
		detection.rect.height = image.rows - 1;
	if (detection.rect.width + detection.rect.x &gt; image.cols)
		detection.rect.width = image.cols - detection.rect.x;
	if (detection.rect.height + detection.rect.y &gt; image.rows)
		detection.rect.height = image.rows - detection.rect.y;

	//save data to kstate
	new_state.active = true;
	new_state.image = image(cv::Rect(detection.rect.x,
		detection.rect.y,
		detection.rect.width,
		detection.rect.height)).clone();//Crop image and obtain only object (ROI)
	new_state.KF = KF;
	new_state.lifespan = INITIAL_LIFESPAN;//start only with 1
	new_state.pos = object.rect;
	new_state.score = object.score;
	new_state.id = getAvailableIndex(kstates);
	new_state.color = colors[new_state.id];
	new_state.real_data = 1;
	new_state.range = range;

	//extractOrbFeatures(new_state.image, new_state.orbKeypoints, new_state.orbDescriptors, ORB_NUM_FEATURES);

	kstates.push_back(new_state);

}

//checks whether an index was previously removed
bool isInRemoved(std::vector&lt;unsigned int&gt; removedIndices, unsigned int index)
{
	for (unsigned int i=0; i&lt; removedIndices.size(); i++)
	{
		if (index == removedIndices[i])
			return true;
	}
	return false;
}

void removeUnusedObjects(std::vector&lt;kstate&gt;&amp; states)
{
	std::vector&lt;kstate&gt;::iterator it;
	for(it = states.begin(); it != states.end();)
	{
		if (!(it-&gt;active))
			it = states.erase(it);
		else
			it++;
	}
}

bool alreadyMatched(int check_index, std::vector&lt;int&gt;&amp; matched_indices)
{
	for (unsigned int i = 0; i &lt; matched_indices.size(); i++)
	{
		if (matched_indices[i] == check_index)
			return true;
	}
	return false;
}

void Sort(const std::vector&lt;float&gt; in_scores, std::vector&lt;unsigned int&gt;&amp; in_out_indices)
{
	for (unsigned int i = 0; i &lt; in_scores.size(); i++)
		for (unsigned int j = i + 1; j &lt; in_scores.size(); j++)
		{
			if (in_scores[in_out_indices[j]] &gt; in_scores[in_out_indices[i]])
			{
				//float x_tmp = x[i];
				int index_tmp = in_out_indices[i];
				//x[i] = x[j];
				in_out_indices[i] = in_out_indices[j];
				//x[j] = x_tmp;
				in_out_indices[j] = index_tmp;
			}
		}
}

void ApplyNonMaximumSuppresion(std::vector&lt; kstate &gt;&amp; in_source, float in_nms_threshold)
{
	std::vector&lt; kstate &gt; tmp_source = in_source;

	if (tmp_source.empty())
		return ;

	unsigned int size = in_source.size();

	std::vector&lt;float&gt; area(size);
	std::vector&lt;float&gt; scores(size);
	std::vector&lt;int&gt; x1(size);
	std::vector&lt;int&gt; y1(size);
	std::vector&lt;int&gt; x2(size);
	std::vector&lt;int&gt; y2(size);
	std::vector&lt;unsigned int&gt; indices(size);
	std::vector&lt;bool&gt; is_suppresed(size);

	for(unsigned int i = 0; i&lt; in_source.size(); i++)
	{
		kstate tmp = in_source[i];
		area[i] = tmp.pos.width * tmp.pos.height;
		indices[i] = i;
		is_suppresed[i] = false;
		scores[i] = tmp.score;
		x1[i] = tmp.pos.x;
		y1[i] = tmp.pos.y;
		x2[i] = tmp.pos.width + tmp.pos.x;
		y2[i] = tmp.pos.height + tmp.pos.y;
	}

	Sort(scores, indices);//returns indices ordered based on scores

	for(unsigned int i=0; i&lt; size; i++)
	{
		if(!is_suppresed[indices[i]])
		{
			for(unsigned int j= i+1; j&lt; size; j++)
			{
				int x1_max = std::max(x1[indices[i]], x1[indices[j]]);
				int x2_min = std::min(x2[indices[i]], x2[indices[j]]);
				int y1_max = std::max(y1[indices[i]], y1[indices[j]]);
				int y2_min = std::min(y2[indices[i]], y2[indices[j]]);
				int overlap_width = x2_min - x1_max + 1;
				int overlap_height = y2_min - y1_max + 1;
				if(overlap_width &gt; 0 &amp;&amp; overlap_height&gt;0)
				{
					float overlap_part = (overlap_width*overlap_height)/area[indices[j]];
					if(overlap_part &gt; in_nms_threshold)
					{
						is_suppresed[indices[j]] = true;
					}
				}
			}
		}
	}

	unsigned int size_out = 0;
	for (unsigned int i = 0; i &lt; size; i++)
	{
		if (!is_suppresed[i])
			size_out++;
	}

	std::vector&lt; kstate &gt; filtered_detections(size_out);

	unsigned int index = 0;
	for(unsigned int i = 0 ; i &lt; size_out; i++)
	{
		if(!is_suppresed[indices[i]])
		{
			filtered_detections[index] = in_source[indices[i]];//x1[indices[i]];
			index++;
		}
	}
	in_source = filtered_detections;
}

void doTracking(std::vector&lt;ObjectDetection_&gt;&amp; detections, int frameNumber,
		std::vector&lt;kstate&gt;&amp; kstates, std::vector&lt;bool&gt;&amp; active, cv::Mat&amp; image,
		std::vector&lt;kstate&gt;&amp; trackedDetections, std::vector&lt;cv::Scalar&gt; &amp; colors)
{
	std::vector&lt;ObjectDetection_&gt; objects;
	//vector&lt;LatentSvmDetector::ObjectDetection_&gt; tracked_objects;
	std::vector&lt;bool&gt; predict_indices;//this will correspond to kstates i
	std::vector&lt;bool&gt; correct_indices;//this will correspond to kstates i
	std::vector&lt;int&gt; correct_detection_indices;//this will correspond to kstates i, used to store the index of the corresponding object
	std::vector&lt;bool&gt; add_as_new_indices;//this will correspond to detections j

	//predict_indices.assign(kstates.size(), true);//always predict
	correct_indices.assign(kstates.size(), false);//correct only those matched
	correct_detection_indices.assign(kstates.size(), false);//correct only those matched
	add_as_new_indices.assign(detections.size(), true);//if the detection was not found add as new

	//Convert Bounding box coordinates from (x1,y1,w,h) to (BoxCenterX, BoxCenterY, width, height)
	objects = detections;//bboxToPosScale(detections);

	std::vector&lt;int&gt; already_matched;
	//compare detections from this frame with tracked objects
	for (unsigned int j = 0; j &lt; detections.size(); j++)
	{
		for (unsigned int i = 0; i &lt; kstates.size(); i++)
		{
			//compare only to active tracked objects(not too old)
			if (kstates[i].active)
			{
				//extend the roi 20%
				int new_x = (detections[j].rect.x - detections[j].rect.width*.1);
				int new_y = (detections[j].rect.y - detections[j].rect.height*.1);

				if (new_x &lt; 0)			new_x = 0;
				if (new_x &gt; image.cols)	new_x = image.cols;
				if (new_y &lt; 0)			new_y = 0;
				if (new_y &gt; image.rows) new_y = image.rows;

				int new_width = detections[j].rect.width*1.2;
				int new_height = detections[j].rect.height*1.2;

				if (new_width  + new_x &gt; image.cols)	new_width  = image.cols - new_x;
				if (new_height + new_y &gt; image.rows)	new_height = image.rows - new_y;

				cv::Rect roi_20(new_x, new_y, new_width, new_height);
				//cv::Rect roi(detections[j].rect);
				cv::Rect roi(roi_20);
				cv::Mat currentObjectROI = image(roi).clone();//Crop image and obtain only object (ROI)

				//cv::Rect intersect = detections[j].rect &amp; kstates[i].pos;//check overlapping

				cv::Rect boundingbox;
				bool matched = false;
				//try to match with previous frame
				//if ( !USE_ORB )
					matched = ( !alreadyMatched(j, already_matched) &amp;&amp; crossCorr(kstates[i].image, currentObjectROI));
				//else
				//	matched = (!alreadyMatched(j, already_matched) &amp;&amp; orbMatch(currentObjectROI, kstates[i].image, boundingbox, ORB_MIN_MATCHES, ORB_KNN_RATIO));

				if(matched)
				{
					correct_indices[i] = true;//if ROI on this frame is matched to a previous object, correct
					correct_detection_indices[i] = j;//store the index of the detection corresponding to matched kstate
					add_as_new_indices[j] = false;//if matched do not add as new
					//kstates[i].image = currentObjectROI;//update image with current frame data
					kstates[i].score = detections[j].score;
					kstates[i].range = _ranges[j];
					already_matched.push_back(j);
				}//crossCorr

			}//kstates[i].active
		}//for (int i = 0; i &lt; kstates.size(); i++)
	}//for (int j = 0; j &lt; detections.size(); j++)


	//do prediction and correction for the marked states
	for (unsigned int i = 0; i &lt; kstates.size(); i++)
	{
		if (kstates[i].active)//predict and correct only active states
		{
			//update params before predicting
			cv::setIdentity(kstates[i].KF.measurementMatrix);
			cv::setIdentity(kstates[i].KF.processNoiseCov, cv::Scalar::all(NOISE_COV));//1e-4
			cv::setIdentity(kstates[i].KF.measurementNoiseCov, cv::Scalar::all(MEAS_NOISE_COV));//1e-3
			cv::setIdentity(kstates[i].KF.errorCovPost, cv::Scalar::all(ERROR_ESTIMATE_COV));//100

			cv::Mat prediction = kstates[i].KF.predict();
			cv::Mat correction;
			kstates[i].pos.x = prediction.at&lt;float&gt;(0);
			kstates[i].pos.y = prediction.at&lt;float&gt;(1);
			kstates[i].pos.width = prediction.at&lt;float&gt;(2);
			kstates[i].pos.height = prediction.at&lt;float&gt;(3);
			kstates[i].real_data = 0;
			kstates[i].range = 0.0f;//fixed to zero temporarily as this is not real_data
			kstates[i].min_height = 0.0f;//fixed to zero temporarily as this is not real_data
			kstates[i].max_height = 0.0f;//fixed to zero temporarily as this is not real_data

			//now do respective corrections on KFs (updates)
			if (correct_indices[i])
			{
				//a match was found hence update KF measurement
				int j = correct_detection_indices[i];//obtain the index of the detection

				//cv::Mat_&lt;float&gt; measurement = (cv::Mat_&lt;float&gt;(2, 1) &lt;&lt; objects[j].rect.x, //XY ONLY
				//												objects[j].rect.y);
				cv::Mat_&lt;float&gt; measurement = (cv::Mat_&lt;float&gt;(4, 1) &lt;&lt; objects[j].rect.x,
					objects[j].rect.y,
					objects[j].rect.width,
					objects[j].rect.height);

				correction = kstates[i].KF.correct(measurement);//UPDATE KF with new info
				kstates[i].lifespan = DEFAULT_LIFESPAN; //RESET Lifespan of object

				//kstates[i].pos.width = objects[j].rect.width;//XY ONLY
				//kstates[i].pos.height = objects[j].rect.height;//XY ONLY

				//use real data instead of predicted if set
				kstates[i].pos.x = objects[j].rect.x;
				kstates[i].pos.y = objects[j].rect.y;
				kstates[i].pos.width = objects[j].rect.width;
				kstates[i].pos.height = objects[j].rect.height;
				kstates[i].real_data = 1;
				//cv::Mat im1 = image(kstates[i].pos);
				//cv::Mat im2 = image(objects[j].rect);
				kstates[i].range = _ranges[j];
				kstates[i].min_height = _min_heights[j];
				kstates[i].max_height = _max_heights[j];
			}


			//check that new widths and heights don't go beyond the image size
			if (kstates[i].pos.width + kstates[i].pos.x &gt; image.cols)
				kstates[i].pos.width = image.cols - kstates[i].pos.x;
			if (kstates[i].pos.height + kstates[i].pos.y &gt; image.rows)
				kstates[i].pos.height = image.rows - kstates[i].pos.y;

			//check that predicted positions are inside the image
			if (kstates[i].pos.x &lt; 0)
				kstates[i].pos.x = 0;
			if (kstates[i].pos.x &gt; image.cols)
				kstates[i].pos.x = image.cols;
			if (kstates[i].pos.y &lt; 0)
				kstates[i].pos.y = 0;
			if (kstates[i].pos.y &gt; image.rows)
				kstates[i].pos.y = image.rows;

			//remove those where the dimensions of are unlikely to be real
			if (kstates[i].pos.width &gt; kstates[i].pos.height*4)
				kstates[i].active = false;

			if (kstates[i].pos.height &gt; kstates[i].pos.width*2)
				kstates[i].active = false;

			kstates[i].lifespan--;//reduce lifespan
			if (kstates[i].lifespan &lt;= 0)
			{
				kstates[i].active = false; //Too old, stop tracking.
			}
		}
	}

	//finally add non matched detections as new
	for (unsigned int i = 0; i &lt; add_as_new_indices.size(); i++)
	{
		if (add_as_new_indices[i])
		{
			initTracking(objects[i], kstates, detections[i], image, colors, _ranges[i]);
		}
	}
	/*
	//check overlapping states and remove them
	float overlap = (OVERLAPPING_PERC/100);
	std::vector&lt;unsigned int&gt; removedIndices;
	for (unsigned int i = 0; i &lt; kstates.size() ; i++)
	{
		for (unsigned int j = kstates.size() - 1; j &gt; 0; j--)
		{
			if (i==j || isInRemoved(removedIndices, i) || isInRemoved(removedIndices, j))
				continue;
			//cout &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot; j:&quot; &lt;&lt; j &lt;&lt; endl;
			cv::Rect intersection = kstates[i].pos &amp; kstates[j].pos;

			if ( ( (intersection.width &gt;= kstates[i].pos.width * overlap) &amp;&amp; (intersection.height &gt;= kstates[i].pos.height * overlap) ) ||
				( (intersection.width &gt;= kstates[j].pos.width * overlap) &amp;&amp; (intersection.height &gt;= kstates[j].pos.height * overlap) ) )
			{
				//if one state is overlapped by &quot;overlap&quot; % remove it (mark it as unused
				if (kstates[i].real_data &amp;&amp; !(kstates[j].real_data))
				{
					kstates[j].active = false;
					removedIndices.push_back(j);
				}
				else if (!(kstates[i].real_data) &amp;&amp; (kstates[j].real_data))
				{
					kstates[i].active = false;
					removedIndices.push_back(i);
				}
				else
				{
					kstates[j].active = false;
					removedIndices.push_back(j);
				}
			}
		}
	}*/
	ApplyNonMaximumSuppresion(kstates, OVERLAPPING_PERC);

	removeUnusedObjects(kstates);

	//return to x,y,w,h
	posScaleToBbox(kstates, trackedDetections);

}

void publish_if_possible()
{
	if (track_ready_ &amp;&amp; detect_ready_)
	{
		image_objects.publish(kf_objects_msg_);
		track_ready_ = false;
		detect_ready_ = false;
	}
}

void trackAndDrawObjects(cv::Mat&amp; image, int frameNumber, std::vector&lt;ObjectDetection_&gt; detections,
			 std::vector&lt;kstate&gt;&amp; kstates, std::vector&lt;bool&gt;&amp; active,
			 std::vector&lt;cv::Scalar&gt; colors, const sensor_msgs::Image&amp; image_source)
{
	std::vector&lt;kstate&gt; tracked_detections;

	cv::TickMeter tm;
	tm.start();
	//std::cout &lt;&lt; &quot;START tracking...&quot;;
	doTracking(detections, frameNumber, kstates, active, image, tracked_detections, colors);
	tm.stop();
	//std::cout &lt;&lt; &quot;END Tracking time = &quot; &lt;&lt; tm.getTimeSec() &lt;&lt; &quot; sec&quot; &lt;&lt; std::endl;

	//ROS
	int num = tracked_detections.size();
	std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; rect_ranged_array;
	std::vector&lt;int&gt; real_data(num,0);
	std::vector&lt;int&gt; obj_id(num, 0);
	std::vector&lt;int&gt; lifespan(num, 0);
	//ENDROS

	for (size_t i = 0; i &lt; tracked_detections.size(); i++)
	{
		kstate od = tracked_detections[i];
		cv_tracker_msgs::image_rect_ranged rect_ranged_;

		//od.rect contains x,y, width, height
		rectangle(image, od.pos, od.color, 3);
		putText(image, SSTR(od.id), cv::Point(od.pos.x + 4, od.pos.y + 13), cv::FONT_HERSHEY_SIMPLEX, 0.55, od.color, 2);
		//ROS
		obj_id[i] = od.id; // ?
		rect_ranged_.rect.x	= od.pos.x;
		rect_ranged_.rect.y	= od.pos.y;
		rect_ranged_.rect.width	= od.pos.width;
		rect_ranged_.rect.height = od.pos.height;
		rect_ranged_.range	= od.range;
		rect_ranged_.min_height	= od.min_height;
		rect_ranged_.max_height	= od.max_height;

		rect_ranged_array.push_back(rect_ranged_);

		real_data[i] = od.real_data;
		lifespan[i] = od.lifespan;
		//ENDROS
	}
	//more ros
	cv_tracker_msgs::image_obj_tracked kf_objects_msg;

	kf_objects_msg.type = object_type;
	kf_objects_msg.total_num = num;
	copy(rect_ranged_array.begin(), rect_ranged_array.end(), back_inserter(kf_objects_msg.rect_ranged)); // copy vector
	copy(real_data.begin(), real_data.end(), back_inserter(kf_objects_msg.real_data)); // copy vector
	copy(obj_id.begin(), obj_id.end(), back_inserter(kf_objects_msg.obj_id)); // copy vector
	copy(lifespan.begin(), lifespan.end(), back_inserter(kf_objects_msg.lifespan)); // copy vector

//	kf_objects_msg_.header = image_source.header;
	kf_objects_msg.header = image_objects_header;
	kf_objects_msg_ = kf_objects_msg;;
	track_ready_ = true;
	publish_if_possible();

	//cout &lt;&lt; &quot;.&quot;&lt;&lt; endl;
}

void image_callback(const sensor_msgs::Image&amp; image_source)
{
	//if (!_ready)
	//	return;

	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
	cv::Mat imageTrack = cv_image-&gt;image;
	trackAndDrawObjects(imageTrack, _counter, _dpm_detections, _kstates, _active, _colors, image_source);
	//_ready=false;
	//imshow(&quot;Tracked&quot;, imageTrack);

	_counter++;
}

void detections_callback(cv_tracker_msgs::image_obj_ranged image_objects_msg)
{
	if(!detect_ready_)
	{
		unsigned int num = image_objects_msg.obj.size();
		std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects = image_objects_msg.obj;
		object_type = image_objects_msg.type;
		image_objects_header = image_objects_msg.header;
		//points are X,Y,W,H and repeat for each instance
		_dpm_detections.clear();
		_ranges.clear();
		_min_heights.clear();
		_max_heights.clear();

		for (unsigned int i=0; i&lt;num;i++)
		{
			cv::Rect tmp;
			tmp.x = objects.at(i).rect.x;
			tmp.y = objects.at(i).rect.y;
			tmp.width = objects.at(i).rect.width;
			tmp.height = objects.at(i).rect.height;
			ObjectDetection_ obj_tmp;
			obj_tmp.rect = tmp; obj_tmp.score=0;
			_dpm_detections.push_back(obj_tmp);
			_ranges.push_back(objects.at(i).range);
			_min_heights.push_back(objects.at(i).min_height);
			_max_heights.push_back(objects.at(i).max_height);
		}
		//_ready = true;
		detect_ready_ = true;
	}
	//cout &lt;&lt; &quot;received pos&quot; &lt;&lt; endl;

	publish_if_possible();
}

static void kf_config_cb(const runtime_manager::ConfigCarKf::ConstPtr&amp; param)
{
	if (param-&gt;initial_lifespan &gt; 0)
		INITIAL_LIFESPAN	= param-&gt;initial_lifespan;
	if (param-&gt;default_lifespan &gt; 0)
		DEFAULT_LIFESPAN	= param-&gt;default_lifespan;
	if(param-&gt;noise_covariance &gt; 0)
		NOISE_COV			= param-&gt;noise_covariance;
	if(param-&gt;measurement_noise_covariance &gt; 0)
		MEAS_NOISE_COV		= param-&gt;measurement_noise_covariance;
	if(param-&gt;error_estimate_covariance &gt; 0)
		ERROR_ESTIMATE_COV	= param-&gt;error_estimate_covariance;
	if(param-&gt;percentage_of_overlapping &gt; 0)
		OVERLAPPING_PERC	= param-&gt;percentage_of_overlapping;

	ORB_NUM_FEATURES	= 2000;
	ORB_MIN_MATCHES		= 3;
	ORB_KNN_RATIO		= 0.7;

	USE_ORB				= param-&gt;use_orb;
}

void init_params()
{
	DEFAULT_LIFESPAN	= 8;
	INITIAL_LIFESPAN	= 4;
	NOISE_COV			= 1;
	MEAS_NOISE_COV		= 25;
	ERROR_ESTIMATE_COV	= 1000000;
	OVERLAPPING_PERC	= 80.0;
	SHOW_PREDICTIONS	= false;

	ORB_NUM_FEATURES	= 2000;
	ORB_MIN_MATCHES		= 3;
	ORB_KNN_RATIO		= 0.7;
	USE_ORB				= false;
}

int kf_main(int argc, char* argv[])
{
	ros::init(argc, argv, &quot;kf&quot;);
	ros::NodeHandle n;
	ros::NodeHandle private_nh(&quot;~&quot;);

	image_objects = n.advertise&lt;cv_tracker_msgs::image_obj_tracked&gt;(&quot;image_obj_tracked&quot;, 1);

#if (CV_MAJOR_VERSION == 3)
	generateColors(_colors, 25);
#else
	cv::generateColors(_colors, 25);

#endif
	std::string image_topic;
	std::string obj_topic;
	if (private_nh.getParam(&quot;image_node&quot;, image_topic))
    	{
        	ROS_INFO(&quot;Setting image node to %s&quot;, image_topic.c_str());
    	}
	else
	{
		ROS_INFO(&quot;No image node received, defaulting to image_raw, you can use _image_node:=YOUR_TOPIC&quot;);
		image_topic = &quot;/image_raw&quot;;
	}
	if (private_nh.getParam(&quot;object_node&quot;, image_topic))
    	{
        	ROS_INFO(&quot;Setting object node to %s&quot;, image_topic.c_str());
    	}
	else
	{
		ROS_INFO(&quot;No object node received, defaulting to image_obj_ranged, you can use _object_node:=YOUR_TOPIC&quot;);
		obj_topic = &quot;image_obj_ranged&quot;;
	}

	init_params();

	ros::Subscriber sub_image = n.subscribe(image_topic, 1, image_callback);
	ros::Subscriber sub_dpm = n.subscribe(obj_topic, 1, detections_callback);


	std::string config_topic(&quot;/config&quot;);
	config_topic += ros::this_node::getNamespace() + &quot;/kf&quot;;
	ros::Subscriber config_subscriber = n.subscribe(config_topic, 1, kf_config_cb);

	//TimeSynchronizer&lt;Image, dpm::ImageObjects&gt; sync(image_sub, pos_sub, 10);

	//sync.registerCallback(boost::bind(&amp;sync_callback, _1, _2));
	track_ready_ = false;
	detect_ready_ = false;

	ros::spin();
	return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/image_d_viewer/image_d_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/image_d_viewer/image_d_viewer.cpp">
				<diff>@@ -36,7 +36,7 @@
 #include &quot;ros/ros.h&quot;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 #include &lt;sensor_msgs/CompressedImage.h&gt;
-#include &quot;cv_tracker_msgs/image_obj_ranged.h&quot;
+#include &quot;autoware_msgs/image_obj_ranged.h&quot;
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
 #define NO_DATA 0
@@ -49,8 +49,8 @@ static IplImage temp;
 static IplImage *image;
 static double ratio = 1;	//resize ratio
 
-static cv_tracker_msgs::image_obj_ranged car_fused_objects;
-static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::image_obj_ranged car_fused_objects;
+static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
 
 static const int OBJ_RECT_THICKNESS = 3;
 static void showImage();
@@ -64,7 +64,7 @@ static inline bool isNearlyNODATA(float x)
 }
 
 void showRects(IplImage *Image,
-               std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+               std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                double ratio,
                CvScalar col)
 {
@@ -80,7 +80,7 @@ void showRects(IplImage *Image,
     }
 }
 
-static void obj_carCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objects)
+static void obj_carCallback(const autoware_msgs::image_obj_ranged&amp; fused_objects)
 {
     if(image == NULL){
       return;
@@ -89,7 +89,7 @@ static void obj_carCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objec
     showImage();
 }
 
-static void obj_personCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objects)
+static void obj_personCallback(const autoware_msgs::image_obj_ranged&amp; fused_objects)
 {
     if(image == NULL){
       return;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;

#include &quot;ros/ros.h&quot;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;sensor_msgs/CompressedImage.h&gt;
#include &quot;cv_tracker_msgs/image_obj_ranged.h&quot;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
#define NO_DATA 0

static char window_name_base[] = &quot;image_d_viewer&quot;;
static std::string window_name;
//for imageCallback
static cv_bridge::CvImagePtr cv_image;
static IplImage temp;
static IplImage *image;
static double ratio = 1;	//resize ratio

static cv_tracker_msgs::image_obj_ranged car_fused_objects;
static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;

static const int OBJ_RECT_THICKNESS = 3;
static void showImage();

/* check whether floating value x is nearly 0 or not */
static inline bool isNearlyNODATA(float x)
{
  float abs_x  = (float)fabs(x);
  const int rangeScale = 100;
  return(abs_x &lt; FLT_MIN*rangeScale);
}

void showRects(IplImage *Image,
               std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
               double ratio,
               CvScalar col)
{
    unsigned int object_num = objects.size();
    for(unsigned int i = 0; i &lt; object_num; i++)
    {
        if (!isNearlyNODATA(objects.at(i).range))
        {
            CvPoint p1=cvPoint(objects.at(i).rect.x, objects.at(i).rect.y);
            CvPoint p2=cvPoint(objects.at(i).rect.x + objects.at(i).rect.width, objects.at(i).rect.y + objects.at(i).rect.height);
            cvRectangle(Image,p1,p2,col,OBJ_RECT_THICKNESS);
        }
    }
}

static void obj_carCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objects)
{
    if(image == NULL){
      return;
    }
    car_fused_objects = fused_objects;
    showImage();
}

static void obj_personCallback(const cv_tracker_msgs::image_obj_ranged&amp; fused_objects)
{
    if(image == NULL){
      return;
    }
    pedestrian_fused_objects = fused_objects;
    showImage();
}

static void imageCallback(const sensor_msgs::Image&amp; image_source)
{
    cv_image = cv_bridge::toCvCopy(image_source, sensor_msgs::image_encodings::BGR8);
    temp = cv_image-&gt;image;
    image = &amp;temp;
    showImage();
}

static void showImage()
{
    IplImage* image_clone = cvCloneImage(image);
    char distance_string[32];
    CvFont dfont;
    float hscale      = 0.7f;
    float vscale      = 0.7f;
    float italicscale = 0.0f;
    int  thickness    = 1;

    std::string objectLabel;
    CvFont      dfont_label;
    float       hscale_label = 0.5f;
    float       vscale_label = 0.5f;
    CvSize      text_size;
    int         baseline     = 0;

    cvInitFont(&amp;dfont_label, CV_FONT_HERSHEY_COMPLEX, hscale_label, vscale_label, italicscale, thickness, CV_AA);
    objectLabel = car_fused_objects.type;
    cvGetTextSize(objectLabel.data(),
                  &amp;dfont_label,
                  &amp;text_size,
                  &amp;baseline);

    /*
     * Plot obstacle frame
     */
    showRects(image_clone,
              car_fused_objects.obj,
              ratio,
              cvScalar(255.0,255.0,0.0));
    showRects(image_clone,
              pedestrian_fused_objects.obj,
              ratio,
              cvScalar(0.0,255.0,0.0));


    /*
     * Plot car distance data on image
     */
    for (unsigned int i = 0; i &lt; car_fused_objects.obj.size(); i++) {
      if(!isNearlyNODATA(car_fused_objects.obj.at(i).range)) {
          int rect_x      = car_fused_objects.obj.at(i).rect.x;
          int rect_y      = car_fused_objects.obj.at(i).rect.y;
          int rect_width  = car_fused_objects.obj.at(i).rect.width;
          int rect_height = car_fused_objects.obj.at(i).rect.height;
          float range     = car_fused_objects.obj.at(i).range;

          /* put label */
          CvPoint labelOrg = cvPoint(rect_x - OBJ_RECT_THICKNESS,
                                     rect_y - baseline - OBJ_RECT_THICKNESS);
          cvRectangle(image_clone,
                      cvPoint(labelOrg.x + 0, labelOrg.y + baseline),
                      cvPoint(labelOrg.x + text_size.width, labelOrg.y - text_size.height),
                      CV_RGB(0, 0, 0), // label background color is black
                      -1, 8, 0
                      );
          cvPutText(image_clone,
                    objectLabel.data(),
                    labelOrg,
                    &amp;dfont_label,
                    CV_RGB(255, 255, 255) // label text color is white
                    );

          /* put distance data */
            cvRectangle(image_clone,
                        cv::Point(rect_x + (rect_width/2) - (((int)log10(range/100)+1) * 5 + 45),
                                  rect_y + rect_height + 5),
                        cv::Point(rect_x + (rect_width/2) + (((int)log10(range/100)+1) * 8 + 38),
                                  rect_y + rect_height + 30),
                        cv::Scalar(255,255,255), -1);
            cvInitFont (&amp;dfont, CV_FONT_HERSHEY_COMPLEX , hscale, vscale, italicscale, thickness, CV_AA);
            sprintf(distance_string, &quot;%.2f m&quot;, range / 100); //unit of length is meter
            cvPutText(image_clone,
                      distance_string,
                      cvPoint(rect_x + (rect_width/2) - (((int)log10(range/100)+1) * 5 + 40),
                              rect_y + rect_height + 25),
                      &amp;dfont,
                      CV_RGB(255, 0, 0));
        }
    }

    objectLabel = pedestrian_fused_objects.type;
    cvGetTextSize(objectLabel.data(),
                  &amp;dfont_label,
                  &amp;text_size,
                  &amp;baseline);

    /*
     * Plot pedestrian distance data on image
     */
    for (unsigned int i = 0; i &lt; pedestrian_fused_objects.obj.size(); i++) {
      if(!isNearlyNODATA(pedestrian_fused_objects.obj.at(i).range)) {
          int rect_x      = pedestrian_fused_objects.obj.at(i).rect.x;
          int rect_y      = pedestrian_fused_objects.obj.at(i).rect.y;
          int rect_width  = pedestrian_fused_objects.obj.at(i).rect.width;
          int rect_height = pedestrian_fused_objects.obj.at(i).rect.height;
          float range     = pedestrian_fused_objects.obj.at(i).range;

          /* put label */
          CvPoint labelOrg = cvPoint(rect_x - OBJ_RECT_THICKNESS,
                                     rect_y - baseline - OBJ_RECT_THICKNESS);
          cvRectangle(image_clone,
                      cvPoint(labelOrg.x + 0, labelOrg.y + baseline),
                      cvPoint(labelOrg.x + text_size.width, labelOrg.y - text_size.height),
                      CV_RGB(0, 0, 0), // label background color is black
                      -1, 8, 0
                      );
          cvPutText(image_clone,
                    objectLabel.data(),
                    labelOrg,
                    &amp;dfont_label,
                    CV_RGB(255, 255, 255) // label text color is white
                    );

          /* put distance data */
            cvRectangle(image_clone,
                        cv::Point(rect_x + (rect_width/2) - (((int)log10(range/100)+1) * 5 + 45),
                                  rect_y + rect_height + 5),
                        cv::Point(rect_x + (rect_width/2) + (((int)log10(range/100)+1) * 8 + 38),
                                  rect_y + rect_height + 30),
                        cv::Scalar(255,255,255), -1);
            cvInitFont (&amp;dfont, CV_FONT_HERSHEY_COMPLEX , hscale, vscale, italicscale, thickness, CV_AA);
            sprintf(distance_string, &quot;%.2f m&quot;, range / 100); //unit of length is meter
            cvPutText(image_clone,
                      distance_string,
                      cvPoint(rect_x + (rect_width/2) - (((int)log10(range/100)+1) * 5 + 40),
                              rect_y + rect_height + 25),
                      &amp;dfont,
                      CV_RGB(255, 0, 0));
        }
    }

    /*
     * Show image
     */
    if (cvGetWindowHandle(window_name.c_str()) != NULL) // Guard not to write destroyed window by using close button on the window
      {
        cvShowImage(window_name.c_str(), image_clone);
        cvWaitKey(2);
      }
    cvReleaseImage(&amp;image_clone);
}

int main(int argc, char **argv)
{
   /**
    * The ros::init() function needs to see argc and argv so that it can perform
    * any ROS arguments and name remapping that were provided at the command line. For programmatic
    * remappings you can use a different version of init() which takes remappings
    * directly, but for most command-line programs, passing argc and argv is the easiest
    * way to do it.  The third argument to init() is the name of the node.
    *
    * You must call one of the versions of ros::init() before using any other
    * part of the ROS system.
    */


    ros::init(argc, argv, &quot;image_d_viewer&quot;);

    /**
     * NodeHandle is the main access point to communications with the ROS system.
     * The first NodeHandle constructed will fully initialize this node, and the last
     * NodeHandle destructed will close down the node.
     */
    ros::NodeHandle n;
    ros::NodeHandle private_nh(&quot;~&quot;);

    /**
     * The subscribe() call is how you tell ROS that you want to receive messages
     * on a given topic.  This invokes a call to the ROS
     * master node, which keeps a registry of who is publishing and who
     * is subscribing.  Messages are passed to a callback function, here
     * called Callback.  subscribe() returns a Subscriber object that you
     * must hold on to until you want to unsubscribe.  When all copies of the Subscriber
     * object go out of scope, this callback will automatically be unsubscribed from
     * this topic.
     *
     * The second parameter to the subscribe() function is the size of the message
     * queue.  If messages are arriving faster than they are being processed, this
     * is the number of messages that will be buffered up before beginning to throw
     * away the oldest ones.
     */
    std::string image_topic;
    std::string car_topic;
    std::string person_topic;

    if (private_nh.getParam(&quot;image_raw_topic&quot;, image_topic)) {
      ROS_INFO(&quot;Setting image topic to %s&quot;, image_topic.c_str());
    } else {
      ROS_INFO(&quot;No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE&quot;);
      image_topic = &quot;/image_raw&quot;;
    }

    if (!private_nh.getParam(&quot;car_topic&quot;, car_topic)) {
      car_topic = &quot;/obj_car/image_obj_ranged&quot;;
    }

    if (!private_nh.getParam(&quot;person_topic&quot;, person_topic)) {
      person_topic = &quot;/obj_person/image_obj_ranged&quot;;
    }

    std::string name_space_str = ros::this_node::getNamespace();
    if (name_space_str != &quot;/&quot;) {
      window_name = std::string(window_name_base) + &quot; (&quot; + ros::this_node::getNamespace() + &quot;)&quot;;
    }
    else {
      window_name = std::string(window_name_base);
    }
    cvNamedWindow(window_name.c_str(), 2);
    cvStartWindowThread();
    image = NULL;
    car_fused_objects.obj.clear();
    pedestrian_fused_objects.obj.clear();

    ros::Subscriber image_sub = n.subscribe(image_topic, 1, imageCallback);
    ros::Subscriber obj_car_sub = n.subscribe(car_topic, 1, obj_carCallback);
    ros::Subscriber obj_person_sub = n.subscribe(person_topic, 1, obj_personCallback);

    /**
     * ros::spin() will enter a loop, pumping callbacks.  With this version, all
     * callbacks will be called from within this thread (the main one).  ros::spin()
     * will exit when Ctrl-C is pressed, or the node is shutdown by the master.
     */
    ros::spin();
    cvDestroyWindow(window_name.c_str());

    return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/image_viewer/image_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/image_viewer/image_viewer.cpp">
				<diff>@@ -44,8 +44,8 @@
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
 
-#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
-#include &lt;cv_tracker_msgs/image_obj.h&gt;
+#include &lt;autoware_msgs/image_obj_tracked.h&gt;
+#include &lt;autoware_msgs/image_obj.h&gt;
 
 //DPM related
 static std::vector&lt;cv::Rect&gt; cars;		//objects detected
@@ -215,7 +215,7 @@ static void image_viewer_callback(const sensor_msgs::Image&amp; image_source)
 	_drawing = false;
 }
 
-static void image_obj_update_cb(const cv_tracker_msgs::image_obj&amp; image_objs)
+static void image_obj_update_cb(const autoware_msgs::image_obj&amp; image_objs)
 {
 	if(_drawing)
 		return;
@@ -245,7 +245,7 @@ static void image_obj_update_cb(const cv_tracker_msgs::image_obj&amp; image_objs)
 	}
 }
 
-static void image_obj_updater_cb_tracked(const cv_tracker_msgs::image_obj_tracked&amp; image_objs_tracked_msg)
+static void image_obj_updater_cb_tracked(const autoware_msgs::image_obj_tracked&amp; image_objs_tracked_msg)
 {
 	if(_drawing)
 		return;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *	list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *	this list of conditions and the following disclaimer in the documentation
 *	and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *	contributors may be used to endorse or promote products derived from
 *	this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;string&gt;
#include &lt;vector&gt;

#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv2/core/version.hpp&gt;
#if (CV_MAJOR_VERSION == 3)
#include &quot;gencolors.cpp&quot;
#else
#include &lt;opencv2/contrib/contrib.hpp&gt;
#endif

#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;

#include &lt;cv_tracker_msgs/image_obj_tracked.h&gt;
#include &lt;cv_tracker_msgs/image_obj.h&gt;

//DPM related
static std::vector&lt;cv::Rect&gt; cars;		//objects detected
static std::vector&lt;float&gt; cars_score;		//score of each object
//KF related
static std::vector&lt;cv::Rect&gt; cars_tracked;	//objects tracked for current frame
static std::vector&lt;int&gt; cars_tracked_lifespan;	//remaining lifespan
static std::vector&lt;int&gt; cars_tracked_id;	//objects' id
static std::vector&lt;int&gt; cars_tracked_real_data;	//states if the data contained in the index is real or prediction

//DPM related
static std::vector&lt;cv::Rect&gt; peds;
static std::vector&lt;float&gt; peds_score;
//KF related
static std::vector&lt;cv::Rect&gt; peds_tracked;
static std::vector&lt;int&gt; peds_tracked_lifespan;
static std::vector&lt;int&gt; peds_tracked_id;
static std::vector&lt;int&gt; peds_tracked_real_data;

static std::vector&lt;cv::Scalar&gt; _colors;

static const int OBJ_RECT_THICKNESS = 3;

static bool _drawing = false;
static bool car_track_ready = false;
static bool car_dpm_ready = false;
static bool ped_track_ready = false;
static bool ped_dpm_ready = false;

static bool car_image_obj_ready = false;
static bool pedestrian_image_obj_ready = false;

static const std::string window_name = &quot;Image Viewer&quot;;

/*static void dashed_rectangle(cv::Mat&amp; img, const cv::Rect&amp; r, const cv::Scalar&amp; color,
			     int thickness = 2, int dash_length = 10)
{
	//draw horizontal dashed lines
	for (int i = 0; i &lt; r.width; i+=dash_length) {
		cv::line(img, cv::Point(r.x+i, r.y),  cv::Point(r.x+i+(dash_length/2), r.y), color, thickness);
		cv::line(img, cv::Point(r.x+i, r.y + r.height), cv::Point(r.x+i+(dash_length/2), r.y + r.height), color, thickness);
	}

	//draw vertical dashes lines
	for (int i = 0; i &lt; r.height; i+=dash_length) {
		cv::line(img, cv::Point(r.x, r.y+i), cv::Point(r.x, r.y+i+(dash_length/2)), color, thickness);
		cv::line(img, cv::Point(r.x +r.width, r.y+i), cv::Point(r.x+ r.width, r.y+i+(dash_length/2)), color, thickness);
	}
}*/

static void drawDetections(std::vector&lt;cv::Rect&gt; dets, std::vector&lt;float&gt; scores, std::string objectLabel, IplImage frame)
{
	/* variables for object label */
	CvFont font;
	const float hscale = 0.5f;
	const float vscale = 0.5f;
	const float italicScale = 0.0f;
	const int thickness = 1;
	CvSize text_size;
	int baseline = 0;

	cvInitFont(&amp;font, CV_FONT_HERSHEY_COMPLEX, hscale, vscale, italicScale, thickness, CV_AA);

	//UNTRACKED
	for(std::size_t i = 0; i &lt; dets.size(); ++i) {
#ifdef TEMP_DISABLED
		//temporal way to avoid drawing detections in the sky
		if (dets[i].y &lt;= frame.height * 0.3)
			continue;
#endif
		std::ostringstream label;
		label &lt;&lt; objectLabel &lt;&lt; &quot;:&quot; &lt;&lt; std::setprecision(2) &lt;&lt; scores[i];
		std::string text = label.str();

		//get text size
		cvGetTextSize(text.data(),
			&amp;font,
			&amp;text_size,
			&amp;baseline);

		//cvRectangle( &amp;frame,
			//cvPoint(dets[i].x, dets[i].y),
			//cvPoint(dets[i].x+dets[i].width, dets[i].y+dets[i].height),
			//CV_RGB(0, 0, 255), OBJ_RECT_THICKNESS, CV_AA, 0);
		cvCircle(&amp;frame, cvPoint(dets[i].x+dets[i].width/2, dets[i].y+dets[i].height/2), 30, cvScalar(0,255,0),3);		/* draw object label */
		CvPoint textOrg = cvPoint(dets[i].x - OBJ_RECT_THICKNESS, dets[i].y - baseline - OBJ_RECT_THICKNESS);

		cvRectangle(&amp;frame,
			cvPoint(textOrg.x + 0 , textOrg.y + baseline),
			cvPoint(textOrg.x + text_size.width, textOrg.y - text_size.height),
			CV_RGB(0, 0, 0), // text background is black
			-1, 8, 0);
		cvPutText(&amp;frame,
			text.data(),
			textOrg,
			&amp;font,
			CV_RGB(255, 255, 255) // text color is white
			);
	}
}

static void drawTracked(std::vector&lt;cv::Rect&gt; dets, std::vector&lt;int&gt; lifespan, std::vector&lt;int&gt; obj_id,
			std::vector&lt;int&gt; real_data, std::string objectLabel, cv::Mat imageTrack)
{
	for(std::size_t i=0; i&lt;dets.size();i++) {
#ifdef TEMP_DISABLED
		//temporal way to avoid drawing detections in the sky
		if (dets[i].y &lt;= imageTrack.rows * 0.3)
			continue;
#endif

		std::ostringstream label;
		label &lt;&lt; objectLabel &lt;&lt; &quot;_&quot; &lt;&lt; obj_id[i] &lt;&lt; &quot;:&quot; &lt;&lt; std::setprecision(2) &lt;&lt; lifespan[i];
		std::string text = label.str();

		//if (real_data[i])
			//rectangle(imageTrack, dets[i], _colors[obj_id[i]], 3);
	//	else
			//dashed_rectangle(imageTrack, dets[i], _colors[obj_id[i]], 3, 10);

		putText(imageTrack, text.c_str(), cv::Point(dets[i].x + 4, dets[i].y + 15),
			cv::FONT_HERSHEY_SIMPLEX, 0.55, _colors[obj_id[i]], 2);
		cv::circle(imageTrack, cv::Point(dets[i].x+dets[i].width/2, dets[i].y+dets[i].height/2), 30, _colors[obj_id[i]],3);
	}
}

static void image_viewer_callback(const sensor_msgs::Image&amp; image_source)
{
	_drawing = true;

	const auto&amp; encoding = sensor_msgs::image_encodings::BGR8;
	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_source,
							     encoding);
	IplImage frame = cv_image-&gt;image;

	cv::Mat matImage(cv_image-&gt;image);
	cv::Mat imageTrack = matImage.clone();

	//UNTRACKED
	putText(matImage, &quot;PIXEL_XY&quot;, cv::Point(10,10), cv::FONT_HERSHEY_SIMPLEX, 0.55, cv::Scalar(0, 0, 255), 2);
	if (car_dpm_ready)
		drawDetections(cars, cars_score, &quot;car&quot;, frame);
	if (ped_dpm_ready)
		drawDetections(peds, peds_score, &quot;pedestrian&quot;, frame);

	if (car_image_obj_ready)
		drawDetections(cars, cars_score, &quot;car&quot;, frame);
	if (pedestrian_image_obj_ready)
		drawDetections(peds, peds_score, &quot;pedestrian&quot;, frame);

	//TRACKED
	putText(imageTrack, &quot;PIXEL_XY_TRACKED&quot;, cv::Point(10,10), cv::FONT_HERSHEY_SIMPLEX, 0.55, cv::Scalar(0, 255, 0), 2);
	if(car_track_ready)
		drawTracked(cars_tracked, cars_tracked_lifespan, cars_tracked_id, cars_tracked_real_data, &quot;car&quot;, imageTrack);
	if(ped_track_ready)
		drawTracked(peds_tracked, peds_tracked_lifespan, peds_tracked_id, peds_tracked_real_data, &quot;pedestrian&quot;, imageTrack);

	cv::Mat merged;
	hconcat(matImage, imageTrack, merged);

	if (cvGetWindowHandle(window_name.c_str()) != NULL) // Guard not to write destroyed window by using close button on the window
		{
			imshow(window_name, merged);
			cvWaitKey(2);
		}

	_drawing = false;
}

static void image_obj_update_cb(const cv_tracker_msgs::image_obj&amp; image_objs)
{
	if(_drawing)
		return;

	bool is_car = (image_objs.type == &quot;car&quot;);
	std::vector&lt;cv::Rect&gt;&amp; objs = is_car ? cars : peds;
	std::vector&lt;float&gt;&amp; scores = is_car ? cars_score : peds_score;
	
	objs.clear();
	scores.clear();

	for (const auto&amp; obj : image_objs.obj) {
		cv::Rect tmp;
		tmp.x = obj.x;
		tmp.y = obj.y;
		tmp.width = obj.width;
		tmp.height = obj.height;

		objs.push_back(tmp);
		scores.push_back(obj.score);
	}

	if (is_car) {
		car_image_obj_ready = true;
	} else {
		pedestrian_image_obj_ready = true;
	}
}

static void image_obj_updater_cb_tracked(const cv_tracker_msgs::image_obj_tracked&amp; image_objs_tracked_msg)
{
	if(_drawing)
		return;
	bool is_car = (image_objs_tracked_msg.type == &quot;car&quot;);
	std::vector&lt;cv::Rect&gt;&amp; objs_tracked = is_car ? cars_tracked : peds_tracked;
	std::vector&lt;int&gt;&amp; objs_tracked_lifespan = is_car ? cars_tracked_lifespan : peds_tracked_lifespan;
	std::vector&lt;int&gt;&amp; objs_tracked_id = is_car ? cars_tracked_id : peds_tracked_id;
	std::vector&lt;int&gt;&amp; objs_tracked_real_data = is_car ? cars_tracked_real_data : peds_tracked_real_data;

	objs_tracked_lifespan = image_objs_tracked_msg.lifespan;
	objs_tracked_id = image_objs_tracked_msg.obj_id;
	objs_tracked_real_data = image_objs_tracked_msg.real_data;

	objs_tracked.clear();
	for (const auto&amp; rect_ranged : image_objs_tracked_msg.rect_ranged)
		{
			cv::Rect tmp;
			tmp.x = rect_ranged.rect.x;
			tmp.y = rect_ranged.rect.y;
			tmp.width = rect_ranged.rect.width;
			tmp.height = rect_ranged.rect.height;

			objs_tracked.push_back(tmp);
		}

	if(is_car) {
		car_track_ready = true;
	} else {
		ped_track_ready = true;
	}
}

int main(int argc, char **argv)
{

	/* create resizable window */
	cv::namedWindow(window_name, cv::WINDOW_NORMAL);
	cv::startWindowThread();

	ros::init(argc, argv, &quot;image_viewer&quot;);
	ros::NodeHandle n;
	ros::NodeHandle private_nh(&quot;~&quot;);

	std::string image_topic_name;

	if (private_nh.getParam(&quot;image_raw_topic&quot;, image_topic_name)) {
		ROS_INFO(&quot;Setting image topic to %s&quot;, image_topic_name.c_str());
	} else {
		ROS_INFO(&quot;No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE&quot;);
		image_topic_name = &quot;/image_raw&quot;;
	}

#if (CV_MAJOR_VERSION == 3)
	generateColors(_colors, 25);
#else
	cv::generateColors(_colors, 25);
#endif

	ros::Subscriber scriber = n.subscribe(image_topic_name, 1, image_viewer_callback);

	ros::Subscriber scriber_car = n.subscribe(&quot;/obj_car/image_obj&quot;, 1,
						image_obj_update_cb);
	ros::Subscriber scriber_ped = n.subscribe(&quot;/obj_person/image_obj&quot;, 1,
						image_obj_update_cb);

	ros::Subscriber scriber_ped_tracked = n.subscribe(&quot;/obj_person/image_obj_tracked&quot;, 1,
						image_obj_updater_cb_tracked);
	ros::Subscriber scriber_car_tracked = n.subscribe(&quot;/obj_car/image_obj_tracked&quot;, 1,
						image_obj_updater_cb_tracked);

	ros::spin();

	/* destroy window */
	cv::destroyWindow(window_name);

	return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/points_image_d_viewer/points_image_d_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/points_image_d_viewer/points_image_d_viewer.cpp">
				<diff>@@ -42,9 +42,9 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;points2image/PointsImage.h&gt;
+#include &lt;autoware_msgs/PointsImage.h&gt;
 
-#include &quot;cv_tracker_msgs/image_obj_ranged.h&quot;
+#include &quot;autoware_msgs/image_obj_ranged.h&quot;
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -56,15 +56,15 @@ static char window_name[] = &quot;points_image_d_viewer&quot;;
 static bool existImage = false;
 static bool existPoints = false;
 static sensor_msgs::Image image_msg;
-static points2image::PointsImageConstPtr points_msg;
+static autoware_msgs::PointsImageConstPtr points_msg;
 static cv::Mat colormap;
 
 #if 0
 static std::vector&lt;cv::Rect&gt; cars;
 static std::vector&lt;cv::Rect&gt; peds;
 #else
-static cv_tracker_msgs::image_obj_ranged car_fused_objects;
-static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::image_obj_ranged car_fused_objects;
+static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
 #endif
 
 /* check whether floating value x is nearly 0 or not */
@@ -83,7 +83,7 @@ static std::vector&lt;cv::Scalar&gt; _colors;
 static const int OBJ_RECT_THICKNESS = 3;
 
 static void drawRects(IplImage *Image,
-                      std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                      std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                       CvScalar color,
                       int threshold_height)
 {
@@ -98,7 +98,7 @@ static void drawRects(IplImage *Image,
 }
 
 static void putDistance(IplImage *Image,
-                        std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                        std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                         int threshold_height,
                         const char* objectLabel)
 {
@@ -283,7 +283,7 @@ static void car_updater_callback(dpm::ImageObjects image_objects_msg)
   }
 }
 #else
-static void car_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
 {
   car_fused_objects = fused_car_msg;
   //  show();
@@ -308,7 +308,7 @@ static void ped_updater_callback(dpm::ImageObjects image_objects_msg)
   }
 }
 #else
-static void ped_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
   //  show();
@@ -322,7 +322,7 @@ static void image_cb(const sensor_msgs::Image&amp; msg)
   show();
 }
 
-static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
+static void points_cb(const autoware_msgs::PointsImageConstPtr&amp; msg)
 {
   points_msg = msg;
   existPoints = true;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv2/opencv.hpp&gt;

#include &lt;opencv2/core/version.hpp&gt;
#if (CV_MAJOR_VERSION == 3)
#include &quot;gencolors.cpp&quot;
#else
#include &lt;opencv2/contrib/contrib.hpp&gt;
#endif

#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;points2image/PointsImage.h&gt;

#include &quot;cv_tracker_msgs/image_obj_ranged.h&quot;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;

#define NO_DATA 0
static char window_name[] = &quot;points_image_d_viewer&quot;;

static bool existImage = false;
static bool existPoints = false;
static sensor_msgs::Image image_msg;
static points2image::PointsImageConstPtr points_msg;
static cv::Mat colormap;

#if 0
static std::vector&lt;cv::Rect&gt; cars;
static std::vector&lt;cv::Rect&gt; peds;
#else
static cv_tracker_msgs::image_obj_ranged car_fused_objects;
static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
#endif

/* check whether floating value x is nearly 0 or not */
static inline bool isNearlyNODATA(float x)
{
  float abs_x  = (float)fabs(x);
  const int rangeScale = 100;
  return(abs_x &lt; FLT_MIN*rangeScale);
}

static std::vector&lt;cv::Scalar&gt; _colors;

#define	IMAGE_WIDTH	800
#define	IMAGE_HEIGHT	600

static const int OBJ_RECT_THICKNESS = 3;

static void drawRects(IplImage *Image,
                      std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                      CvScalar color,
                      int threshold_height)
{
  unsigned int object_num = objects.size();
  for(unsigned int i = 0; i &lt; object_num; i++) {
    if (objects.at(i).rect.y &gt; threshold_height &amp;&amp; !isNearlyNODATA(objects.at(i).range)) {  // temporal way to avoid drawing detections in the sky
      CvPoint p1=cvPoint(objects.at(i).rect.x, objects.at(i).rect.y);
      CvPoint p2=cvPoint(objects.at(i).rect.x + objects.at(i).rect.width, objects.at(i).rect.y + objects.at(i).rect.height);
      cvRectangle(Image,p1,p2,color,OBJ_RECT_THICKNESS);
    }
  }
}

static void putDistance(IplImage *Image,
                        std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                        int threshold_height,
                        const char* objectLabel)
{
  char distance_string[32];
  CvFont dfont;
  float hscale	    = 0.7f;
  float vscale	    = 0.7f;
  float italicscale = 0.0f;
  int	thickness   = 1;

  CvFont      dfont_label;
  float       hscale_label = 0.5f;
  float       vscale_label = 0.5f;
  CvSize      text_size;
  int         baseline     = 0;

  cvInitFont(&amp;dfont_label, CV_FONT_HERSHEY_COMPLEX, hscale_label, vscale_label, italicscale, thickness, CV_AA);
  cvGetTextSize(objectLabel,
                &amp;dfont_label,
                &amp;text_size,
                &amp;baseline);

  for (unsigned int i=0; i&lt;objects.size(); i++)
    {
      if (objects.at(i).rect.y &gt; threshold_height) // temporal way to avoid drawing detections in the sky
        {
          if (!isNearlyNODATA(objects.at(i).range))
            {

              /*put label */
              CvPoint labelOrg = cvPoint(objects.at(i).rect.x - OBJ_RECT_THICKNESS,
                                         objects.at(i).rect.y - baseline - OBJ_RECT_THICKNESS);

              cvRectangle(Image,
                          cvPoint(labelOrg.x + 0, labelOrg.y + baseline),
                          cvPoint(labelOrg.x + text_size.width, labelOrg.y - text_size.height),
                          CV_RGB(0, 0, 0), // label background is black
                          -1, 8, 0
                          );
              cvPutText(Image,
                        objectLabel,
                        labelOrg,
                        &amp;dfont_label,
                        CV_RGB(255, 255, 255) // label text color is white
                        );

              /* put distance data */
              cvRectangle(Image,
                          cv::Point(objects.at(i).rect.x + (objects.at(i).rect.width/2) - (((int)log10(objects.at(i).range/100)+1) * 5 + 45),
                                    objects.at(i).rect.y + objects.at(i).rect.height + 5),
                          cv::Point(objects.at(i).rect.x + (objects.at(i).rect.width/2) + (((int)log10(objects.at(i).range/100)+1) * 8 + 38),
                                    objects.at(i).rect.y + objects.at(i).rect.height + 30),
                          cv::Scalar(255,255,255),
                          -1);

              cvInitFont (&amp;dfont,
                          CV_FONT_HERSHEY_COMPLEX,
                          hscale,
                          vscale,
                          italicscale,
                          thickness,
                          CV_AA);

              sprintf(distance_string, &quot;%.2f m&quot;, objects.at(i).range / 100); //unit of length is meter
              cvPutText(Image,
                        distance_string,
                        cvPoint(objects.at(i).rect.x + (objects.at(i).rect.width/2) - (((int)log10(objects.at(i).range/100)+1) * 5 + 40),
                                objects.at(i).rect.y + objects.at(i).rect.height + 25),
                        &amp;dfont,
                        CV_RGB(255, 0, 0));
            }

        }
    }
}

void show(void)
{
  if(!existImage || !existPoints){
    return;
  }
  const auto&amp; encoding = sensor_msgs::image_encodings::BGR8;
  cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, encoding);
  IplImage frame = cv_image-&gt;image;

  cv::Mat matImage = cv::cvarrToMat(&amp;frame);//(&amp;frame, false);

  /* DRAW RECTANGLES of detected objects */
#if 0
  for(std::size_t i=0; i&lt;cars.size();i++) {
      if(cars[i].y &gt; matImage.rows*.3) { //temporal way to avoid drawing detections in the sky
          cvRectangle( &amp;frame,
                       cvPoint(cars[i].x, cars[i].y),
                       cvPoint(cars[i].x+cars[i].width, cars[i].y+cars[i].height),
                       _colors[0], 3, 8,0 );
    }
  }
  for(std::size_t i=0; i&lt;peds.size();i++) {
    if(peds[i].y &gt; matImage.rows*.3) {
      cvRectangle( &amp;frame,
                   cvPoint(peds[i].x, peds[i].y),
                   cvPoint(peds[i].x+peds[i].width, peds[i].y+peds[i].height),
                   _colors[1], 3, 8,0 );
    }
  }
#else
  drawRects(&amp;frame,
            car_fused_objects.obj,
            cvScalar(255.0, 255.0, 0,0),
            matImage.rows*.10);

  drawRects(&amp;frame,
            pedestrian_fused_objects.obj,
            cvScalar(0.0, 255.0, 0,0),
            matImage.rows*.10);
#endif
  /* PUT DISTANCE text on image */
  putDistance(&amp;frame,
              car_fused_objects.obj,
              matImage.rows*.10,
              car_fused_objects.type.c_str());
  putDistance(&amp;frame,
              pedestrian_fused_objects.obj,
              matImage.rows*.10,
              pedestrian_fused_objects.type.c_str());

  /* DRAW POINTS of lidar scanning */
  int w = matImage.size().width;
  int h = matImage.size().height;

  int n = w * h;
  float min_d = 1&lt;&lt;16, max_d = -1;
  //	int min_i = 1&lt;&lt;8, max_i = -1;
  for(int i=0; i&lt;n; i++){
    int di = points_msg-&gt;distance[i];
    max_d = di &gt; max_d ? di : max_d;
    min_d = di &lt; min_d ? di : min_d;
    // int it = points_msg-&gt;intensity[i];
    // max_i = it &gt; max_i ? it : max_i;
    // min_i = it &lt; min_i ? it : min_i;
  }
  float wid_d = max_d - min_d;

  for(int y=0; y&lt;h; y++){
    for(int x=0; x&lt;w; x++){
      int j = y * w + x;
      double distance = points_msg-&gt;distance[j];
      if(distance == 0){
        continue;
      }
      int colorid= wid_d ? ( (distance - min_d) * 255 / wid_d ) : 128;
      cv::Vec3b color=colormap.at&lt;cv::Vec3b&gt;(colorid);
      int g = color[1];
      int b = color[2];
      int r = color[0];
      cvRectangle(&amp;frame, cvPoint(x, y), cvPoint(x+1, y+1), CV_RGB(r, g, b));
    }
  }

  if (cvGetWindowHandle(window_name) != NULL) // Guard not to write destroyed window by using close button on the window
    {
      cvShowImage(window_name, &amp;frame);
      cvWaitKey(2);
    }
}

#if 0
static void car_updater_callback(dpm::ImageObjects image_objects_msg)
{
  int num = image_objects_msg.car_num;
  std::vector&lt;int&gt; points = image_objects_msg.corner_point;
  //points are X,Y,W,H and repeat for each instance
  cars.clear();

  for (int i=0; i&lt;num;i++) {
    cv::Rect tmp;
    tmp.x = points[i*4 + 0];
    tmp.y = points[i*4 + 1];
    tmp.width = points[i*4 + 2];
    tmp.height = points[i*4 + 3];
    cars.push_back(tmp);
  }
}
#else
static void car_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
{
  car_fused_objects = fused_car_msg;
  //  show();
}
#endif

#if 0
static void ped_updater_callback(dpm::ImageObjects image_objects_msg)
{
  int num = image_objects_msg.car_num;
  std::vector&lt;int&gt; points = image_objects_msg.corner_point;
  //points are X,Y,W,H and repeat for each instance
  peds.clear();

  for (int i=0; i&lt;num;i++) {
    cv::Rect tmp;
    tmp.x = points[i*4 + 0];
    tmp.y = points[i*4 + 1];
    tmp.width = points[i*4 + 2];
    tmp.height = points[i*4 + 3];
    peds.push_back(tmp);
  }
}
#else
static void ped_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
{
  pedestrian_fused_objects = fused_pds_msg;
  //  show();
}
#endif

static void image_cb(const sensor_msgs::Image&amp; msg)
{
  image_msg = msg;
  existImage = true;
  show();
}

static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
{
  points_msg = msg;
  existPoints = true;
  show();
}

int main(int argc, char **argv)
{
  /* create resizable window */
  cvNamedWindow(window_name, CV_WINDOW_NORMAL);
  cvStartWindowThread();

  ros::init(argc, argv, &quot;points_image_d_viewer&quot;);
  ros::NodeHandle n;
  ros::NodeHandle private_nh(&quot;~&quot;);

  std::string image_topic_name;
  std::string car_node;
  std::string pedestrian_node;
  std::string points_node;

  if (private_nh.getParam(&quot;image_raw_topic&quot;, image_topic_name)) {
    ROS_INFO(&quot;Setting image topic to %s&quot;, image_topic_name.c_str());
  } else {
    ROS_INFO(&quot;No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE&quot;);
    image_topic_name = &quot;/image_raw&quot;;
  }

  if (private_nh.getParam(&quot;car_node&quot;, car_node)) {
    ROS_INFO(&quot;Setting car positions node to %s&quot;, car_node.c_str());
  } else {
    ROS_INFO(&quot;No car positions node received, defaulting to car_pixel_xyz, you can use _car_node:=YOUR_TOPIC&quot;);
    car_node = &quot;/obj_car/image_obj_ranged&quot;;
  }

  if (private_nh.getParam(&quot;pedestrian_node&quot;, pedestrian_node)) {
    ROS_INFO(&quot;Setting pedestrian positions node to %s&quot;, pedestrian_node.c_str());
  } else {
    ROS_INFO(&quot;No pedestrian positions node received, defaulting to pedestrian_pixel_xyz, you can use _pedestrian_node:=YOUR_TOPIC&quot;);
    pedestrian_node = &quot;/obj_person/image_obj_ranged&quot;;
  }

  if (private_nh.getParam(&quot;points_node&quot;, points_node)) {
    ROS_INFO(&quot;Setting pedestrian positions node to %s&quot;, points_node.c_str());
  } else {
    ROS_INFO(&quot;No points node received, defaulting to points_image, you can use _points_node:=YOUR_TOPIC&quot;);
    points_node = &quot;/points_image&quot;;
  }

#if (CV_MAJOR_VERSION == 3)
	generateColors(_colors, 25);
#else
	cv::generateColors(_colors, 25);
#endif

  ros::Subscriber scriber = n.subscribe(image_topic_name, 1,
                                        image_cb);
  ros::Subscriber scriber_car = n.subscribe(car_node, 1,
                                            car_updater_callback);
  ros::Subscriber scriber_ped = n.subscribe(pedestrian_node, 1,
                                            ped_updater_callback);
  ros::Subscriber scriber_points = n.subscribe(points_node, 1,
                                               points_cb);

  cv::Mat grayscale(256,1,CV_8UC1);
  for(int i=0;i&lt;256;i++) {
    grayscale.at&lt;uchar&gt;(i)=i;
  }
  cv::applyColorMap(grayscale,colormap,cv::COLORMAP_JET);

  ros::spin();

  cvDestroyWindow(window_name);

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/points_image_viewer/points_image_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/points_image_viewer/points_image_viewer.cpp">
				<diff>@@ -35,7 +35,7 @@
 
 #include &quot;ros/ros.h&quot;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &quot;points2image/PointsImage.h&quot;
+#include &quot;autoware_msgs/PointsImage.h&quot;
 
 #define IMAGE_WIDTH 800
 #define IMAGE_HEIGHT 640
@@ -43,7 +43,7 @@
 static bool existImage = false;
 static bool existPoints = false;
 static sensor_msgs::Image image_msg;
-static points2image::PointsImageConstPtr points_msg;
+static autoware_msgs::PointsImageConstPtr points_msg;
 static cv::Mat colormap;
 
 static const char window_name_base[] = &quot;points_image_viewer&quot;;
@@ -103,7 +103,7 @@ static void image_cb(const sensor_msgs::Image&amp; msg)
 	show();
 }
 
-static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
+static void points_cb(const autoware_msgs::PointsImageConstPtr&amp; msg)
 {
 	points_msg = msg;
 	existPoints = true;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;

#include &quot;ros/ros.h&quot;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &quot;points2image/PointsImage.h&quot;

#define IMAGE_WIDTH 800
#define IMAGE_HEIGHT 640

static bool existImage = false;
static bool existPoints = false;
static sensor_msgs::Image image_msg;
static points2image::PointsImageConstPtr points_msg;
static cv::Mat colormap;

static const char window_name_base[] = &quot;points_image_viewer&quot;;
static std::string window_name;

static void show(void)
{
	if(!existImage || !existPoints){
		return;
	}
	const auto&amp; encoding = sensor_msgs::image_encodings::BGR8;
	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, encoding);
	IplImage frame = cv_image-&gt;image;

	cv::Mat matImage = cv::cvarrToMat(&amp;frame);//(&amp;frame, false);

	int w = matImage.size().width;
	int h = matImage.size().height;
	int n = w * h;

	float min_d, max_d;
	min_d = max_d = points_msg-&gt;distance[0];
	for(int i=1; i&lt;n; i++){
		float di = points_msg-&gt;distance[i];
		max_d = di &gt; max_d ? di : max_d;
		min_d = di &lt; min_d ? di : min_d;
	}
	float wid_d = max_d - min_d;

	for(int y=0; y&lt;h; y++){
		for(int x=0; x&lt;w; x++){
			int j = y * w + x;
			float distance = points_msg-&gt;distance[j];
			if(distance == 0){
				continue;
			}
			int colorid= wid_d ? ( (distance - min_d) * 255 / wid_d ) : 128;
			cv::Vec3b color=colormap.at&lt;cv::Vec3b&gt;(colorid);
			int g = color[1];
			int b = color[2];
			int r = color[0];
			cvRectangle(&amp;frame, cvPoint(x, y), cvPoint(x+1, y+1), CV_RGB(r, g, b));
		}
	}

	if (cvGetWindowHandle(window_name.c_str()) != NULL) // Guard not to write destroyed window by using close button on the window
	{
		cvShowImage(window_name.c_str(), &amp;frame);
		cvWaitKey(2);
	}
}

static void image_cb(const sensor_msgs::Image&amp; msg)
{
	image_msg = msg;
	existImage = true;
	show();
}

static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
{
	points_msg = msg;
	existPoints = true;
	show();
}

int main(int argc, char **argv)
{
	ros::init(argc, argv, &quot;points_image_viewer&quot;);
	ros::NodeHandle n;
	ros::NodeHandle private_nh(&quot;~&quot;);

	std::string points_topic;
	if (!private_nh.getParam(&quot;points_topic&quot;, points_topic)) {
		points_topic = &quot;points_image&quot;;
	}

	std::string image_topic;
	if (private_nh.getParam(&quot;image_raw_topic&quot;, image_topic)) {
		ROS_INFO(&quot;Setting image topic to %s&quot;, image_topic.c_str());
	} else {
		ROS_INFO(&quot;No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE&quot;);
		image_topic = &quot;/image_raw&quot;;
	}

	std::string name_space_str = ros::this_node::getNamespace();
	window_name = std::string(window_name_base);
	if (name_space_str != &quot;/&quot;) {
		window_name += &quot; (&quot; + name_space_str + &quot;)&quot;;
	}

	/* create resizable window */
	cvNamedWindow(window_name.c_str(), CV_WINDOW_NORMAL);
	cvStartWindowThread();

	ros::Subscriber sub_image = n.subscribe(image_topic, 1, image_cb);
	ros::Subscriber sub_points = n.subscribe(points_topic, 1, points_cb);

	cv::Mat grayscale(256,1,CV_8UC1);
	for(int i=0;i&lt;256;i++)
	{
		grayscale.at&lt;uchar&gt;(i)=i;
	}
	cv::applyColorMap(grayscale,colormap,cv::COLORMAP_JET);

	ros::spin();

	cvDestroyWindow(window_name.c_str());
	return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/scan_image_d_viewer/scan_image_d_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/scan_image_d_viewer/scan_image_d_viewer.cpp">
				<diff>@@ -42,8 +42,8 @@
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
 #include &lt;float.h&gt;
-#include &quot;cv_tracker_msgs/image_obj_ranged.h&quot;
-#include &quot;scan2image/ScanImage.h&quot;
+#include &quot;autoware_msgs/image_obj_ranged.h&quot;
+#include &quot;autoware_msgs/ScanImage.h&quot;
 
 #define IMAGE_WIDTH 800
 #define IMAGE_HEIGHT 600
@@ -53,13 +53,13 @@ char window_name[] = &quot;SCAN_IMAGE_VIEWER&quot;;
 //for imageCallback
 cv_bridge::CvImagePtr cv_image;
 IplImage image;
-scan2image::ScanImage scan_image;
+autoware_msgs::ScanImage scan_image;
 bool exist_image = false;
 bool exist_scan = false;
 cv::Mat colormap;
 
-cv_tracker_msgs::image_obj_ranged car_fused_objects;
-cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
+autoware_msgs::image_obj_ranged car_fused_objects;
+autoware_msgs::image_obj_ranged pedestrian_fused_objects;
 static const int OBJ_RECT_THICKNESS = 3;
 
 /* check whether floating value x is nearly 0 or not */
@@ -71,7 +71,7 @@ static inline bool isNearlyNODATA(float x)
 }
 
 static void putDistance(IplImage *Image,
-                        std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                        std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                         int threshold_height,
                         const char* objectLabel)
 {
@@ -147,7 +147,7 @@ static void putDistance(IplImage *Image,
 }
 
 static void drawRects(IplImage *Image,
-                      std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                      std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
                       CvScalar color,
                       int threshold_height)
 {
@@ -229,20 +229,20 @@ static void show()
     cvReleaseImage(&amp;image_view);
 }
 
-static void scan_image_callback(const scan2image::ScanImage&amp; scan_image_msg)
+static void scan_image_callback(const autoware_msgs::ScanImage&amp; scan_image_msg)
 {
     scan_image = scan_image_msg;
     exist_scan = true;
     show();
 }
 
-static void car_fusion_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_fusion_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
 {
   car_fused_objects = fused_car_msg;
 //  show();
 }
 
-static void ped_fusion_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_fusion_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
 //  show();
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//openCV library
#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv/cxcore.h&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;ros/ros.h&quot;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;
#include &quot;cv_tracker_msgs/image_obj_ranged.h&quot;
#include &quot;scan2image/ScanImage.h&quot;

#define IMAGE_WIDTH 800
#define IMAGE_HEIGHT 600
#define NO_DATA 0

char window_name[] = &quot;SCAN_IMAGE_VIEWER&quot;;
//for imageCallback
cv_bridge::CvImagePtr cv_image;
IplImage image;
scan2image::ScanImage scan_image;
bool exist_image = false;
bool exist_scan = false;
cv::Mat colormap;

cv_tracker_msgs::image_obj_ranged car_fused_objects;
cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
static const int OBJ_RECT_THICKNESS = 3;

/* check whether floating value x is nearly 0 or not */
static inline bool isNearlyNODATA(float x)
{
    float abs_x  = (float)fabs(x);
    const int rangeScale = 100;
    return(abs_x &lt; FLT_MIN*rangeScale);
}

static void putDistance(IplImage *Image,
                        std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                        int threshold_height,
                        const char* objectLabel)
{
  char distance_string[32];
  CvFont dfont;
  float hscale	    = 0.7f;
  float vscale	    = 0.7f;
  float italicscale = 0.0f;
  int	thickness   = 1;

  CvFont      dfont_label;
  float       hscale_label = 0.5f;
  float       vscale_label = 0.5f;
  CvSize      text_size;
  int         baseline     = 0;

  cvInitFont(&amp;dfont_label, CV_FONT_HERSHEY_COMPLEX, hscale_label, vscale_label, italicscale, thickness, CV_AA);
  cvGetTextSize(objectLabel,
                &amp;dfont_label,
                &amp;text_size,
                &amp;baseline);

  for (unsigned int i=0; i&lt;objects.size(); i++)
    {
      if (objects.at(i).rect.y &gt; threshold_height) // temporal way to avoid drawing detections in the sky
        {
          if (!isNearlyNODATA(objects.at(i).range))
            {
              /* put label */
              CvPoint labelOrg = cvPoint(objects.at(i).rect.x - OBJ_RECT_THICKNESS,
                                         objects.at(i).rect.y - baseline - OBJ_RECT_THICKNESS);

              cvRectangle(Image,
                          cvPoint(labelOrg.x + 0, labelOrg.y + baseline),
                          cvPoint(labelOrg.x + text_size.width, labelOrg.y - text_size.height),
                          CV_RGB(0, 0, 0), // label background is black
                          -1, 8, 0
                          );
              cvPutText(Image,
                        objectLabel,
                        labelOrg,
                        &amp;dfont_label,
                        CV_RGB(255, 255, 255) // label text color is white
                        );

              /* put distance data */
              cvRectangle(Image,
                          cv::Point(objects.at(i).rect.x + (objects.at(i).rect.width/2) - (((int)log10(objects.at(i).range/100)+1) * 5 + 45),
                                    objects.at(i).rect.y + objects.at(i).rect.height + 5),
                          cv::Point(objects.at(i).rect.x + (objects.at(i).rect.width/2) + (((int)log10(objects.at(i).range/100)+1) * 8 + 38),
                                    objects.at(i).rect.y + objects.at(i).rect.height + 30),
                          cv::Scalar(255,255,255),
                          -1);

              cvInitFont (&amp;dfont,
                          CV_FONT_HERSHEY_COMPLEX,
                          hscale,
                          vscale,
                          italicscale,
                          thickness,
                          CV_AA);

              sprintf(distance_string, &quot;%.2f m&quot;, objects.at(i).range / 100); //unit of length is meter
              cvPutText(Image,
                        distance_string,
                        cvPoint(objects.at(i).rect.x + (objects.at(i).rect.width/2) - (((int)log10(objects.at(i).range/100)+1) * 5 + 40),
                                objects.at(i).rect.y + objects.at(i).rect.height + 25),
                        &amp;dfont,
                        CV_RGB(255, 0, 0));
            }
        }
    }
}

static void drawRects(IplImage *Image,
                      std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
                      CvScalar color,
                      int threshold_height)
{
    unsigned int object_num = objects.size();
    for(unsigned int i = 0; i &lt; object_num; i++)
    {
        if (objects.at(i).rect.y &gt; threshold_height &amp;&amp; !isNearlyNODATA(objects.at(i).range)) // temporal way to avoid drawing detections in the sky
        {
            CvPoint p1=cvPoint(objects.at(i).rect.x, objects.at(i).rect.y);
            CvPoint p2=cvPoint(objects.at(i).rect.x + objects.at(i).rect.width, objects.at(i).rect.y + objects.at(i).rect.height);
            cvRectangle(Image,p1,p2,color,OBJ_RECT_THICKNESS);
        }
    }
}

static void show()
{
    if(!exist_image || !exist_scan){
        return;
    }

    IplImage* image_view = cvCreateImage(cvGetSize(&amp;image), image.depth, image.nChannels);
    cvCopy(&amp;image, image_view);

	float min_d, max_d;
	min_d = max_d = scan_image.distance.at(0);
	for(int i = 1; i &lt; IMAGE_WIDTH * IMAGE_HEIGHT; i++){
		float di = scan_image.distance.at(i);
		max_d = di &gt; max_d ? di : max_d;
		min_d = di &lt; min_d ? di : min_d;
	}
	float wid_d = max_d - min_d;

    /*
     * Plot depth points on an image
     */
    CvPoint pt;
    int height, width;
    for(int i = 0; i &lt; (int)scan_image.distance.size(); i++) {
        height = (int)(i % IMAGE_HEIGHT);
        width = (int)(i / IMAGE_HEIGHT);
        if(scan_image.distance.at(i) != 0.0) {
            pt.x = width;
            pt.y = height;
			int colorid= wid_d ? ( (scan_image.distance.at(i) - min_d) * 255 / wid_d ) : 128;
			cv::Vec3b color=colormap.at&lt;cv::Vec3b&gt;(colorid);
			int g = color[1];
			int b = color[2];
			int r = color[0];
            cvCircle(image_view, pt, 2, CV_RGB (r, g, b), CV_FILLED, 8, 0);
        }
    }


  drawRects(image_view,
            car_fused_objects.obj,
            cvScalar(255.0, 255.0, 0,0),
            (image_view-&gt;height)*.3);

  drawRects(image_view,
            pedestrian_fused_objects.obj,
            cvScalar(0.0, 255.0, 0,0),
            (image_view-&gt;height)*.3);
  /* PUT DISTANCE text on image */
  putDistance(image_view,
              car_fused_objects.obj,
              (image_view-&gt;height)*.3,
              car_fused_objects.type.c_str());
  putDistance(image_view,
              pedestrian_fused_objects.obj,
              (image_view-&gt;height)*.3,
              pedestrian_fused_objects.type.c_str());

    /*
     * Show image
     */
    cvShowImage(window_name, image_view);
    cvWaitKey(2);
    cvReleaseImage(&amp;image_view);
}

static void scan_image_callback(const scan2image::ScanImage&amp; scan_image_msg)
{
    scan_image = scan_image_msg;
    exist_scan = true;
    show();
}

static void car_fusion_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
{
  car_fused_objects = fused_car_msg;
//  show();
}

static void ped_fusion_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
{
  pedestrian_fused_objects = fused_pds_msg;
//  show();
}

static void image_callback(const sensor_msgs::Image&amp; image_msg)
{
    cv_image = cv_bridge::toCvCopy(image_msg, sensor_msgs::image_encodings::BGR8);
    image = cv_image-&gt;image;
    exist_image = true;
    show();
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, &quot;sca_image_d_viewer&quot;);
    ros::NodeHandle n;
    ros::NodeHandle private_nh(&quot;~&quot;);
    std::string image_topic_name;
    if (private_nh.getParam(&quot;image_raw_topic&quot;, image_topic_name)) {
      ROS_INFO(&quot;Setting image topic to %s&quot;, image_topic_name.c_str());
    } else {
      ROS_INFO(&quot;No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE&quot;);
      image_topic_name = &quot;/image_raw&quot;;
    }

    ros::Subscriber scan_image_sub = n.subscribe(&quot;/scan_image&quot;, 1, scan_image_callback);
    ros::Subscriber image_sub = n.subscribe(image_topic_name, 1, image_callback);
    ros::Subscriber car_fusion_sub = n.subscribe(&quot;/obj_car/image_obj_ranged&quot;, 1, car_fusion_callback);
    ros::Subscriber pedestrian_fusion_sub = n.subscribe(&quot;/obj_person/image_obj_ranged&quot;, 1, ped_fusion_callback);

    cv::Mat grayscale(256,1,CV_8UC1);
    for(int i = 0; i &lt; 256; i++) {
        grayscale.at&lt;uchar&gt;(i)=i;
    }
    cv::applyColorMap(grayscale, colormap, cv::COLORMAP_JET);
    cvNamedWindow(window_name, 2);

    ros::spin();

    cvDestroyWindow(window_name);
    return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/scan_image_viewer/scan_image_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/scan_image_viewer/scan_image_viewer.cpp">
				<diff>@@ -38,14 +38,14 @@
 #include &quot;ros/ros.h&quot;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &quot;scan2image/ScanImage.h&quot;
+#include &quot;autoware_msgs/ScanImage.h&quot;
 #include &lt;sensor_msgs/CameraInfo.h&gt;
 
 static char window_name[] = &quot;SCAN_IMAGE_VIEWER&quot;;
 //for imageCallback
 static cv_bridge::CvImagePtr cv_image;
 static IplImage image;
-static scan2image::ScanImage scan_image;
+static autoware_msgs::ScanImage scan_image;
 static bool exist_image = false;
 static bool exist_scan = false;
 static cv::Mat colormap;
@@ -96,7 +96,7 @@ static void show()
     cvReleaseImage(&amp;image_view);
 }
 
-static void scan_image_callback(const scan2image::ScanImage&amp; scan_image_msg)
+static void scan_image_callback(const autoware_msgs::ScanImage&amp; scan_image_msg)
 {
     scan_image = scan_image_msg;
     exist_scan = true;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

//openCV library
#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv/cxcore.h&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &quot;ros/ros.h&quot;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &quot;scan2image/ScanImage.h&quot;
#include &lt;sensor_msgs/CameraInfo.h&gt;

static char window_name[] = &quot;SCAN_IMAGE_VIEWER&quot;;
//for imageCallback
static cv_bridge::CvImagePtr cv_image;
static IplImage image;
static scan2image::ScanImage scan_image;
static bool exist_image = false;
static bool exist_scan = false;
static cv::Mat colormap;
static cv::Size imageSize;

static void show()
{
    if(!exist_image || !exist_scan){
        return;
    }

    IplImage* image_view = cvCreateImage(cvGetSize(&amp;image), image.depth, image.nChannels);
    cvCopy(&amp;image, image_view);

    float min_d, max_d;
    min_d = max_d = scan_image.distance.at(0);
    for(int i = 1; i &lt; imageSize.width * imageSize.height; i++){
        float di = scan_image.distance.at(i);
        max_d = di &gt; max_d ? di : max_d;
        min_d = di &lt; min_d ? di : min_d;
    }

    float wid_d = max_d - min_d;

    /*
     * Plot depth points on an image
     */
    CvPoint pt;
    for(int i = 0; i &lt; (int)scan_image.distance.size(); i++) {
        int height = (int)(i % imageSize.height);
        int width = (int)(i / imageSize.height);
        if(scan_image.distance.at(i) != 0.0) {
            pt.x = width;
            pt.y = height;
			int colorid= wid_d ? ( (scan_image.distance.at(i) - min_d) * 255 / wid_d ) : 128;
			cv::Vec3b color=colormap.at&lt;cv::Vec3b&gt;(colorid);
			int g = color[1];
			int b = color[2];
			int r = color[0];
            cvCircle(image_view, pt, 2, CV_RGB (r, g, b), CV_FILLED, 8, 0);
        }
    }
    /*
     * Show image
     */
    cvShowImage(window_name, image_view);
    cvWaitKey(2);
    cvReleaseImage(&amp;image_view);
}

static void scan_image_callback(const scan2image::ScanImage&amp; scan_image_msg)
{
    scan_image = scan_image_msg;
    exist_scan = true;
    show();
}

static void image_callback(const sensor_msgs::Image&amp; image_msg)
{
    imageSize.height = image_msg.height;
    imageSize.width = image_msg.width;
    cv_image = cv_bridge::toCvCopy(image_msg, sensor_msgs::image_encodings::BGR8);
    image = cv_image-&gt;image;
    exist_image = true;
    show();
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, &quot;scan_image_viewer&quot;);
    ros::NodeHandle n;
    ros::NodeHandle private_nh(&quot;~&quot;);
    std::string image_topic_name;

    if (private_nh.getParam(&quot;image_raw_topic&quot;, image_topic_name)) {
        ROS_INFO(&quot;Setting image topic to %s&quot;, image_topic_name.c_str());
    } else {
        ROS_INFO(&quot;No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE&quot;);
        image_topic_name = &quot;/image_raw&quot;;
    }

    ros::Subscriber scan_image_sub = n.subscribe(&quot;/scan_image&quot;, 1, scan_image_callback);
    ros::Subscriber image_sub = n.subscribe(image_topic_name, 1, image_callback);

    cv::Mat grayscale(256,1,CV_8UC1);
    for(int i = 0; i &lt; 256; i++) {
        grayscale.at&lt;uchar&gt;(i)=i;
    }
    cv::applyColorMap(grayscale, colormap, cv::COLORMAP_JET);
    cvNamedWindow(window_name, 2);

    ros::spin();

    cvDestroyWindow(window_name);
    return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/traffic_light_viewer/traffic_light_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/traffic_light_viewer/traffic_light_viewer.cpp">
				<diff>@@ -1,5 +1,5 @@
 #include &lt;ros/ros.h&gt;
-#include &lt;runtime_manager/traffic_light.h&gt;
+#include &lt;autoware_msgs/traffic_light.h&gt;
 #include &lt;opencv2/core/core.hpp&gt;
 #include &lt;opencv2/highgui/highgui.hpp&gt;
 #include &lt;opencv2/imgproc/imgproc.hpp&gt;
@@ -13,7 +13,7 @@ static const int32_t TRAFFIC_LIGHT_RED     = 0;
 static const int32_t TRAFFIC_LIGHT_GREEN   = 1;
 static const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;
 
-static void signalState_cb(const runtime_manager::traffic_light::ConstPtr&amp; msg)
+static void signalState_cb(const autoware_msgs::traffic_light::ConstPtr&amp; msg)
 {
   const int   fontFace      = cv::FONT_HERSHEY_COMPLEX;
   const float fontScale     = 1.0f;
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;runtime_manager/traffic_light.h&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

#define WINDOW_NAME &quot;traffic light detection result&quot;
#define WINDOW_SIZE 500
#define RADIUS      200


static const int32_t TRAFFIC_LIGHT_RED     = 0;
static const int32_t TRAFFIC_LIGHT_GREEN   = 1;
static const int32_t TRAFFIC_LIGHT_UNKNOWN = 2;

static void signalState_cb(const runtime_manager::traffic_light::ConstPtr&amp; msg)
{
  const int   fontFace      = cv::FONT_HERSHEY_COMPLEX;
  const float fontScale     = 1.0f;
  const int   fontThickness = 1;
  int         baseLine      = 0;
  cv::Point   textOrg;
  std::string label;
  cv::Scalar  textColor;
  cv::Scalar  signalColor;

  switch (msg-&gt;traffic_light) {
  case TRAFFIC_LIGHT_RED:
    label       = &quot;RED&quot;;
    textColor   = CV_RGB(255, 0, 0);
    signalColor = CV_RGB(255, 0, 0);
    break;
  case TRAFFIC_LIGHT_GREEN:
    label       = &quot;GREEN&quot;;
    textColor   = CV_RGB(0, 255, 0);
    signalColor = CV_RGB(0, 255, 0);
    break;
  default:
    label       = &quot;NO SIGNAL DETECTED&quot;;
    textColor   = CV_RGB(255, 255, 255);
    signalColor = CV_RGB(0, 0, 0);
    break;
  }

  cv::Mat result(WINDOW_SIZE, WINDOW_SIZE, CV_8UC3, cv::Scalar(0));

  cv::circle(result, cv::Point(WINDOW_SIZE/2, WINDOW_SIZE/2), RADIUS, signalColor, CV_FILLED);

  cv::Size textSize = cv::getTextSize(label,
                                      fontFace,
                                      fontScale,
                                      fontThickness,
                                      &amp;baseLine);

  textOrg = cv::Point(0, textSize.height + baseLine);

  cv::putText(result,
              label,
              textOrg,
              fontFace,
              fontScale,
              textColor,
              fontThickness,
              CV_AA);

  if (cvGetWindowHandle(WINDOW_NAME) != NULL) // Guard not to write destroyed window by using close button on the window
    {
      cv::imshow(WINDOW_NAME, result);
      cv::waitKey(5);
    }


}

int main(int argc, char* argv[])
{
  cv::namedWindow(WINDOW_NAME, cv::WINDOW_NORMAL);
  cv::startWindowThread();

  ros::init(argc, argv, &quot;traffic_light_viewer&quot;);

  ros::NodeHandle n;

  ros::Subscriber signalState_sub = n.subscribe(&quot;/light_color&quot;, 1, signalState_cb);

  ros::spin();

  cv::destroyWindow(WINDOW_NAME);

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/vscan_image_d_viewer/vscan_image_d_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/vscan_image_d_viewer/vscan_image_d_viewer.cpp">
				<diff>@@ -33,9 +33,9 @@
 #include &lt;ros/ros.h&gt;
 #include &lt;cv_bridge/cv_bridge.h&gt;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &lt;points2image/PointsImage.h&gt;
+#include &lt;autoware_msgs/PointsImage.h&gt;
 
-#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
+#include &lt;autoware_msgs/image_obj_ranged.h&gt;
 #include &lt;vector&gt;
 #include &lt;iostream&gt;
 #include &lt;math.h&gt;
@@ -51,15 +51,15 @@ static char window_name[] = &quot;vscan_image_d_viewer&quot;;
 static bool existImage = false;
 static bool existPoints = false;
 static sensor_msgs::Image image_msg;
-static points2image::PointsImageConstPtr points_msg;
+static autoware_msgs::PointsImageConstPtr points_msg;
 static cv::Mat colormap;
 
 #if 0
 static std::vector&lt;cv::Rect&gt; cars;
 static std::vector&lt;cv::Rect&gt; peds;
 #else
-static cv_tracker_msgs::image_obj_ranged car_fused_objects;
-static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
+static autoware_msgs::image_obj_ranged car_fused_objects;
+static autoware_msgs::image_obj_ranged pedestrian_fused_objects;
 #endif
 
 /* check whether floating value x is nearly 0 or not */
@@ -80,7 +80,7 @@ static std::vector&lt;cv::Scalar&gt; _colors;
 static const int OBJ_RECT_THICKNESS = 3;
 
 static void drawRects(cv::Mat image,
-                    std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
+                    std::vector&lt;autoware_msgs::image_rect_ranged&gt; objects,
 					CvScalar color,
 					int threshold_height,
 					std::string objectClass)
@@ -176,13 +176,13 @@ static void show(void)
 		cvWaitKey(2);
 	}
 }
-static void car_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
+static void car_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_car_msg)
 {
 	car_fused_objects = fused_car_msg;
 	//  show();
 }
 
-static void ped_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
+static void ped_updater_callback(const autoware_msgs::image_obj_ranged&amp; fused_pds_msg)
 {
   pedestrian_fused_objects = fused_pds_msg;
   //  show();
@@ -195,7 +195,7 @@ static void image_cb(const sensor_msgs::Image&amp; msg)
 	show();
 }
 
-static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
+static void points_cb(const autoware_msgs::PointsImageConstPtr&amp; msg)
 {
 	points_msg = msg;
 	existPoints = true;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;opencv2/opencv.hpp&gt;

#include &lt;ros/ros.h&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;points2image/PointsImage.h&gt;

#include &lt;cv_tracker_msgs/image_obj_ranged.h&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;float.h&gt;

#include &lt;opencv2/core/core.hpp&gt;

#include &quot;gencolors.cpp&quot;

#define NO_DATA 0
static char window_name[] = &quot;vscan_image_d_viewer&quot;;

static bool existImage = false;
static bool existPoints = false;
static sensor_msgs::Image image_msg;
static points2image::PointsImageConstPtr points_msg;
static cv::Mat colormap;

#if 0
static std::vector&lt;cv::Rect&gt; cars;
static std::vector&lt;cv::Rect&gt; peds;
#else
static cv_tracker_msgs::image_obj_ranged car_fused_objects;
static cv_tracker_msgs::image_obj_ranged pedestrian_fused_objects;
#endif

/* check whether floating value x is nearly 0 or not */
static inline bool isNearlyNODATA(float x)
{
	float abs_x  = (float)fabs(x);
	const int rangeScale = 100;
	return(abs_x &lt; FLT_MIN*rangeScale);
}

static std::vector&lt;cv::Scalar&gt; _colors;

#define	IMAGE_WIDTH		800
#define	IMAGE_HEIGHT 	600

#define POINTS_THRESHOLD 0.1

static const int OBJ_RECT_THICKNESS = 3;

static void drawRects(cv::Mat image,
                    std::vector&lt;cv_tracker_msgs::image_rect_ranged&gt; objects,
					CvScalar color,
					int threshold_height,
					std::string objectClass)
{
	int object_num = objects.size();
	char distance_string[32];
	int fontFace = cv::FONT_HERSHEY_SIMPLEX; double fontScale = 0.55; int fontThick = 2;
	std::vector&lt;int&gt; pointsInBoundingBox;
	for(int i = 0; i &lt; object_num; i++)
	{
		//corner_point[0]=&gt;X1		corner_point[1]=&gt;Y1
		//corner_point[2]=&gt;width	corner_point[3]=&gt;height
		cv::Rect detection = cv::Rect(objects.at(i).rect.x, objects.at(i).rect.y, objects.at(i).rect.width, objects.at(i).rect.height);

		rectangle(image, detection, color, OBJ_RECT_THICKNESS);//draw bounding box
		putText(image, objectClass, cv::Point(detection.x + 4, detection.y + 10), fontFace, fontScale, color, fontThick);//draw label text

		sprintf(distance_string, &quot;D:%.2f m H:%.1f,%.1f&quot;, objects.at(i).range / 100, objects.at(i).min_height, objects.at(i).max_height);
		//Size textSize = getTextSize(string(distance_string), fontFace, fontScale, fontThick, 0);
		//rectangle(image, cv::Rect( detection.x, detection.y, textSize.width + 4, textSize.height + 10), Scalar::all(0), CV_FILLED);//draw fill distance rectangle
		putText(image, std::string(distance_string), cv::Point(detection.x + 4, detection.y - 10), fontFace, fontScale, color, fontThick);//draw distance text
	}
}

static void drawVScanPoints(cv::Mat image)
{
	/* DRAW POINTS of lidar scanning */
    int w = image.size().width;
	int h = image.size().height;

	int i, n = w * h;
	float min_d = 1&lt;&lt;16, max_d = -1;
	//	int min_i = 1&lt;&lt;8, max_i = -1;
	for(i=0; i&lt;n; i++){
		int di = points_msg-&gt;distance[i];
		max_d = di &gt; max_d ? di : max_d;
		min_d = di &lt; min_d ? di : min_d;
		// int it = points_msg-&gt;intensity[i];
		// max_i = it &gt; max_i ? it : max_i;
		// min_i = it &lt; min_i ? it : min_i;
	}
	float wid_d = max_d - min_d;

	int x, y;
	for(y=0; y&lt;h; y++){
		for(x=0; x&lt;w; x++){
			int i = y * w + x;
			double distance = points_msg-&gt;distance[i];

			if(distance == 0){
				continue;
			}
			int colorid= wid_d ? ( (distance - min_d) * 255 / wid_d ) : 128;
			cv::Vec3b color=colormap.at&lt;cv::Vec3b&gt;(colorid);
			int g = color[1];
			int b = color[2];
			int r = color[0];
			rectangle(image, cv::Rect(x, y,1, 1), cv::Scalar(r, g, b), OBJ_RECT_THICKNESS);
		}
	}
}

static void show(void)
{
	if(!existImage || !existPoints){
		return;
	}
	const auto&amp; encoding = sensor_msgs::image_encodings::BGR8;
	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, encoding);
	IplImage frame = cv_image-&gt;image;

	cv::Mat matImage=cv::cvarrToMat(&amp;frame);//(&amp;frame, false);

	//Draw VScan Points
	drawVScanPoints(matImage);

	/* DRAW RECTANGLES of detected objects */
	drawRects(matImage,
		  car_fused_objects.obj,
		  cv::Scalar(255.0, 255.0, 0,0),
		  matImage.rows*.25,
		  car_fused_objects.type);

	drawRects(matImage,
		  pedestrian_fused_objects.obj,
		  cv::Scalar(0.0, 255.0, 0,0),
		  matImage.rows*.25,
		  pedestrian_fused_objects.type);

	if (cvGetWindowHandle(window_name) != NULL) // Guard not to write destroyed window by using close button on the window
	{
		cvShowImage(window_name, &amp;frame);
		cvWaitKey(2);
	}
}
static void car_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_car_msg)
{
	car_fused_objects = fused_car_msg;
	//  show();
}

static void ped_updater_callback(const cv_tracker_msgs::image_obj_ranged&amp; fused_pds_msg)
{
  pedestrian_fused_objects = fused_pds_msg;
  //  show();
}

static void image_cb(const sensor_msgs::Image&amp; msg)
{
	image_msg = msg;
	existImage = true;
	show();
}

static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
{
	points_msg = msg;
	existPoints = true;
	show();
}

int main(int argc, char **argv)
{
	/* create resizable window */
	cvNamedWindow(window_name, CV_WINDOW_NORMAL);
	cvStartWindowThread();

	ros::init(argc, argv, &quot;vscan_image_d_viewer&quot;);
	ros::NodeHandle n;
	ros::NodeHandle private_nh(&quot;~&quot;);

	std::string image_topic_name;
	std::string car_node;
	std::string pedestrian_node;
	std::string points_node;

	if (private_nh.getParam(&quot;image_raw_topic&quot;, image_topic_name))
	{
		ROS_INFO(&quot;Setting image topic to %s&quot;, image_topic_name.c_str());
	}
	else
	{
		ROS_INFO(&quot;No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE&quot;);
		image_topic_name = &quot;/image_raw&quot;;
	}

	if (private_nh.getParam(&quot;car_node&quot;, car_node))
	{
		ROS_INFO(&quot;Setting car positions node to %s&quot;, car_node.c_str());
	}
	else
	{
		ROS_INFO(&quot;No car positions node received, defaulting to car_pixel_xyz, you can use _car_node:=YOUR_TOPIC&quot;);
		car_node = &quot;/obj_car/image_obj_ranged&quot;;
	}

	if (private_nh.getParam(&quot;pedestrian_node&quot;, pedestrian_node))
	{
		ROS_INFO(&quot;Setting pedestrian positions node to %s&quot;, pedestrian_node.c_str());
	}
	else
	{
		ROS_INFO(&quot;No pedestrian positions node received, defaulting to pedestrian_pixel_xyz, you can use _pedestrian_node:=YOUR_TOPIC&quot;);
		pedestrian_node = &quot;/obj_person/image_obj_ranged&quot;;
	}

	if (private_nh.getParam(&quot;points_node&quot;, points_node))
	{
		ROS_INFO(&quot;Setting pedestrian positions node to %s&quot;, points_node.c_str());
	}
	else
	{
		ROS_INFO(&quot;No points node received, defaulting to points_image, you can use _points_node:=YOUR_TOPIC&quot;);
		points_node = &quot;/vscan_image&quot;;
	}
#if (CV_MAJOR_VERSION == 3)
	generateColors(_colors, 25);
#else
	cv::generateColors(_colors, 25);
#endif

	ros::Subscriber scriber = n.subscribe(image_topic_name, 1,
					    image_cb);
	ros::Subscriber scriber_car = n.subscribe(car_node, 1,
						car_updater_callback);
	ros::Subscriber scriber_ped = n.subscribe(pedestrian_node, 1,
						ped_updater_callback);
	ros::Subscriber scriber_points = n.subscribe(points_node, 1,
						points_cb);

	cv::Mat grayscale(256,1,CV_8UC1);
	for(int i=0;i&lt;256;i++)
	{
		grayscale.at&lt;uchar&gt;(i)=i;
	}
	cv::applyColorMap(grayscale,colormap,cv::COLORMAP_JET);

	ros::spin();

	cvDestroyWindow(window_name);

	return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/viewers/nodes/vscan_image_viewer/vscan_image_viewer.cpp" new_path="ros/src/computing/perception/detection/packages/viewers/nodes/vscan_image_viewer/vscan_image_viewer.cpp">
				<diff>@@ -35,7 +35,7 @@
 
 #include &quot;ros/ros.h&quot;
 #include &lt;sensor_msgs/image_encodings.h&gt;
-#include &quot;points2image/PointsImage.h&quot;
+#include &quot;autoware_msgs/PointsImage.h&quot;
 
 #define IMAGE_WIDTH 800
 #define IMAGE_HEIGHT 640
@@ -43,7 +43,7 @@
 static bool existImage = false;
 static bool existPoints = false;
 static sensor_msgs::Image image_msg;
-static points2image::PointsImageConstPtr points_msg;
+static autoware_msgs::PointsImageConstPtr points_msg;
 static cv::Mat colormap;
 
 static const char window_name[] = &quot;vscan_image_viewer&quot;;
@@ -102,7 +102,7 @@ static void image_cb(const sensor_msgs::Image&amp; msg)
 	show();
 }
 
-static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
+static void points_cb(const autoware_msgs::PointsImageConstPtr&amp; msg)
 {
 	points_msg = msg;
 	existPoints = true;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;

#include &quot;ros/ros.h&quot;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &quot;points2image/PointsImage.h&quot;

#define IMAGE_WIDTH 800
#define IMAGE_HEIGHT 640

static bool existImage = false;
static bool existPoints = false;
static sensor_msgs::Image image_msg;
static points2image::PointsImageConstPtr points_msg;
static cv::Mat colormap;

static const char window_name[] = &quot;vscan_image_viewer&quot;;

static void show(void)
{
	if(!existImage || !existPoints){
		return;
	}
	const auto&amp; encoding = sensor_msgs::image_encodings::BGR8;
	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(image_msg, encoding);
	IplImage frame = cv_image-&gt;image;

	cv::Mat matImage=cv::cvarrToMat(&amp;frame);//(&amp;frame, false);

	int w = matImage.size().width;
	int h = matImage.size().height;
	int n = w * h;

	float min_d, max_d;
	min_d = max_d = points_msg-&gt;distance[0];
	for(int i=1; i&lt;n; i++){
		float di = points_msg-&gt;distance[i];
		max_d = di &gt; max_d ? di : max_d;
		min_d = di &lt; min_d ? di : min_d;
	}
	float wid_d = max_d - min_d;

	for(int y=0; y&lt;h; y++){
		for(int x=0; x&lt;w; x++){
			int j = y * w + x;
			float distance = points_msg-&gt;distance[j];
			if(distance == 0){
				continue;
			}
			int colorid= wid_d ? ( (distance - min_d) * 255 / wid_d ) : 128;
			cv::Vec3b color=colormap.at&lt;cv::Vec3b&gt;(colorid);
			int g = color[1];
			int b = color[2];
			int r = color[0];
			cvRectangle(&amp;frame, cvPoint(x, y), cvPoint(x+1, y+1), CV_RGB(r, g, b));
		}
	}

	if (cvGetWindowHandle(window_name) != NULL) // Guard not to write destroyed window by using close button on the window
	{
		cvShowImage(window_name, &amp;frame);
		cvWaitKey(2);
	}
}

static void image_cb(const sensor_msgs::Image&amp; msg)
{
	image_msg = msg;
	existImage = true;
	show();
}

static void points_cb(const points2image::PointsImageConstPtr&amp; msg)
{
	points_msg = msg;
	existPoints = true;
	show();
}

int main(int argc, char **argv)
{
	/* create resizable window */
	cvNamedWindow(window_name, CV_WINDOW_NORMAL);
	cvStartWindowThread();

	ros::init(argc, argv, &quot;vscan_image_viewer&quot;);
	ros::NodeHandle n;
	ros::NodeHandle private_nh(&quot;~&quot;);

	std::string image_topic_name;
	if (private_nh.getParam(&quot;image_raw_topic&quot;, image_topic_name)) {
		ROS_INFO(&quot;Setting image topic to %s&quot;, image_topic_name.c_str());
	} else {
		ROS_INFO(&quot;No image topic received, defaulting to image_raw, you can use _image_raw_topic:=YOUR_NODE&quot;);
		image_topic_name = &quot;/image_raw&quot;;
	}

	ros::Subscriber sub_image = n.subscribe(image_topic_name, 1, image_cb);

	ros::Subscriber sub_points = n.subscribe(&quot;vscan_image&quot;, 1, points_cb);

	cv::Mat grayscale(256,1,CV_8UC1);
	for(int i=0;i&lt;256;i++)
	{
		grayscale.at&lt;uchar&gt;(i)=i;
	}
	cv::applyColorMap(grayscale,colormap,cv::COLORMAP_JET);

	ros::spin();

	cvDestroyWindow(window_name);

	return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/sensing/polygon/packages/points2polygon/nodes/points2polygon/points2polygon.cpp" new_path="ros/src/sensing/polygon/packages/points2polygon/nodes/points2polygon/points2polygon.cpp">
				<diff>@@ -32,7 +32,7 @@
 #include &lt;ros/console.h&gt;
 
 #include &lt;sensor_msgs/PointCloud2.h&gt;
-#include &lt;runtime_manager/ConfigPoints2Polygon.h&gt;
+#include &lt;autoware_msgs/ConfigPoints2Polygon.h&gt;
 
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl/io/pcd_io.h&gt;
@@ -115,7 +115,7 @@ static void points_to_polygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&amp; cloud)
 	pcl::io::saveVTKFile(points_polygon_vtk, triangles);
 }
 
-static void config_callback(const runtime_manager::ConfigPoints2Polygon&amp; msg)
+static void config_callback(const autoware_msgs::ConfigPoints2Polygon&amp; msg)
 {
 	config_k_search = msg.k_search;
 	config_search_radius = msg.search_radius;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;ros/ros.h&gt;
#include &lt;ros/console.h&gt;

#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;runtime_manager/ConfigPoints2Polygon.h&gt;

#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/io/vtk_io.h&gt;
#include &lt;pcl/kdtree/kdtree_flann.h&gt;
#include &lt;pcl/features/normal_3d.h&gt;
#include &lt;pcl/surface/gp3.h&gt;

#include &lt;pcl_conversions/pcl_conversions.h&gt;

static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 1;

static constexpr bool USE_PCD_FILE = false;
static const std::string VELODYNE_POINTS_PCD = &quot;/tmp/velodyne_points.pcd&quot;;
static const std::string POINTS_POLYGON_VTK = &quot;/tmp/points_polygon.vtk&quot;;

static int config_k_search = 20;
static double config_search_radius = 0.025;
static double config_mu = 2.5;
static int config_maximum_nearest_neighbors = 100;
static double config_maximum_surface_angle = M_PI / 4; // 45 degrees
static double config_minimum_angle = M_PI / 18; // 10 degrees
static double config_maximum_angle = 2 * M_PI / 3; // 120 degrees
static bool config_normal_consistency = false;

static bool use_pcd_file;
static std::string velodyne_points_pcd;
static std::string points_polygon_vtk;

static void points_to_polygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&amp; cloud)
{
	// Normal estimation
	pcl::NormalEstimation&lt;pcl::PointXYZ, pcl::Normal&gt; n;
	pcl::PointCloud&lt;pcl::Normal&gt;::Ptr
		normals(new pcl::PointCloud&lt;pcl::Normal&gt;);
	pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr
		tree(new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);
	tree-&gt;setInputCloud(cloud);
	n.setInputCloud(cloud);
	n.setSearchMethod(tree);
	n.setKSearch(config_k_search);
	n.compute(*normals);

	// Concatenate the XYZ and normal fields
	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr
		cloud_with_normals(new pcl::PointCloud&lt;pcl::PointNormal&gt;);
	pcl::concatenateFields(*cloud, *normals, *cloud_with_normals);

	// Create search tree
	pcl::search::KdTree&lt;pcl::PointNormal&gt;::Ptr
		tree2(new pcl::search::KdTree&lt;pcl::PointNormal&gt;);
	tree2-&gt;setInputCloud(cloud_with_normals);

	// Initialize objects
	pcl::GreedyProjectionTriangulation&lt;pcl::PointNormal&gt; gp3;
	pcl::PolygonMesh triangles;

	// Set the maximum distance between connected points
	// (maximum edge length)
	gp3.setSearchRadius(config_search_radius);

	// Set typical values for the parameters
	gp3.setMu(config_mu);
	gp3.setMaximumNearestNeighbors(config_maximum_nearest_neighbors);
	gp3.setMaximumSurfaceAngle(config_maximum_surface_angle);
	gp3.setMinimumAngle(config_minimum_angle);
	gp3.setMaximumAngle(config_maximum_angle);
	gp3.setNormalConsistency(config_normal_consistency);

	// Get result
	gp3.setInputCloud(cloud_with_normals);
	gp3.setSearchMethod(tree2);
	gp3.reconstruct(triangles);

	// Additional vertex information
	std::vector&lt;int&gt; parts = gp3.getPartIDs();
	std::vector&lt;int&gt; states = gp3.getPointStates();

	// Save result into a output file
	pcl::io::saveVTKFile(points_polygon_vtk, triangles);
}

static void config_callback(const runtime_manager::ConfigPoints2Polygon&amp; msg)
{
	config_k_search = msg.k_search;
	config_search_radius = msg.search_radius;
	config_mu = msg.mu;
	config_maximum_nearest_neighbors = msg.maximum_nearest_neighbors;
	config_maximum_surface_angle = msg.maximum_surface_angle;
	config_minimum_angle = msg.minimum_angle;
	config_maximum_angle = msg.maximum_angle;
	config_normal_consistency = msg.normal_consistency;

	if (use_pcd_file) {
		// Load input file into a PointCloud&lt;T&gt; with an appropriate
		// type
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr
			cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PCLPointCloud2 cloud_blob;
		pcl::io::loadPCDFile(velodyne_points_pcd, cloud_blob);
		pcl::fromPCLPointCloud2(cloud_blob, *cloud);

		points_to_polygon(cloud);
	}
}

static void velodyne_points_callback(const sensor_msgs::PointCloud2&amp; msg)
{
	if (use_pcd_file)
		ROS_WARN(&quot;use_pcd_file: true&quot;);
	else {
		// Load ROS message into a PointCloud&lt;T&gt; with an appropriate
		// type
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr
			cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::fromROSMsg(msg, *cloud);

		points_to_polygon(cloud);
	}
}

int main(int argc, char **argv)
{
	ros::init(argc, argv, &quot;points2polygon&quot;);

	ros::NodeHandle n;
	n.param&lt;bool&gt;(&quot;points2polygon/use_pcd_file&quot;,
		      use_pcd_file, USE_PCD_FILE);
	n.param&lt;std::string&gt;(&quot;points2polygon/velodyne_points_pcd&quot;,
			     velodyne_points_pcd, VELODYNE_POINTS_PCD);
	n.param&lt;std::string&gt;(&quot;points2polygon/points_polygon_vtk&quot;,
			     points_polygon_vtk, POINTS_POLYGON_VTK);

	ros::Subscriber sub_config = n.subscribe(&quot;config/points2polygon&quot;,
						 SUBSCRIBE_QUEUE_SIZE,
						 config_callback);
	ros::Subscriber sub_points = n.subscribe(&quot;points_raw&quot;,
						 SUBSCRIBE_QUEUE_SIZE,
						 velodyne_points_callback);

	if (use_pcd_file) {
		// Load input file into a PointCloud&lt;T&gt; with an appropriate
		// type
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr
			cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PCLPointCloud2 cloud_blob;
		pcl::io::loadPCDFile(velodyne_points_pcd, cloud_blob);
		pcl::fromPCLPointCloud2(cloud_blob, *cloud);

		points_to_polygon(cloud);
	}

	ros::spin();

	return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="c0dc6cff7b9068dd121c5185b08b00a4cdca02a9" fix_time="0,52173">
		<msg>ROS_WARN_ONCE &quot; VectorMap Server Call failed&quot;</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/euclidean_cluster/euclidean_cluster.cpp" new_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/euclidean_cluster/euclidean_cluster.cpp">
				<diff>@@ -607,7 +607,7 @@ void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
 				}
 				else
 				{
-					ROS_WARN(&quot;vectormap_filtering: VectorMap Server Call failed. Make sure vectormap_server is running. No filtering performed.&quot;);
+					ROS_WARN_ONCE(&quot;vectormap_filtering: VectorMap Server Call failed. Make sure vectormap_server is running. No filtering performed.&quot;);
 					final_clusters[i]-&gt;SetValidity(true);
 				}
 			}
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/PCLPointCloud2.h&gt;
#include &lt;pcl/conversions.h&gt;
#include &lt;pcl_ros/transforms.h&gt;
#include &lt;pcl_ros/point_cloud.h&gt;

#include &lt;pcl/ModelCoefficients.h&gt;
#include &lt;pcl/point_types.h&gt;

#include &lt;pcl/filters/extract_indices.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;pcl/filters/conditional_removal.h&gt;

#include &lt;pcl/features/normal_3d.h&gt;
#include &lt;pcl/features/normal_3d_omp.h&gt;
#include &lt;pcl/features/don.h&gt;
#include &lt;pcl/features/fpfh_omp.h&gt;

#include &lt;pcl/kdtree/kdtree.h&gt;

#include &lt;pcl/sample_consensus/method_types.h&gt;
#include &lt;pcl/sample_consensus/model_types.h&gt;

#include &lt;pcl/segmentation/sac_segmentation.h&gt;
#include &lt;pcl/segmentation/extract_clusters.h&gt;
#include &lt;pcl/segmentation/conditional_euclidean_clustering.h&gt;

#include &lt;pcl/common/common.h&gt;

#include &lt;pcl/search/organized.h&gt;
#include &lt;pcl/search/kdtree.h&gt;

#include &lt;pcl/segmentation/extract_clusters.h&gt;

#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;

#include &lt;std_msgs/Float32MultiArray.h&gt;
#include &lt;std_msgs/MultiArrayLayout.h&gt;
#include &lt;std_msgs/MultiArrayDimension.h&gt;

#include &quot;autoware_msgs/centroids.h&quot;
#include &quot;autoware_msgs/CloudCluster.h&quot;
#include &quot;autoware_msgs/CloudClusterArray.h&quot;

#include &lt;vector_map_server/PositionState.h&gt;

#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;jsk_rviz_plugins/Pictogram.h&gt;
#include &lt;jsk_rviz_plugins/PictogramArray.h&gt;

#include &lt;tf/tf.h&gt;

#include &lt;limits&gt;
#include &lt;cmath&gt;

#include &lt;opencv/cv.h&gt;
#include &lt;opencv/highgui.h&gt;
#include &lt;opencv2/core/version.hpp&gt;
#if (CV_MAJOR_VERSION == 3)
#include &quot;gencolors.cpp&quot;
#else
#include &lt;opencv2/contrib/contrib.hpp&gt;
#endif

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;

#include &quot;Cluster.h&quot;

//#include &lt;vector_map/vector_map.h&gt;
//#include &lt;vector_map_server/GetSignal.h&gt;

#ifdef GPU_CLUSTERING
	#include &quot;gpu_euclidean_clustering.h&quot;
#endif

using namespace cv;

std::vector&lt;cv::Scalar&gt; _colors;
ros::Publisher _pub_cluster_cloud;
ros::Publisher _pub_ground_cloud;
ros::Publisher _centroid_pub;
ros::Publisher _marker_pub;
ros::Publisher _pub_clusters_message;
ros::Publisher _pub_text_pictogram;
visualization_msgs::Marker _visualization_marker;

ros::Publisher _pub_points_lanes_cloud;
ros::Publisher _pub_jsk_boundingboxes;
ros::Publisher _pub_jsk_hulls;

ros::ServiceClient _vectormap_server;

std_msgs::Header _velodyne_header;

pcl::PointCloud&lt;pcl::PointXYZ&gt; _sensor_cloud;

std::vector&lt;double&gt; _clustering_thresholds;
std::vector&lt;double&gt; _clustering_distances;

tf::StampedTransform* _transform;
tf::StampedTransform* _velodyne_output_transform;
tf::TransformListener* _transform_listener;

std::string _output_frame;
std::string _vectormap_frame;
static bool _velodyne_transform_available;
static bool _downsample_cloud;
static bool _pose_estimation;
static double _leaf_size;
static int _cluster_size_min;
static int _cluster_size_max;

static bool _remove_ground;	//only ground

static bool _using_sensor_cloud;
static bool _use_diffnormals;
static bool _use_vector_map;

static double _clip_min_height;
static double _clip_max_height;

static bool _keep_lanes;
static double _keep_lane_left_distance;
static double _keep_lane_right_distance;

static double _max_boundingbox_side;
static double _remove_points_upto;
static double _cluster_merge_threshold;

static bool _use_gpu;
static std::chrono::system_clock::time_point _start, _end;

void transformBoundingBox(const jsk_recognition_msgs::BoundingBox&amp; in_boundingbox, jsk_recognition_msgs::BoundingBox&amp; out_boundingbox, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
{
	geometry_msgs::PoseStamped pose_in, pose_out;
	pose_in.header = in_header;
	pose_in.pose = in_boundingbox.pose;
	try
	{
		_transform_listener-&gt;transformPose(in_target_frame, ros::Time(), pose_in, in_header.frame_id,  pose_out);
	}
	catch (tf::TransformException &amp;ex)
	{
		ROS_ERROR(&quot;transformBoundingBox: %s&quot;,ex.what());
	}
	out_boundingbox.pose = pose_out.pose;
	out_boundingbox.header = in_header;
	out_boundingbox.header.frame_id = in_target_frame;
	out_boundingbox.dimensions = in_boundingbox.dimensions;
	out_boundingbox.value = in_boundingbox.value;
	out_boundingbox.label = in_boundingbox.label;
}

void publishCloudClusters(const ros::Publisher* in_publisher, const autoware_msgs::CloudClusterArray&amp; in_clusters, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
{
	if (in_target_frame!=in_header.frame_id)
	{
		autoware_msgs::CloudClusterArray clusters_transformed;
		clusters_transformed.header = in_header;
		clusters_transformed.header.frame_id = in_target_frame;
		for (auto i=in_clusters.clusters.begin(); i!= in_clusters.clusters.end(); i++)
		{
			autoware_msgs::CloudCluster cluster_transformed;
			cluster_transformed.header = in_header;
			try
			{
				_transform_listener-&gt;lookupTransform(in_target_frame, _velodyne_header.frame_id,
										ros::Time(), *_transform);
				pcl_ros::transformPointCloud(in_target_frame, *_transform, i-&gt;cloud, cluster_transformed.cloud);
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;min_point, in_header.frame_id, cluster_transformed.min_point);
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;max_point, in_header.frame_id, cluster_transformed.max_point);
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;avg_point, in_header.frame_id, cluster_transformed.avg_point);
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), i-&gt;centroid_point, in_header.frame_id, cluster_transformed.centroid_point);

				cluster_transformed.dimensions = i-&gt;dimensions;
				cluster_transformed.eigen_values = i-&gt;eigen_values;
				cluster_transformed.eigen_vectors = i-&gt;eigen_vectors;

				transformBoundingBox(i-&gt;bounding_box, cluster_transformed.bounding_box, in_target_frame, in_header);

				clusters_transformed.clusters.push_back(cluster_transformed);
			}
			catch (tf::TransformException &amp;ex)
			{
				ROS_ERROR(&quot;publishCloudClusters: %s&quot;,ex.what());
			}
		}
		in_publisher-&gt;publish(clusters_transformed);
	}
	else
	{
		in_publisher-&gt;publish(in_clusters);
	}
}

void publishCentroids(const ros::Publisher* in_publisher, const autoware_msgs::centroids&amp; in_centroids, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
{
	if (in_target_frame!=in_header.frame_id)
	{
		autoware_msgs::centroids centroids_transformed;
		centroids_transformed.header = in_header;
		centroids_transformed.header.frame_id = in_target_frame;
		for (auto i=centroids_transformed.points.begin(); i!= centroids_transformed.points.end(); i++)
		{
			geometry_msgs::PointStamped centroid_in, centroid_out;
			centroid_in.header = in_header;
			centroid_in.point = *i;
			try
			{
				_transform_listener-&gt;transformPoint(in_target_frame, ros::Time(), centroid_in, in_header.frame_id, centroid_out);

				centroids_transformed.points.push_back(centroid_out.point);
			}
			catch (tf::TransformException &amp;ex)
			{
				ROS_ERROR(&quot;publishCentroids: %s&quot;,ex.what());
			}
		}
		in_publisher-&gt;publish(centroids_transformed);
	}
	else
	{
		in_publisher-&gt;publish(in_centroids);
	}
}

void publishBoundingBoxArray(const ros::Publisher* in_publisher, const jsk_recognition_msgs::BoundingBoxArray&amp; in_boundingbox_array, const std::string&amp; in_target_frame, const std_msgs::Header&amp; in_header)
{
	if (in_target_frame!=in_header.frame_id)
	{
		jsk_recognition_msgs::BoundingBoxArray boundingboxes_transformed;
		boundingboxes_transformed.header = in_header;
		boundingboxes_transformed.header.frame_id = in_target_frame;
		for (auto i=in_boundingbox_array.boxes.begin(); i!= in_boundingbox_array.boxes.end(); i++)
		{
			jsk_recognition_msgs::BoundingBox boundingbox_transformed;
			transformBoundingBox(*i, boundingbox_transformed, in_target_frame, in_header);
			boundingboxes_transformed.boxes.push_back(boundingbox_transformed);
		}
		in_publisher-&gt;publish(boundingboxes_transformed);
	}
	else
	{
		in_publisher-&gt;publish(in_boundingbox_array);
	}
}

void publishCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_to_publish_ptr)
{
	sensor_msgs::PointCloud2 cloud_msg;
	pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
	cloud_msg.header=_velodyne_header;
	in_publisher-&gt;publish(cloud_msg);
}

void publishColorCloud(const ros::Publisher* in_publisher, const pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr in_cloud_to_publish_ptr)
{
	sensor_msgs::PointCloud2 cloud_msg;
	pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
	cloud_msg.header=_velodyne_header;
	in_publisher-&gt;publish(cloud_msg);
}

void keepLanePoints(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
					pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr,
					float in_left_lane_threshold = 1.5,
					float in_right_lane_threshold = 1.5)
{
	pcl::PointIndices::Ptr far_indices (new pcl::PointIndices);
	for(unsigned int i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
	{
		pcl::PointXYZ current_point;
		current_point.x=in_cloud_ptr-&gt;points[i].x;
		current_point.y=in_cloud_ptr-&gt;points[i].y;
		current_point.z=in_cloud_ptr-&gt;points[i].z;

		if (
				current_point.y &gt; (in_left_lane_threshold) || current_point.y &lt; -1.0*in_right_lane_threshold
			)
		{
			far_indices-&gt;indices.push_back(i);
		}
	}
	out_cloud_ptr-&gt;points.clear();
	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
	extract.setInputCloud (in_cloud_ptr);
	extract.setIndices(far_indices);
	extract.setNegative(true);//true removes the indices, false leaves only the indices
	extract.filter(*out_cloud_ptr);
}

#ifdef GPU_CLUSTERING
std::vector&lt;ClusterPtr&gt; clusterAndColorGpu(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
											pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
											jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
											autoware_msgs::centroids&amp; in_out_centroids,
											double in_max_cluster_distance=0.5)
{
	std::vector&lt;ClusterPtr&gt; clusters;

	//Convert input point cloud to vectors of x, y, and z

	int size = in_cloud_ptr-&gt;points.size();

	if (size == 0)
		return clusters;

	float *tmp_x, *tmp_y, *tmp_z;

	tmp_x = (float *)malloc(sizeof(float) * size);
	tmp_y = (float *)malloc(sizeof(float) * size);
	tmp_z = (float *)malloc(sizeof(float) * size);

	for (int i = 0; i &lt; size; i++) {
		pcl::PointXYZ tmp_point = in_cloud_ptr-&gt;at(i);

		tmp_x[i] = tmp_point.x;
		tmp_y[i] = tmp_point.y;
		tmp_z[i] = tmp_point.z;
	}

	GpuEuclideanCluster gecl_cluster;

	gecl_cluster.setInputPoints(tmp_x, tmp_y, tmp_z, size);
	gecl_cluster.setThreshold(in_max_cluster_distance);
	gecl_cluster.setMinClusterPts (_cluster_size_min);
	gecl_cluster.setMaxClusterPts (_cluster_size_max);
	gecl_cluster.extractClusters();
	std::vector&lt;GpuEuclideanCluster::GClusterIndex&gt; cluster_indices = gecl_cluster.getOutput();

	unsigned int k = 0;

	for (auto it = cluster_indices.begin(); it != cluster_indices.end(); it++)
	{
		ClusterPtr cluster(new Cluster());
		cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;points_in_cluster, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], &quot;&quot;, _pose_estimation);
		clusters.push_back(cluster);

		k++;
	}

	free(tmp_x);
	free(tmp_y);
	free(tmp_z);

	return clusters;
}
#endif

std::vector&lt;ClusterPtr&gt; clusterAndColor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
		autoware_msgs::centroids&amp; in_out_centroids,
		double in_max_cluster_distance=0.5)
{
	pcl::search::KdTree&lt;pcl::PointXYZ&gt;::Ptr tree (new pcl::search::KdTree&lt;pcl::PointXYZ&gt;);

	//create 2d pc
	pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_2d(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
	pcl::copyPointCloud(*in_cloud_ptr, *cloud_2d);
	//make it flat
	for (size_t i=0; i&lt;cloud_2d-&gt;points.size(); i++)
	{
		cloud_2d-&gt;points[i].z = 0;
	}

	if (cloud_2d-&gt;points.size() &gt; 0)
		tree-&gt;setInputCloud (cloud_2d);

	std::vector&lt;pcl::PointIndices&gt; cluster_indices;

	//perform clustering on 2d cloud
	pcl::EuclideanClusterExtraction&lt;pcl::PointXYZ&gt; ec;
	ec.setClusterTolerance (in_max_cluster_distance); //
	ec.setMinClusterSize (_cluster_size_min);
	ec.setMaxClusterSize (_cluster_size_max);
	ec.setSearchMethod(tree);
	ec.setInputCloud (cloud_2d);
	ec.extract (cluster_indices);
	//use indices on 3d cloud

	/*pcl::ConditionalEuclideanClustering&lt;pcl::PointXYZ&gt; cec (true);
	cec.setInputCloud (in_cloud_ptr);
	cec.setConditionFunction (&amp;independentDistance);
	cec.setMinClusterSize (cluster_size_min);
	cec.setMaxClusterSize (cluster_size_max);
	cec.setClusterTolerance (_distance*2.0f);
	cec.segment (cluster_indices);*/

	/////////////////////////////////
	//---	3. Color clustered points
	/////////////////////////////////
	unsigned int k = 0;
	//pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr final_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);

	std::vector&lt;ClusterPtr&gt; clusters;
	//pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_cluster (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);//coord + color cluster
	for (auto it = cluster_indices.begin(); it != cluster_indices.end(); ++it)
	{
		ClusterPtr cluster(new Cluster());
		cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], &quot;&quot;, _pose_estimation);
		clusters.push_back(cluster);

		k++;
	}
	//std::cout &lt;&lt; &quot;Clusters: &quot; &lt;&lt; k &lt;&lt; std::endl;
	return clusters;

}

void checkClusterMerge(size_t in_cluster_id, std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;bool&gt;&amp; in_out_visited_clusters, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold)
{
	//std::cout &lt;&lt; &quot;checkClusterMerge&quot; &lt;&lt; std::endl;
	pcl::PointXYZ point_a = in_clusters[in_cluster_id]-&gt;GetCentroid();
	for(size_t i=0; i&lt; in_clusters.size(); i++)
	{
		if (i != in_cluster_id &amp;&amp; !in_out_visited_clusters[i])
		{
			pcl::PointXYZ point_b = in_clusters[i]-&gt;GetCentroid();
			double distance = sqrt( pow(point_b.x - point_a.x,2) + pow(point_b.y - point_a.y,2) );
			if (distance &lt;= in_merge_threshold)
			{
				in_out_visited_clusters[i] = true;
				out_merge_indices.push_back(i);
				//std::cout &lt;&lt; &quot;Merging &quot; &lt;&lt; in_cluster_id &lt;&lt; &quot; with &quot; &lt;&lt; i &lt;&lt; &quot; dist:&quot; &lt;&lt; distance &lt;&lt; std::endl;
				checkClusterMerge(i, in_clusters, in_out_visited_clusters, out_merge_indices, in_merge_threshold);
			}
		}
	}
}

void mergeClusters(const std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_clusters)
{
	//std::cout &lt;&lt; &quot;mergeClusters:&quot; &lt;&lt; in_merge_indices.size() &lt;&lt; std::endl;
	pcl::PointCloud&lt;pcl::PointXYZRGB&gt; sum_cloud;
	pcl::PointCloud&lt;pcl::PointXYZ&gt; mono_cloud;
	ClusterPtr merged_cluster(new Cluster());
	for (size_t i=0; i&lt;in_merge_indices.size(); i++)
	{
		sum_cloud += *(in_clusters[in_merge_indices[i]]-&gt;GetCloud());
		in_out_merged_clusters[in_merge_indices[i]] = true;
	}
	std::vector&lt;int&gt; indices(sum_cloud.points.size(), 0);
	for (size_t i=0; i&lt;sum_cloud.points.size(); i++)
	{
		indices[i]=i;
	}

	if (sum_cloud.points.size() &gt; 0)
	{
		pcl::copyPointCloud(sum_cloud, mono_cloud);
		//std::cout &lt;&lt; &quot;mergedClusters &quot; &lt;&lt; sum_cloud.points.size() &lt;&lt; &quot; mono:&quot; &lt;&lt; mono_cloud.points.size() &lt;&lt; std::endl;
		//cluster-&gt;SetCloud(in_cloud_ptr, it-&gt;indices, _velodyne_header, k, (int)_colors[k].val[0], (int)_colors[k].val[1], (int)_colors[k].val[2], &quot;&quot;, _pose_estimation);
		merged_cluster-&gt;SetCloud(mono_cloud.makeShared(), indices, _velodyne_header, current_index,(int)_colors[current_index].val[0], (int)_colors[current_index].val[1], (int)_colors[current_index].val[2], &quot;&quot;, _pose_estimation);
		out_clusters.push_back(merged_cluster);
	}
}

void checkAllForMerge(std::vector&lt;ClusterPtr&gt;&amp; in_clusters, std::vector&lt;ClusterPtr&gt;&amp; out_clusters, float in_merge_threshold)
{
	//std::cout &lt;&lt; &quot;checkAllForMerge&quot; &lt;&lt; std::endl;
	std::vector&lt;bool&gt; visited_clusters(in_clusters.size(), false);
	std::vector&lt;bool&gt; merged_clusters(in_clusters.size(), false);
	size_t current_index=0;
	for (size_t i = 0; i&lt; in_clusters.size(); i++)
	{
		if (!visited_clusters[i])
		{
			visited_clusters[i] = true;
			std::vector&lt;size_t&gt; merge_indices;
			checkClusterMerge(i, in_clusters, visited_clusters, merge_indices, in_merge_threshold);
			mergeClusters(in_clusters, out_clusters, merge_indices, current_index++, merged_clusters);
		}
	}
	for(size_t i =0; i&lt; in_clusters.size(); i++)
	{
		//check for clusters not merged, add them to the output
		if (!merged_clusters[i])
		{
			out_clusters.push_back(in_clusters[i]);
		}
	}

	//ClusterPtr cluster(new Cluster());
}

void segmentByDistance(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr,
		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr out_cloud_ptr,
		jsk_recognition_msgs::BoundingBoxArray&amp; in_out_boundingbox_array,
		autoware_msgs::centroids&amp; in_out_centroids,
		autoware_msgs::CloudClusterArray&amp; in_out_clusters,
		jsk_recognition_msgs::PolygonArray&amp; in_out_polygon_array,
		jsk_rviz_plugins::PictogramArray&amp; in_out_pictogram_array)
{
	//cluster the pointcloud according to the distance of the points using different thresholds (not only one for the entire pc)
	//in this way, the points farther in the pc will also be clustered

	//0 =&gt; 0-15m d=0.5
	//1 =&gt; 15-30 d=1
	//2 =&gt; 30-45 d=1.6
	//3 =&gt; 45-60 d=2.1
	//4 =&gt; &gt;60   d=2.6

	std::vector&lt;pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr&gt; cloud_segments_array(5);

	for(unsigned int i=0; i&lt;cloud_segments_array.size(); i++)
	{
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr tmp_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		cloud_segments_array[i] = tmp_cloud;
	}

	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
	{
		pcl::PointXYZ current_point;
		current_point.x = in_cloud_ptr-&gt;points[i].x;
		current_point.y = in_cloud_ptr-&gt;points[i].y;
		current_point.z = in_cloud_ptr-&gt;points[i].z;

		float origin_distance = sqrt( pow(current_point.x,2) + pow(current_point.y,2) );

		if 		(origin_distance &lt; _clustering_distances[0] )	{cloud_segments_array[0]-&gt;points.push_back (current_point);}
		else if(origin_distance &lt; _clustering_distances[1])		{cloud_segments_array[1]-&gt;points.push_back (current_point);}
		else if(origin_distance &lt; _clustering_distances[2])		{cloud_segments_array[2]-&gt;points.push_back (current_point);}
		else if(origin_distance &lt; _clustering_distances[3])		{cloud_segments_array[3]-&gt;points.push_back (current_point);}
		else													{cloud_segments_array[4]-&gt;points.push_back (current_point);}
	}

	std::vector &lt;ClusterPtr&gt; all_clusters;
	for(unsigned int i=0; i&lt;cloud_segments_array.size(); i++)
	{
#ifdef GPU_CLUSTERING
    std::vector&lt;ClusterPtr&gt; local_clusters;
		if (_use_gpu) {
			local_clusters = clusterAndColorGpu(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
		} else {
			local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
		}
#else
		std::vector&lt;ClusterPtr&gt; local_clusters = clusterAndColor(cloud_segments_array[i], out_cloud_ptr, in_out_boundingbox_array, in_out_centroids, _clustering_thresholds[i]);
#endif
		all_clusters.insert(all_clusters.end(), local_clusters.begin(), local_clusters.end());
	}

	//Clusters can be merged or checked in here
	//....
	//check for mergable clusters
	std::vector&lt;ClusterPtr&gt; mid_clusters;
	std::vector&lt;ClusterPtr&gt; final_clusters;

	if (all_clusters.size() &gt; 0)
		checkAllForMerge(all_clusters, mid_clusters, _cluster_merge_threshold);
	else
		mid_clusters = all_clusters;

	if (mid_clusters.size() &gt; 0)
			checkAllForMerge(mid_clusters, final_clusters, _cluster_merge_threshold);
	else
		final_clusters = mid_clusters;

	tf::StampedTransform vectormap_transform;
	if (_use_vector_map)
	{
		cv::TickMeter timer;

		try
		{
			//if the frame of the vectormap is different than the input, obtain transform
			if (_vectormap_frame != _velodyne_header.frame_id)
			{
				_transform_listener-&gt;lookupTransform(_vectormap_frame, _velodyne_header.frame_id, ros::Time(), vectormap_transform);
			}

			timer.reset();timer.start();

			//check if centroids are inside the drivable area
			for(unsigned int i=0; i&lt;final_clusters.size(); i++)
			{
				//transform centroid points to vectormap frame
				pcl::PointXYZ pcl_centroid = final_clusters[i]-&gt;GetCentroid();
				tf::Vector3 vector_centroid (pcl_centroid.x, pcl_centroid.y, pcl_centroid.z);
				tf::Vector3 transformed_centroid;

				if (_vectormap_frame != _velodyne_header.frame_id)
					transformed_centroid = vectormap_transform*vector_centroid;
				else
					transformed_centroid = vector_centroid;

				vector_map_server::PositionState position_state;
				position_state.request.position.x = transformed_centroid.getX();
				position_state.request.position.y = transformed_centroid.getY();
				position_state.request.position.z = transformed_centroid.getZ();


				if (_vectormap_server.call(position_state))
				{
					final_clusters[i]-&gt;SetValidity(position_state.response.state);
					/*std::cout &lt;&lt; &quot;Original:&quot; &lt;&lt; pcl_centroid.x &lt;&lt; &quot;,&quot; &lt;&lt; pcl_centroid.y &lt;&lt; &quot;,&quot; &lt;&lt; pcl_centroid.z &lt;&lt;
							&quot; Transformed:&quot; &lt;&lt; transformed_centroid.x() &lt;&lt; &quot;,&quot; &lt;&lt; transformed_centroid.y() &lt;&lt; &quot;,&quot; &lt;&lt; transformed_centroid.z() &lt;&lt;
							&quot; Validity:&quot; &lt;&lt; position_state.response.state &lt;&lt; std::endl;*/
				}
				else
				{
					ROS_WARN(&quot;vectormap_filtering: VectorMap Server Call failed. Make sure vectormap_server is running. No filtering performed.&quot;);
					final_clusters[i]-&gt;SetValidity(true);
				}
			}
			timer.stop();
			//std::cout &lt;&lt; &quot;vm server took &quot; &lt;&lt; timer.getTimeMilli() &lt;&lt; &quot; ms to check &quot; &lt;&lt; final_clusters.size() &lt;&lt; std::endl;
		}
		catch(tf::TransformException &amp;ex)
		{
			ROS_INFO(&quot;vectormap_filtering: %s&quot;, ex.what());
		}
	}
	//Get final PointCloud to be published
	in_out_polygon_array.header = _velodyne_header;
	in_out_pictogram_array.header = _velodyne_header;
	for(unsigned int i=0; i&lt;final_clusters.size(); i++)
	{
		*out_cloud_ptr = *out_cloud_ptr + *(final_clusters[i]-&gt;GetCloud());

		jsk_recognition_msgs::BoundingBox bounding_box = final_clusters[i]-&gt;GetBoundingBox();
		geometry_msgs::PolygonStamped polygon = final_clusters[i]-&gt;GetPolygon();
		jsk_rviz_plugins::Pictogram pictogram_cluster;
		pictogram_cluster.header = _velodyne_header;

		//PICTO
		pictogram_cluster.mode = pictogram_cluster.STRING_MODE;
		pictogram_cluster.pose.position.x = final_clusters[i]-&gt;GetMaxPoint().x;
		pictogram_cluster.pose.position.y = final_clusters[i]-&gt;GetMaxPoint().y;
		pictogram_cluster.pose.position.z = final_clusters[i]-&gt;GetMaxPoint().z;
		tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
		tf::quaternionTFToMsg(quat, pictogram_cluster.pose.orientation);
		pictogram_cluster.size = 4;
		std_msgs::ColorRGBA color;
		color.a = 1; color.r = 1; color.g = 1; color.b = 1;
		pictogram_cluster.color = color;
		pictogram_cluster.character = std::to_string( i );
		//PICTO

		//pcl::PointXYZ min_point = final_clusters[i]-&gt;GetMinPoint();
		//pcl::PointXYZ max_point = final_clusters[i]-&gt;GetMaxPoint();
		pcl::PointXYZ center_point = final_clusters[i]-&gt;GetCentroid();
		geometry_msgs::Point centroid;
		centroid.x = center_point.x; centroid.y = center_point.y; centroid.z = center_point.z;
		bounding_box.header = _velodyne_header;
		polygon.header = _velodyne_header;

		if (	final_clusters[i]-&gt;IsValid()
				//&amp;&amp; bounding_box.dimensions.x &gt;0 &amp;&amp; bounding_box.dimensions.y &gt;0 &amp;&amp; bounding_box.dimensions.z &gt; 0
				//&amp;&amp;	bounding_box.dimensions.x &lt; _max_boundingbox_side &amp;&amp; bounding_box.dimensions.y &lt; _max_boundingbox_side
				)
		{
			in_out_boundingbox_array.boxes.push_back(bounding_box);
			in_out_centroids.points.push_back(centroid);
			_visualization_marker.points.push_back(centroid);

			in_out_polygon_array.polygons.push_back(polygon);
			in_out_pictogram_array.pictograms.push_back(pictogram_cluster);

			autoware_msgs::CloudCluster cloud_cluster;
			final_clusters[i]-&gt;ToRosMessage(_velodyne_header, cloud_cluster);
			in_out_clusters.clusters.push_back(cloud_cluster);
		}
	}

	for(size_t i=0; i&lt; in_out_polygon_array.polygons.size();i++)
	{
		in_out_polygon_array.labels.push_back(i);
	}

}

void removeFloor(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_nofloor_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_onlyfloor_cloud_ptr, float in_max_height=0.2, float in_floor_max_angle=0.1)
{
	/*pcl::PointIndicesPtr ground (new pcl::PointIndices);
	// Create the filtering object
	pcl::ProgressiveMorphologicalFilter&lt;pcl::PointXYZ&gt; pmf;
	pmf.setInputCloud (in_cloud_ptr);
	pmf.setMaxWindowSize (20);
	pmf.setSlope (1.0f);
	pmf.setInitialDistance (0.5f);
	pmf.setMaxDistance (3.0f);
	pmf.extract (ground-&gt;indices);

	// Create the filtering object
	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
	extract.setInputCloud (in_cloud_ptr);
	extract.setIndices (ground);
	extract.setNegative(true);//true removes the indices, false leaves only the indices
	extract.filter(*out_nofloor_cloud_ptr);

	//EXTRACT THE FLOOR FROM THE CLOUD
	extract.setNegative(false);//true removes the indices, false leaves only the indices
	extract.filter(*out_onlyfloor_cloud_ptr);*/

	pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
	pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
	pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);

	seg.setOptimizeCoefficients (true);
	seg.setModelType(pcl::SACMODEL_PERPENDICULAR_PLANE);
	seg.setMethodType(pcl::SAC_RANSAC);
	seg.setMaxIterations(100);
	seg.setAxis(Eigen::Vector3f(0,0,1));
	seg.setEpsAngle(in_floor_max_angle);

	seg.setDistanceThreshold (in_max_height);//floor distance
	seg.setOptimizeCoefficients(true);
	seg.setInputCloud(in_cloud_ptr);
	seg.segment(*inliers, *coefficients);
	if (inliers-&gt;indices.size () == 0)
	{
		std::cout &lt;&lt; &quot;Could not estimate a planar model for the given dataset.&quot; &lt;&lt; std::endl;
	}

	//REMOVE THE FLOOR FROM THE CLOUD
	pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
	extract.setInputCloud (in_cloud_ptr);
	extract.setIndices(inliers);
	extract.setNegative(true);//true removes the indices, false leaves only the indices
	extract.filter(*out_nofloor_cloud_ptr);

	//EXTRACT THE FLOOR FROM THE CLOUD
	extract.setNegative(false);//true removes the indices, false leaves only the indices
	extract.filter(*out_onlyfloor_cloud_ptr);
}

void downsampleCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_leaf_size=0.2)
{
	pcl::VoxelGrid&lt;pcl::PointXYZ&gt; sor;
	sor.setInputCloud(in_cloud_ptr);
	sor.setLeafSize((float)in_leaf_size, (float)in_leaf_size, (float)in_leaf_size);
	sor.filter(*out_cloud_ptr);
}

void clipCloud(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, float in_min_height=-1.3, float in_max_height=0.5)
{
	out_cloud_ptr-&gt;points.clear();
	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
	{
		if (in_cloud_ptr-&gt;points[i].z &gt;= in_min_height &amp;&amp;
				in_cloud_ptr-&gt;points[i].z &lt;= in_max_height)
		{
			out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
		}
	}
}

void differenceNormalsSegmentation(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr)
{
	float small_scale=0.5;
	float large_scale=2.0;
	float angle_threshold=0.5;
	pcl::search::Search&lt;pcl::PointXYZ&gt;::Ptr tree;
	if (in_cloud_ptr-&gt;isOrganized ())
	{
		tree.reset (new pcl::search::OrganizedNeighbor&lt;pcl::PointXYZ&gt; ());
	}
	else
	{
		tree.reset (new pcl::search::KdTree&lt;pcl::PointXYZ&gt; (false));
	}

	// Set the input pointcloud for the search tree
	tree-&gt;setInputCloud (in_cloud_ptr);

	pcl::NormalEstimationOMP&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
	//pcl::gpu::NormalEstimation&lt;pcl::PointXYZ, pcl::PointNormal&gt; normal_estimation;
	normal_estimation.setInputCloud (in_cloud_ptr);
	normal_estimation.setSearchMethod (tree);

	normal_estimation.setViewPoint (std::numeric_limits&lt;float&gt;::max (), std::numeric_limits&lt;float&gt;::max (), std::numeric_limits&lt;float&gt;::max ());

	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_small_scale (new pcl::PointCloud&lt;pcl::PointNormal&gt;);
	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr normals_large_scale (new pcl::PointCloud&lt;pcl::PointNormal&gt;);

	normal_estimation.setRadiusSearch (small_scale);
	normal_estimation.compute (*normals_small_scale);

	normal_estimation.setRadiusSearch (large_scale);
	normal_estimation.compute (*normals_large_scale);

	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud (new pcl::PointCloud&lt;pcl::PointNormal&gt;);
	pcl::copyPointCloud&lt;pcl::PointXYZ, pcl::PointNormal&gt;(*in_cloud_ptr, *diffnormals_cloud);

	// Create DoN operator
	pcl::DifferenceOfNormalsEstimation&lt;pcl::PointXYZ, pcl::PointNormal, pcl::PointNormal&gt; diffnormals_estimator;
	diffnormals_estimator.setInputCloud (in_cloud_ptr);
	diffnormals_estimator.setNormalScaleLarge (normals_large_scale);
	diffnormals_estimator.setNormalScaleSmall (normals_small_scale);

	diffnormals_estimator.initCompute();

	diffnormals_estimator.computeFeature(*diffnormals_cloud);

	pcl::ConditionOr&lt;pcl::PointNormal&gt;::Ptr range_cond (new pcl::ConditionOr&lt;pcl::PointNormal&gt;() );
	range_cond-&gt;addComparison (pcl::FieldComparison&lt;pcl::PointNormal&gt;::ConstPtr (
			new pcl::FieldComparison&lt;pcl::PointNormal&gt; (&quot;curvature&quot;, pcl::ComparisonOps::GT, angle_threshold) )
			);
	// Build the filter
	pcl::ConditionalRemoval&lt;pcl::PointNormal&gt; cond_removal;
	cond_removal.setCondition(range_cond);
	cond_removal.setInputCloud (diffnormals_cloud);

	pcl::PointCloud&lt;pcl::PointNormal&gt;::Ptr diffnormals_cloud_filtered (new pcl::PointCloud&lt;pcl::PointNormal&gt;);

	// Apply filter
	cond_removal.filter (*diffnormals_cloud_filtered);

	pcl::copyPointCloud&lt;pcl::PointNormal, pcl::PointXYZ&gt;(*diffnormals_cloud, *out_cloud_ptr);
}

void removePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr in_cloud_ptr, pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr out_cloud_ptr, const double in_distance)
{
	out_cloud_ptr-&gt;points.clear();
	for (unsigned int i=0; i&lt;in_cloud_ptr-&gt;points.size(); i++)
	{
		float origin_distance = sqrt( pow(in_cloud_ptr-&gt;points[i].x,2) + pow(in_cloud_ptr-&gt;points[i].y,2) );
		if (origin_distance &gt; in_distance)
		{
			out_cloud_ptr-&gt;points.push_back(in_cloud_ptr-&gt;points[i]);
		}
	}
}

void velodyne_callback(const sensor_msgs::PointCloud2ConstPtr&amp; in_sensor_cloud)
{
	_start = std::chrono::system_clock::now(); // 計測開始時間

	if (!_using_sensor_cloud)
	{
		_using_sensor_cloud = true;

		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_sensor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr removed_points_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr downsampled_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr inlanes_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr nofloor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr onlyfloor_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr diffnormals_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr clipped_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
		pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr colored_clustered_cloud_ptr (new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);

		autoware_msgs::centroids centroids;
		autoware_msgs::CloudClusterArray cloud_clusters;
		jsk_recognition_msgs::BoundingBoxArray boundingbox_array;
		jsk_recognition_msgs::PolygonArray polygon_array;
		jsk_rviz_plugins::PictogramArray pictograms_array;

		pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);

		_velodyne_header = in_sensor_cloud-&gt;header;

		if (_remove_points_upto &gt; 0.0)
		{
			removePointsUpTo(current_sensor_cloud_ptr, removed_points_cloud_ptr, _remove_points_upto);
		}
		else
			removed_points_cloud_ptr = current_sensor_cloud_ptr;

		if (_downsample_cloud)
			downsampleCloud(removed_points_cloud_ptr, downsampled_cloud_ptr, _leaf_size);
		else
			downsampled_cloud_ptr =removed_points_cloud_ptr;

		clipCloud(downsampled_cloud_ptr, clipped_cloud_ptr, _clip_min_height, _clip_max_height);

		if(_keep_lanes)
			keepLanePoints(clipped_cloud_ptr, inlanes_cloud_ptr, _keep_lane_left_distance, _keep_lane_right_distance);
		else
			inlanes_cloud_ptr = clipped_cloud_ptr;

		if(_remove_ground)
		{
			removeFloor(inlanes_cloud_ptr, nofloor_cloud_ptr, onlyfloor_cloud_ptr);
			publishCloud(&amp;_pub_ground_cloud, onlyfloor_cloud_ptr);
		}
		else
			nofloor_cloud_ptr = inlanes_cloud_ptr;

		publishCloud(&amp;_pub_points_lanes_cloud, nofloor_cloud_ptr);

		if (_use_diffnormals)
			differenceNormalsSegmentation(nofloor_cloud_ptr, diffnormals_cloud_ptr);
		else
			diffnormals_cloud_ptr = nofloor_cloud_ptr;

		segmentByDistance(diffnormals_cloud_ptr, colored_clustered_cloud_ptr, boundingbox_array, centroids, cloud_clusters, polygon_array, pictograms_array);

		publishColorCloud(&amp;_pub_cluster_cloud, colored_clustered_cloud_ptr);

		// Publish BB
		boundingbox_array.header = _velodyne_header;

		_pub_jsk_hulls.publish(polygon_array);//publish convex hulls
		_pub_text_pictogram.publish(pictograms_array);//publish_ids

		publishBoundingBoxArray(&amp;_pub_jsk_boundingboxes, boundingbox_array, _output_frame, _velodyne_header);
		centroids.header = _velodyne_header;

		publishCentroids(&amp;_centroid_pub, centroids, _output_frame, _velodyne_header);

		_marker_pub.publish(_visualization_marker);
		_visualization_marker.points.clear();//transform? is it used?
		cloud_clusters.header = _velodyne_header;

		publishCloudClusters(&amp;_pub_clusters_message, cloud_clusters, _output_frame, _velodyne_header);

		_using_sensor_cloud = false;
	}
	_end = std::chrono::system_clock::now();  // 計測終了時間
  double elapsed = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(_end-_start).count(); //処理に要した時間をミリ秒に変換
  ROS_INFO(&quot;Euclidean Clustering : %f&quot;, elapsed);
}

/*
void vectormap_callback(const visualization_msgs::MarkerArray::Ptr in_vectormap_markers)
{
	float min_x=std::numeric_limits&lt;float&gt;::max();float max_x=-std::numeric_limits&lt;float&gt;::max();
	float min_y=std::numeric_limits&lt;float&gt;::max();float max_y=-std::numeric_limits&lt;float&gt;::max();
	pcl::PointXYZ min_point;
	pcl::PointXYZ max_point;
	std::vector&lt;geometry_msgs::Point&gt; vectormap_points;
	std::string marker_frame;
	double map_scale = -10.0;
	for(auto i=in_vectormap_markers-&gt;markers.begin(); i!= in_vectormap_markers-&gt;markers.end(); i++)
	{
		visualization_msgs::Marker current_marker = *i;
		marker_frame = current_marker.header.frame_id;
		if (current_marker.ns == &quot;road_edge&quot;)
		{
			for (unsigned int j=0; j&lt; current_marker.points.size(); j++)
			{
				geometry_msgs::Point p = current_marker.points[j];
				p.x*=map_scale;
				p.y*=map_scale;
				if(p.x&lt;min_x)	min_x = p.x;
				if(p.y&lt;min_y)	min_y = p.y;
				if(p.x&gt;max_x)	max_x = p.x;
				if(p.y&gt;max_y)	max_y = p.y;
				vectormap_points.push_back(p);
			}
		}
	}
	min_point.x = min_x;	min_point.y = min_y;
	max_point.x = max_x;	max_point.y = max_y;

	min_point.x*=-1.0;
	min_point.y*=-1.0;
	//translate the points to the minimum point
	for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
	{
		(*i).x+=min_point.x;
		(*i).y+=min_point.y;
	}
	max_point.x+=min_point.x;
	max_point.y+=min_point.y;
	//get world tf
	std::string error_transform_msg;
	tf::Vector3 map_origin_point;
	if(_transform_listener-&gt;waitForTransform(&quot;/map&quot;, marker_frame, ros::Time(0), ros::Duration(5), ros::Duration(0.1), &amp;error_transform_msg))
	{
		_transform_listener-&gt;lookupTransform(&quot;/map&quot;, marker_frame, ros::Time(0), *_transform);
		map_origin_point = _transform-&gt;getOrigin();
		map_origin_point.setX( map_origin_point.x() - min_point.x);
		map_origin_point.setY( map_origin_point.y() - min_point.y);
	}
	else
	{
		ROS_INFO(&quot;Euclidean Cluster (vectormap_callback): %s&quot;, error_transform_msg.c_str());
	}

	cv::Mat map_image = cv::Mat::zeros(max_point.y, max_point.x, CV_8UC3);

	std::cout &lt;&lt; &quot;W,H:&quot; &lt;&lt; max_point &lt;&lt; std::endl;

	cv::Point image_start_point (vectormap_points[0].x, vectormap_points[0].y);
	cv::Point prev_point = image_start_point;
	for (auto i=vectormap_points.begin(); i!=vectormap_points.end(); i++)
	{
		cv::line(map_image, prev_point, cv::Point((int)(i-&gt;x), (int)(i-&gt;y)), cv::Scalar::all(255));

		prev_point.x = (int)(i-&gt;x);
		prev_point.y = (int)(i-&gt;y);
	}
	cv::circle(map_image, image_start_point, 3, cv::Scalar(255,0,0));
	cv::imshow(&quot;vectormap&quot;, map_image);
	cv::waitKey(0);
}*/

int main (int argc, char** argv)
{
	// Initialize ROS
	ros::init (argc, argv, &quot;euclidean_cluster&quot;);

	ros::NodeHandle h;
	ros::NodeHandle private_nh(&quot;~&quot;);

	tf::StampedTransform transform;
	tf::TransformListener listener;

	_transform = &amp;transform;
	_transform_listener = &amp;listener;

#if (CV_MAJOR_VERSION == 3)
	generateColors(_colors, 100);
#else
	cv::generateColors(_colors, 100);
#endif

	_pub_cluster_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/points_cluster&quot;,1);
	_pub_ground_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/points_ground&quot;,1);
	_centroid_pub = h.advertise&lt;autoware_msgs::centroids&gt;(&quot;/cluster_centroids&quot;,1);
	_marker_pub = h.advertise&lt;visualization_msgs::Marker&gt;(&quot;centroid_marker&quot;,1);

	_pub_points_lanes_cloud = h.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/points_lanes&quot;,1);
	_pub_jsk_boundingboxes = h.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;/bounding_boxes&quot;,1);
	_pub_jsk_hulls = h.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;(&quot;/cluster_hulls&quot;,1);
	_pub_clusters_message = h.advertise&lt;autoware_msgs::CloudClusterArray&gt;(&quot;/cloud_clusters&quot;,1);
	_pub_text_pictogram = h.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;(&quot;cluster_ids&quot;, 10); ROS_INFO(&quot;output pictograms topic: %s&quot;, &quot;cluster_id&quot;);

	std::string points_topic;

	_using_sensor_cloud = false;

	if (private_nh.getParam(&quot;points_node&quot;, points_topic))
	{
		ROS_INFO(&quot;euclidean_cluster &gt; Setting points node to %s&quot;, points_topic.c_str());
	}
	else
	{
		ROS_INFO(&quot;euclidean_cluster &gt; No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC&quot;);
		points_topic = &quot;/points_raw&quot;;
	}

	_use_diffnormals = false;
	if (private_nh.getParam(&quot;use_diffnormals&quot;, _use_diffnormals))
	{
		if (_use_diffnormals)
			ROS_INFO(&quot;Euclidean Clustering: Applying difference of normals on clustering pipeline&quot;);
		else
			ROS_INFO(&quot;Euclidean Clustering: Difference of Normals will not be used.&quot;);
	}

	/* Initialize tuning parameter */
	private_nh.param(&quot;downsample_cloud&quot;, _downsample_cloud, false);	ROS_INFO(&quot;downsample_cloud: %d&quot;, _downsample_cloud);
	private_nh.param(&quot;remove_ground&quot;, _remove_ground, true);		ROS_INFO(&quot;remove_ground: %d&quot;, _remove_ground);
	private_nh.param(&quot;leaf_size&quot;, _leaf_size, 0.1);					ROS_INFO(&quot;leaf_size: %f&quot;, _leaf_size);
	private_nh.param(&quot;cluster_size_min&quot;, _cluster_size_min, 20);	ROS_INFO(&quot;cluster_size_min %d&quot;, _cluster_size_min);
	private_nh.param(&quot;cluster_size_max&quot;, _cluster_size_max, 100000);ROS_INFO(&quot;cluster_size_max: %d&quot;, _cluster_size_max);
	private_nh.param(&quot;pose_estimation&quot;, _pose_estimation, false);	ROS_INFO(&quot;pose_estimation: %d&quot;, _pose_estimation);
	private_nh.param(&quot;clip_min_height&quot;, _clip_min_height, -1.3);	ROS_INFO(&quot;clip_min_height: %f&quot;, _clip_min_height);
	private_nh.param(&quot;clip_max_height&quot;, _clip_max_height, 0.5);		ROS_INFO(&quot;clip_max_height: %f&quot;, _clip_max_height);
	private_nh.param(&quot;keep_lanes&quot;, _keep_lanes, false);				ROS_INFO(&quot;keep_lanes: %d&quot;, _keep_lanes);
	private_nh.param(&quot;keep_lane_left_distance&quot;, _keep_lane_left_distance, 5.0);		ROS_INFO(&quot;keep_lane_left_distance: %f&quot;, _keep_lane_left_distance);
	private_nh.param(&quot;keep_lane_right_distance&quot;, _keep_lane_right_distance, 5.0);	ROS_INFO(&quot;keep_lane_right_distance: %f&quot;, _keep_lane_right_distance);
	private_nh.param(&quot;clustering_thresholds&quot;, _clustering_thresholds);
	private_nh.param(&quot;clustering_distances&quot;, _clustering_distances);
	private_nh.param(&quot;max_boundingbox_side&quot;, _max_boundingbox_side, 10.0);				ROS_INFO(&quot;max_boundingbox_side: %f&quot;, _max_boundingbox_side);
	private_nh.param(&quot;cluster_merge_threshold&quot;, _cluster_merge_threshold, 1.5);			ROS_INFO(&quot;cluster_merge_threshold: %f&quot;, _cluster_merge_threshold);
	private_nh.param&lt;std::string&gt;(&quot;output_frame&quot;, _output_frame, &quot;velodyne&quot;);			ROS_INFO(&quot;output_frame: %s&quot;, _output_frame.c_str());

	private_nh.param(&quot;use_vector_map&quot;, _use_vector_map, false);							ROS_INFO(&quot;use_vector_map: %d&quot;, _use_vector_map);
	private_nh.param&lt;std::string&gt;(&quot;vectormap_frame&quot;, _vectormap_frame, &quot;map&quot;);			ROS_INFO(&quot;vectormap_frame: %s&quot;, _output_frame.c_str());

	private_nh.param(&quot;remove_points_upto&quot;, _remove_points_upto, 0.0);		ROS_INFO(&quot;remove_points_upto: %f&quot;, _remove_points_upto);

	private_nh.param(&quot;use_gpu&quot;, _use_gpu, false);				ROS_INFO(&quot;use_gpu: %d&quot;, _use_gpu);

	_velodyne_transform_available = false;

	if (_clustering_distances.size()!=4)
	{
		_clustering_distances = {15, 30, 45, 60};//maximum distance from sensor origin to separate segments
	}
	if (_clustering_thresholds.size()!=5)
	{
		_clustering_thresholds = {0.5, 1.1, 1.6, 2.1, 2.6};//Nearest neighbor distance threshold for each segment
	}

	std::cout &lt;&lt; &quot;_clustering_thresholds: &quot;; for (auto i = _clustering_thresholds.begin(); i != _clustering_thresholds.end(); ++i)  std::cout &lt;&lt; *i &lt;&lt; ' '; std::cout &lt;&lt; std::endl;
	std::cout &lt;&lt; &quot;_clustering_distances: &quot;;for (auto i = _clustering_distances.begin(); i != _clustering_distances.end(); ++i)  std::cout &lt;&lt; *i &lt;&lt; ' '; std::cout &lt;&lt;std::endl;

	// Create a ROS subscriber for the input point cloud
	ros::Subscriber sub = h.subscribe (points_topic, 1, velodyne_callback);
	//ros::Subscriber sub_vectormap = h.subscribe (&quot;vector_map&quot;, 1, vectormap_callback);
	_vectormap_server = h.serviceClient&lt;vector_map_server::PositionState&gt;(&quot;vector_map_server/is_way_area&quot;);

	_visualization_marker.header.frame_id = &quot;velodyne&quot;;
	_visualization_marker.header.stamp = ros::Time();
	_visualization_marker.ns = &quot;my_namespace&quot;;
	_visualization_marker.id = 0;
	_visualization_marker.type = visualization_msgs::Marker::SPHERE_LIST;
	_visualization_marker.action = visualization_msgs::Marker::ADD;
	_visualization_marker.scale.x = 1.0;
	_visualization_marker.scale.y = 1.0;
	_visualization_marker.scale.z = 1.0;
	_visualization_marker.color.a = 1.0;
	_visualization_marker.color.r = 0.0;
	_visualization_marker.color.g = 0.0;
	_visualization_marker.color.b = 1.0;
	// marker.lifetime = ros::Duration(0.1);
	_visualization_marker.frame_locked = true;

	// Spin
	ros::spin ();
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="3425662de7b23ac9955e5569f0f9ef61222d072c" fix_time="422,53938">
		<msg>TierFusion Driver Updated (#742)

Added Support for new firmware version.
Features:
-IP Address changed to the same as Velodyne's
-Automatic Device Initialization &quot;PlugAndPlay&quot;

Host IP Address MUST be set 192.168.1.1
TierFusion address is fixed to 192.168.1.200
Velodyne address is considered as default value, 192.168.1.201

Tested in 14.04 and 16.04</msg>
		<modified_files>
			<file old_path="ros/src/sensing/drivers/camera/packages/vectacam/nodes/vectacam/VectaCam.cpp" new_path="ros/src/sensing/drivers/camera/packages/vectacam/nodes/vectacam/VectaCam.cpp">
				<diff>@@ -1,6 +1,6 @@
 #include &quot;VectaCam.h&quot;
 
-VectaCam::VectaCam(unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file)
+VectaCam::VectaCam(std::string in_camera_ip, unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file)
 {
 	this-&gt;data_port_ 			= in_data_port;
 	this-&gt;configuration_port_ 	= in_configuration_port;
@@ -14,6 +14,7 @@ VectaCam::VectaCam(unsigned int in_configuration_port, unsigned int in_data_port
 	this-&gt;image_height_ 		= VECTACAM_IMG_HEIGHT;
 	this-&gt;image_buffer_ 		= new char[image_width_ * 3 * image_height_];
 	this-&gt;parameter_file_ 		= in_parameter_file;
+	this-&gt;camera_ip_			= in_camera_ip;
 	_initialize_camera(configuration_port_, data_port_, parameter_file_);
 }
 
@@ -61,7 +62,7 @@ void VectaCam::_send_commands_to_camera(unsigned int in_port, std::vector&lt;VectaC
 	memset((char *) &amp;socket_address, 0, sizeof(socket_address));
 	socket_address.sin_family = AF_INET;
 	socket_address.sin_port = htons(in_port);
-	if (inet_aton(&quot;10.0.0.1&quot;, &amp;socket_address.sin_addr)==0)
+	if (inet_aton(camera_ip_.c_str(), &amp;socket_address.sin_addr)==0)
 	{
 		std::cout &lt;&lt; &quot;Invalid IP address&quot; &lt;&lt; std::endl;
 		return;
@@ -121,7 +122,7 @@ void VectaCam::_enable_camera(unsigned int in_port, bool in_enable)
 	memset((char *) &amp;socket_address, 0, sizeof(socket_address));
 	socket_address.sin_family = AF_INET;
 	socket_address.sin_port = htons(in_port);
-	if (inet_aton(VECTACAM_CAMERA_IP, &amp;socket_address.sin_addr)==0)
+	if (inet_aton(camera_ip_.c_str(), &amp;socket_address.sin_addr)==0)
 	{
 		std::cout &lt;&lt; &quot;Invalid IP address&quot; &lt;&lt; std::endl;
 		return;
@@ -167,7 +168,6 @@ long int VectaCam::GetFrameNumber()
 
 void VectaCam::StartCamera()
 {
-
 	int 		socket_descriptor;
 	struct 		sockaddr_in socket_address;
 	socklen_t length;
@@ -177,6 +177,7 @@ void VectaCam::StartCamera()
 		std::cout &lt;&lt; &quot;Problem creating socket\n&quot;;
 		return;
 	}
+	std::cout &lt;&lt; &quot;Socket Created\n&quot;;
 
 	socket_address.sin_family = AF_INET;
 	socket_address.sin_addr.s_addr = htonl(INADDR_ANY);
@@ -187,6 +188,7 @@ void VectaCam::StartCamera()
 		std::cout &lt;&lt; &quot;Problem binding&quot; &lt;&lt; std::endl;
 		return;
 	}
+	std::cout &lt;&lt; &quot;Binded...&quot; &lt;&lt; std::endl;
 
 	length = sizeof(socket_address);
 	if (getsockname(socket_descriptor, reinterpret_cast&lt;sockaddr *&gt; (&amp;socket_address), &amp;length) &lt; 0)
@@ -241,6 +243,7 @@ void VectaCam::_udp_receive(int in_socket_descriptor)
 		}
 		else
 		{
+			//std::cout &lt;&lt; &quot;Received data &quot; &lt;&lt; n &lt;&lt; std::endl;
 			uint32_t packet_offset = ntohl(*(uint32_t*)(buffer_in + 4));
 			uint32_t packet_length = ntohl(*(uint32_t*)(buffer_in + 8));
 			uint32_t header = ntohl(*(uint32_t*)(buffer_in + 12));
@@ -256,7 +259,6 @@ void VectaCam::_udp_receive(int in_socket_descriptor)
 			}
 			else
 			{
-
 				line_number = header - 1;
 				_form_image(line_number, buffer_in, packet_offset, packet_length);
 			}
</diff>
				<old_file>#include &quot;VectaCam.h&quot;

VectaCam::VectaCam(unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file)
{
	this-&gt;data_port_ 			= in_data_port;
	this-&gt;configuration_port_ 	= in_configuration_port;
	this-&gt;camera_ready_ 		= false;
	this-&gt;running_ 				= false;
	this-&gt;fps_ 					= 0.0;
	this-&gt;frame_number_			= 0;
	this-&gt;frame_counter_		= 0;
	this-&gt;payload_offset_ 		= 16;
	this-&gt;image_width_ 			= VECTACAM_IMG_WIDTH * VECTACAM_NUM_CAMERAS;
	this-&gt;image_height_ 		= VECTACAM_IMG_HEIGHT;
	this-&gt;image_buffer_ 		= new char[image_width_ * 3 * image_height_];
	this-&gt;parameter_file_ 		= in_parameter_file;
	_initialize_camera(configuration_port_, data_port_, parameter_file_);
}

void VectaCam::_parse_parameter_file(std::string in_parameter_file, std::vector&lt;VectaCamCommand&gt;&amp; out_commands)
{
	std::string line;
	std::ifstream config_file (parameter_file_);
	std::string delimiter = &quot;:&quot;;
	out_commands.clear();
	if (!config_file.is_open())
	{
		std::cout &lt;&lt; &quot;Unable to open file:&quot; &lt;&lt; parameter_file_;
		return;
	}

	while ( getline (config_file,line) )
	{
		std::vector&lt;std::string&gt; tokens;
		boost::split(tokens, line, boost::is_any_of(&quot;:&quot;));
		if (tokens.size()==2)
		{
			VectaCamCommand current_command;
			int full_address = std::stoi(tokens[0], NULL, 16);
			current_command.low_nibble_address = (unsigned char)( (full_address&gt;&gt;0) &amp; 0xFF);
			current_command.high_nibble_address = (unsigned char)((full_address&gt;&gt;8) &amp; 0xFF);
			current_command.command_data = std::stoi(tokens[1], NULL, 16);
			out_commands.push_back(current_command);
		}
		else
			std::cout &lt;&lt; &quot;Unrecognized command in configuration file: &quot; &lt;&lt; parameter_file_ &lt;&lt; std::endl;
	}
	config_file.close();
}

void VectaCam::_send_commands_to_camera(unsigned int in_port, std::vector&lt;VectaCamCommand&gt; in_commands)
{

	int socket_descriptor;
	struct sockaddr_in socket_address;
	if ((socket_descriptor=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0)
	{
		std::cout &lt;&lt; &quot;Problem creating socket\n&quot;;
		return;
	}
	memset((char *) &amp;socket_address, 0, sizeof(socket_address));
	socket_address.sin_family = AF_INET;
	socket_address.sin_port = htons(in_port);
	if (inet_aton(&quot;10.0.0.1&quot;, &amp;socket_address.sin_addr)==0)
	{
		std::cout &lt;&lt; &quot;Invalid IP address&quot; &lt;&lt; std::endl;
		return;
	}
	for (unsigned int i=0; i&lt; in_commands.size(); i++)
	{
		VectaCamCommand current_command = in_commands[i];
		unsigned char command_buffer[12] = {0x05, 0x00, 0x36, 0x00, 0x00, 0x00,
									current_command.low_nibble_address, current_command.high_nibble_address, current_command.command_data,
									0x00, 0x00, 0x00};
		ssize_t sent_data = sendto(socket_descriptor, command_buffer, sizeof(command_buffer), 0,(struct sockaddr *) &amp;socket_address, sizeof(socket_address));
		if (sent_data &lt; 0)
		{
			std::cout &lt;&lt; &quot;Could not send the data to the camera socket&quot; &lt;&lt; std::endl;
		}
		else
			std::cout &lt;&lt; (int)current_command.high_nibble_address &lt;&lt;
						(int)current_command.low_nibble_address &lt;&lt; &quot;:&quot; &lt;&lt;
						(int)current_command.command_data &lt;&lt; std::endl;
		usleep(50000);
	}
}

void VectaCam::_enable_camera(unsigned int in_port, bool in_enable)
{
	unsigned char camonoff = in_enable ? 0xff : 0x00;
	unsigned char enable_command[] =	{0x00, 0x00, // upldest = 0
				 0x00, // inspect target
				 0x02, // command(write)
				 0x00, 0x00, 0x00, 0x00, // data_output
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00,
				 0x00, 0x00, 0x00, (camonoff),
				 0x00, 0x00, 0x00, 0x00, // module_reset
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00, //
				 0x00, 0x00, 0x00, 0x00 };
	int socket_descriptor;
	struct sockaddr_in socket_address;
	if ((socket_descriptor=socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0)
	{
		std::cout &lt;&lt; &quot;Problem creating socket\n&quot;;
		return;
	}
	memset((char *) &amp;socket_address, 0, sizeof(socket_address));
	socket_address.sin_family = AF_INET;
	socket_address.sin_port = htons(in_port);
	if (inet_aton(VECTACAM_CAMERA_IP, &amp;socket_address.sin_addr)==0)
	{
		std::cout &lt;&lt; &quot;Invalid IP address&quot; &lt;&lt; std::endl;
		return;
	}
	if (sendto(socket_descriptor, enable_command, sizeof(enable_command), 0, reinterpret_cast&lt;sockaddr *&gt;(&amp;socket_address), sizeof(socket_address)) &lt; 0)
	{
		std::cout &lt;&lt; &quot;Could not send the enable command to the camera socket&quot; &lt;&lt; std::endl;
	}
}

void VectaCam::_initialize_camera(unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file)
{
	std::cout &lt;&lt; &quot;Reading configuration file...&quot;;
	_parse_parameter_file(parameter_file_, camera_commands_);
	std::cout &lt;&lt; &quot;DONE&quot; &lt;&lt; std::endl &lt;&lt; &quot;Configuring camera.&quot;;
	_send_commands_to_camera(in_configuration_port, camera_commands_);
	std::cout &lt;&lt; &quot;DONE&quot; &lt;&lt; std::endl &lt;&lt; &quot;Enabling camera.&quot;;
	_enable_camera(in_data_port, true);
	std::cout &lt;&lt; &quot;DONE&quot; &lt;&lt; std::endl;
}

VectaCam::~VectaCam()
{
	this-&gt;running_=false;
	delete[] this-&gt;image_buffer_;
}

void VectaCam::GetImage(cv::Mat&amp; out_image)
{
	out_image = camera_image_.clone();
}

void VectaCam::StopCamera()
{
	this-&gt;running_ = false;
	_enable_camera(data_port_, false);
}

long int VectaCam::GetFrameNumber()
{
	return this-&gt;frame_number_;
}

void VectaCam::StartCamera()
{

	int 		socket_descriptor;
	struct 		sockaddr_in socket_address;
	socklen_t length;

	if ((socket_descriptor = socket( PF_INET, SOCK_DGRAM, 0)) &lt; 0)
	{
		std::cout &lt;&lt; &quot;Problem creating socket\n&quot;;
		return;
	}

	socket_address.sin_family = AF_INET;
	socket_address.sin_addr.s_addr = htonl(INADDR_ANY);
	socket_address.sin_port = htons(this-&gt;data_port_);

	if (bind(socket_descriptor, reinterpret_cast&lt;sockaddr *&gt; (&amp;socket_address), sizeof(socket_address)) &lt; 0)
	{
		std::cout &lt;&lt; &quot;Problem binding&quot; &lt;&lt; std::endl;
		return;
	}

	length = sizeof(socket_address);
	if (getsockname(socket_descriptor, reinterpret_cast&lt;sockaddr *&gt; (&amp;socket_address), &amp;length) &lt; 0)
	{
		std::cout &lt;&lt; &quot;Error getsockname&quot; &lt;&lt; std::endl;
		return;
	}
	this-&gt;camera_ready_ = true;
	this-&gt;running_ = true;

	std::cout &lt;&lt; &quot;Listening camera in UDP port number &quot; &lt;&lt; ntohs(socket_address.sin_port) &lt;&lt; std::endl;

	_udp_receive(socket_descriptor);
}

void VectaCam::_form_image(int in_line_number, char* in_buffer, uint32_t in_packet_offset, uint32_t in_packet_length)
{
	int p = in_packet_offset * 3;
	int k = payload_offset_ + 4 * in_packet_length;
	int total = (in_packet_length);
	if (in_line_number &lt; image_height_ &amp;&amp; total &lt; 1500 &amp;&amp; p &lt; image_width_ * 3
			&amp;&amp; total &gt; 10)
	{
		for (int i = 0; i &lt; total; ++i)
		{
			image_buffer_[in_line_number * image_width_ * 3 + p + 2] = (((((int) in_buffer[k + 0]) &lt;&lt; 4) &amp; 0x3f0) + ((((int) in_buffer[k + 1]) &gt;&gt; 4) &amp; 0xf)) &gt;&gt; 2; // R
			image_buffer_[in_line_number * image_width_ * 3 + p + 1] = (((((int) in_buffer[k + 1]) &lt;&lt; 6) &amp; 0x3c0) + ((((int) in_buffer[k + 2]) &gt;&gt; 2) &amp; 0x3f)) &gt;&gt;2; // G
			image_buffer_[in_line_number * image_width_ * 3 + p + 0] = (((((int) in_buffer[k + 2]) &lt;&lt; 8) &amp; 0x300)	+ ((((int) in_buffer[k + 3]) &gt;&gt; 0) &amp; 0xff)) &gt;&gt; 2; // B

			p += 3;
			k -= 4;
		}
	}
}

void VectaCam::_udp_receive(int in_socket_descriptor)
{
	int 			n;
	size_t			length;
	char 			buffer_in[VECTACAM_MAX_BUFFER];
	struct 			sockaddr_in remote;
	length = sizeof(remote);

	int line_number = 0;

	while (this-&gt;running_)
	{
		n = recvfrom(in_socket_descriptor, buffer_in, VECTACAM_MAX_BUFFER, 0, reinterpret_cast&lt;sockaddr *&gt; (&amp;remote), (unsigned int*) &amp;length);
		if (n &lt; 0)
		{
			std::cout &lt;&lt; &quot;Error receiving data&quot; &lt;&lt; std::endl;
		}
		else
		{
			uint32_t packet_offset = ntohl(*(uint32_t*)(buffer_in + 4));
			uint32_t packet_length = ntohl(*(uint32_t*)(buffer_in + 8));
			uint32_t header = ntohl(*(uint32_t*)(buffer_in + 12));

			if (header == VECTACAM_FRAME_START) {
				// frame start
			}
			else if (header == VECTACAM_FRAME_END)
			{
				// frame end
				this-&gt;camera_image_ = cv::Mat(image_height_, image_width_, CV_8UC3, image_buffer_);
				frame_number_++;
			}
			else
			{

				line_number = header - 1;
				_form_image(line_number, buffer_in, packet_offset, packet_length);
			}
		}
	}
}

</old_file>
			</file>
			<file old_path="ros/src/sensing/drivers/camera/packages/vectacam/nodes/vectacam/VectaCam.h" new_path="ros/src/sensing/drivers/camera/packages/vectacam/nodes/vectacam/VectaCam.h">
				<diff>@@ -40,7 +40,7 @@ struct VectaCamCommand
 class VectaCam
 {
 public:
-	VectaCam(unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file);
+	VectaCam(std::string in_camera_ip, unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file);
 	void 			GetImage(cv::Mat&amp; out_image);
 	virtual 		~VectaCam();
 	void 			StartCamera();
@@ -61,6 +61,7 @@ private:
 	int				image_width_;
 	int				image_height_;
 	char			*image_buffer_;
+	std::string		camera_ip_;
 	void 			_udp_receive(int in_socket_descriptor);
 	void			_initialize_camera(unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file);
 	void			_parse_parameter_file(std::string in_parameter_file, std::vector&lt;VectaCamCommand&gt;&amp; out_commands);
</diff>
				<old_file>#ifndef VECTACAM_H_
#define VECTACAM_H_

#include &lt;unistd.h&gt;     /* defines STDIN_FILENO, system calls,etc */
#include &lt;sys/types.h&gt;  /* system data type definitions */
#include &lt;sys/socket.h&gt; /* socket specific definitions */
#include &lt;netinet/in.h&gt; /* INET constants and stuff */
#include &lt;arpa/inet.h&gt;  /* IP address conversion stuff */
#include &lt;netdb.h&gt;      /* gethostbyname */

#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;boost/algorithm/string.hpp&gt;

#include &quot;opencv2/core/core.hpp&quot;

#define VECTACAM_CONFIG_PORT 		16385
#define VECTACAM_DATA_PORT 			16386
#define VECTACAM_NUM_CAMERAS		8

#define VECTACAM_FRAME_START 		(0x01000000)
#define VECTACAM_FRAME_END   		(0x02000000)

#define VECTACAM_DATA_OFFSET 		(16)

#define VECTACAM_MAX_BUFFER 			1024*1024

#define VECTACAM_IMG_WIDTH			640
#define VECTACAM_IMG_HEIGHT			480

#define VECTACAM_CAMERA_IP			&quot;10.0.0.1&quot;

struct VectaCamCommand
{
	unsigned char low_nibble_address;
	unsigned char high_nibble_address;
	unsigned char command_data;
};

class VectaCam
{
public:
	VectaCam(unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file);
	void 			GetImage(cv::Mat&amp; out_image);
	virtual 		~VectaCam();
	void 			StartCamera();
	void 			StopCamera();
	long int		GetFrameNumber();
	std::string 	GetFps();

private:
	int 			data_port_;
	int 			configuration_port_;
	bool 			running_;
	cv::Mat			camera_image_;
	bool			camera_ready_;
	long 	 		frame_counter_;
	long 	 		frame_number_;
	double 			fps_;
	int 			payload_offset_;
	int				image_width_;
	int				image_height_;
	char			*image_buffer_;
	void 			_udp_receive(int in_socket_descriptor);
	void			_initialize_camera(unsigned int in_configuration_port, unsigned int in_data_port, std::string in_parameter_file);
	void			_parse_parameter_file(std::string in_parameter_file, std::vector&lt;VectaCamCommand&gt;&amp; out_commands);
	void			_send_commands_to_camera(unsigned int in_port, std::vector&lt;VectaCamCommand&gt; in_commands);
	void 			_enable_camera(unsigned int in_port, bool in_enable);
	void 			_form_image(int in_line_number, char* in_buffer, uint32_t in_packet_offset, uint32_t in_packet_length);
	std::string		parameter_file_;
	std::vector&lt;VectaCamCommand&gt; camera_commands_;
};

#endif /* VECTACAM_H_ */
</old_file>
			</file>
			<file old_path="ros/src/sensing/drivers/camera/packages/vectacam/nodes/vectacam/vectacam_node.cpp" new_path="ros/src/sensing/drivers/camera/packages/vectacam/nodes/vectacam/vectacam_node.cpp">
				<diff>@@ -76,7 +76,7 @@ public:
 			publishers_cameras_[i] = node_handle_.advertise&lt;sensor_msgs::Image&gt;(current_topic, 1);
 		}
 
-		VectaCam vectacamera(VECTACAM_CONFIG_PORT, VECTACAM_DATA_PORT, config_file_path);
+		VectaCam vectacamera(camera_ip, VECTACAM_CONFIG_PORT, VECTACAM_DATA_PORT, config_file_path);
 		std::thread *capture_thread= new std::thread(&amp;VectaCam::StartCamera, &amp;vectacamera);
 
 		cv::Mat image;
</diff>
				<old_file>/*
 *  Copyright (c) 2016, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include &lt;ros/ros.h&gt;
#include &quot;ros/package.h&quot;
#include &lt;image_transport/image_transport.h&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;cv_bridge/cv_bridge.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &lt;thread&gt;
#include &lt;signal.h&gt;
#include&lt;unistd.h&gt;

#include &quot;VectaCam.h&quot;

class RosVectaCam
{
public:
	void Run()
	{
		std::string config_file_path;
		std::string camera_ip;

		ros::NodeHandle private_node_handle(&quot;~&quot;);

		if (private_node_handle.getParam(&quot;configfile&quot;, config_file_path))
		{
			ROS_INFO(&quot;Setting config file path to %s&quot;, config_file_path.c_str());
		}
		else
		{
			ROS_INFO(&quot;No config file received. Terminating...&quot;);
			config_file_path = ros::package::getPath(ros::this_node::getName())+&quot;/initialization_params.txt&quot;;
			//return;
		}
		if (private_node_handle.getParam(&quot;camera_ip&quot;, camera_ip))
		{
			ROS_INFO(&quot;Setting camera IP to %s&quot;, camera_ip.c_str());
		}
		else
		{
			ROS_INFO(&quot;No IP, defaulting to %s, you can use _img_obj_node:=YOUR_TOPIC&quot;, VECTACAM_CAMERA_IP);
			camera_ip = VECTACAM_CAMERA_IP;
		}

		for (unsigned int i=0; i&lt; VECTACAM_NUM_CAMERAS; i++)
		{
			std::string current_topic = &quot;camera&quot; + std::to_string(i) + &quot;/image_raw&quot;;
			publishers_cameras_[i] = node_handle_.advertise&lt;sensor_msgs::Image&gt;(current_topic, 1);
		}

		VectaCam vectacamera(VECTACAM_CONFIG_PORT, VECTACAM_DATA_PORT, config_file_path);
		std::thread *capture_thread= new std::thread(&amp;VectaCam::StartCamera, &amp;vectacamera);

		cv::Mat image;
		std::vector&lt;cv::Mat&gt; camera_images(VECTACAM_NUM_CAMERAS);
		unsigned long int counter = 0;
		ros::Rate loop_rate(7); // Hz
		ros::Publisher full_publisher = node_handle_.advertise&lt;sensor_msgs::Image&gt;(&quot;image_raw&quot;, 1);
		while(ros::ok())
		{
			vectacamera.GetImage(image);
			if(!image.empty())
			{
				cv::flip(image, image, 0);
				_publish_image(image, full_publisher, counter);
				for (unsigned int i=0; i&lt; VECTACAM_NUM_CAMERAS; i++)
				{
					camera_images[i]= image(cv::Rect(i*image.cols/VECTACAM_NUM_CAMERAS, 0, image.cols/VECTACAM_NUM_CAMERAS,image.rows));
					//if(!camera_images[i].empty())
						_publish_image(camera_images[i], publishers_cameras_[i], counter);
					//else
						//std::cout &lt;&lt; &quot;Empty frame from image: &quot; &lt;&lt; i &lt;&lt; &quot; at frame &quot; &lt;&lt; counter &lt;&lt; std::endl;
				}
				//_publish_image(image, publishers_cameras_[NUM_CAMERAS], counter);

				counter++;
				if (counter&lt;=2)
					std::cout &lt;&lt; &quot;Image received&quot; &lt;&lt; std::endl;
			}
			else
			{
				std::cout &lt;&lt; &quot;No image received&quot; &lt;&lt; std::endl;
			}
			loop_rate.sleep();
		}
		vectacamera.StopCamera();
		capture_thread-&gt;join();
		delete capture_thread;
	}
private:
	ros::Publisher 		publishers_cameras_[VECTACAM_NUM_CAMERAS];
	ros::NodeHandle 	node_handle_;

	void _publish_image(cv::Mat &amp;in_image, ros::Publisher &amp;in_publisher, unsigned long int in_counter)
	{
		sensor_msgs::ImagePtr msg;
		std_msgs::Header header;
		msg = cv_bridge::CvImage(std_msgs::Header(), &quot;bgr8&quot;, in_image).toImageMsg();
		msg-&gt;header.frame_id = &quot;camera&quot;;
		msg-&gt;header.stamp.sec = ros::Time::now().sec;
		msg-&gt;header.stamp.nsec = ros::Time::now().nsec;
		msg-&gt;header.seq = in_counter;

		in_publisher.publish(msg);
	}
};

int main(int argc, char* argv[])
{
	ros::init(argc, argv, &quot;vectacam&quot;);

	RosVectaCam app;

	app.Run();

	return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="046b973dae7e21b1cfa73f772fade9557e5b1157" fix_time="0,71784">
		<msg>Fixed a bug that caused missing points</msg>
		<modified_files>
			<file old_path="ros/src/sensing/filters/packages/points_preprocessor/nodes/ground_filter/ground_filter.cpp" new_path="ros/src/sensing/filters/packages/points_preprocessor/nodes/ground_filter/ground_filter.cpp">
				<diff>@@ -162,7 +162,8 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 
 	velodyne_pointcloud::PointXYZIR point;
 
-	horizontal_res_ = int(in_cloud_msg-&gt;points.size() / vertical_res_);
+	//This line is not necessary
+	//horizontal_res_ = int(in_cloud_msg-&gt;points.size() / vertical_res_);
 	InitDepthMap(horizontal_res_);
 
 	for (size_t i = 0; i &lt; in_cloud_msg-&gt;points.size(); i++)
@@ -259,6 +260,11 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 						}
 						point_index_size = 0;
 					}
+					//These line were missing
+					r_ref = r0;
+					z_ref = z0;
+					point_index[point_index_size] = j;
+					point_index_size++;
 				}
 			}
 			if (j == 0)
@@ -332,6 +338,20 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 						}
 					}
 					else
+					{
+						if(cluster_index_size &gt; 1)
+						{
+							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
+						}
+						else
+						{
+							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
+						}
+						cluster_index[cluster_index_size] = unknown_index[m];
+						cluster_index_size++;
+						centroid = r0;
+					}
+					if (m == 0)
 					{
 						if(cluster_index_size &gt; 1)
 						{
</diff>
				<old_file>/*
 * ground_filter.cpp
 *
 * Created on	: May 19, 2017
 * Author	: Patiphon Narksri					
 */
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;opencv/cv.h&gt;

enum Label
{
	GROUND,
	VERTICAL,
	UNKNOWN //Initial state, not classified
};

class GroundFilter
{
public:
	
	GroundFilter();

private:

	ros::NodeHandle node_handle_;
	ros::Subscriber points_node_sub_;
	ros::Publisher groundless_points_pub_;
	ros::Publisher ground_points_pub_;

	std::string point_topic_;
	int 		sensor_model_;
	double 		sensor_height_;
	double 		max_slope_;
	int 		min_point_;
	double 		clipping_thres_;
	double 		gap_thres_;
	double		point_distance_;
	bool		floor_removal_;

	int 		vertical_res_;
	int 		horizontal_res_;
	double 		limiting_ratio_;
	cv::Mat 	index_map_;
	Label 		class_label_[64];

	boost::chrono::high_resolution_clock::time_point t1_;
	boost::chrono::high_resolution_clock::time_point t2_;
	boost::chrono::nanoseconds elap_time_;

	const int 	DEFAULT_HOR_RES = 2000;

	void InitLabelArray(int in_model);
	void InitDepthMap(int in_width);
	void PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				int in_indices[], int &amp;in_out_index_size, 
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud);


	void VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg);
	void FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points);

};

GroundFilter::GroundFilter() : node_handle_(&quot;~&quot;)
{
	ROS_INFO(&quot;Inititalizing Ground Filter...&quot;);
	node_handle_.param&lt;std::string&gt;(&quot;point_topic&quot;, point_topic_, &quot;/points_raw&quot;);
	ROS_INFO(&quot;Input Point Cloud: %s&quot;, point_topic_.c_str());
 	node_handle_.param(&quot;remove_floor&quot;,  floor_removal_,  true);
 	ROS_INFO(&quot;Floor Removal: %d&quot;, floor_removal_);
	node_handle_.param(&quot;sensor_model&quot;, sensor_model_, 64);
	ROS_INFO(&quot;Sensor Model: %d&quot;, sensor_model_);
	node_handle_.param(&quot;sensor_height&quot;, sensor_height_, 1.72);
	ROS_INFO(&quot;Sensor Height: %f&quot;, sensor_height_);
	node_handle_.param(&quot;max_slope&quot;, max_slope_, 20.0);
	ROS_INFO(&quot;Max Slope: %f&quot;, max_slope_);
	node_handle_.param(&quot;point_distance&quot;, point_distance_, 0.05);
	ROS_INFO(&quot;Point Distance: %f&quot;, point_distance_);
	node_handle_.param(&quot;min_point&quot;, min_point_, 3);
	ROS_INFO(&quot;Min Points: %d&quot;, min_point_);
	node_handle_.param(&quot;clipping_thres&quot;, clipping_thres_, 0.5);
	ROS_INFO(&quot;Lower Clipping Threshold: %f&quot;, clipping_thres_);
	node_handle_.param(&quot;gap_thres&quot;, gap_thres_, 0.5);
	ROS_INFO(&quot;Point Gap Threshold: %f&quot;, gap_thres_);

	std::string no_ground_topic, ground_topic;
	node_handle_.param&lt;std::string&gt;(&quot;no_ground_point_topic&quot;, no_ground_topic, &quot;/points_no_ground&quot;);
	ROS_INFO(&quot;No Ground Output Point Cloud: %s&quot;, no_ground_topic.c_str());
	node_handle_.param&lt;std::string&gt;(&quot;ground_point_topic&quot;, ground_topic, &quot;/points_ground&quot;);
	ROS_INFO(&quot;Only Ground Output Point Cloud: %s&quot;, ground_topic.c_str());

	int default_horizontal_res;
	switch(sensor_model_)
	{
		case 64:
			default_horizontal_res = 2083;
			break;
		case 32:
			default_horizontal_res = 2250;
			break;
		case 16:
			default_horizontal_res = 1800;
			break;
		default:
			default_horizontal_res = DEFAULT_HOR_RES;
			break;
	}
	node_handle_.param(&quot;horizontal_res&quot;, horizontal_res_, default_horizontal_res);

	points_node_sub_ = node_handle_.subscribe(point_topic_, 2, &amp;GroundFilter::VelodyneCallback, this);
	groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 2);
	ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 2);

	vertical_res_ = sensor_model_;
	InitLabelArray(sensor_model_);
	limiting_ratio_ = tan(max_slope_*M_PI/180);

}

void GroundFilter::InitLabelArray(int in_model)
{
	for(int a = 0; a &lt; vertical_res_; a++)
	{
		class_label_[a] = UNKNOWN;
	}
}

void GroundFilter::InitDepthMap(int in_width)
{
	const int mOne = -1;
	index_map_ = cv::Mat_&lt;int&gt;(vertical_res_, in_width, mOne);
}

void GroundFilter::PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				int in_indices[], int &amp;in_out_index_size, 
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud)
{
	velodyne_pointcloud::PointXYZIR point;
	for (int i = 0; i &lt; in_out_index_size; i++)
	{
		point.x = in_cloud_msg-&gt;points[in_indices[i]].x;
		point.y = in_cloud_msg-&gt;points[in_indices[i]].y;
		point.z = in_cloud_msg-&gt;points[in_indices[i]].z;
		point.intensity = in_cloud_msg-&gt;points[in_indices[i]].intensity;
		point.ring = in_cloud_msg-&gt;points[in_indices[i]].ring;
		in_cloud.push_back(point);
	}
	in_out_index_size = 0;	
}

void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
			pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
			pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points)
{

	velodyne_pointcloud::PointXYZIR point;

	horizontal_res_ = int(in_cloud_msg-&gt;points.size() / vertical_res_);
	InitDepthMap(horizontal_res_);

	for (size_t i = 0; i &lt; in_cloud_msg-&gt;points.size(); i++)
	{
		double u = atan2(in_cloud_msg-&gt;points[i].y,in_cloud_msg-&gt;points[i].x) * 180/M_PI;
		if (u &lt; 0) { u = 360 + u; }
		int column = horizontal_res_ - (int)((double)horizontal_res_ * u / 360.0) - 1;
		int row = vertical_res_ - 1 - in_cloud_msg-&gt;points[i].ring;
		index_map_.at&lt;int&gt;(row, column) = i;
	}
	
	for (int i = 0; i &lt; horizontal_res_; i++)
	{
		Label point_class[vertical_res_];
		int unknown_index[vertical_res_];
		int point_index[vertical_res_];
		int unknown_index_size = 0;
		int point_index_size = 0;
		double z_ref = 0;
		double r_ref = 0;
		std::copy(class_label_, class_label_ + vertical_res_, point_class); 

		for (int j = vertical_res_ - 1; j &gt;= 0; j--)
		{
			if (index_map_.at&lt;int&gt;(j,i) &gt; -1 &amp;&amp; point_class[j] == UNKNOWN)
			{
				double x0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].x;
				double y0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].y;
				double z0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].z;
				double r0 = sqrt(x0*x0 + y0*y0);
				double r_diff = r0 - r_ref;
				double z_diff = fabs(z0 - z_ref);
				double pair_angle;

				if (r_diff != 0.)
				{
					pair_angle = z_diff/r_diff;
				}
				else
				{//this should never execute due to Sensor specs
					ROS_ERROR(&quot;GrooundFilter: Division by Zero avoided on pair_angle&quot;);
					pair_angle = 0;
				}
				if (
					 (	(pair_angle &gt; 0 &amp;&amp; pair_angle &lt; limiting_ratio_)
						&amp;&amp; z_diff &lt; gap_thres_
						&amp;&amp; z0 &lt; clipping_thres_
					 )
					|| point_index_size == 0
					)
				{
					r_ref = r0;
					z_ref = z0;
					point_index[point_index_size] = j;
					point_index_size++;
				}
				else
				{
					if (point_index_size &gt; min_point_)
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.x = in_cloud_msg-&gt;points[index].x;
							point.y = in_cloud_msg-&gt;points[index].y;
							point.z = in_cloud_msg-&gt;points[index].z;
							point.intensity = in_cloud_msg-&gt;points[index].intensity;
							point.ring = in_cloud_msg-&gt;points[index].ring;
							out_ground_points.push_back(point);
							point_class[point_index[m]] = GROUND;
						}
						point_index_size = 0;
					}
					else
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.z = in_cloud_msg-&gt;points[index].z;
							if (point.z &gt; clipping_thres_ - sensor_height_)
							{
								point.x = in_cloud_msg-&gt;points[index].x;
								point.y = in_cloud_msg-&gt;points[index].y;
								point.intensity = in_cloud_msg-&gt;points[index].intensity;
								point.ring = in_cloud_msg-&gt;points[index].ring;
								out_groundless_points.push_back(point);
								point_class[point_index[m]] = VERTICAL;
							}
							else
							{
								unknown_index[unknown_index_size] = index;
								unknown_index_size++;
							}
						}
						point_index_size = 0;
					}
				}
			}
			if (j == 0)
			{
				if (point_index_size != 0)
				{
					if (point_index_size &gt; min_point_)
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.x = in_cloud_msg-&gt;points[index].x;
							point.y = in_cloud_msg-&gt;points[index].y;
							point.z = in_cloud_msg-&gt;points[index].z;
							point.intensity = in_cloud_msg-&gt;points[index].intensity;
							point.ring = in_cloud_msg-&gt;points[index].ring;
							out_ground_points.push_back(point);
							point_class[point_index[m]] = GROUND;
						}
						point_index_size = 0;
					}
					else
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.z = in_cloud_msg-&gt;points[index].z;
							if (point.z &gt; clipping_thres_ - sensor_height_)
							{
								point.x = in_cloud_msg-&gt;points[index].x;
								point.y = in_cloud_msg-&gt;points[index].y;
								point.intensity = in_cloud_msg-&gt;points[index].intensity;
								point.ring = in_cloud_msg-&gt;points[index].ring;
								out_groundless_points.push_back(point);
								point_class[point_index[m]] = VERTICAL;
							}
							else
							{
								unknown_index[unknown_index_size] = index;
								unknown_index_size++;
							}
						}
						point_index_size = 0;
					}//end else
				}//end if (point_index_size != 0)

				double centroid = 0;
				int cluster_index[vertical_res_];
				int cluster_index_size = 0;
				for (int m = unknown_index_size - 1; m &gt;= 0; m--)
				{
					double x0 = in_cloud_msg-&gt;points[unknown_index[m]].x;
					double y0 = in_cloud_msg-&gt;points[unknown_index[m]].y;
					double r0 = sqrt(x0*x0 + y0*y0);
					double r_diff = fabs(r0 - centroid);
					if ((r_diff &lt; point_distance_) || cluster_index_size == 0)
					{
						cluster_index[cluster_index_size] = unknown_index[m];
						cluster_index_size++;
						centroid = r0;
						if (m == 0)
						{
							if(cluster_index_size &gt; 1)
							{
								PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
							}
							else
							{
								PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
							}
						}
					}
					else
					{
						if(cluster_index_size &gt; 1)
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
						}
						else
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
						}
					}
				}//end for (int m = unknown_index_size - 1; m &gt;= 0; m--)
			}//end if (j == 0)
		}
	}

}

void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg)
{

	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; vertical_points;
	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; ground_points;
	vertical_points.header = in_cloud_msg-&gt;header;
	ground_points.header = in_cloud_msg-&gt;header;
	vertical_points.clear();
	ground_points.clear();

	FilterGround(in_cloud_msg, vertical_points, ground_points);

	if (!floor_removal_)
	{
		vertical_points = *in_cloud_msg;
	} 
	
	groundless_points_pub_.publish(vertical_points);
	ground_points_pub_.publish(ground_points);

}

int main(int argc, char **argv)
{

	ros::init(argc, argv, &quot;ground_filter&quot;);
	GroundFilter node;
	ros::spin();

	return 0;

}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="29b934b98b12aec3f9053e23bb3e0517dde925cf" fix_time="0,24037">
		<msg>Typo Fix</msg>
		<modified_files>
			<file old_path="ros/src/sensing/filters/packages/points_preprocessor/nodes/ground_filter/ground_filter.cpp" new_path="ros/src/sensing/filters/packages/points_preprocessor/nodes/ground_filter/ground_filter.cpp">
				<diff>@@ -204,7 +204,7 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 				}
 				else
 				{//this should never execute due to Sensor specs
-					ROS_ERROR(&quot;GrooundFilter: Division by Zero avoided on pair_angle&quot;);
+					ROS_ERROR(&quot;GroundFilter: Division by Zero avoided on pair_angle&quot;);
 					pair_angle = 0;
 				}
 				if (
</diff>
				<old_file>/*
 * ground_filter.cpp
 *
 * Created on	: May 19, 2017
 * Author	: Patiphon Narksri					
 */
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;opencv/cv.h&gt;

enum Label
{
	GROUND,
	VERTICAL,
	UNKNOWN //Initial state, not classified
};

class GroundFilter
{
public:
	
	GroundFilter();

private:

	ros::NodeHandle node_handle_;
	ros::Subscriber points_node_sub_;
	ros::Publisher groundless_points_pub_;
	ros::Publisher ground_points_pub_;

	std::string point_topic_;
	int 		sensor_model_;
	double 		sensor_height_;
	double 		max_slope_;
	int 		min_point_;
	double 		clipping_thres_;
	double 		gap_thres_;
	double		point_distance_;
	bool		floor_removal_;

	int 		vertical_res_;
	int 		horizontal_res_;
	double 		limiting_ratio_;
	cv::Mat 	index_map_;
	Label 		class_label_[64];

	boost::chrono::high_resolution_clock::time_point t1_;
	boost::chrono::high_resolution_clock::time_point t2_;
	boost::chrono::nanoseconds elap_time_;

	const int 	DEFAULT_HOR_RES = 2000;

	void InitLabelArray(int in_model);
	void InitDepthMap(int in_width);
	void PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				int in_indices[], int &amp;in_out_index_size, 
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud);


	void VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg);
	void FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points);

};

GroundFilter::GroundFilter() : node_handle_(&quot;~&quot;)
{
	ROS_INFO(&quot;Inititalizing Ground Filter...&quot;);
	node_handle_.param&lt;std::string&gt;(&quot;point_topic&quot;, point_topic_, &quot;/points_raw&quot;);
	ROS_INFO(&quot;Input Point Cloud: %s&quot;, point_topic_.c_str());
 	node_handle_.param(&quot;remove_floor&quot;,  floor_removal_,  true);
 	ROS_INFO(&quot;Floor Removal: %d&quot;, floor_removal_);
	node_handle_.param(&quot;sensor_model&quot;, sensor_model_, 64);
	ROS_INFO(&quot;Sensor Model: %d&quot;, sensor_model_);
	node_handle_.param(&quot;sensor_height&quot;, sensor_height_, 1.72);
	ROS_INFO(&quot;Sensor Height: %f&quot;, sensor_height_);
	node_handle_.param(&quot;max_slope&quot;, max_slope_, 20.0);
	ROS_INFO(&quot;Max Slope: %f&quot;, max_slope_);
	node_handle_.param(&quot;point_distance&quot;, point_distance_, 0.05);
	ROS_INFO(&quot;Point Distance: %f&quot;, point_distance_);
	node_handle_.param(&quot;min_point&quot;, min_point_, 3);
	ROS_INFO(&quot;Min Points: %d&quot;, min_point_);
	node_handle_.param(&quot;clipping_thres&quot;, clipping_thres_, 0.5);
	ROS_INFO(&quot;Lower Clipping Threshold: %f&quot;, clipping_thres_);
	node_handle_.param(&quot;gap_thres&quot;, gap_thres_, 0.5);
	ROS_INFO(&quot;Point Gap Threshold: %f&quot;, gap_thres_);

	std::string no_ground_topic, ground_topic;
	node_handle_.param&lt;std::string&gt;(&quot;no_ground_point_topic&quot;, no_ground_topic, &quot;/points_no_ground&quot;);
	ROS_INFO(&quot;No Ground Output Point Cloud: %s&quot;, no_ground_topic.c_str());
	node_handle_.param&lt;std::string&gt;(&quot;ground_point_topic&quot;, ground_topic, &quot;/points_ground&quot;);
	ROS_INFO(&quot;Only Ground Output Point Cloud: %s&quot;, ground_topic.c_str());

	int default_horizontal_res;
	switch(sensor_model_)
	{
		case 64:
			default_horizontal_res = 2083;
			break;
		case 32:
			default_horizontal_res = 2250;
			break;
		case 16:
			default_horizontal_res = 1800;
			break;
		default:
			default_horizontal_res = DEFAULT_HOR_RES;
			break;
	}
	node_handle_.param(&quot;horizontal_res&quot;, horizontal_res_, default_horizontal_res);

	points_node_sub_ = node_handle_.subscribe(point_topic_, 2, &amp;GroundFilter::VelodyneCallback, this);
	groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 2);
	ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 2);

	vertical_res_ = sensor_model_;
	InitLabelArray(sensor_model_);
	limiting_ratio_ = tan(max_slope_*M_PI/180);

}

void GroundFilter::InitLabelArray(int in_model)
{
	for(int a = 0; a &lt; vertical_res_; a++)
	{
		class_label_[a] = UNKNOWN;
	}
}

void GroundFilter::InitDepthMap(int in_width)
{
	const int mOne = -1;
	index_map_ = cv::Mat_&lt;int&gt;(vertical_res_, in_width, mOne);
}

void GroundFilter::PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				int in_indices[], int &amp;in_out_index_size, 
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud)
{
	velodyne_pointcloud::PointXYZIR point;
	for (int i = 0; i &lt; in_out_index_size; i++)
	{
		point.x = in_cloud_msg-&gt;points[in_indices[i]].x;
		point.y = in_cloud_msg-&gt;points[in_indices[i]].y;
		point.z = in_cloud_msg-&gt;points[in_indices[i]].z;
		point.intensity = in_cloud_msg-&gt;points[in_indices[i]].intensity;
		point.ring = in_cloud_msg-&gt;points[in_indices[i]].ring;
		in_cloud.push_back(point);
	}
	in_out_index_size = 0;	
}

void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
			pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
			pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points)
{

	velodyne_pointcloud::PointXYZIR point;

	//This line is not necessary
	//horizontal_res_ = int(in_cloud_msg-&gt;points.size() / vertical_res_);
	InitDepthMap(horizontal_res_);

	for (size_t i = 0; i &lt; in_cloud_msg-&gt;points.size(); i++)
	{
		double u = atan2(in_cloud_msg-&gt;points[i].y,in_cloud_msg-&gt;points[i].x) * 180/M_PI;
		if (u &lt; 0) { u = 360 + u; }
		int column = horizontal_res_ - (int)((double)horizontal_res_ * u / 360.0) - 1;
		int row = vertical_res_ - 1 - in_cloud_msg-&gt;points[i].ring;
		index_map_.at&lt;int&gt;(row, column) = i;
	}
	
	for (int i = 0; i &lt; horizontal_res_; i++)
	{
		Label point_class[vertical_res_];
		int unknown_index[vertical_res_];
		int point_index[vertical_res_];
		int unknown_index_size = 0;
		int point_index_size = 0;
		double z_ref = 0;
		double r_ref = 0;
		std::copy(class_label_, class_label_ + vertical_res_, point_class); 

		for (int j = vertical_res_ - 1; j &gt;= 0; j--)
		{
			if (index_map_.at&lt;int&gt;(j,i) &gt; -1 &amp;&amp; point_class[j] == UNKNOWN)
			{
				double x0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].x;
				double y0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].y;
				double z0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].z;
				double r0 = sqrt(x0*x0 + y0*y0);
				double r_diff = r0 - r_ref;
				double z_diff = fabs(z0 - z_ref);
				double pair_angle;

				if (r_diff != 0.)
				{
					pair_angle = z_diff/r_diff;
				}
				else
				{//this should never execute due to Sensor specs
					ROS_ERROR(&quot;GrooundFilter: Division by Zero avoided on pair_angle&quot;);
					pair_angle = 0;
				}
				if (
					 (	(pair_angle &gt; 0 &amp;&amp; pair_angle &lt; limiting_ratio_)
						&amp;&amp; z_diff &lt; gap_thres_
						&amp;&amp; z0 &lt; clipping_thres_
					 )
					|| point_index_size == 0
					)
				{
					r_ref = r0;
					z_ref = z0;
					point_index[point_index_size] = j;
					point_index_size++;
				}
				else
				{
					if (point_index_size &gt; min_point_)
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.x = in_cloud_msg-&gt;points[index].x;
							point.y = in_cloud_msg-&gt;points[index].y;
							point.z = in_cloud_msg-&gt;points[index].z;
							point.intensity = in_cloud_msg-&gt;points[index].intensity;
							point.ring = in_cloud_msg-&gt;points[index].ring;
							out_ground_points.push_back(point);
							point_class[point_index[m]] = GROUND;
						}
						point_index_size = 0;
					}
					else
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.z = in_cloud_msg-&gt;points[index].z;
							if (point.z &gt; clipping_thres_ - sensor_height_)
							{
								point.x = in_cloud_msg-&gt;points[index].x;
								point.y = in_cloud_msg-&gt;points[index].y;
								point.intensity = in_cloud_msg-&gt;points[index].intensity;
								point.ring = in_cloud_msg-&gt;points[index].ring;
								out_groundless_points.push_back(point);
								point_class[point_index[m]] = VERTICAL;
							}
							else
							{
								unknown_index[unknown_index_size] = index;
								unknown_index_size++;
							}
						}
						point_index_size = 0;
					}
					//These line were missing
					r_ref = r0;
					z_ref = z0;
					point_index[point_index_size] = j;
					point_index_size++;
				}
			}
			if (j == 0)
			{
				if (point_index_size != 0)
				{
					if (point_index_size &gt; min_point_)
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.x = in_cloud_msg-&gt;points[index].x;
							point.y = in_cloud_msg-&gt;points[index].y;
							point.z = in_cloud_msg-&gt;points[index].z;
							point.intensity = in_cloud_msg-&gt;points[index].intensity;
							point.ring = in_cloud_msg-&gt;points[index].ring;
							out_ground_points.push_back(point);
							point_class[point_index[m]] = GROUND;
						}
						point_index_size = 0;
					}
					else
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.z = in_cloud_msg-&gt;points[index].z;
							if (point.z &gt; clipping_thres_ - sensor_height_)
							{
								point.x = in_cloud_msg-&gt;points[index].x;
								point.y = in_cloud_msg-&gt;points[index].y;
								point.intensity = in_cloud_msg-&gt;points[index].intensity;
								point.ring = in_cloud_msg-&gt;points[index].ring;
								out_groundless_points.push_back(point);
								point_class[point_index[m]] = VERTICAL;
							}
							else
							{
								unknown_index[unknown_index_size] = index;
								unknown_index_size++;
							}
						}
						point_index_size = 0;
					}//end else
				}//end if (point_index_size != 0)

				double centroid = 0;
				int cluster_index[vertical_res_];
				int cluster_index_size = 0;
				for (int m = unknown_index_size - 1; m &gt;= 0; m--)
				{
					double x0 = in_cloud_msg-&gt;points[unknown_index[m]].x;
					double y0 = in_cloud_msg-&gt;points[unknown_index[m]].y;
					double r0 = sqrt(x0*x0 + y0*y0);
					double r_diff = fabs(r0 - centroid);
					if ((r_diff &lt; point_distance_) || cluster_index_size == 0)
					{
						cluster_index[cluster_index_size] = unknown_index[m];
						cluster_index_size++;
						centroid = r0;
						if (m == 0)
						{
							if(cluster_index_size &gt; 1)
							{
								PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
							}
							else
							{
								PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
							}
						}
					}
					else
					{
						if(cluster_index_size &gt; 1)
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
						}
						else
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
						}
						cluster_index[cluster_index_size] = unknown_index[m];
						cluster_index_size++;
						centroid = r0;
					}
					if (m == 0)
					{
						if(cluster_index_size &gt; 1)
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
						}
						else
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
						}
					}
				}//end for (int m = unknown_index_size - 1; m &gt;= 0; m--)
			}//end if (j == 0)
		}
	}

}

void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg)
{

	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; vertical_points;
	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; ground_points;
	vertical_points.header = in_cloud_msg-&gt;header;
	ground_points.header = in_cloud_msg-&gt;header;
	vertical_points.clear();
	ground_points.clear();

	FilterGround(in_cloud_msg, vertical_points, ground_points);

	if (!floor_removal_)
	{
		vertical_points = *in_cloud_msg;
	} 
	
	groundless_points_pub_.publish(vertical_points);
	ground_points_pub_.publish(ground_points);

}

int main(int argc, char **argv)
{

	ros::init(argc, argv, &quot;ground_filter&quot;);
	GroundFilter node;
	ros::spin();

	return 0;

}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="8d05bdaf8f345078fb3fb879a317fe2d919ebc4f" fix_time="236,75358">
		<msg>Fix coodinate bug and small refactor</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/obj_fusion/obj_fusion.cpp" new_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/obj_fusion/obj_fusion.cpp">
				<diff>@@ -22,8 +22,8 @@ using vector_map::Node;
 using vector_map::Point;
 using vector_map::Key;
 
-static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 100;
-static constexpr uint32_t ADVERTISE_QUEUE_SIZE = 10;
+static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 1;
+static constexpr uint32_t ADVERTISE_QUEUE_SIZE = 1;
 static constexpr bool ADVERTISE_LATCH = false;
 static constexpr double LOOP_RATE = 15.0;
 
@@ -152,7 +152,7 @@ void fusion_cb(const autoware_msgs::obj_label::ConstPtr &amp;obj_label_msg,
   autoware_msgs::CloudClusterArray cloud_clusters_msg;
   cloud_clusters_msg.header = header;
   visualization_msgs::MarkerArray marker_array_msg;
-  int id = 0;
+  int marker_id = 0;
 
   for (unsigned int i = 0; i &lt; obj_label.obj_id.size(); ++i) {
     if (obj_indices.at(i) == -1) continue;
@@ -171,13 +171,13 @@ void fusion_cb(const autoware_msgs::obj_label::ConstPtr &amp;obj_label_msg,
     bounding_box = v_cloud_cluster.at(obj_indices.at(i)).bounding_box;
 
     /* adjust object rotation using lane in vector_map */
-    tf::Quaternion q1(bounding_box.pose.orientation.x,
+    tf::Quaternion q_obj(bounding_box.pose.orientation.x,
       bounding_box.pose.orientation.y,
       bounding_box.pose.orientation.z,
       bounding_box.pose.orientation.w);
     bool fixed_rotation = false;
     if (use_vmap) {
-      int mi = 0; // number of rotaiton 90deg
+      int rot_n = 0; // yaw' = yaw + n*pi/2
       vector_map_server::GetLane get_lane;
       get_lane.request.pose.pose = bounding_box.pose;
       tf::Vector3 orgpt(bounding_box.pose.position.x,
@@ -202,25 +202,26 @@ void fusion_cb(const autoware_msgs::obj_label::ConstPtr &amp;obj_label_msg,
           double my = get_lane.request.pose.pose.position.y;
           if ((mx-fp.ly)*(mx-fp.ly)+(my-fp.bx)*(my-fp.bx) &lt; vmap_threshold) {
             fixed_rotation = true;
-            tf::Quaternion ql;
-            ql.setRPY(0, 0, atan2(fp.bx - bp.bx, fp.ly - bp.ly)); // y,x
-            tf::Quaternion qb = tform * q1;
-            tf::Quaternion qm;
-            qm.setRPY(0, 0, M_PI/2);
-            double mr = M_PI;
+            tf::Quaternion qm_lane;   // map-cood
+            qm_lane.setRPY(0, 0, atan2(fp.bx - bp.bx, fp.ly - bp.ly)); // y,x
+            tf::Quaternion q_step;  // 90 deg
+            q_step.setRPY(0, 0, M_PI/2);
+            double r_max = M_PI;
             // search in 0,90,180,270-degree
+            tf::Quaternion qr_obj = q_obj; // rotated
             for (int i = 0; i &lt; 4; i++) {
-              double r = ql.angle(qb);
+              tf::Quaternion qrm_obj = tform * qr_obj;  // map-cood
+              double r = qm_lane.angle(qrm_obj);
               r = (r &gt;= M_PI/2) ? (r - M_PI):r;
-              if (fabs(r) &lt; mr) {
-                mr = fabs(r);
-                mi = i;
+              if (fabs(r) &lt; r_max) {
+                r_max = fabs(r);
+                rot_n = i;
               }
-              qb *= qm;
+              qr_obj *= q_step;
             }
             double roll, pitch, yaw;
-            tf::Matrix3x3(q1).getRPY(roll, pitch, yaw);
-            ROS_INFO(&quot; %d roll=%f pitch=%f yaw=%f&quot;, mi*90, roll, pitch, yaw);
+            tf::Matrix3x3(q_obj).getRPY(roll, pitch, yaw);
+            ROS_INFO(&quot; %d roll=%f pitch=%f yaw=%f&quot;, rot_n*90, roll, pitch, yaw);
             break;
           }
         }
@@ -228,24 +229,25 @@ void fusion_cb(const autoware_msgs::obj_label::ConstPtr &amp;obj_label_msg,
         ROS_INFO(&quot;%s: VectorMap Server call failed.&quot;, __FUNCTION__);
       }
       // determine rotation
-      tf::Quaternion dq1;
-      dq1.setRPY(0, 0, M_PI*mi/2);
-      q1 *= dq1;
+      tf::Quaternion dq_obj;
+      dq_obj.setRPY(0, 0, M_PI*rot_n/2);
+      q_obj *= dq_obj;
       // bounding_box
-      bounding_box.pose.orientation.x = q1.x();
-      bounding_box.pose.orientation.y = q1.y();
-      bounding_box.pose.orientation.z = q1.z();
-      bounding_box.pose.orientation.w = q1.w();
-      if (mi % 2 == 1) { // swap x-y at 90,270 deg
+      bounding_box.pose.orientation.x = q_obj.x();
+      bounding_box.pose.orientation.y = q_obj.y();
+      bounding_box.pose.orientation.z = q_obj.z();
+      bounding_box.pose.orientation.w = q_obj.w();
+      if (rot_n % 2 == 1) { // swap x-y at 90,270 deg
         std::swap(bounding_box.dimensions.x, bounding_box.dimensions.y);
       }
+      // cloud clusters
       v_cloud_cluster.at(obj_indices.at(i)).bounding_box = bounding_box;
     }
 
     // x-axis
     visualization_msgs::Marker marker;
     marker.header = header;
-    marker.id = id++;
+    marker.id = marker_id++;
     marker.lifetime = ros::Duration(0.1);
     marker.type = visualization_msgs::Marker::ARROW;
     marker.pose.position = bounding_box.pose.position;
@@ -258,28 +260,28 @@ void fusion_cb(const autoware_msgs::obj_label::ConstPtr &amp;obj_label_msg,
     marker_array_msg.markers.push_back(marker);
 
     // y-axis
-    tf::Quaternion q2;
-    q2.setRPY(0, 0, M_PI/2);
-    q1 *= q2;
-    marker.id = id++;
-    marker.pose.orientation.x = q1.x();
-    marker.pose.orientation.y = q1.y();
-    marker.pose.orientation.z = q1.z();
-    marker.pose.orientation.w = q1.w();
+    tf::Quaternion qy;
+    qy.setRPY(0, 0, M_PI/2);
+    q_obj *= qy;
+    marker.id = marker_id++;
+    marker.pose.orientation.x = q_obj.x();
+    marker.pose.orientation.y = q_obj.y();
+    marker.pose.orientation.z = q_obj.z();
+    marker.pose.orientation.w = q_obj.w();
     marker.color.r = 0.0;
     marker.color.g = 1.0;
     marker.color.a = 1.0;
     marker_array_msg.markers.push_back(marker);
 
     // z-axis
-    tf::Quaternion q3;
-    q3.setRPY(0, -M_PI/2, 0);
-    q1 *= q3;
-    marker.id = id++;
-    marker.pose.orientation.x = q1.x();
-    marker.pose.orientation.y = q1.y();
-    marker.pose.orientation.z = q1.z();
-    marker.pose.orientation.w = q1.w();
+    tf::Quaternion qz;
+    qz.setRPY(0, -M_PI/2, 0);
+    q_obj *= qz;
+    marker.id = marker_id++;
+    marker.pose.orientation.x = q_obj.x();
+    marker.pose.orientation.y = q_obj.y();
+    marker.pose.orientation.z = q_obj.z();
+    marker.pose.orientation.w = q_obj.w();
     marker.color.g = 0.0;
     marker.color.b = 1.0;
     marker.color.a = 1.0;
@@ -287,14 +289,14 @@ void fusion_cb(const autoware_msgs::obj_label::ConstPtr &amp;obj_label_msg,
 
     // rotated by lane
     if (fixed_rotation) {
-      marker.id = id++;
+      marker.id = marker_id++;
       marker.type = visualization_msgs::Marker::SPHERE;
       marker.scale.x = 1.0;
       marker.scale.y = 1.0;
       marker.scale.z = 1.0;
+      marker.color.r = 1.0;
       marker.color.g = 1.0;
       marker.color.b = 1.0;
-      marker.color.a = 1.0;
       marker_array_msg.markers.push_back(marker);
     }
 
</diff>
				<old_file>#include &lt;float.h&gt;
#include &lt;geometry_msgs/Point.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &quot;autoware_msgs/obj_label.h&quot;
#include &quot;autoware_msgs/CloudCluster.h&quot;
#include &quot;autoware_msgs/CloudClusterArray.h&quot;
#include &lt;math.h&gt;
#include &lt;mutex&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Time.h&gt;
#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;vector_map/vector_map.h&gt;
#include &lt;vector_map_server/GetLane.h&gt;
#include &lt;message_filters/subscriber.h&gt;
#include &lt;message_filters/synchronizer.h&gt;
#include &lt;message_filters/sync_policies/approximate_time.h&gt;

using vector_map::Node;
using vector_map::Point;
using vector_map::Key;

static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 100;
static constexpr uint32_t ADVERTISE_QUEUE_SIZE = 10;
static constexpr bool ADVERTISE_LATCH = false;
static constexpr double LOOP_RATE = 15.0;

ros::Publisher obj_pose_pub;
ros::Publisher obj_pose_timestamp_pub;
ros::Publisher cluster_class_pub;
ros::Publisher marker_array_pub;

static std::string object_type;
static std::vector&lt;geometry_msgs::Point&gt; centroids;
static std_msgs::Header sensor_header;
static std::vector&lt;autoware_msgs::CloudCluster&gt; v_cloud_cluster;
static ros::Time obj_pose_timestamp;
static double threshold_min_dist;

static vector_map::VectorMap vmap;
static ros::ServiceClient vmap_server;
static bool use_vmap;
static double vmap_threshold;

struct obj_label_t {
  std::vector&lt;geometry_msgs::Point&gt; reprojected_positions;
  std::vector&lt;int&gt; obj_id;
};
obj_label_t obj_label;

static double euclid_distance(const geometry_msgs::Point pos1,
                              const geometry_msgs::Point pos2) {
  return sqrt(pow(pos1.x - pos2.x, 2) + pow(pos1.y - pos2.y, 2) +
              pow(pos1.z - pos2.z, 2));

} /* static double distance() */

/* fusion reprojected position and pointcloud centroids */
void fusion_cb(const autoware_msgs::obj_label::ConstPtr &amp;obj_label_msg,
  const autoware_msgs::CloudClusterArray::ConstPtr &amp;in_cloud_cluster_array_ptr) {

  tf::StampedTransform tform;
  tf::TransformListener tflistener;
  try {
    ros::Time now = ros::Time(0);
    tflistener.waitForTransform(&quot;/map&quot;, &quot;/velodyne&quot;, now, ros::Duration(10));
    tflistener.lookupTransform(&quot;/map&quot;, &quot;/velodyne&quot;, now, tform);
  } catch (tf::TransformException ex) {
    ROS_INFO(&quot;%s: %s&quot;, __FUNCTION__, ex.what());
    return;
  }

  obj_label_t obj_label;
  object_type = obj_label_msg-&gt;type;
  obj_pose_timestamp = obj_label_msg-&gt;header.stamp;

  for (unsigned int i = 0; i &lt; obj_label_msg-&gt;obj_id.size(); ++i) {
    obj_label.reprojected_positions.push_back(
        obj_label_msg-&gt;reprojected_pos.at(i));
    obj_label.obj_id.push_back(obj_label_msg-&gt;obj_id.at(i));
  }

  std::vector&lt;autoware_msgs::CloudCluster&gt; v_cloud_cluster;
  std_msgs::Header header = sensor_header;
  std::vector&lt;geometry_msgs::Point&gt; centroids;

  for (int i(0); i &lt; (int)in_cloud_cluster_array_ptr-&gt;clusters.size(); ++i) {
    autoware_msgs::CloudCluster cloud_cluster =
        in_cloud_cluster_array_ptr-&gt;clusters.at(i);
    /* convert centroids coodinate from velodyne frame to map frame */
    tf::Vector3 pt(cloud_cluster.centroid_point.point.x,
                   cloud_cluster.centroid_point.point.y,
                   cloud_cluster.centroid_point.point.z);
    tf::Vector3 converted = tform * pt;
    sensor_header = cloud_cluster.header;
    v_cloud_cluster.push_back(cloud_cluster);
    geometry_msgs::Point point_in_map;
    point_in_map.x = converted.x();
    point_in_map.y = converted.y();
    point_in_map.z = converted.z();

    centroids.push_back(point_in_map);
  }

  if (centroids.empty() ||
      obj_label.reprojected_positions.empty() ||
      obj_label.obj_id.empty()) {
    jsk_recognition_msgs::BoundingBoxArray pub_msg;
    pub_msg.header = header;
    std_msgs::Time time;
    obj_pose_pub.publish(pub_msg);
    autoware_msgs::CloudClusterArray cloud_clusters_msg;
    cloud_clusters_msg.header = header;
    cluster_class_pub.publish(cloud_clusters_msg);
    visualization_msgs::MarkerArray marker_array_msg;
    marker_array_pub.publish(marker_array_msg);
    time.data = obj_pose_timestamp;
    obj_pose_timestamp_pub.publish(time);
    return;
  }

  std::vector&lt;int&gt; obj_indices;
  for (unsigned int i = 0; i &lt; obj_label.obj_id.size(); ++i) {
    unsigned int min_idx = 0;
    double min_distance = DBL_MAX;

    /* calculate each euclid distance between reprojected position and centroids
     */
    for (unsigned int j = 0; j &lt; centroids.size(); j++) {
      double distance =
          euclid_distance(obj_label.reprojected_positions.at(i),
                          centroids.at(j));

      /* Nearest centroid correspond to this reprojected object */
      if (distance &lt; min_distance) {
        min_distance = distance;
        min_idx = j;
      }
    }
    if (min_distance &lt; threshold_min_dist) {
      obj_indices.push_back(min_idx);
    } else {
      obj_indices.push_back(-1);
    }
  }

  /* Publish marker with centroids coordinates */
  jsk_recognition_msgs::BoundingBoxArray pub_msg;
  pub_msg.header = header;
  autoware_msgs::CloudClusterArray cloud_clusters_msg;
  cloud_clusters_msg.header = header;
  visualization_msgs::MarkerArray marker_array_msg;
  int id = 0;

  for (unsigned int i = 0; i &lt; obj_label.obj_id.size(); ++i) {
    if (obj_indices.at(i) == -1) continue;

    v_cloud_cluster.at(obj_indices.at(i)).label = object_type;
    if (object_type == &quot;car&quot;) {
      v_cloud_cluster.at(obj_indices.at(i)).bounding_box.label = 0;
    } else if (object_type == &quot;person&quot;) {
      v_cloud_cluster.at(obj_indices.at(i)).bounding_box.label = 1;
    } else {
      v_cloud_cluster.at(obj_indices.at(i)).bounding_box.label = 2;
      v_cloud_cluster.at(obj_indices.at(i)).label = &quot;unknown&quot;;
    }

    jsk_recognition_msgs::BoundingBox bounding_box;
    bounding_box = v_cloud_cluster.at(obj_indices.at(i)).bounding_box;

    /* adjust object rotation using lane in vector_map */
    tf::Quaternion q1(bounding_box.pose.orientation.x,
      bounding_box.pose.orientation.y,
      bounding_box.pose.orientation.z,
      bounding_box.pose.orientation.w);
    bool fixed_rotation = false;
    if (use_vmap) {
      int mi = 0; // number of rotaiton 90deg
      vector_map_server::GetLane get_lane;
      get_lane.request.pose.pose = bounding_box.pose;
      tf::Vector3 orgpt(bounding_box.pose.position.x,
        bounding_box.pose.position.y,
        bounding_box.pose.position.z);
      tf::Vector3 convpt = tform * orgpt;
      get_lane.request.pose.pose.position.x = convpt.x();
      get_lane.request.pose.pose.position.y = convpt.y();
      get_lane.request.pose.pose.position.z = convpt.z();
      ROS_INFO(&quot;pos x=%f y=%f z=%f&quot;,
        get_lane.request.pose.pose.position.x,
        get_lane.request.pose.pose.position.y,
        get_lane.request.pose.pose.position.z);
      if (vmap_server.call(get_lane)) {
        for (const auto&amp; lane : get_lane.response.objects.data) {
          Node bn = vmap.findByKey(Key&lt;Node&gt;(lane.bnid));
          Point bp = vmap.findByKey(Key&lt;Point&gt;(bn.pid));
          Node fn = vmap.findByKey(Key&lt;Node&gt;(lane.fnid));
          Point fp = vmap.findByKey(Key&lt;Point&gt;(fn.pid));
          ROS_INFO(&quot; lane bn=(%f,%f) fn=(%f,%f)&quot;, bp.ly, bp.bx, fp.ly, fp.bx);
          double mx = get_lane.request.pose.pose.position.x;
          double my = get_lane.request.pose.pose.position.y;
          if ((mx-fp.ly)*(mx-fp.ly)+(my-fp.bx)*(my-fp.bx) &lt; vmap_threshold) {
            fixed_rotation = true;
            tf::Quaternion ql;
            ql.setRPY(0, 0, atan2(fp.bx - bp.bx, fp.ly - bp.ly)); // y,x
            tf::Quaternion qb = tform * q1;
            tf::Quaternion qm;
            qm.setRPY(0, 0, M_PI/2);
            double mr = M_PI;
            // search in 0,90,180,270-degree
            for (int i = 0; i &lt; 4; i++) {
              double r = ql.angle(qb);
              r = (r &gt;= M_PI/2) ? (r - M_PI):r;
              if (fabs(r) &lt; mr) {
                mr = fabs(r);
                mi = i;
              }
              qb *= qm;
            }
            double roll, pitch, yaw;
            tf::Matrix3x3(q1).getRPY(roll, pitch, yaw);
            ROS_INFO(&quot; %d roll=%f pitch=%f yaw=%f&quot;, mi*90, roll, pitch, yaw);
            break;
          }
        }
      } else {
        ROS_INFO(&quot;%s: VectorMap Server call failed.&quot;, __FUNCTION__);
      }
      // determine rotation
      tf::Quaternion dq1;
      dq1.setRPY(0, 0, M_PI*mi/2);
      q1 *= dq1;
      // bounding_box
      bounding_box.pose.orientation.x = q1.x();
      bounding_box.pose.orientation.y = q1.y();
      bounding_box.pose.orientation.z = q1.z();
      bounding_box.pose.orientation.w = q1.w();
      if (mi % 2 == 1) { // swap x-y at 90,270 deg
        std::swap(bounding_box.dimensions.x, bounding_box.dimensions.y);
      }
      v_cloud_cluster.at(obj_indices.at(i)).bounding_box = bounding_box;
    }

    // x-axis
    visualization_msgs::Marker marker;
    marker.header = header;
    marker.id = id++;
    marker.lifetime = ros::Duration(0.1);
    marker.type = visualization_msgs::Marker::ARROW;
    marker.pose.position = bounding_box.pose.position;
    marker.pose.orientation = bounding_box.pose.orientation;
    marker.scale.x = 2.0;
    marker.scale.y = 0.2;
    marker.scale.z = 0.1;
    marker.color.r = 1.0;
    marker.color.a = 1.0;
    marker_array_msg.markers.push_back(marker);

    // y-axis
    tf::Quaternion q2;
    q2.setRPY(0, 0, M_PI/2);
    q1 *= q2;
    marker.id = id++;
    marker.pose.orientation.x = q1.x();
    marker.pose.orientation.y = q1.y();
    marker.pose.orientation.z = q1.z();
    marker.pose.orientation.w = q1.w();
    marker.color.r = 0.0;
    marker.color.g = 1.0;
    marker.color.a = 1.0;
    marker_array_msg.markers.push_back(marker);

    // z-axis
    tf::Quaternion q3;
    q3.setRPY(0, -M_PI/2, 0);
    q1 *= q3;
    marker.id = id++;
    marker.pose.orientation.x = q1.x();
    marker.pose.orientation.y = q1.y();
    marker.pose.orientation.z = q1.z();
    marker.pose.orientation.w = q1.w();
    marker.color.g = 0.0;
    marker.color.b = 1.0;
    marker.color.a = 1.0;
    marker_array_msg.markers.push_back(marker);

    // rotated by lane
    if (fixed_rotation) {
      marker.id = id++;
      marker.type = visualization_msgs::Marker::SPHERE;
      marker.scale.x = 1.0;
      marker.scale.y = 1.0;
      marker.scale.z = 1.0;
      marker.color.g = 1.0;
      marker.color.b = 1.0;
      marker.color.a = 1.0;
      marker_array_msg.markers.push_back(marker);
    }

    v_cloud_cluster.at(obj_indices.at(i)).bounding_box.value
      = obj_label.obj_id.at(i);
    pub_msg.boxes.push_back(bounding_box);
    cloud_clusters_msg.clusters.push_back(
      v_cloud_cluster.at(obj_indices.at(i)));
  }

  marker_array_pub.publish(marker_array_msg);
  obj_pose_pub.publish(pub_msg);
  cluster_class_pub.publish(cloud_clusters_msg);
  std_msgs::Time time;
  time.data = obj_pose_timestamp;
  obj_pose_timestamp_pub.publish(time);
}

int main(int argc, char *argv[]) {
  /* ROS initialization */
  ros::init(argc, argv, &quot;obj_fusion&quot;);

  ros::NodeHandle n;
  ros::NodeHandle private_n(&quot;~&quot;);

  private_n.param(&quot;min_dist&quot;, threshold_min_dist, 2.0);
  private_n.param(&quot;use_vmap&quot;, use_vmap, true);
  private_n.param(&quot;vmap_threshold&quot;, vmap_threshold, 5.0);
  vmap_threshold *= vmap_threshold; // squared

  typedef message_filters::sync_policies::ApproximateTime&lt;
    autoware_msgs::obj_label, autoware_msgs::CloudClusterArray&gt; SyncPolicy;
  message_filters::Subscriber&lt;autoware_msgs::obj_label&gt; obj_label_sub(
    n, &quot;obj_label&quot;, SUBSCRIBE_QUEUE_SIZE);
  message_filters::Subscriber&lt;autoware_msgs::CloudClusterArray&gt; cluster_centroids_sub(
    n, &quot;/cloud_clusters&quot;, SUBSCRIBE_QUEUE_SIZE);
  message_filters::Synchronizer&lt;SyncPolicy&gt; sync(
    SyncPolicy(SUBSCRIBE_QUEUE_SIZE), obj_label_sub, cluster_centroids_sub);
  sync.registerCallback(boost::bind(&amp;fusion_cb, _1, _2));

  obj_pose_pub = n.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(
      &quot;obj_pose&quot;, ADVERTISE_QUEUE_SIZE, ADVERTISE_LATCH);
  cluster_class_pub = n.advertise&lt;autoware_msgs::CloudClusterArray&gt;(
      &quot;/cloud_clusters_class&quot;, ADVERTISE_QUEUE_SIZE);
  obj_pose_timestamp_pub =
      n.advertise&lt;std_msgs::Time&gt;(&quot;obj_pose_timestamp&quot;, ADVERTISE_QUEUE_SIZE);
  marker_array_pub = n.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;obj_pose_arrow&quot;, 1, true);
  vmap_server = n.serviceClient&lt;vector_map_server::GetLane&gt;(&quot;/vector_map_server/get_lane&quot;);
  vmap.subscribe(n, vector_map::Category::POINT | vector_map::Category::NODE,
                 ros::Duration(0)); // non-blocking

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="2f215effe591e992383f02745da8f8b3e7ea1d6c" fix_time="61,8059">
		<msg>revise bugs in planninghelpers.cpp</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/PlanningHelpers.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/PlanningHelpers.cpp">
				<diff>@@ -1391,7 +1391,7 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
 
 				wp-&gt;cost = pH-&gt;cost + d;
 				wp-&gt;pRight = pH;
-				wp-&gt;pRight = 0;
+				wp-&gt;pLeft = 0;
 
 				nextLeafToTrace.push_back(make_pair(pH, wp));
 				all_cells_to_delete.push_back(wp);
</diff>
				<old_file>/*
 * PlanningHelpers.cpp
 *
 *  Created on: Jun 16, 2016
 *      Author: hatem
 */

#include &quot;PlanningHelpers.h&quot;
#include &quot;MatrixOperations.h&quot;
#include &lt;string&gt;
//#include &quot;spline.hpp&quot;



using namespace UtilityHNS;
using namespace std;



namespace PlannerHNS {



PlanningHelpers::PlanningHelpers()
{
}

PlanningHelpers::~PlanningHelpers()
{
}

bool PlanningHelpers::GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p,const double&amp; searchDistance, RelativeInfo&amp; info)
{
	if(trajectories.size() == 0) return false;

	vector&lt;RelativeInfo&gt; infos;
	for(unsigned int i=0; i &lt; trajectories.size(); i++)
	{
		RelativeInfo info_item;
		GetRelativeInfo(trajectories.at(i), p, info_item);
		double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(info_item.perp_point.pos.a, p.pos.a)*RAD2DEG;
		if(angle_diff &lt; 75)
		{
			info_item.iGlobalPath = i;
			infos.push_back(info_item);
		}
	}

	if(infos.size() == 0)
		return false;
	else if(infos.size() == 1)
	{
		info = infos.at(0);
		return true;
	}

	double minCost = 9999999999;
	int min_index = 0;

	for(unsigned int i=0 ; i&lt; infos.size(); i++)
	{
		if(searchDistance &gt; 0)
		{
			double laneChangeCost = trajectories.at(infos.at(i).iGlobalPath).at(infos.at(i).iFront).laneChangeCost;
			if(fabs(infos.at(i).perp_distance) &lt; searchDistance &amp;&amp; laneChangeCost &lt; minCost)
			{
				min_index = i;
				minCost = laneChangeCost;
			}
		}
		else
		{
			if(fabs(infos.at(i).perp_distance) &lt; minCost)
			{
				min_index = i;
				minCost = infos.at(i).perp_distance;
			}
		}
	}

	info = infos.at(min_index);

	return true;
}

bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex )
{
	if(trajectory.size() &lt; 2) return false;

	WayPoint p0, p1;
	if(trajectory.size()==2)
	{
		p0 = trajectory.at(0);
		p1 = WayPoint((trajectory.at(0).pos.x+trajectory.at(1).pos.x)/2.0,
					  (trajectory.at(0).pos.y+trajectory.at(1).pos.y)/2.0,
					  (trajectory.at(0).pos.z+trajectory.at(1).pos.z)/2.0, trajectory.at(0).pos.a);
		info.iFront = 1;
		info.iBack = 0;
	}
	else
	{
		info.iFront = GetClosestNextPointIndex(trajectory, p, prevIndex);

		if(info.iFront &gt; 0)
			info.iBack = info.iFront -1;
		else
			info.iBack = 0;

		if(info.iFront == 0)
		{
			p0 = trajectory.at(info.iFront);
			p1 = trajectory.at(info.iFront+1);
		}
		else if(info.iFront &gt; 0 &amp;&amp; info.iFront &lt; trajectory.size()-1)
		{
			p0 = trajectory.at(info.iFront-1);
			p1 = trajectory.at(info.iFront);
		}
		else
		{
			p0 = trajectory.at(info.iFront-1);
			p1 = WayPoint((p0.pos.x+trajectory.at(info.iFront).pos.x)/2.0, (p0.pos.y+trajectory.at(info.iFront).pos.y)/2.0, (p0.pos.z+trajectory.at(info.iFront).pos.z)/2.0, p0.pos.a);
		}
	}

	WayPoint prevWP = p0;
	Mat3 rotationMat(-p1.pos.a);
	Mat3 translationMat(-p.pos.x, -p.pos.y);
	Mat3 invRotationMat(p1.pos.a);
	Mat3 invTranslationMat(p.pos.x, p.pos.y);

	p0.pos = translationMat*p0.pos;
	p0.pos = rotationMat*p0.pos;

	p1.pos = translationMat*p1.pos;
	p1.pos = rotationMat*p1.pos;

	double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
	info.perp_distance = p1.pos.y - m*p1.pos.x; // solve for x = 0

	if(isnan(info.perp_distance) || isinf(info.perp_distance)) info.perp_distance = 0;

	info.to_front_distance = fabs(p1.pos.x); // distance on the x axes


	info.perp_point = p1;
	info.perp_point.pos.x = 0; // on the same y axis of the car
	info.perp_point.pos.y = info.perp_distance; //perp distance between the car and the trajectory

	info.perp_point.pos = invRotationMat  * info.perp_point.pos;
	info.perp_point.pos = invTranslationMat  * info.perp_point.pos;

	info.from_back_distance = hypot(info.perp_point.pos.y - prevWP.pos.y, info.perp_point.pos.x - prevWP.pos.x);

	info.angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(p1.pos.a, p.pos.a)*RAD2DEG;

	return true;
}

WayPoint PlanningHelpers::GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index)
{
	WayPoint follow_point;

	if(trajectory.size()==0) return follow_point;

	//condition 1, if far behind the first point on the trajectory
	int local_i = init_p.iFront;

	if(init_p.iBack == 0 &amp;&amp; init_p.iBack == init_p.iFront &amp;&amp; init_p.from_back_distance &gt; distance)
	{
		follow_point = trajectory.at(init_p.iFront);
		follow_point.pos.x = init_p.perp_point.pos.x + distance * cos(follow_point.pos.a);
		follow_point.pos.y = init_p.perp_point.pos.y + distance * sin(follow_point.pos.a);
	}
	//condition 2, if far after the last point on the trajectory
	else if(init_p.iFront == trajectory.size() -1)
	{
		follow_point = trajectory.at(init_p.iFront);
		follow_point.pos.x = init_p.perp_point.pos.x + distance * cos(follow_point.pos.a);
		follow_point.pos.y = init_p.perp_point.pos.y + distance * sin(follow_point.pos.a);
	}
	else
	{
		double d = init_p.to_front_distance;
		while(local_i &lt; trajectory.size()-1 &amp;&amp; d &lt; distance)
		{
			local_i++;
			d += hypot(trajectory.at(local_i).pos.y - trajectory.at(local_i-1).pos.y, trajectory.at(local_i).pos.x - trajectory.at(local_i-1).pos.x);
		}

		double d_part = distance - d;

		follow_point = trajectory.at(local_i);
		follow_point.pos.x = follow_point.pos.x + d_part * cos(follow_point.pos.a);
		follow_point.pos.y = follow_point.pos.y + d_part * sin(follow_point.pos.a);
	}

	point_index = local_i;

	return follow_point;
}

double PlanningHelpers::GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2)
{
	if(trajectory.size() == 0) return 0;

	if(p2.iFront == p1.iFront &amp;&amp; p2.iBack == p1.iBack)
	{
		return p2.to_front_distance - p1.to_front_distance;
	}
	else if(p2.iBack &gt;= p1.iFront)
	{
		double d_on_path = p1.to_front_distance + p2.from_back_distance;
		for(unsigned int i = p1.iFront; i &lt; p2.iBack; i++)
			d_on_path += hypot(trajectory.at(i+1).pos.y - trajectory.at(i).pos.y, trajectory.at(i+1).pos.x - trajectory.at(i).pos.x);

		return d_on_path;
	}
	else if(p2.iFront &lt;= p1.iBack)
	{
		double d_on_path = p1.from_back_distance + p2.to_front_distance;
		for(unsigned int i = p2.iFront; i &lt; p1.iBack; i++)
			d_on_path += hypot(trajectory.at(i+1).pos.y - trajectory.at(i).pos.y, trajectory.at(i+1).pos.x - trajectory.at(i).pos.x);

		return -d_on_path;
	}
	else
	{
		return 0;
	}
}

int PlanningHelpers::GetClosestNextPointIndex(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
{
	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;

	double d = 0, minD = 9999999999;
	int min_index  = prevIndex;

	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
	{
		d  = distance2pointsSqr(trajectory.at(i).pos, p.pos);
		if(d &lt; minD)
		{
			min_index = i;
			minD = d;
		}
	}

	if(min_index &lt; (int)trajectory.size()-2)
	{
		GPSPoint curr, next;
		curr = trajectory.at(min_index).pos;
		next = trajectory.at(min_index+1).pos;
		POINT2D v_1(p.pos.x - curr.x   ,p.pos.y - curr.y);
		double norm1 = pointNorm(v_1);
		POINT2D v_2(next.x - curr.x,next.y - curr.y);
		double norm2 = pointNorm(v_2);
		double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
		double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
		if(a &lt;= M_PI_2)
			min_index = min_index+1;
	}

	return min_index;
}

int PlanningHelpers::GetClosestNextPointIndexDirection(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
{
	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;

	double d = 0, minD = 9999999999;
	int min_index  = prevIndex;

	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
	{
		d  = distance2pointsSqr(trajectory.at(i).pos, p.pos);
		double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(trajectory.at(i).pos.a, p.pos.a)*RAD2DEG;

		if(d &lt; minD &amp;&amp; angle_diff &lt; 45)
		{
			min_index = i;
			minD = d;
		}
	}

	if(min_index &lt; (int)trajectory.size()-2)
	{
		GPSPoint curr, next;
		curr = trajectory.at(min_index).pos;
		next = trajectory.at(min_index+1).pos;
		POINT2D v_1(p.pos.x - curr.x   ,p.pos.y - curr.y);
		double norm1 = pointNorm(v_1);
		POINT2D v_2(next.x - curr.x,next.y - curr.y);
		double norm2 = pointNorm(v_2);
		double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
		double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
		if(a &lt;= M_PI_2)
			min_index = min_index+1;
	}

	return min_index;
}

int PlanningHelpers::GetClosestPointIndex_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
{
	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;

	double d = 0, minD = 9999999999;
	int min_index  = prevIndex;

	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
	{
		d  = distance2pointsSqr(trajectory.at(i).pos, p.pos);
		if(d &lt; minD)
		{
			min_index = i;
			minD = d;
		}
	}

	return min_index;
}

WayPoint PlanningHelpers::GetPerpendicularOnTrajectory_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex )
{
	if(trajectory.size() &lt; 2) return p;

	WayPoint p0, p1, p2, perp;
	if(trajectory.size()==2)
	{
		p0 = trajectory.at(0);
		p1 = WayPoint((trajectory.at(0).pos.x+trajectory.at(1).pos.x)/2.0,
					  (trajectory.at(0).pos.y+trajectory.at(1).pos.y)/2.0,
					  (trajectory.at(0).pos.z+trajectory.at(1).pos.z)/2.0, trajectory.at(0).pos.a);
		p2 = trajectory.at(1);
	}
	else
	{
		int next_index = GetClosestNextPointIndex(trajectory, p, prevIndex);

		if(next_index == 0)
		{
			p0 = trajectory[next_index];
			p1 = trajectory[next_index+1];
			p2 = trajectory[next_index+2];
		}
		else if(next_index &gt; 0 &amp;&amp; next_index &lt; trajectory.size()-1)
		{
			p0 = trajectory[next_index-1];
			p1 = trajectory[next_index];
			p2 = trajectory[next_index+1];
		}
		else
		{
			p0 = trajectory[next_index-1];
			p2 = trajectory[next_index];

			p1 = WayPoint((p0.pos.x+p2.pos.x)/2.0, (p0.pos.y+p2.pos.y)/2.0, (p0.pos.z+p2.pos.z)/2.0, p0.pos.a);

		}
	}

	Mat3 rotationMat(-p1.pos.a);
	Mat3 translationMat(-p.pos.x, -p.pos.y);
	Mat3 invRotationMat(p1.pos.a);
	Mat3 invTranslationMat(p.pos.x, p.pos.y);

	p0.pos = translationMat*p0.pos;
	p0.pos = rotationMat*p0.pos;

	p1.pos = translationMat*p1.pos;
	p1.pos = rotationMat*p1.pos;

	p2.pos = translationMat*p2.pos;
	p2.pos= rotationMat*p2.pos;

	double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
	double d = p1.pos.y - m*p1.pos.x; // solve for x = 0
	distance = p1.pos.x; // distance on the x axes

	perp = p1;
	perp.pos.x = 0; // on the same y axis of the car
	perp.pos.y = d; //perp distance between the car and the trajectory

	perp.pos = invRotationMat  * perp.pos;
	perp.pos = invTranslationMat  * perp.pos;

	return perp;
}

double PlanningHelpers::GetPerpDistanceToTrajectorySimple_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex)
{

	if(trajectory.size() &lt; 2)
		return 0;

	WayPoint p0, p1, p2;
	int next_index = 0;
	if(trajectory.size()==2)
	{
		p0 = trajectory.at(0);
		p2 = trajectory.at(1);
		p1 = WayPoint((p0.pos.x+p2.pos.x)/2.0, (p0.pos.y+p2.pos.y)/2.0, (p0.pos.z+p2.pos.z)/2.0, p0.pos.a);

	}
	else
	{
		next_index = GetClosestNextPointIndex(trajectory, p, prevIndex);
		if(next_index == 0)
		{
			p0 = trajectory[next_index];
			p1 = trajectory[next_index+1];
			p2 = trajectory[next_index+2];
		}
		else if(next_index &gt; 0 &amp;&amp; next_index &lt; trajectory.size()-1)
		{
			p0 = trajectory[next_index-1];
			p1 = trajectory[next_index];
			p2 = trajectory[next_index+1];
		}
		else
		{
			p0 = trajectory[next_index-1];
			p2 = trajectory[next_index];

			p1 = WayPoint((p0.pos.x+p2.pos.x)/2.0, (p0.pos.y+p2.pos.y)/2.0, (p0.pos.z+p2.pos.z)/2.0, p0.pos.a);

		}

	}


	Mat3 rotationMat(-p1.pos.a);
	Mat3 translationMat(-p.pos.x, -p.pos.y);

	p0.pos = translationMat*p0.pos;
	p0.pos = rotationMat*p0.pos;

	p1.pos = translationMat*p1.pos;
	p1.pos = rotationMat*p1.pos;

	p2.pos = translationMat*p2.pos;
	p2.pos = rotationMat*p2.pos;

	double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
	double d = p1.pos.y - m*p1.pos.x;

	if(isnan(d) || isinf(d))
	{
	  //assert(false);
	  d = 0;
	}

	return d;
}

double PlanningHelpers::GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; point1, const WayPoint&amp; point2, const WayPoint&amp; pose)
{
	WayPoint p1 = point1, p2 = point2;
	Mat3 rotationMat(-p1.pos.a);
	Mat3 translationMat(-pose.pos.x, -pose.pos.y);

	p1.pos = translationMat*p1.pos;
	p1.pos = rotationMat*p1.pos;

	p2.pos = translationMat*p2.pos;
	p2.pos = rotationMat*p2.pos;

	double m = (p2.pos.y-p1.pos.y)/(p2.pos.x-p1.pos.x);
	double d = p2.pos.y - m*p2.pos.x;

	if(isnan(d) || isinf(d))
	{
	  //assert(false);
	  d = 0;
	}

	return d;
}

WayPoint PlanningHelpers::GetNextPointOnTrajectory_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex)
{
	assert(trajectory.size()&gt;0);

	int local_currIndex = currIndex;

	if(local_currIndex &lt; 0 || local_currIndex &gt;= trajectory.size())
		return trajectory.at(0);

	WayPoint p1 = trajectory.at(local_currIndex);
	WayPoint p2;

	double d = 0;
	while(local_currIndex &lt; (trajectory.size()-1) &amp;&amp; d &lt; distance)
	{
		local_currIndex++;
		p2 = p1;
		p1 = trajectory.at(local_currIndex);
		d += distance2points(p1.pos, p2.pos);
	}

	if(local_currIndex &gt;= trajectory.size()-1)
	  return p1;

	double distance_diff = distance -  d;

	p2 = trajectory.at(local_currIndex);
	p1 = trajectory.at(local_currIndex+1);

	POINT2D uv(p1.pos.x - p2.pos.x, p1.pos.y - p2.pos.y);
	double v_norm = pointNorm(uv);

	assert(v_norm != 0);

	uv.x = (uv.x / v_norm) * distance_diff;
	uv.y = (uv.y / v_norm) * distance_diff;

	double ydiff = p1.pos.y-p2.pos.y;
	double xdiff = p1.pos.x-p2.pos.x;
	double a =  atan2(ydiff,xdiff);

	WayPoint abs_waypoint = p2;

	abs_waypoint.pos.x = p2.pos.x + uv.x;
	abs_waypoint.pos.y = p2.pos.y + uv.y;
	abs_waypoint.pos.a = a;

	return abs_waypoint;
}

double PlanningHelpers::GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p)
{

	int end_point_index = GetClosestPointIndex_obsolete(path, p);
	if(end_point_index &gt; 0)
		end_point_index--;

	double padding_distance = distance2points(path.at(end_point_index).pos, p.pos);

	double d_on_path = 0;
	if(end_point_index &gt;= start_index)
	{
		for(unsigned int i = start_index; i &lt; end_point_index; i++)
			d_on_path += distance2points(path.at(i).pos, path.at(i+1).pos);

		d_on_path += padding_distance;
	}
	else
	{
		for(unsigned int i = start_index; i &gt; end_point_index; i--)
			d_on_path -= distance2points(path.at(i).pos, path.at(i-1).pos);
	}

	return d_on_path;
}

bool PlanningHelpers::CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2)
{
	if(path1.size() != path2.size())
		return false;

	for(unsigned int i=0; i&lt; path1.size(); i++)
	{
		if(path1.at(i).v != path2.at(i).v || path1.at(i).pos.x != path2.at(i).pos.x || path1.at(i).pos.y != path2.at(i).pos.y || path1.at(i).pos.alt != path2.at(i).pos.alt || path1.at(i).pos.lon != path2.at(i).pos.lon)
			return false;
	}

	return true;
}

double PlanningHelpers::GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID, int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex)
{

//	trafficLightID = stopSignID = stopLineID = -1;
//
//	RelativeInfo info;
//	GetRelativeInfo(path, p, info);
//
//	for(unsigned int i=info.iBack; i&lt;path.size(); i++)
//	{
//		if(path.at(i).pLane &amp;&amp; path.at(i).pLane-&gt;stopLines.size() &gt; 0)
//		{
//			stopSignID = path.at(i).pLane-&gt;stopLines.at(0).stopSignID;
//			trafficLightID = path.at(i).pLane-&gt;stopLines.at(0).trafficLightID;
//			return 1;
////			for(unsigned int j = 0; j &lt; path.at(i).pLane-&gt;stopLines.size(); j++)
////			{
////				RelativeInfo local_info;
////				WayPoint stopLineWP;
////				stopLineWP.pos = path.at(i).pLane-&gt;stopLines.at(j).points.at(0);
////
////				GetRelativeInfo(path, stopLineWP, local_info, i);
////
////				double d = GetExactDistanceOnTrajectory(path, info, local_info);
////				if(d &gt; 0)
////				{
////						stopSignID = path.at(i).pLane-&gt;stopLines.at(j).stopSignID;
////						trafficLightID = path.at(i).pLane-&gt;stopLines.at(j).trafficLightID;
////						return d;
////				}
////			}
//		}
//	}

	trafficLightID = stopSignID = stopLineID = -1;

	RelativeInfo info;
	GetRelativeInfo(path, p, info, prevIndex);

	for(unsigned int i=info.iBack; i&lt;path.size(); i++)
	{
		if(path.at(i).stopLineID &gt; 0 &amp;&amp; path.at(i).pLane)
		{
			for(unsigned int j = 0; j &lt; path.at(i).pLane-&gt;stopLines.size(); j++)
			{
				if(path.at(i).pLane-&gt;stopLines.at(j).id == path.at(i).stopLineID)
				{
					stopLineID = path.at(i).stopLineID;

					RelativeInfo stop_info;
					WayPoint stopLineWP ;
					stopLineWP.pos = path.at(i).pLane-&gt;stopLines.at(j).points.at(0);
					GetRelativeInfo(path, stopLineWP, stop_info);
					double localDistance = GetExactDistanceOnTrajectory(path, info, stop_info);

					if(localDistance&gt;0)
					{
						stopSignID = path.at(i).pLane-&gt;stopLines.at(j).stopSignID;
						trafficLightID = path.at(i).pLane-&gt;stopLines.at(j).trafficLightID;
						return localDistance;
					}
				}
			}
		}
	}

	return -1;
}

void PlanningHelpers::FixPathDensity(vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity)
{
	if(path.size() == 0 || distanceDensity==0) return;

	double d = 0, a = 0;
	double margin = distanceDensity*0.01;
	double remaining = 0;
	int nPoints = 0;
	vector&lt;WayPoint&gt; fixedPath;
	fixedPath.push_back(path.at(0));
	for(unsigned int si = 0, ei=1; ei &lt; path.size(); )
	{
		d += hypot(path.at(ei).pos.x- path.at(ei-1).pos.x, path.at(ei).pos.y- path.at(ei-1).pos.y) + remaining;
		a = atan2(path.at(ei).pos.y - path.at(si).pos.y, path.at(ei).pos.x - path.at(si).pos.x);

		if(d &lt; distanceDensity - margin ) // skip
		{
			ei++;
			remaining = 0;
		}
		else if(d &gt; (distanceDensity +  margin)) // skip
		{
			WayPoint pm = path.at(si);
			nPoints = d  / distanceDensity;
			for(int k = 0; k &lt; nPoints; k++)
			{
				pm.pos.x = pm.pos.x + distanceDensity * cos(a);
				pm.pos.y = pm.pos.y + distanceDensity * sin(a);
				fixedPath.push_back(pm);
			}
			remaining = d - nPoints*distanceDensity;
			si++;
			path.at(si).pos = pm.pos;
			d = 0;
			ei++;
		}
		else
		{
			d = 0;
			remaining = 0;
			fixedPath.push_back(path.at(ei));
			ei++;
			si = ei - 1;
		}
	}

	path = fixedPath;
}

void PlanningHelpers::SmoothPath(vector&lt;WayPoint&gt;&amp; path, double weight_data,
		double weight_smooth, double tolerance)
{

	if (path.size() &lt;= 2 )
	{
		cout &lt;&lt; &quot;Can't Smooth Path, Path_in Size=&quot; &lt;&lt; path.size() &lt;&lt; endl;
		return;
	}

	const vector&lt;WayPoint&gt;&amp; path_in = path;
	vector&lt;WayPoint&gt; smoothPath_out =  path_in;

	double change = tolerance;
	double xtemp, ytemp;
	int nIterations = 0;

	int size = path_in.size();

	while (change &gt;= tolerance)
	{
		change = 0.0;
		for (int i = 1; i &lt; size - 1; i++)
		{
//			if (smoothPath_out[i].pos.a != smoothPath_out[i - 1].pos.a)
//				continue;

			xtemp = smoothPath_out[i].pos.x;
			ytemp = smoothPath_out[i].pos.y;

			smoothPath_out[i].pos.x += weight_data
					* (path_in[i].pos.x - smoothPath_out[i].pos.x);
			smoothPath_out[i].pos.y += weight_data
					* (path_in[i].pos.y - smoothPath_out[i].pos.y);

			smoothPath_out[i].pos.x += weight_smooth
					* (smoothPath_out[i - 1].pos.x + smoothPath_out[i + 1].pos.x
							- (2.0 * smoothPath_out[i].pos.x));
			smoothPath_out[i].pos.y += weight_smooth
					* (smoothPath_out[i - 1].pos.y + smoothPath_out[i + 1].pos.y
							- (2.0 * smoothPath_out[i].pos.y));

			change += fabs(xtemp - smoothPath_out[i].pos.x);
			change += fabs(ytemp - smoothPath_out[i].pos.y);

		}
		nIterations++;
	}

	path = smoothPath_out;
}

//double PlanningHelpers::CalcAngleAndCostSimple(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost)
//{
//	if(path.size() &lt;= 2) return 0;
//
//	path[0].pos.a = atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x );
//	path[0].cost = lastCost;
//
//	for(int j = 1; j &lt; path.size()-1; j++)
//	{
//		path[j].pos.a 	= atan2(path[j+1].pos.y - path[j].pos.y, path[j+1].pos.x - path[j].pos.x );
//		path[j].cost 	= path[j-1].cost +  hypot(path[j-1].pos.y- path[j].pos.y, path[j-1].pos.x- path[j].pos.x);
//	}
//
//	int j = (int)path.size()-1;
//
//	path[j].pos.a 	= path[j-1].pos.a;
//	path[j].cost 	= path[j-1].cost + hypot(path[j-1].pos.y- path[j].pos.y, path[j-1].pos.x- path[j].pos.x);
//
//	for(int j = 0; j &lt; path.size()-1; j++)
//	{
//		if(path.at(j).pos.x == path.at(j+1).pos.x &amp;&amp; path.at(j).pos.y == path.at(j+1).pos.y)
//			path.at(j).pos.a = path.at(j+1).pos.a;
//	}
//
//	return path[j].cost;
//}

double PlanningHelpers::CalcAngleAndCost(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost, const bool&amp; bSmooth)
{
	if(path.size() &lt;= 2) return 0;

	path[0].pos.a = UtilityH::FixNegativeAngle(atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x ));
	path[0].cost = lastCost;

	for(int j = 1; j &lt; path.size()-1; j++)
	{
		path[j].pos.a 		= UtilityH::FixNegativeAngle(atan2(path[j+1].pos.y - path[j].pos.y, path[j+1].pos.x - path[j].pos.x ));
		path[j].cost 	= path[j-1].cost +  distance2points(path[j-1].pos, path[j].pos);
	}

	int j = (int)path.size()-1;

	path[j].pos.a 		= path[j-1].pos.a;
	path[j].cost 	= path[j-1].cost + distance2points(path[j-1].pos, path[j].pos);

	for(int j = 0; j &lt; path.size()-1; j++)
	{
		if(path.at(j).pos.x == path.at(j+1).pos.x &amp;&amp; path.at(j).pos.y == path.at(j+1).pos.y)
			path.at(j).pos.a = path.at(j+1).pos.a;
	}

	return path[j].cost;
}

double PlanningHelpers::CalcAngleAndCostAndCurvatureAnd2D(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost)
{
	path[0].pos.a 	= atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x );
	path[0].cost 	= lastCost;

	double k = 0;
	GPSPoint center;

	for(unsigned int j = 1; j &lt; path.size()-1; j++)
	{
		k =  CalcCircle(path[j-1].pos,path[j].pos, path[j+1].pos, center);
		if(k &gt; 150.0 || isnan(k))
			k = 150.0;

		if(k&lt;1.0)
			path[j].cost = 0;
		else
			path[j].cost = 1.0-1.0/k;

		path[j].pos.a 	= atan2(path[j+1].pos.y - path[j].pos.y, path[j+1].pos.x - path[j].pos.x );
	}
	unsigned int j = path.size()-1;

	path[0].cost    = path[1].cost;
	path[j].cost 	= path[j-1].cost;
	path[j].pos.a 	= path[j-1].pos.a;
	path[j].cost 	= path[j-1].cost ;

	return path[j].cost;
}

double PlanningHelpers::CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center)
{
	double yDelta_a= pt2.y - pt1.y;
	double xDelta_a= pt2.x - pt1.x;
	double yDelta_b= pt3.y - pt2.y;
	double xDelta_b= pt3.x - pt2.x;

	if (fabs(xDelta_a) &lt;= 0.000000000001 &amp;&amp; fabs(yDelta_b) &lt;= 0.000000000001)
	{
		center.x= 0.5*(pt2.x + pt3.x);
		center.y= 0.5*(pt1.y + pt2.y);
		return distance2points(center,pt1);
	}

	double aSlope=yDelta_a/xDelta_a;
	double bSlope=yDelta_b/xDelta_b;
	if (fabs(aSlope-bSlope) &lt;= 0.000000000001)
	{
		return 100000;
	}

	center.x= (aSlope*bSlope*(pt1.y - pt3.y) + bSlope*(pt1.x + pt2 .x) - aSlope*(pt2.x+pt3.x) )/(2.0* (bSlope-aSlope) );
	center.y = -1.0*(center.x - (pt1.x+pt2.x)/2.0)/aSlope +  (pt1.y+pt2.y)/2.0;

	return  distance2points(center,pt1);
}

void PlanningHelpers::ExtractPartFromPointToDistance(const vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
		const double&amp; pathDensity, vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance)
{
	extractedPath.clear();
	unsigned int close_index = GetClosestNextPointIndexDirection(originalPath, pos);
	vector&lt;WayPoint&gt; tempPath;
	double d_limit = 0;
	if(close_index &gt;= 5) close_index -=5;
	else close_index = 0;

	for(unsigned int i=close_index; i&lt; originalPath.size(); i++)
	{
		tempPath.push_back(originalPath.at(i));

		if(i&gt;0)
			d_limit += hypot(originalPath.at(i).pos.y - originalPath.at(i-1).pos.y, originalPath.at(i).pos.x - originalPath.at(i-1).pos.x);

		if(d_limit &gt; minDistance)
			break;
	}

	if(tempPath.size() &lt; 2)
	{
		cout &lt;&lt; endl &lt;&lt; &quot;### Planner Z . Extracted Rollout Path is too Small, Size = &quot; &lt;&lt; tempPath.size() &lt;&lt; endl;
		return;
	}

	FixPathDensity(tempPath, pathDensity);
	SmoothPath(tempPath, SmoothDataWeight, SmoothWeight , SmoothTolerance);
	CalcAngleAndCost(tempPath);

	extractedPath = tempPath;
	//tempPath.clear();
	//TestQuadraticSpline(extractedPath, tempPath);
}

void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
		int&amp; end_index, vector&lt;double&gt;&amp; end_laterals ,
		vector&lt;vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
		const double&amp; maxSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
		const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
		const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
		const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
		std::vector&lt;WayPoint&gt;&amp; sampledPoints)
{
	WayPoint p;
	double dummyd = 0;

	int iLimitIndex = (carTipMargin/0.3)/pathDensity;
	if(iLimitIndex &gt;= originalCenter.size())
		iLimitIndex = originalCenter.size() - 1;

	//Get Closest Index
	RelativeInfo info;
	GetRelativeInfo(originalCenter, carPos, info);
	double remaining_distance = 0;
	int close_index = info.iBack;
	for(unsigned int i=close_index; i&lt; originalCenter.size()-1; i++)
	  {
		if(i&gt;0)
			remaining_distance += distance2points(originalCenter[i].pos, originalCenter[i+1].pos);
	  }

	double initial_roll_in_distance = info.perp_distance ; //GetPerpDistanceToTrajectorySimple(originalCenter, carPos, close_index);


	vector&lt;WayPoint&gt; RollOutStratPath;
	///***   Smoothing From Car Heading Section ***///
//	if(bHeadingSmooth)
//	{
//		unsigned int num_of_strait_points = carTipMargin / pathDensity;
//		int closest_for_each_iteration = 0;
//		WayPoint np = GetPerpendicularOnTrajectory(originalCenter, rearPos, dummyd, closest_for_each_iteration);
//		np.pos = rearPos.pos;
//
//		RollOutStratPath.push_back(np);
//		for(unsigned int i = 0; i &lt; num_of_strait_points; i++)
//		{
//			p = RollOutStratPath.at(i);
//			p.pos.x = p.pos.x +  pathDensity*cos(p.pos.a);
//			p.pos.y = p.pos.y +  pathDensity*sin(p.pos.a);
//			np = GetPerpendicularOnTrajectory(originalCenter, p, dummyd, closest_for_each_iteration);
//			np.pos = p.pos;
//			RollOutStratPath.push_back(np);
//		}
//
//		initial_roll_in_distance = GetPerpDistanceToTrajectorySimple(originalCenter, RollOutStratPath.at(RollOutStratPath.size()-1), close_index);
//	}
	///***   -------------------------------- ***///


	//printf(&quot;\n Lateral Distance: %f&quot; , initial_roll_in_distance);

	//calculate the starting index
	double d_limit = 0;
	unsigned int far_index = close_index;

	//calculate end index
	double start_distance = rollInSpeedFactor*speed+rollInMargin;
	if(start_distance &gt; remaining_distance)
		start_distance = remaining_distance;

	d_limit = 0;
	for(unsigned int i=close_index; i&lt; originalCenter.size(); i++)
	  {
		  if(i&gt;0)
			  d_limit += distance2points(originalCenter[i].pos, originalCenter[i-1].pos);

		  if(d_limit &gt;= start_distance)
		  {
			  far_index = i;
			  break;
		  }
	  }

	int centralTrajectoryIndex = rollOutNumber/2;
	vector&lt;double&gt; end_distance_list;
	for(int i=0; i&lt; rollOutNumber+1; i++)
	  {
		  double end_roll_in_distance = rollOutDensity*(i - centralTrajectoryIndex);
		  end_distance_list.push_back(end_roll_in_distance);
	  }

	start_index = close_index;
	end_index = far_index;
	end_laterals = end_distance_list;

	//calculate the actual calculation starting index
	d_limit = 0;
	unsigned int smoothing_start_index = start_index;
	unsigned int smoothing_end_index = end_index;

	for(unsigned int i=smoothing_start_index; i&lt; originalCenter.size(); i++)
	{
		if(i &gt; 0)
			d_limit += distance2points(originalCenter[i].pos, originalCenter[i-1].pos);
		if(d_limit &gt; carTipMargin)
			break;

		smoothing_start_index++;
	}

	d_limit = 0;
	for(unsigned int i=end_index; i&lt; originalCenter.size(); i++)
	{
		if(i &gt; 0)
			d_limit += distance2points(originalCenter[i].pos, originalCenter[i-1].pos);
		if(d_limit &gt; carTipMargin)
			break;

		smoothing_end_index++;
	}

	int nSteps = end_index - smoothing_start_index;


	vector&lt;double&gt; inc_list;
	rollInPaths.clear();
	vector&lt;double&gt; inc_list_inc;
	for(int i=0; i&lt; rollOutNumber+1; i++)
	{
		double diff = end_laterals.at(i)-initial_roll_in_distance;
		inc_list.push_back(diff/(double)nSteps);
		rollInPaths.push_back(vector&lt;WayPoint&gt;());
		inc_list_inc.push_back(0);
	}



	vector&lt;vector&lt;WayPoint&gt; &gt; execluded_from_smoothing;
	for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
		execluded_from_smoothing.push_back(vector&lt;WayPoint&gt;());



	//Insert First strait points within the tip of the car range
	for(unsigned int j = start_index; j &lt; smoothing_start_index; j++)
	{
		p = originalCenter.at(j);
		double original_speed = p.v;
	  for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
	  {
		  p.pos.x = originalCenter.at(j).pos.x -  initial_roll_in_distance*cos(p.pos.a + M_PI_2);
		  p.pos.y = originalCenter.at(j).pos.y -  initial_roll_in_distance*sin(p.pos.a + M_PI_2);
		  if(i!=centralTrajectoryIndex)
			  p.v = original_speed * LANE_CHANGE_SPEED_FACTOR;
		  else
			  p.v = original_speed ;

		  if(j &lt; iLimitIndex)
			  execluded_from_smoothing.at(i).push_back(p);
		  else
			  rollInPaths.at(i).push_back(p);

		  sampledPoints.push_back(p);
	  }
	}

	for(unsigned int j = smoothing_start_index; j &lt; end_index; j++)
	  {
		  p = originalCenter.at(j);
		  double original_speed = p.v;
		  for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
		  {
			  inc_list_inc[i] += inc_list[i];
			  double d = inc_list_inc[i];
			  p.pos.x = originalCenter.at(j).pos.x -  initial_roll_in_distance*cos(p.pos.a + M_PI_2) - d*cos(p.pos.a+ M_PI_2);
			  p.pos.y = originalCenter.at(j).pos.y -  initial_roll_in_distance*sin(p.pos.a + M_PI_2) - d*sin(p.pos.a+ M_PI_2);
			  if(i!=centralTrajectoryIndex)
				  p.v = original_speed * LANE_CHANGE_SPEED_FACTOR;
			  else
				  p.v = original_speed ;

			  rollInPaths.at(i).push_back(p);

			  sampledPoints.push_back(p);
		  }
	  }

	//Insert last strait points to make better smoothing
	for(unsigned int j = end_index; j &lt; smoothing_end_index; j++)
	{
		p = originalCenter.at(j);
		double original_speed = p.v;
	  for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
	  {
		  double d = end_laterals.at(i);
		  p.pos.x  = originalCenter.at(j).pos.x - d*cos(p.pos.a + M_PI_2);
		  p.pos.y  = originalCenter.at(j).pos.y - d*sin(p.pos.a + M_PI_2);
		  if(i!=centralTrajectoryIndex)
			  p.v = original_speed * LANE_CHANGE_SPEED_FACTOR;
		  else
			  p.v = original_speed ;
		  rollInPaths.at(i).push_back(p);

		  sampledPoints.push_back(p);
	  }
	}

	for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
		rollInPaths.at(i).insert(rollInPaths.at(i).begin(), execluded_from_smoothing.at(i).begin(), execluded_from_smoothing.at(i).end());

	///***   Smoothing From Car Heading Section ***///
//	if(bHeadingSmooth)
//	{
//		for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
//		{
//			unsigned int cut_index = GetClosestNextPointIndex(rollInPaths.at(i), RollOutStratPath.at(RollOutStratPath.size()-1));
//			rollInPaths.at(i).erase(rollInPaths.at(i).begin(), rollInPaths.at(i).begin()+cut_index);
//			rollInPaths.at(i).insert(rollInPaths.at(i).begin(), RollOutStratPath.begin(), RollOutStratPath.end());
//		}
//	}
	///***   -------------------------------- ***///

	for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
	{
		SmoothPath(rollInPaths.at(i), SmoothDataWeight, SmoothWeight, SmoothTolerance);
	}

	d_limit = 0;
	for(unsigned int j = smoothing_end_index; j &lt; originalCenter.size(); j++)
	  {
		if(j &gt; 0)
			d_limit += distance2points(originalCenter.at(j).pos, originalCenter.at(j-1).pos);

		if(d_limit &gt; max_roll_distance)
			break;

			p = originalCenter.at(j);
			double original_speed = p.v;
		  for(unsigned int i=0; i&lt; rollInPaths.size() ; i++)
		  {
			  double d = end_laterals.at(i);
			  p.pos.x  = originalCenter.at(j).pos.x - d*cos(p.pos.a + M_PI_2);
			  p.pos.y  = originalCenter.at(j).pos.y - d*sin(p.pos.a + M_PI_2);

			  if(i!=centralTrajectoryIndex)
				  p.v = original_speed * LANE_CHANGE_SPEED_FACTOR;
			  else
				  p.v = original_speed ;

			  rollInPaths.at(i).push_back(p);

			  sampledPoints.push_back(p);
		  }
	  }

//	for(unsigned int i=0; i&lt; rollInPaths.size(); i++)
//		CalcAngleAndCost(rollInPaths.at(i));
}

bool PlanningHelpers::FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x)
{
	for(unsigned int i = 0 ; i &lt; list.size(); i++)
	{
		if(list.at(i) == x)
			return true;
	}
	return false;
}

void PlanningHelpers::RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x)
{
	for(unsigned int i = 0 ; i &lt; list.size(); i++)
	{
		if(list.at(i) == x)
		{
			list.erase(list.begin()+i);
		}
	}
}

std::vector&lt;int&gt; PlanningHelpers::GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path)
{
	 vector&lt;int&gt; sideLanes;
	for(unsigned int iwp = 0; iwp &lt; path.size(); iwp++)
	 {
		 if(path.at(iwp).LeftLaneId&gt;0)
		 {
			 bool bFound = false;
			 for(unsigned int is = 0 ; is &lt; sideLanes.size(); is++)
			 {
				 if(sideLanes.at(is) == path.at(iwp).LeftLaneId)
				 {
					 bFound = true;
					 break;
				 }
			 }

			 if(!bFound)
				 sideLanes.push_back(path.at(iwp).LeftLaneId);
		 }

		 if(path.at(iwp).RightLaneId&gt;0)
		 {
			 bool bFound = false;
			 for(unsigned int is = 0 ; is &lt; sideLanes.size(); is++)
			 {
				 if(sideLanes.at(is) == path.at(iwp).RightLaneId)
				 {
					 bFound = true;
					 break;
				 }
			 }

			 if(!bFound)
				 sideLanes.push_back(path.at(iwp).RightLaneId);
		 }

		 //RemoveWithValue(sideLanes, path.at(iwp).laneId);
	 }
	return sideLanes;
}

void PlanningHelpers::SmoothSpeedProfiles(vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	)
{

	if (path_in.size() &lt;= 1)
		return;
	vector&lt;WayPoint&gt; newpath = path_in;

	double change = tolerance;
	double xtemp;
	int nIterations = 0;
	int size = newpath.size();

	while (change &gt;= tolerance)
	{
		change = 0.0;
		for (int i = 1; i &lt; size -1; i++)
		{
			xtemp = newpath[i].v;
			newpath[i].v += weight_data * (path_in[i].v - newpath[i].v);
			newpath[i].v += weight_smooth * (newpath[i - 1].v + newpath[i + 1].v - (2.0 * newpath[i].v));
			change += fabs(xtemp - newpath[i].v);

		}
		nIterations++;
	}

	path_in = newpath;
}

void PlanningHelpers::SmoothCurvatureProfiles(vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance)
{
	if (path_in.size() &lt;= 1)
			return;
	vector&lt;WayPoint&gt; newpath = path_in;

	double change = tolerance;
	double xtemp;
	int nIterations = 0;
	int size = newpath.size();

	while (change &gt;= tolerance)
	{
		change = 0.0;
		for (int i = 1; i &lt; size -1; i++)
		{
			xtemp = newpath[i].cost;
			newpath[i].cost += weight_data * (path_in[i].cost - newpath[i].cost);
			newpath[i].cost += weight_smooth * (newpath[i - 1].cost + newpath[i + 1].cost - (2.0 * newpath[i].cost));
			change += fabs(xtemp - newpath[i].cost);

		}
		nIterations++;
	}
	path_in = newpath;
}

void PlanningHelpers::SmoothWayPointsDirections(vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	)
{

	if (path_in.size() &lt;= 1)
		return;

	vector&lt;WayPoint&gt; newpath = path_in;

	double change = tolerance;
	double xtemp;
	int nIterations = 0;
	int size = newpath.size();

	while (change &gt;= tolerance)
	{
		change = 0.0;
		for (int i = 1; i &lt; size -1; i++)
		{
			xtemp = newpath[i].pos.a;
			newpath[i].pos.a += weight_data * (path_in[i].pos.a - newpath[i].pos.a);
			newpath[i].pos.a += weight_smooth * (newpath[i - 1].pos.a + newpath[i + 1].pos.a - (2.0 * newpath[i].pos.a));
			change += fabs(xtemp - newpath[i].pos.a);

		}
		nIterations++;
	}
	path_in = newpath;
}

void PlanningHelpers::GenerateRecommendedSpeed(vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor)
{
	FixPathDensity(path, 0.5);

	CalcAngleAndCostAndCurvatureAnd2D(path);

	SmoothCurvatureProfiles(path, 0.3, 0.49, 0.01);

	for(unsigned int i = 0 ; i &lt; path.size(); i++)
	{
		double k_ratio = path.at(i).cost*10.0;

		if(k_ratio &gt;= 9.5)
			path.at(i).v = max_speed;
		else if(k_ratio &lt;= 8.5)
			path.at(i).v = 1.0*speedProfileFactor;
		else
		{
			k_ratio = k_ratio - 8.5;
			path.at(i).v = (max_speed - 1.0) * k_ratio + 1.0;
			path.at(i).v = path.at(i).v*speedProfileFactor;
		}

		if(path.at(i).v &gt; max_speed)
			path.at(i).v = max_speed;

	}

	//SmoothSpeedProfiles(path, 0.15,0.45, 0.1);
}

WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
		const WayPoint&amp; goalPos,
		const vector&lt;int&gt;&amp; globalPath,
		const double&amp; DistanceLimit,
		const bool&amp; bEnableLaneChange,
		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete)
{
	if(!pStart) return NULL;

	vector&lt;pair&lt;WayPoint*, WayPoint*&gt; &gt;nextLeafToTrace;

	WayPoint* pZero = 0;
	WayPoint* wp    = new WayPoint();
	*wp = *pStart;
	nextLeafToTrace.push_back(make_pair(pZero, wp));
	all_cells_to_delete.push_back(wp);

	double 		distance 		= 0;
	WayPoint* 	pGoalCell 		= 0;
	double 		nCounter 		= 0;


	while(nextLeafToTrace.size()&gt;0)
	{
		nCounter++;

		unsigned int min_cost_index = 0;
		double min_cost = 99999999999;

		for(unsigned int i=0; i &lt; nextLeafToTrace.size(); i++)
		{
			if(nextLeafToTrace.at(i).second-&gt;cost &lt; min_cost)
			{
				min_cost = nextLeafToTrace.at(i).second-&gt;cost;
				min_cost_index = i;
			}
		}

		WayPoint* pH 	= nextLeafToTrace.at(min_cost_index).second;

		assert(pH != 0);

		nextLeafToTrace.erase(nextLeafToTrace.begin()+min_cost_index);

		double distance_to_goal = distance2points(pH-&gt;pos, goalPos.pos);
		double angle_to_goal = UtilityH::AngleBetweenTwoAnglesPositive(UtilityH::FixNegativeAngle(pH-&gt;pos.a), UtilityH::FixNegativeAngle(goalPos.pos.a));
		if( distance_to_goal &lt;= 0.1 &amp;&amp; angle_to_goal &lt; M_PI_4)
		{
			cout &lt;&lt; &quot;Goal Found, LaneID: &quot; &lt;&lt; pH-&gt;laneId &lt;&lt;&quot;, Distance : &quot; &lt;&lt; distance_to_goal &lt;&lt; &quot;, Angle: &quot; &lt;&lt; angle_to_goal*RAD2DEG &lt;&lt; endl;
			pGoalCell = pH;
			break;
		}
		else
		{

			if(pH-&gt;pLeft &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pLeft-&gt;pLane) &amp;&amp; bEnableLaneChange)
			{
				wp = new WayPoint();
				*wp = *pH-&gt;pLeft;
				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
				distance += d;

				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
				{
					//if(wp-&gt;actionCost.at(a).first == LEFT_TURN_ACTION)
						d += wp-&gt;actionCost.at(a).second;
				}

				wp-&gt;cost = pH-&gt;cost + d;
				wp-&gt;pRight = pH;
				wp-&gt;pRight = 0;

				nextLeafToTrace.push_back(make_pair(pH, wp));
				all_cells_to_delete.push_back(wp);
			}

			if(pH-&gt;pRight &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pRight-&gt;pLane) &amp;&amp; bEnableLaneChange)
			{
				wp = new WayPoint();
				*wp = *pH-&gt;pRight;
				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
				distance += d;

				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
				{
					//if(wp-&gt;actionCost.at(a).first == RIGHT_TURN_ACTION)
						d += wp-&gt;actionCost.at(a).second;
				}

				wp-&gt;cost = pH-&gt;cost + d ;
				wp-&gt;pLeft = pH;
				wp-&gt;pRight = 0;
				nextLeafToTrace.push_back(make_pair(pH, wp));
				all_cells_to_delete.push_back(wp);
			}

			for(unsigned int i =0; i&lt; pH-&gt;pFronts.size(); i++)
			{
				if(CheckLaneIdExits(globalPath, pH-&gt;pLane) &amp;&amp; pH-&gt;pFronts.at(i) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pFronts.at(i)))
				{
					wp = new WayPoint();
					*wp = *pH-&gt;pFronts.at(i);

					double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
					distance += d;

					for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
					{
						//if(wp-&gt;actionCost.at(a).first == FORWARD_ACTION)
							d += wp-&gt;actionCost.at(a).second;
					}

					wp-&gt;cost = pH-&gt;cost + d;
					wp-&gt;pBacks.push_back(pH);

					nextLeafToTrace.push_back(make_pair(pH, wp));
					all_cells_to_delete.push_back(wp);
				}
			}
		}

		if(distance &gt; DistanceLimit &amp;&amp; globalPath.size()==0)
		{
			//if(!pGoalCell)
			cout &lt;&lt; &quot;Goal Not Found, LaneID: &quot; &lt;&lt; pH-&gt;laneId &lt;&lt;&quot;, Distance : &quot; &lt;&lt; distance &lt;&lt; endl;
			pGoalCell = pH;
			break;
		}

		//pGoalCell = pH;
	}

	while(nextLeafToTrace.size()!=0)
		nextLeafToTrace.pop_back();
	//closed_nodes.clear();

	return pGoalCell;
}

WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
		const double&amp; DistanceLimit,
		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete)
{
	if(!pStart) return NULL;

	vector&lt;pair&lt;WayPoint*, WayPoint*&gt; &gt;nextLeafToTrace;

	WayPoint* pZero = 0;
	WayPoint* wp    = new WayPoint();
	*wp = *pStart;
	nextLeafToTrace.push_back(make_pair(pZero, wp));
	all_cells_to_delete.push_back(wp);

	double 		distance 		= 0;
	WayPoint* 	pGoalCell 		= 0;
	double 		nCounter 		= 0;

	while(nextLeafToTrace.size()&gt;0)
	{
		nCounter++;

		unsigned int min_cost_index = 0;
		double min_cost = 99999999999;

		for(unsigned int i=0; i &lt; nextLeafToTrace.size(); i++)
		{
			if(nextLeafToTrace.at(i).second-&gt;cost &lt; min_cost)
			{
				min_cost = nextLeafToTrace.at(i).second-&gt;cost;
				min_cost_index = i;
			}
		}

		WayPoint* pH 	= nextLeafToTrace.at(min_cost_index).second;
		assert(pH != 0);

		nextLeafToTrace.erase(nextLeafToTrace.begin()+min_cost_index);

		for(unsigned int i =0; i&lt; pH-&gt;pFronts.size(); i++)
		{
			if(pH-&gt;pFronts.at(i) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pFronts.at(i)))
			{
				wp = new WayPoint();
				*wp = *pH-&gt;pFronts.at(i);

				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
				distance += d;

				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
				{
					//if(wp-&gt;actionCost.at(a).first == FORWARD_ACTION)
						d += wp-&gt;actionCost.at(a).second;
				}

				wp-&gt;cost = pH-&gt;cost + d;
				wp-&gt;pBacks.push_back(pH);
				if(wp-&gt;cost &lt; DistanceLimit)
				{
					nextLeafToTrace.push_back(make_pair(pH, wp));
					all_cells_to_delete.push_back(wp);
				}
				else
					delete wp;
			}
		}

//		if(pH-&gt;pLeft &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pLeft-&gt;pLane))
//		{
//			wp = new WayPoint();
//			*wp = *pH-&gt;pLeft;
//			double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
//
//			for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
//			{
//				//if(wp-&gt;actionCost.at(a).first == LEFT_TURN_ACTION)
//					d += wp-&gt;actionCost.at(a).second;
//			}
//
//			wp-&gt;cost = pH-&gt;cost + d + LANE_CHANGE_COST;
//			wp-&gt;pRight = pH;
//			wp-&gt;pRight = 0;
//
//			nextLeafToTrace.push_back(make_pair(pH, wp));
//			all_cells_to_delete.push_back(wp);
//		}
//
//		if(pH-&gt;pRight &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pRight-&gt;pLane))
//		{
//			wp = new WayPoint();
//			*wp = *pH-&gt;pRight;
//			double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);;
//
//			for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
//			{
//				//if(wp-&gt;actionCost.at(a).first == RIGHT_TURN_ACTION)
//					d += wp-&gt;actionCost.at(a).second;
//			}
//
//			wp-&gt;cost = pH-&gt;cost + d + LANE_CHANGE_COST;
//			wp-&gt;pLeft = pH;
//			wp-&gt;pRight = 0;
//			nextLeafToTrace.push_back(make_pair(pH, wp));
//			all_cells_to_delete.push_back(wp);
//		}

		pGoalCell = pH;
	}

	while(nextLeafToTrace.size()!=0)
		nextLeafToTrace.pop_back();

	return pGoalCell;
}

int PlanningHelpers::PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete,vector&lt;WayPoint*&gt;&amp; end_waypoints)
{
	if(!pStart) return 0;

	vector&lt;pair&lt;WayPoint*, WayPoint*&gt; &gt;nextLeafToTrace;

	WayPoint* pZero = 0;
	WayPoint* wp    = new WayPoint();
	*wp = *pStart;
	wp-&gt;pLeft = 0;
	wp-&gt;pRight = 0;
	nextLeafToTrace.push_back(make_pair(pZero, wp));
	all_cells_to_delete.push_back(wp);

	double 		distance 		= 0;
	end_waypoints.clear();
	double 		nCounter 		= 0;

	while(nextLeafToTrace.size()&gt;0)
	{
		nCounter++;

		WayPoint* pH 	= nextLeafToTrace.at(0).second;

		assert(pH != 0);

		nextLeafToTrace.erase(nextLeafToTrace.begin()+0);

		for(unsigned int i =0; i&lt; pH-&gt;pFronts.size(); i++)
		{
			if(pH-&gt;pFronts.at(i) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pFronts.at(i)))
			{
				if(pH-&gt;cost &lt; DistanceLimit)
				{
					wp = new WayPoint();
					*wp = *pH-&gt;pFronts.at(i);

					double d = distance2points(wp-&gt;pos, pH-&gt;pos);
					distance += d;
					wp-&gt;cost = pH-&gt;cost + d;
					wp-&gt;pBacks.push_back(pH);
					wp-&gt;pLeft = 0;
					wp-&gt;pRight = 0;

					nextLeafToTrace.push_back(make_pair(pH, wp));
					all_cells_to_delete.push_back(wp);
				}
				else
				{
					end_waypoints.push_back(pH);
				}
			}
		}
	}

	while(nextLeafToTrace.size()!=0)
		nextLeafToTrace.pop_back();
	//closed_nodes.clear();

	return end_waypoints.size();
}

bool PlanningHelpers::CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL)
{
	if(lanes.size()==0) return true;

	for(unsigned int i=0; i&lt; lanes.size(); i++)
	{
		if(lanes.at(i) == pL-&gt;id)
			return true;
	}

	return false;
}

WayPoint* PlanningHelpers::CheckLaneExits(const vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL)
{
	if(nodes.size()==0) return 0;

	for(unsigned int i=0; i&lt; nodes.size(); i++)
	{
		if(nodes.at(i)-&gt;pLane == pL)
			return nodes.at(i);
	}

	return 0;
}

WayPoint* PlanningHelpers::CheckNodeExits(const vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL)
{
	if(nodes.size()==0) return 0;

	for(unsigned int i=0; i&lt; nodes.size(); i++)
	{
		if(nodes.at(i)-&gt;id == pL-&gt;id)
			return nodes.at(i);
	}

	return 0;
}

WayPoint* PlanningHelpers::CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
		WayPoint* pBack)
{
	if(!pLane) return 0;
	if(pLane-&gt;points.size()==0) return 0;

	WayPoint* c = new WayPoint;
	c-&gt;pLane 		= pLane;
	c-&gt;pos 			= pLane-&gt;points.at(0).pos;
	c-&gt;v			= pLane-&gt;speed;
	c-&gt;laneId  		= pLane-&gt;id;
	c-&gt;pLeft 		= pLeft;
	if(pLeft)
		c-&gt;cost		= pLeft-&gt;cost;

	c-&gt;pRight		= pRight;
	if(pRight)
		c-&gt;cost = pRight-&gt;cost;

	if(pBack)
	{
		pBack-&gt;pFronts.push_back(c);
		c-&gt;pBacks.push_back(pBack);
		c-&gt;cost = pBack-&gt;cost + distance2points(c-&gt;pos, pBack-&gt;pos);

		for(unsigned int i=0; i&lt; c-&gt;pBacks.size(); i++)
		{
				if(c-&gt;pBacks.at(i)-&gt;cost &lt; c-&gt;cost)
					c-&gt;cost = c-&gt;pBacks.at(i)-&gt;cost;
		}
	}
	return c;
}

double PlanningHelpers::GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
		const double&amp; minDistance , const double&amp; prevCost, vector&lt;WayPoint&gt;&amp; points)
{
	if(l == NULL || minDistance&lt;=0) return 0;

	int index = 0;
	WayPoint  p1, p2;
	WayPoint idx;

	p2 = p1 = l-&gt;points.at(index);
	p1.pLane = l;
	p1.cost = prevCost;
	p2.cost = p1.cost + distance2points(p1.pos, p2.pos);

	points.push_back(p1);

	for(unsigned int i=index+1; i&lt;l-&gt;points.size(); i++)
	{

		p2 = l-&gt;points.at(i);
		p2.pLane = l;
		p2.cost = p1.cost + distance2points(p1.pos, p2.pos);
		points.push_back(p2);

		if(p2.cost &gt;= minDistance)
				break;
		p1 = p2;
	}
	return p2.cost;
}

WayPoint* PlanningHelpers::GetMinCostCell(const vector&lt;WayPoint*&gt;&amp; cells, const vector&lt;int&gt;&amp; globalPathIds)
{
	if(cells.size() == 1)
	{
//		for(unsigned int j = 0; j &lt; cells.at(0)-&gt;actionCost.size(); j++)
//			cout &lt;&lt; &quot;Cost (&quot; &lt;&lt; cells.at(0)-&gt;laneId &lt;&lt; &quot;) of going : &quot; &lt;&lt; cells.at(0)-&gt;actionCost.at(j).first &lt;&lt; &quot;, is : &quot; &lt;&lt; cells.at(0)-&gt;actionCost.at(j).second &lt;&lt; endl;
		return cells.at(0);
	}

	WayPoint* pC = cells.at(0); //cost is distance
	for(unsigned int i=1; i &lt; cells.size(); i++)
	{
		bool bFound = false;
		if(globalPathIds.size()==0)
			bFound = true;

		int iLaneID = cells.at(i)-&gt;id;
		for(unsigned int j=0; j &lt; globalPathIds.size(); j++)
		{
			if(globalPathIds.at(j) == iLaneID)
			{
				bFound = true;
				break;
			}
		}

//		for(unsigned int j = 0; j &lt; cells.at(0)-&gt;actionCost.size(); j++)
//			cout &lt;&lt; &quot;Cost (&quot;&lt;&lt; i &lt;&lt;&quot;) of going : &quot; &lt;&lt; cells.at(0)-&gt;actionCost.at(j).first &lt;&lt; &quot;, is : &quot; &lt;&lt; cells.at(0)-&gt;actionCost.at(j).second &lt;&lt; endl;


		if(cells.at(i)-&gt;cost &lt; pC-&gt;cost &amp;&amp; bFound == true)
			pC = cells.at(i);
	}


	return pC;
}

void PlanningHelpers::ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths)
{
	allPaths.clear();
	std::vector&lt;WayPoint&gt; path;
	path.push_back(singlePath.at(0));
	double skip_distance = 8;
	double d = 0;
	bool bStartSkip = false;
	for(unsigned int i= 1; i &lt; singlePath.size(); i++)
	{
		if(singlePath.at(i).bDir != FORWARD_DIR &amp;&amp; singlePath.at(i).pLane &amp;&amp; singlePath.at(i).pFronts.size() &gt; 0)
		{

			bStartSkip = true;
			WayPoint start_point = singlePath.at(i-1);

			cout &lt;&lt; &quot;Current Velocity = &quot; &lt;&lt; start_point.v &lt;&lt; endl;

			RelativeInfo start_info;
			PlanningHelpers::GetRelativeInfo(start_point.pLane-&gt;points, start_point, start_info);
			vector&lt;WayPoint*&gt; local_cell_to_delete;
			PlannerHNS::WayPoint* pStart = &amp;start_point.pLane-&gt;points.at(start_info.iFront);
			WayPoint* pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, local_cell_to_delete);
			if(pLaneCell)
			{
				vector&lt;WayPoint&gt; straight_path;
				vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
				vector&lt;int&gt; globalPathIds;
				PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPathIds, straight_path, tempCurrentForwardPathss);
				if(straight_path.size() &gt; 2)
				{
					straight_path.insert(straight_path.begin(), path.begin(), path.end());
					for(unsigned int ic = 0; ic &lt; straight_path.size(); ic++)
						straight_path.at(ic).laneChangeCost = 1;
					allPaths.push_back(straight_path);
				}
			}
		}

		if(bStartSkip)
		{
			d += hypot(singlePath.at(i).pos.y - singlePath.at(i-1).pos.y, singlePath.at(i).pos.x - singlePath.at(i-1).pos.x);
			if(d &gt; skip_distance)
			{
				d = 0;
				bStartSkip = false;
			}
		}

		if(!bStartSkip)
			path.push_back(singlePath.at(i));
	}

	allPaths.push_back(path);
}

void PlanningHelpers::TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP,const vector&lt;int&gt;&amp; globalPathIds,
		vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths)
{
	if(pHead != NULL &amp;&amp; pHead != pStartWP)
	{
		if(pHead-&gt;pBacks.size()&gt;0)
		{
			localPaths.push_back(localPath);
			TraversePathTreeBackwards(GetMinCostCell(pHead-&gt;pBacks, globalPathIds),pStartWP, globalPathIds, localPath, localPaths);
			pHead-&gt;bDir = FORWARD_DIR;
			localPath.push_back(*pHead);
		}
		else if(pHead-&gt;pLeft &amp;&amp; pHead-&gt;cost &gt; 0)
		{
			//vector&lt;Vector2D&gt; forward_path;
			//TravesePathTreeForwards(pHead-&gt;pLeft, forward_path, FORWARD_RIGHT);
			//localPaths.push_back(forward_path);
			cout &lt;&lt; &quot;Global Lane Change  Right &quot; &lt;&lt; endl;
			TraversePathTreeBackwards(pHead-&gt;pLeft,pStartWP, globalPathIds, localPath, localPaths);
			pHead-&gt;bDir = FORWARD_RIGHT_DIR;
			localPath.push_back(*pHead);
		}
		else if(pHead-&gt;pRight &amp;&amp; pHead-&gt;cost &gt; 0)
		{
			//vector&lt;Vector2D&gt; forward_path;
			//TravesePathTreeForwards(pHead-&gt;pRight, forward_path, FORWARD_LEFT);
			//localPaths.push_back(forward_path);

			cout &lt;&lt; &quot;Global Lane Change  Left &quot; &lt;&lt; endl;
			TraversePathTreeBackwards(pHead-&gt;pRight,pStartWP, globalPathIds, localPath, localPaths);
			pHead-&gt;bDir = FORWARD_LEFT_DIR;
			localPath.push_back(*pHead);
		}
//		else
//			cout &lt;&lt; &quot;Err: PlannerZ -&gt; NULL Back Pointer &quot; &lt;&lt; pHead;
	}
	else
		assert(pHead);
}

ACTION_TYPE PlanningHelpers::GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP)
{
	ACTION_TYPE t = FORWARD_ACTION;

//	//first Get the average of the next 3 waypoint directions
//	double angle = 0;
//	if(nextWP.pLane-&gt;id == 487)
//		angle = 11;
//
//	int counter = 0;
//	angle = 0;
//
//	for(unsigned int i=0; i &lt; nextWP.pLane-&gt;points.size() &amp;&amp; counter &lt; 10; i++, counter++)
//	{
//		angle += nextWP.pLane-&gt;points.at(i).pos.a;
//	}
//	angle = angle / counter;
//
//	//Get Circular angle for correct subtraction
//	double circle_angle = UtilityH::GetCircularAngle(currWP.pos.a, angle);
//
//	if( currWP.pos.a - circle_angle &gt; (7.5*DEG2RAD))
//	{
//		t = RIGHT_TURN_ACTION;
//		cout &lt;&lt; &quot;Right Lane, Average Angle = &quot; &lt;&lt; angle*RAD2DEG &lt;&lt; &quot;, Circle Angle = &quot; &lt;&lt; circle_angle*RAD2DEG &lt;&lt; &quot;, currAngle = &quot; &lt;&lt; currWP.pos.a*RAD2DEG &lt;&lt; endl;
//	}
//	else if( currWP.pos.a - circle_angle &lt; (-7.5*DEG2RAD))
//	{
//		t = LEFT_TURN_ACTION;
//		cout &lt;&lt; &quot;Left Lane, Average Angle = &quot; &lt;&lt; angle*RAD2DEG &lt;&lt; &quot;, Circle Angle = &quot; &lt;&lt; circle_angle*RAD2DEG &lt;&lt; &quot;, currAngle = &quot; &lt;&lt; currWP.pos.a*RAD2DEG &lt;&lt; endl;
//	}

	return t;
}

void PlanningHelpers::CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance)
{
	vector&lt;DetectedObject&gt; res_list;
	for(unsigned int i = 0; i &lt; obj_list.size(); i++)
	{
		GPSPoint center = obj_list.at(i).center.pos;
		double distance = distance2points(center, currPose.pos);

		if(distance &lt; filterDistance)
		{
			DetectedObject obj = obj_list.at(i);

			Mat3 rotationMat(center.a);
			Mat3 translationMat(center.x, center.y);
			double w2 = obj.w/2.0;
			double h2 = obj.l/2.0;
			double z = center.z + obj.h/2.0;

			GPSPoint left_bottom(-w2, -h2, z,0);
			GPSPoint right_bottom(w2,-h2, z,0);
			GPSPoint right_top(w2,h2, z,0);
			GPSPoint left_top(-w2,h2, z,0);

			left_bottom 	= rotationMat * left_bottom;
			right_bottom 	= rotationMat * right_bottom;
			right_top 		= rotationMat * right_top;
			left_top 		= rotationMat * left_top;

			left_bottom 	= translationMat * left_bottom;
			right_bottom 	= translationMat * right_bottom;
			right_top 		= translationMat * right_top;
			left_top 		= translationMat * left_top;

			obj.contour.clear();
			obj.contour.push_back(left_bottom);
			obj.contour.push_back(right_bottom);
			obj.contour.push_back(right_top);
			obj.contour.push_back(left_top);

			res_list.push_back(obj);
		}
	}

	obj_list = res_list;
}

double PlanningHelpers::GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance)
{
	int iStart = GetClosestNextPointIndex(path, pose);

	double d = 0;
	double min_v = 99999;
	for(unsigned int i=iStart; i&lt; path.size(); i++)
	{
		d  += distance2points(path.at(i).pos, pose.pos);

		if(path.at(i).v &lt; min_v)
			min_v = path.at(i).v;

		if(d &gt;= distance)
			return min_v;
	}
	return 0;
}

void PlanningHelpers::WritePathToFile(const string&amp; fileName, const vector&lt;WayPoint&gt;&amp; path)
{
	DataRW  dataFile;
	ostringstream str_header;
	str_header &lt;&lt; &quot;laneID&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;wpID&quot;  &lt;&lt; &quot;,&quot; &quot;x&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;y&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;a&quot;&lt;&lt;&quot;,&quot;&lt;&lt; &quot;cost&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;Speed&quot; &lt;&lt; &quot;,&quot; ;
	vector&lt;string&gt; dataList;
	 for(unsigned int i=0; i&lt;path.size(); i++)
	 {
		 ostringstream strwp;
		 strwp &lt;&lt; path.at(i).laneId &lt;&lt; &quot;,&quot; &lt;&lt; path.at(i).id &lt;&lt;&quot;,&quot;&lt;&lt;path.at(i).pos.x&lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).pos.y
				 &lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).pos.a &lt;&lt; &quot;,&quot; &lt;&lt; path.at(i).cost &lt;&lt; &quot;,&quot; &lt;&lt; path.at(i).v &lt;&lt; &quot;,&quot;;
		 dataList.push_back(strwp.str());
	 }

	 dataFile.WriteLogData(&quot;&quot;, fileName, str_header.str(), dataList);
}

void PlanningHelpers::TestQuadraticSpline (const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path)
{

//  int N = center_line.size();
//  int i;
//	int ibcbeg;
//	int ibcend;
//	int j;
//	int jhi;
//	int k;
//	double t[N];
//	double tval;
//	double y[N];
//	double ybcbeg;
//	double ybcend;
//	double *ypp;
//	double yppval;
//	double ypval;
//	double yval;
//
//  cout &lt;&lt; &quot;\n&quot;;
//  cout &lt;&lt; &quot;TEST24\n&quot;;
//  cout &lt;&lt; &quot;  SPLINE_QUADRATIC_VAL evaluates a\n&quot;;
//  cout &lt;&lt; &quot;    quadratic spline.\n&quot;;
//  cout &lt;&lt; &quot;\n&quot;;
//  cout &lt;&lt; &quot;  Runge''s function, evenly spaced knots.\n&quot;;
//
//  for ( i = 0; i &lt; N; i++ )
//  {
//    t[i] =  center_line.at(i).pos.x;
//    y[i] =  center_line.at(i).pos.y;
//  }
//
//  //
//  //  Try various boundary conditions.
//  //
//    for ( k = 0; k &lt;= 4; k++ )
//    {
//      if ( k == 0 )
//      {
//        ibcbeg = 0;
//        ybcbeg = 0.0;
//
//        ibcend = 0;
//        ybcend = 0.0;
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Boundary condition 0 at both ends:\n&quot;;
//        cout &lt;&lt; &quot;  Spline is quadratic in boundary intervals.\n&quot;;
//      }
//      else if ( k == 1 )
//      {
//        ibcbeg = 1;
//        ybcbeg = t[0];
//
//        ibcend = 1;
//        ybcend = t[N-1] ;
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Boundary condition 1 at both ends:\n&quot;;
//        cout &lt;&lt; &quot;  Y'(left) =  &quot; &lt;&lt; ybcbeg &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Y'(right) = &quot; &lt;&lt; ybcend &lt;&lt; &quot;\n&quot;;
//
//      }
//      else if ( k == 2 )
//      {
//        ibcbeg = 2;
//        ybcbeg = fpprunge ( t[0] );
//
//        ibcend = 2;
//        ybcend = fpprunge ( t[N-1] );
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Boundary condition 2 at both ends:\n&quot;;
//        cout &lt;&lt; &quot;  YP''(left) =  &quot; &lt;&lt; ybcbeg &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  YP''(right) = &quot; &lt;&lt; ybcend &lt;&lt; &quot;\n&quot;;
//      }
//      else if ( k == 3 )
//      {
//        ibcbeg = 2;
//        ybcbeg = 0.0;
//
//        ibcend = 2;
//        ybcend = 0.0;
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Natural spline:\n&quot;;
//        cout &lt;&lt; &quot;  YP''(left) =  &quot; &lt;&lt; ybcbeg &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  YP''(right) = &quot; &lt;&lt; ybcend &lt;&lt; &quot;\n&quot;;
//      }
//      else if ( k == 4 )
//      {
//        ibcbeg = 3;
//        ibcend = 3;
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  \&quot;Not-a-knot\&quot; spline:\n&quot;;
//      }
//
//      ypp = spline_cubic_set ( N, t, y, ibcbeg, ybcbeg, ibcend, ybcend );
//
//      cout &lt;&lt; &quot;\n&quot;;
//      cout &lt;&lt; &quot;  SPLINE''(T), F''(T):\n&quot;;
//      cout &lt;&lt; &quot;\n&quot;;
//      for ( i = 0; i &lt; N; i++ )
//      {
//        cout &lt;&lt; ypp[i] &lt;&lt; &quot;  &quot;
//             &lt;&lt; fpprunge ( t[i] ) &lt;&lt; &quot;\n&quot;;
//      }
//
//      cout &lt;&lt; &quot;\n&quot;;
//      cout &lt;&lt; &quot;  T, SPLINE(T), F(T)\n&quot;;
//      cout &lt;&lt; &quot;\n&quot;;
//
//      for ( i = 0; i &lt;= N; i++ )
//      {
//        if ( i == 0 )
//        {
//          jhi = 1;
//        }
//        else if ( i &lt; N )
//        {
//          jhi = 2;
//        }
//        else
//        {
//          jhi = 2;
//        }
//
//        for ( j = 1; j &lt;= jhi; j++ )
//        {
//          if ( i == 0 )
//          {
//            tval = t[0] - 1.0;
//          }
//          else if ( i &lt; N )
//          {
//            tval = (
//                ( double ) ( jhi - j + 1 ) * t[i-1]
//              + ( double ) (       j - 1 ) * t[i] )
//              / ( double ) ( jhi         );
//          }
//          else
//          {
//            if ( j == 1 )
//            {
//              tval = t[N-1];
//            }
//            else
//            {
//              tval = t[N-1] + 1.0;
//            }
//          }
//
//          yval = spline_cubic_val ( N, t, y, ypp, tval, &amp;ypval, &amp;yppval );
//
//          cout &lt;&lt; tval &lt;&lt; &quot;  &quot;
//               &lt;&lt; yval &lt;&lt; &quot;  &quot;
//               &lt;&lt; frunge ( tval ) &lt;&lt; &quot;\n&quot;;
//        }
//      }
//      delete [] ypp;
//    }
//
//    return;
}

double PlanningHelpers::frunge ( double x )
{
  double fx;

  fx = 1.0 / ( 1.0 + 25.0 * x * x );

  return fx;
}

double PlanningHelpers::fprunge ( double x )
{
  double bot;
  double fx;

  bot = 1.0 + 25.0 * x * x;
  fx = -50.0 * x / ( bot * bot );

  return fx;
}

double PlanningHelpers::fpprunge ( double x )
{
  double bot;
  double fx;

  bot = 1.0 + 25.0 * x * x;
  fx = ( -50.0 + 3750.0 * x * x ) / ( bot * bot * bot );

  return fx;
}


} /* namespace PlannerHNS */
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="7417a0d4bdbe3a784e01c418cb3caa23139fca04" fix_time="712,5981">
		<msg>Fixed zero division in scan2image</msg>
		<modified_files>
			<file old_path="ros/src/sensing/fusion/packages/scan2image/nodes/scan2image/scan2image.cpp" new_path="ros/src/sensing/fusion/packages/scan2image/nodes/scan2image/scan2image.cpp">
				<diff>@@ -56,7 +56,7 @@ void trans_depth_points_to_image_points(Scan_points_dataset* scan_points_dataset
                     + cameraExtrinsicMat.at&lt;double&gt;(2,1) * scan_points_dataset-&gt;scan_points.y.at(i)*1000
                     + cameraExtrinsicMat.at&lt;double&gt;(2,2) * scan_points_dataset-&gt;scan_points.z.at(i)*1000)
             + (cameraExtrinsicMat.at&lt;double&gt;(2,3));
-        if (camera_z &gt;= 0.0) {
+        if (camera_z &gt; 0.0) {
             /*
              * Projection transformation. Change from camera coordinate to image coordinate
              */
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;opencv/cv.h&gt;
#include &lt;opencv/cxcore.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &lt;time.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;sys/resource.h&gt;
#include &lt;sensor_msgs/LaserScan.h&gt;
#include &lt;algorithm&gt;
#include &quot;scan2image.h&quot;

#include &quot;autoware_msgs/ScanImage.h&quot;
#include &quot;autoware_msgs/projection_matrix.h&quot;
#include &lt;sensor_msgs/CameraInfo.h&gt;

#if 1 // AXE
#define XSTR(x) #x
#define STR(x) XSTR(x)
#endif

static cv::Mat cameraExtrinsicMat;
static cv::Mat cameraMat;
static cv::Mat distCoeff;
static cv::Size imageSize;

ros::Publisher transformed_point_data;
static bool isProjection;
static bool isIntrinsic;
Scan_image scan_image;

void trans_depth_points_to_image_points(Scan_points_dataset* scan_points_dataset, Image_points_dataset* image_points_dataset)
{
    float camera_x;
    float camera_y;
    float camera_z;
    int i;

    for(i = 0; i &lt; (int)scan_points_dataset-&gt;scan_points.x.size(); i++) {

        /*
         * Coordinate transformation. Change from laser range finder coordinate to camera coordinate
         */
        camera_x = (cameraExtrinsicMat.at&lt;double&gt;(0,0) * scan_points_dataset-&gt;scan_points.x.at(i)*1000
                    + cameraExtrinsicMat.at&lt;double&gt;(0,1) * scan_points_dataset-&gt;scan_points.y.at(i)*1000
                    + cameraExtrinsicMat.at&lt;double&gt;(0,2) * scan_points_dataset-&gt;scan_points.z.at(i)*1000)
            + (cameraExtrinsicMat.at&lt;double&gt;(0,3));
        camera_y = (cameraExtrinsicMat.at&lt;double&gt;(1,0) * scan_points_dataset-&gt;scan_points.x.at(i)*1000
                    + cameraExtrinsicMat.at&lt;double&gt;(1,1) * scan_points_dataset-&gt;scan_points.y.at(i)*1000
                    + cameraExtrinsicMat.at&lt;double&gt;(1,2) * scan_points_dataset-&gt;scan_points.z.at(i)*1000)
            + (cameraExtrinsicMat.at&lt;double&gt;(1,3));
        camera_z = (cameraExtrinsicMat.at&lt;double&gt;(2,0) * scan_points_dataset-&gt;scan_points.x.at(i)*1000
                    + cameraExtrinsicMat.at&lt;double&gt;(2,1) * scan_points_dataset-&gt;scan_points.y.at(i)*1000
                    + cameraExtrinsicMat.at&lt;double&gt;(2,2) * scan_points_dataset-&gt;scan_points.z.at(i)*1000)
            + (cameraExtrinsicMat.at&lt;double&gt;(2,3));
        if (camera_z &gt;= 0.0) {
            /*
             * Projection transformation. Change from camera coordinate to image coordinate
             */
            image_points_dataset-&gt;image_points.x.push_back((camera_x * cameraMat.at&lt;double&gt;(0,0) / camera_z) + cameraMat.at&lt;double&gt;(0,2));
            image_points_dataset-&gt;image_points.y.push_back((camera_y * cameraMat.at&lt;double&gt;(1,1) / camera_z) + cameraMat.at&lt;double&gt;(1,2));
            /*
             * Calculate euclidean distance from the camera to objects
             */
            image_points_dataset-&gt;distance.push_back(sqrt(camera_x * camera_x + camera_y * camera_y + camera_z * camera_z) * 100); //unit of length is centimeter

            /*
             * Copy to intensity
             */
            if(!(scan_points_dataset-&gt;intensity.empty())){
                image_points_dataset-&gt;intensity.push_back(scan_points_dataset-&gt;intensity.at(i));
            }
        }
    }
}

static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
{
    printf(&quot;projection\n&quot;);

	cameraExtrinsicMat = cv::Mat(4,4,CV_64F);
	for (int row=0; row&lt;4; row++) {
		for (int col=0; col&lt;4; col++) {
			cameraExtrinsicMat.at&lt;double&gt;(row, col) = msg.projection_matrix[row * 4 + col];
            printf(&quot;%f\t&quot;, cameraExtrinsicMat.at&lt;double&gt;(row, col));
		}
        printf(&quot;\n&quot;);
	}
    isProjection = true;
}

static void intrinsic_callback(const sensor_msgs::CameraInfo&amp; msg)
{
    printf(&quot;intrinsic\n&quot;);

    if (!isIntrinsic || imageSize.height != msg.height || imageSize.width != msg.width) {
        if (isIntrinsic) {
            free(scan_image.distance);
            free(scan_image.intensity);
        }
        scan_image.distance = (float *)calloc(msg.height * msg.width, sizeof(float));
        scan_image.intensity = (float *)calloc(msg.height * msg.width, sizeof(float));
        scan_image.max_y = NO_DATA;
        scan_image.min_y = NO_DATA;

    }

	imageSize.height = msg.height;
	imageSize.width = msg.width;

	cameraMat = cv::Mat(3,3, CV_64F);
	for (int row=0; row&lt;3; row++) {
		for (int col=0; col&lt;3; col++) {
			cameraMat.at&lt;double&gt;(row, col) = msg.K[row * 3 + col];
            printf(&quot;%f\t&quot;, cameraMat.at&lt;double&gt;(row, col));
		}
        printf(&quot;\n&quot;);
	}

	distCoeff = cv::Mat(1,5,CV_64F);
	for (int col=0; col&lt;5; col++) {
		distCoeff.at&lt;double&gt;(col) = msg.D[col];
	}
    isIntrinsic = true;
}

void scanCallback(const sensor_msgs::LaserScan::ConstPtr&amp; msg)
{
    if (!(isIntrinsic &amp;&amp; isProjection)){
        return;
    }

    static Scan_points_dataset scan_points_dataset;
    static Image_points_dataset image_points_dataset;
    int i;

//    ROS_INFO(&quot;angle_min[%f]\nangle_max:[%f]\nangle_increment:[%f]\ntime_increment:[%f]\nscan_time:[%f]\nrange_min:[%f]\nrange_max:[%f]\n&quot;, msg-&gt;angle_min * 180 / 3.141592, msg-&gt;angle_max * 180 / 3.141592, msg-&gt;angle_increment * 180 / 3.141592, msg-&gt;time_increment, msg-&gt;scan_time, msg-&gt;range_min, msg-&gt;range_max);

    /*
     * Initialize
     */
    scan_points_dataset.scan_points.x.resize(msg-&gt;ranges.size());
    scan_points_dataset.scan_points.y.resize(msg-&gt;ranges.size());
    scan_points_dataset.scan_points.z.resize(msg-&gt;ranges.size());
    scan_points_dataset.intensity.resize(msg-&gt;intensities.size());
    image_points_dataset.image_points.x.clear();
    image_points_dataset.image_points.y.clear();
    image_points_dataset.distance.clear();
    image_points_dataset.intensity.clear();

    /*
     * Change to three dimentional coordinate. And copy intensity
     */
    for(i = 0; i &lt; (int)msg-&gt;ranges.size(); i++) {
        scan_points_dataset.scan_points.x.at(i) = msg-&gt;ranges.at(i) * sin(msg-&gt;angle_min + msg-&gt;angle_increment * i); //unit of length is meter
        scan_points_dataset.scan_points.y.at(i) = 0; //unit of length is meter
        scan_points_dataset.scan_points.z.at(i) = msg-&gt;ranges.at(i) * cos(msg-&gt;angle_min + msg-&gt;angle_increment * i); //unit of length is meter
        if(!(msg-&gt;intensities.empty())){
            scan_points_dataset.intensity.at(i) = msg-&gt;intensities.at(i);
        }
    }

    /*
     * Change from laser range finder coordinate to image coordinate
     */
    trans_depth_points_to_image_points(&amp;scan_points_dataset, &amp;image_points_dataset);

    /*
     * Judge out of image frame. And Determine max_y and min_y
     */
    for (i = 0; i &lt; (int)image_points_dataset.image_points.x.size(); i++) {
        /* Judge NaN */
        if(isnan(image_points_dataset.image_points.x.at(i)) == 1 || isnan(image_points_dataset.image_points.y.at(i)) == 1) {
            std::cout &lt;&lt;&quot;Not a Number is i:&quot; &lt;&lt; i &lt;&lt; std::endl;
            continue;
        }
        /* Judge out of X-axis image */
        if(0 &gt; (int)image_points_dataset.image_points.x.at(i) || (int)image_points_dataset.image_points.x.at(i) &gt; imageSize.width - 1) {
            continue;
        }
        /* Judge out of Y-axis image */
        if(0 &gt; (int)image_points_dataset.image_points.y.at(i) || (int)image_points_dataset.image_points.y.at(i) &gt; imageSize.height - 1) {
            continue;
        }

        scan_image.distance[(int)image_points_dataset.image_points.x.at(i) * imageSize.height + (int)image_points_dataset.image_points.y.at(i)] = image_points_dataset.distance.at(i);

        if(!msg-&gt;intensities.empty()){
            scan_image.intensity[(int)image_points_dataset.image_points.x.at(i) * imageSize.height + (int)image_points_dataset.image_points.y.at(i)] = image_points_dataset.intensity.at(i);
        }

        if ((scan_image.max_y &lt; (int)image_points_dataset.image_points.y.at(i)) || (scan_image.max_y == NO_DATA)) {
            scan_image.max_y = (int)image_points_dataset.image_points.y.at(i);
        } else if ((scan_image.min_y &gt; (int)image_points_dataset.image_points.y.at(i)) || (scan_image.min_y == NO_DATA)) {
            scan_image.min_y = (int)image_points_dataset.image_points.y.at(i);
        }
    }

    /*
     * Create message(Topic)
     */
    autoware_msgs::ScanImage scan_image_msg;
    scan_image_msg.header = msg-&gt;header;
    scan_image_msg.distance.assign(scan_image.distance, scan_image.distance + imageSize.width * imageSize.height);
    scan_image_msg.intensity.assign(scan_image.intensity, scan_image.intensity + imageSize.width * imageSize.height);
    scan_image_msg.max_y = scan_image.max_y;
    scan_image_msg.min_y = scan_image.min_y;

    /*
     * Publish message(Topic)
     */
    transformed_point_data.publish(scan_image_msg);

    /*
     * Init zero
     */
    std::fill_n(scan_image.distance, imageSize.width * imageSize.height,0);
    std::fill_n(scan_image.intensity, imageSize.width * imageSize.height,0);
    scan_image.max_y = NO_DATA;
    scan_image.min_y = NO_DATA;
}

int main(int argc, char **argv)
{
    isProjection = false;
    isIntrinsic = false;
    ros::init(argc, argv, &quot;scan2image&quot;);
    ros::NodeHandle n;
    ros::Subscriber sub = n.subscribe(&quot;scan&quot;, 1, scanCallback);
    ros::Subscriber projection_sub = n.subscribe(&quot;projection_matrix&quot;, 1, projection_callback);
    ros::Subscriber intrinsic_sub = n.subscribe(&quot;camera/camera_info&quot;, 1, intrinsic_callback);
    transformed_point_data = n.advertise&lt;autoware_msgs::ScanImage&gt;(&quot;scan_image&quot;, 1);

    ros::spin();

    free(scan_image.distance);
    free(scan_image.intensity);
    return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="e624c0f31800e99b1bbbde20f5ede2be7bdcd142" fix_time="222,57319">
		<msg>fix segv</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/velocity_set/libvelocity_set.cpp" new_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/velocity_set/libvelocity_set.cpp">
				<diff>@@ -263,7 +263,7 @@ int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_m
   initDetectionCrossWalkIDs();  // for multiple
 
   // Find near cross walk
-  for (int num = closest_waypoint; num &lt; closest_waypoint + search_distance; num++)
+  for (int num = closest_waypoint; num &lt; closest_waypoint + search_distance &amp;&amp; num &lt; (int)lane.waypoints.size(); num++)
   {
     geometry_msgs::Point waypoint = lane.waypoints[num].pose.pose.position;
     waypoint.z = 0.0;  // ignore Z axis
</diff>
				<old_file>#include &quot;libvelocity_set.h&quot;

// extract edge points from zebra zone
std::vector&lt;geometry_msgs::Point&gt; removeNeedlessPoints(std::vector&lt;geometry_msgs::Point&gt; &amp;area_points)
{
  area_points.push_back(area_points.front());
  std::map&lt;double, int&gt; length_index;
  for (unsigned int i = 0; i &lt; area_points.size() - 1; i++)
    length_index[calcSquareOfLength(area_points[i], area_points[i + 1])] = i;

  std::vector&lt;geometry_msgs::Point&gt; new_points;
  auto it = length_index.end();
  int first = (--it)-&gt;second;
  int second = (--it)-&gt;second;
  new_points.push_back(area_points[first]);
  new_points.push_back(area_points[first + 1]);
  new_points.push_back(area_points[second]);
  new_points.push_back(area_points[second + 1]);

  return new_points;
}

void CrossWalk::crossWalkCallback(const vector_map::CrossWalkArray &amp;msg)
{
  crosswalk_ = msg;

  loaded_crosswalk = true;
  if (loaded_crosswalk &amp;&amp; loaded_area &amp;&amp; loaded_line &amp;&amp; loaded_point)
  {
    loaded_all = true;
    ROS_INFO(&quot;All VectorMap loaded&quot;);
  }
}

void CrossWalk::areaCallback(const vector_map::AreaArray &amp;msg)
{
  area_ = msg;

  loaded_area = true;
  if (loaded_crosswalk &amp;&amp; loaded_area &amp;&amp; loaded_line &amp;&amp; loaded_point)
  {
    loaded_all = true;
    ROS_INFO(&quot;All VectorMap loaded&quot;);
  }
}

void CrossWalk::lineCallback(const vector_map::LineArray &amp;msg)
{
  line_ = msg;

  loaded_line = true;
  if (loaded_crosswalk &amp;&amp; loaded_area &amp;&amp; loaded_line &amp;&amp; loaded_point)
  {
    loaded_all = true;
    ROS_INFO(&quot;All VectorMap loaded&quot;);
  }
}

void CrossWalk::pointCallback(const vector_map::PointArray &amp;msg)
{
  point_ = msg;

  loaded_point = true;
  if (loaded_crosswalk &amp;&amp; loaded_area &amp;&amp; loaded_line &amp;&amp; loaded_point)
  {
    loaded_all = true;
    ROS_INFO(&quot;All VectorMap loaded&quot;);
  }
}

geometry_msgs::Point CrossWalk::getPoint(const int &amp;pid) const
{
  geometry_msgs::Point point;
  for (const auto &amp;p : point_.data)
  {
    if (p.pid == pid)
    {
      point.x = p.ly;
      point.y = p.bx;
      point.z = p.h;
      return point;
    }
  }

  ROS_ERROR(&quot;can't find a point of pid %d&quot;, pid);
  return point;
}

geometry_msgs::Point CrossWalk::calcCenterofGravity(const int &amp;aid) const
{
  int search_lid = -1;
  for (const auto &amp;area : area_.data)
    if (area.aid == aid)
    {
      search_lid = area.slid;
      break;
    }

  std::vector&lt;geometry_msgs::Point&gt; area_points;
  while (search_lid)
  {
    for (const auto &amp;line : line_.data)
    {
      if (line.lid == search_lid)
      {
        area_points.push_back(getPoint(line.bpid));
        search_lid = line.flid;
      }
    }
  }

  geometry_msgs::Point point;
  point.x = 0.0;
  point.y = 0.0;
  point.z = 0.0;
  if (area_points.size() &gt; 4)
  {
    std::vector&lt;geometry_msgs::Point&gt; filterd_points = removeNeedlessPoints(area_points);
    for (const auto &amp;p : filterd_points)
    {
      point.x += p.x;
      point.y += p.y;
      point.z += p.z;
    }
  }
  else
  {
    for (const auto &amp;p : area_points)
    {
      point.x += p.x;
      point.y += p.y;
      point.z += p.z;
    }
  }

  point.x /= 4;
  point.y /= 4;
  point.z /= 4;
  return point;
}

double CrossWalk::calcCrossWalkWidth(const int &amp;aid) const
{
  int search_lid = -1;
  for (const auto &amp;area : area_.data)
    if (area.aid == aid)
    {
      search_lid = area.slid;
      break;
    }

  std::vector&lt;geometry_msgs::Point&gt; area_points;
  while (search_lid)
  {
    for (const auto &amp;line : line_.data)
    {
      if (line.lid == search_lid)
      {
        area_points.push_back(getPoint(line.bpid));
        //_points.push_back(area_points.back());///
        search_lid = line.flid;
      }
    }
  }

  area_points.push_back(area_points.front());
  double max_length = calcSquareOfLength(area_points[0], area_points[1]);
  for (unsigned int i = 1; i &lt; area_points.size() - 1; i++)
  {
    if (calcSquareOfLength(area_points[i], area_points[i + 1]) &gt; max_length)
      max_length = calcSquareOfLength(area_points[i], area_points[i + 1]);
  }

  return sqrt(max_length);
}

// count the number of crosswalks
int CrossWalk::countAreaSize() const
{
  int count = 0;
  for (const auto &amp;x : crosswalk_.data)
    if (x.type == 0)  // type:0 -&gt; outer frame of crosswalks
      count++;

  return count;
}

void CrossWalk::getAID(std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; &amp;bdid2aid_map) const
{
  for (const auto &amp;x : crosswalk_.data)
    if (x.type == 1)
    {                                         // if it is zebra
      bdid2aid_map[x.bdid].push_back(x.aid);  // save area id
    }
}

void CrossWalk::calcDetectionArea(const std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; &amp;bdid2aid_map)
{
  for (const auto &amp;crosswalk_aids : bdid2aid_map)
  {
    int bdid = crosswalk_aids.first;
    double width = 0.0;
    for (const auto &amp;aid : crosswalk_aids.second)
    {
      detection_points_[bdid].points.push_back(calcCenterofGravity(aid));
      width += calcCrossWalkWidth(aid);
    }
    width /= crosswalk_aids.second.size();
    detection_points_[bdid].width = width;
  }
}

void CrossWalk::calcCenterPoints()
{
  for (const auto &amp;i : bdID_)
  {
    geometry_msgs::Point center;
    center.x = 0.0;
    center.y = 0.0;
    center.z = 0.0;
    for (const auto &amp;p : detection_points_[i].points)
    {
      center.x += p.x;
      center.y += p.y;
      center.z += p.z;
    }
    center.x /= detection_points_[i].points.size();
    center.y /= detection_points_[i].points.size();
    center.z /= detection_points_[i].points.size();
    detection_points_[i].center = center;
  }
}

void CrossWalk::setCrossWalkPoints()
{
  // bdid2aid_map[BDID] has AIDs of its zebra zone
  std::unordered_map&lt;int, std::vector&lt;int&gt;&gt; bdid2aid_map;
  getAID(bdid2aid_map);

  // Save key values
  for (const auto &amp;bdid2aid : bdid2aid_map)
    bdID_.push_back(bdid2aid.first);

  calcDetectionArea(bdid2aid_map);
  calcCenterPoints();

  ROS_INFO(&quot;Set cross walk detection points&quot;);
  set_points = true;
}

int CrossWalk::findClosestCrosswalk(const int closest_waypoint, const autoware_msgs::lane &amp;lane,
                                    const int search_distance)
{
  if (!set_points || closest_waypoint &lt; 0)
    return -1;

  double find_distance = 2.0 * 2.0;      // meter
  double ignore_distance = 20.0 * 20.0;  // meter
  static std::vector&lt;int&gt; bdid = getBDID();

  int _return_val = 0;

  initDetectionCrossWalkIDs();  // for multiple

  // Find near cross walk
  for (int num = closest_waypoint; num &lt; closest_waypoint + search_distance; num++)
  {
    geometry_msgs::Point waypoint = lane.waypoints[num].pose.pose.position;
    waypoint.z = 0.0;  // ignore Z axis
    for (const auto &amp;i : bdid)
    {
      // ignore far crosswalk
      geometry_msgs::Point crosswalk_center = getDetectionPoints(i).center;
      crosswalk_center.z = 0.0;
      if (calcSquareOfLength(crosswalk_center, waypoint) &gt; ignore_distance)
        continue;

      for (auto p : getDetectionPoints(i).points)
      {
        p.z = waypoint.z;
        if (calcSquareOfLength(p, waypoint) &lt; find_distance)
        {
          addDetectionCrossWalkIDs(i);
          if (!this-&gt;isMultipleDetection())
          {
            setDetectionCrossWalkID(i);
            return num;
          }
          else if (!_return_val)
          {
            setDetectionCrossWalkID(i);
            _return_val = num;
          }
        }
      }
    }
  }

  if (_return_val)
    return _return_val;

  setDetectionCrossWalkID(-1);
  return -1;  // no near crosswalk
}

geometry_msgs::Point ObstaclePoints::getObstaclePoint(const EControl &amp;kind) const
{
  geometry_msgs::Point point;

  if (kind == EControl::STOP)
  {
    for (const auto &amp;p : stop_points_)
    {
      point.x += p.x;
      point.y += p.y;
      point.z += p.z;
    }
    point.x /= stop_points_.size();
    point.y /= stop_points_.size();
    point.z /= stop_points_.size();

    return point;
  }
  else  // kind == DECELERATE
  {
    for (const auto &amp;p : decelerate_points_)
    {
      point.x += p.x;
      point.y += p.y;
      point.z += p.z;
    }
    point.x /= decelerate_points_.size();
    point.y /= decelerate_points_.size();
    point.z /= decelerate_points_.size();

    return point;
  }
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="f9ace9e138b61a9738ef60a4ea6c0b1bf2ca97bd" fix_time="0,12927">
		<msg>disabling debug massages on planner_selector</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/planner_selector/nodes/planner_selector/planner_selector_node.cpp" new_path="ros/src/computing/planning/decision/packages/planner_selector/nodes/planner_selector/planner_selector_node.cpp">
				<diff>@@ -73,9 +73,9 @@ void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
   _mutex.lock();
   if (msg.data != enableLattice_)
     enableLattice_ = msg.data;
-  std::cout &lt;&lt; &quot;[&quot; &lt;&lt; __func__ &lt;&lt; &quot;]: setEnableLattice&quot; &lt;&lt; enableLattice_ &lt;&lt; &quot; &lt;=&quot; &lt;&lt; msg.data &lt;&lt; std::endl;
   _mutex.unlock();
 #endif
+  // for debug
   //	ROS_INFO(&quot;\n***** EnableLattice = %d  **** \n&quot;,enableLattice_,msg.data);
 }
 
@@ -91,14 +91,13 @@ void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware
   if (this-&gt;enableLattice_ &amp;&amp; topic.find(&quot;dp&quot;) != std::string::npos)
   {
     Pubs[&quot;final_waypoints&quot;].publish(*waypoints);
-    std::cout &lt;&lt; &quot;ENABLE_LATTTICE&quot; &lt;&lt; enableLattice_ &lt;&lt; topic;
   }
   else if (!this-&gt;enableLattice_ &amp;&amp; topic.find(&quot;astar&quot;) != std::string::npos)
   {
-    std::cout &lt;&lt; &quot;ENABLE_ASTAR:&quot; &lt;&lt; enableLattice_ &lt;&lt; topic;
     Pubs[&quot;final_waypoints&quot;].publish(*waypoints);
   }
-  ROS_INFO(&quot;%s, %d-%d-%d&quot;, topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
+//for debug
+//ROS_INFO(&quot;%s, %d-%d-%d&quot;, topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
   _mutex.unlock();
 }
 
</diff>
				<old_file>#include &lt;autoware_msgs/lane.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Int32.h&gt;

#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;unordered_map&gt;

namespace decision_maker
{
class PlannerSelectorNode
{
private:
  ros::NodeHandle nh_;

  std::unordered_map&lt;std::string, autoware_msgs::lane&gt; waypoints_;
  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;

  std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
  int __closest_waypoint_astar;
  int __closest_waypoint_dp;

  std::mutex _mutex;

  int enableLattice_;

public:
  PlannerSelectorNode()
  {
    this-&gt;initROS();
    enableLattice_ = 0;
  }

  void initROS();

  void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
  void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
  void callbackFromLattice(const std_msgs::Int32 &amp;msg);
};

void PlannerSelectorNode::initROS()
{
  Subs[&quot;/dp/final_waypoints&quot;] =
      nh_.subscribe(&quot;/dp/final_waypoints&quot;, 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
  Subs[&quot;/astar/final_waypoints&quot;] =
      nh_.subscribe(&quot;/astar/final_waypoints&quot;, 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
  Subs[&quot;/enableLattice&quot;] = nh_.subscribe(&quot;/enableLattice&quot;, 10, &amp;PlannerSelectorNode::callbackFromLattice, this);

  Subs[&quot;/dp/closest_waypoint&quot;] =
      nh_.subscribe(&quot;/dp/closest_waypoint&quot;, 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
  Subs[&quot;/astar/closest_waypoint&quot;] =
      nh_.subscribe(&quot;/astar/closest_waypoint&quot;, 1, &amp;PlannerSelectorNode::callbackFromClosest, this);

  Pubs[&quot;final_waypoints&quot;] = nh_.advertise&lt;autoware_msgs::lane&gt;(&quot;/final_waypoints&quot;, 1);
  Pubs[&quot;closest_waypoint&quot;] = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;/closest_waypoint&quot;, 1);
}

#define LATENCY_NUM 3
void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
{
  static int prev[LATENCY_NUM] = { 1 };
#if 0
	if(enableLattice_ == 1)	{
		for(int i = 1; i&lt;LATENCY_NUM; i++)
			prev[i] = prev[i-1];
		prev[0] = msg.data;
		enableLattice_ = prev[LATENCY_NUM];
	}else{
		enableLattice_ = msg.data;
	}
#else
  _mutex.lock();
  if (msg.data != enableLattice_)
    enableLattice_ = msg.data;
  std::cout &lt;&lt; &quot;[&quot; &lt;&lt; __func__ &lt;&lt; &quot;]: setEnableLattice&quot; &lt;&lt; enableLattice_ &lt;&lt; &quot; &lt;=&quot; &lt;&lt; msg.data &lt;&lt; std::endl;
  _mutex.unlock();
#endif
  //	ROS_INFO(&quot;\n***** EnableLattice = %d  **** \n&quot;,enableLattice_,msg.data);
}

void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);
  const autoware_msgs::lane *waypoints = event.getMessage().get();

  /// ROS_INFO(&quot;%s&quot;, enableLattice_?&quot;flag = True&quot;:&quot;flag = False&quot;);

  _mutex.lock();
  if (this-&gt;enableLattice_ &amp;&amp; topic.find(&quot;dp&quot;) != std::string::npos)
  {
    Pubs[&quot;final_waypoints&quot;].publish(*waypoints);
    std::cout &lt;&lt; &quot;ENABLE_LATTTICE&quot; &lt;&lt; enableLattice_ &lt;&lt; topic;
  }
  else if (!this-&gt;enableLattice_ &amp;&amp; topic.find(&quot;astar&quot;) != std::string::npos)
  {
    std::cout &lt;&lt; &quot;ENABLE_ASTAR:&quot; &lt;&lt; enableLattice_ &lt;&lt; topic;
    Pubs[&quot;final_waypoints&quot;].publish(*waypoints);
  }
  ROS_INFO(&quot;%s, %d-%d-%d&quot;, topic.c_str(), __closest_waypoint_dp, __closest_waypoint_astar, this-&gt;enableLattice_);
  _mutex.unlock();
}

void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);

  int temp = event.getMessage().get()-&gt;data;
  std_msgs::Int32 msg;

#if 1
  if (topic.find(&quot;/dp&quot;) == 0)
  {
    closest_waypoints_[&quot;dp&quot;] = temp;

    if (closest_waypoints_[&quot;astar&quot;])
    {
      msg.data = __closest_waypoint_astar;
    }
    __closest_waypoint_dp = temp;
  }
  else if (topic.find(&quot;/astar&quot;) == 0)
  {
    closest_waypoints_[&quot;astar&quot;] = temp;
    __closest_waypoint_astar = temp;
  }
  msg.data = __closest_waypoint_astar;
#endif
  Pubs[&quot;closest_waypoint&quot;].publish(msg);
}
}
int main(int argc, char **argv)
{
  ros::init(argc, argv, &quot;planner_selector&quot;);

  decision_maker::PlannerSelectorNode _psn;
  ros::spin();
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="28ce05e727d1205f93c7596c24ab5fadde3c6b2b" fix_time="0,6125">
		<msg>fix a planner selector
- lane select got to be able to change topicname for planner selector</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/velocity_set/velocity_set.cpp" new_path="ros/src/computing/planning/motion/packages/astar_planner/nodes/velocity_set/velocity_set.cpp">
				<diff>@@ -515,7 +515,7 @@ int main(int argc, char** argv)
   std::string points_topic;
   private_nh.param&lt;bool&gt;(&quot;use_crosswalk_detection&quot;, use_crosswalk_detection, true);
   private_nh.param&lt;bool&gt;(&quot;enable_multiple_crosswalk_detection&quot;, enable_multiple_crosswalk_detection, true);
-  private_nh.param&lt;bool&gt;(&quot;enablePlannerDynamicSwitch&quot;, enablePlannerDynamicSwitch, true);
+  private_nh.param&lt;bool&gt;(&quot;enablePlannerDynamicSwitch&quot;, enablePlannerDynamicSwitch, false);
 
 
   private_nh.param&lt;std::string&gt;(&quot;points_topic&quot;, points_topic, &quot;points_lanes&quot;);
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include &lt;ros/ros.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;iostream&gt;

#include &quot;libvelocity_set.h&quot;
#include &quot;velocity_set_info.h&quot;
#include &quot;velocity_set_path.h&quot;

namespace
{
constexpr int LOOP_RATE = 10;
constexpr double DECELERATION_SEARCH_DISTANCE = 30;
constexpr double STOP_SEARCH_DISTANCE = 60;

// Display a detected obstacle
void displayObstacle(const EControl&amp; kind, const ObstaclePoints&amp; obstacle_points, const ros::Publisher&amp; obstacle_pub)
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;/map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;my_namespace&quot;;
  marker.id = 0;
  marker.type = visualization_msgs::Marker::CUBE;
  marker.action = visualization_msgs::Marker::ADD;

  static geometry_msgs::Point prev_obstacle_point;
  if (kind == EControl::STOP || kind == EControl::DECELERATE)
  {
    marker.pose.position = obstacle_points.getObstaclePoint(kind);
    prev_obstacle_point = marker.pose.position;
  }
  else  // kind == OTHERS
  {
    marker.pose.position = prev_obstacle_point;
  }
  geometry_msgs::Quaternion quat;
  marker.pose.orientation = quat;

  marker.scale.x = 1.0;
  marker.scale.y = 1.0;
  marker.scale.z = 2.0;
  marker.color.a = 0.7;
  if (kind == EControl::STOP)
  {
    marker.color.r = 1.0;
    marker.color.g = 0.0;
    marker.color.b = 0.0;
  }
  else
  {
    marker.color.r = 1.0;
    marker.color.g = 1.0;
    marker.color.b = 0.0;
  }
  marker.lifetime = ros::Duration(0.1);
  marker.frame_locked = true;

  // obstacle_pub.publish(marker);
}

void displayDetectionRange(const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const int closest_waypoint,
                           const EControl&amp; kind, const int obstacle_waypoint, const double stop_range,
                           const double deceleration_range, const ros::Publisher&amp; detection_range_pub)
{
  // set up for marker array
  visualization_msgs::MarkerArray marker_array;
  visualization_msgs::Marker crosswalk_marker;
  visualization_msgs::Marker waypoint_marker_stop;
  visualization_msgs::Marker waypoint_marker_decelerate;
  visualization_msgs::Marker stop_line;
  crosswalk_marker.header.frame_id = &quot;/map&quot;;
  crosswalk_marker.header.stamp = ros::Time();
  crosswalk_marker.id = 0;
  crosswalk_marker.type = visualization_msgs::Marker::SPHERE_LIST;
  crosswalk_marker.action = visualization_msgs::Marker::ADD;
  waypoint_marker_stop = crosswalk_marker;
  waypoint_marker_decelerate = crosswalk_marker;
  stop_line = crosswalk_marker;
  stop_line.type = visualization_msgs::Marker::CUBE;

  // set each namespace
  crosswalk_marker.ns = &quot;Crosswalk Detection&quot;;
  waypoint_marker_stop.ns = &quot;Stop Detection&quot;;
  waypoint_marker_decelerate.ns = &quot;Decelerate Detection&quot;;
  stop_line.ns = &quot;Stop Line&quot;;

  // set scale and color
  double scale = 2 * stop_range;
  waypoint_marker_stop.scale.x = scale;
  waypoint_marker_stop.scale.y = scale;
  waypoint_marker_stop.scale.z = scale;
  waypoint_marker_stop.color.a = 0.2;
  waypoint_marker_stop.color.r = 0.0;
  waypoint_marker_stop.color.g = 1.0;
  waypoint_marker_stop.color.b = 0.0;
  waypoint_marker_stop.frame_locked = true;

  scale = 2 * (stop_range + deceleration_range);
  waypoint_marker_decelerate.scale.x = scale;
  waypoint_marker_decelerate.scale.y = scale;
  waypoint_marker_decelerate.scale.z = scale;
  waypoint_marker_decelerate.color.a = 0.15;
  waypoint_marker_decelerate.color.r = 1.0;
  waypoint_marker_decelerate.color.g = 1.0;
  waypoint_marker_decelerate.color.b = 0.0;
  waypoint_marker_decelerate.frame_locked = true;

  if (obstacle_waypoint &gt; -1)
  {
    stop_line.pose.position = lane.waypoints[obstacle_waypoint].pose.pose.position;
    stop_line.pose.orientation = lane.waypoints[obstacle_waypoint].pose.pose.orientation;
  }
  stop_line.pose.position.z += 1.0;
  stop_line.scale.x = 0.1;
  stop_line.scale.y = 15.0;
  stop_line.scale.z = 2.0;
  stop_line.color.a = 0.3;
  stop_line.color.r = 1.0;
  stop_line.color.g = 0.0;
  stop_line.color.b = 0.0;
  stop_line.lifetime = ros::Duration(0.1);
  stop_line.frame_locked = true;

  int crosswalk_id = crosswalk.getDetectionCrossWalkID();
  if (crosswalk_id &gt; 0)
    scale = crosswalk.getDetectionPoints(crosswalk_id).width;
  crosswalk_marker.scale.x = scale;
  crosswalk_marker.scale.y = scale;
  crosswalk_marker.scale.z = scale;
  crosswalk_marker.color.a = 0.5;
  crosswalk_marker.color.r = 0.0;
  crosswalk_marker.color.g = 1.0;
  crosswalk_marker.color.b = 0.0;
  crosswalk_marker.frame_locked = true;

  // set marker points coordinate
  for (int i = 0; i &lt; STOP_SEARCH_DISTANCE; i++)
  {
    if (closest_waypoint &lt; 0 || i + closest_waypoint &gt; static_cast&lt;int&gt;(lane.waypoints.size()) - 1)
      break;

    geometry_msgs::Point point;
    point = lane.waypoints[closest_waypoint + i].pose.pose.position;

    waypoint_marker_stop.points.push_back(point);

    if (i &gt; DECELERATION_SEARCH_DISTANCE)
      continue;
    waypoint_marker_decelerate.points.push_back(point);
  }

  if (crosswalk_id &gt; 0)
  {
    if (!crosswalk.isMultipleDetection())
    {
      for (const auto&amp; p : crosswalk.getDetectionPoints(crosswalk_id).points)
        crosswalk_marker.points.push_back(p);
    }
    else
    {
      for (const auto&amp; c_id : crosswalk.getDetectionCrossWalkIDs())
      {
        for (const auto&amp; p : crosswalk.getDetectionPoints(c_id).points)
        {
          scale = crosswalk.getDetectionPoints(c_id).width;
          crosswalk_marker.points.push_back(p);
        }
      }
    }
  }
  // publish marker
  marker_array.markers.push_back(crosswalk_marker);
  marker_array.markers.push_back(waypoint_marker_stop);
  marker_array.markers.push_back(waypoint_marker_decelerate);
  if (kind == EControl::STOP)
    marker_array.markers.push_back(stop_line);
  detection_range_pub.publish(marker_array);
  marker_array.markers.clear();
}

// obstacle detection for crosswalk
EControl crossWalkDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const CrossWalk&amp; crosswalk,
                            const geometry_msgs::PoseStamped&amp; localizer_pose, const int points_threshold,
                            ObstaclePoints* obstacle_points)
{
  int crosswalk_id = crosswalk.getDetectionCrossWalkID();
  double search_radius = crosswalk.getDetectionPoints(crosswalk_id).width / 2;
  // std::vector&lt;int&gt; crosswalk_ids crosswalk.getDetectionCrossWalkIDs();

  // Search each calculated points in the crosswalk
  for (const auto&amp; c_id : crosswalk.getDetectionCrossWalkIDs())
  {
    for (const auto&amp; p : crosswalk.getDetectionPoints(c_id).points)
    {
      geometry_msgs::Point detection_point = calcRelativeCoordinate(p, localizer_pose.pose);
      tf::Vector3 detection_vector = point2vector(detection_point);
      detection_vector.setZ(0.0);

      int stop_count = 0;  // the number of points in the detection area
      for (const auto&amp; p : points)
      {
        tf::Vector3 point_vector(p.x, p.y, 0.0);
        double distance = tf::tfDistance(point_vector, detection_vector);
        if (distance &lt; search_radius)
        {
          stop_count++;
          geometry_msgs::Point point_temp;
          point_temp.x = p.x;
          point_temp.y = p.y;
          point_temp.z = p.z;
          obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
        }
        if (stop_count &gt; points_threshold)
          return EControl::STOP;
      }
    }

    obstacle_points-&gt;clearStopPoints();
    if (!crosswalk.isMultipleDetection())
      break;
  }
  return EControl::KEEP;  // find no obstacles
}

int detectStopObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
                       const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, double stop_range,
                       double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose,
                       ObstaclePoints* obstacle_points)
{
  int stop_obstacle_waypoint = -1;
  // start search from the closest waypoint
  for (int i = closest_waypoint; i &lt; closest_waypoint + STOP_SEARCH_DISTANCE; i++)
  {
    // reach the end of waypoints
    if (i &gt;= static_cast&lt;int&gt;(lane.waypoints.size()))
      break;

    // Detection for cross walk
    if (i == crosswalk.getDetectionWaypoint())
    {
      // found an obstacle in the cross walk
      if (crossWalkDetection(points, crosswalk, localizer_pose, points_threshold, obstacle_points) == EControl::STOP)
      {
        stop_obstacle_waypoint = i;
        break;
      }
    }

    // waypoint seen by localizer
    geometry_msgs::Point waypoint = calcRelativeCoordinate(lane.waypoints[i].pose.pose.position, localizer_pose.pose);
    tf::Vector3 tf_waypoint = point2vector(waypoint);
    tf_waypoint.setZ(0);

    int stop_point_count = 0;
    for (const auto&amp; p : points)
    {
      tf::Vector3 point_vector(p.x, p.y, 0);

      // 2D distance between waypoint and points (obstacle)
      double dt = tf::tfDistance(point_vector, tf_waypoint);
      if (dt &lt; stop_range)
      {
        stop_point_count++;
        geometry_msgs::Point point_temp;
        point_temp.x = p.x;
        point_temp.y = p.y;
        point_temp.z = p.z;
        obstacle_points-&gt;setStopPoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
      }
    }

    // there is an obstacle if the number of points exceeded the threshold
    if (stop_point_count &gt; points_threshold)
    {
      stop_obstacle_waypoint = i;
      break;
    }

    obstacle_points-&gt;clearStopPoints();

    // check next waypoint...
  }

  return stop_obstacle_waypoint;
}

int detectDecelerateObstacle(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
                             const autoware_msgs::lane&amp; lane, const double stop_range, const double deceleration_range,
                             const double points_threshold, const geometry_msgs::PoseStamped&amp; localizer_pose,
                             ObstaclePoints* obstacle_points)
{
  int decelerate_obstacle_waypoint = -1;
  // start search from the closest waypoint
  for (int i = closest_waypoint; i &lt; closest_waypoint + DECELERATION_SEARCH_DISTANCE; i++)
  {
    // reach the end of waypoints
    if (i &gt;= static_cast&lt;int&gt;(lane.waypoints.size()))
      break;

    // waypoint seen by localizer
    geometry_msgs::Point waypoint = calcRelativeCoordinate(lane.waypoints[i].pose.pose.position, localizer_pose.pose);
    tf::Vector3 tf_waypoint = point2vector(waypoint);
    tf_waypoint.setZ(0);

    int decelerate_point_count = 0;
    for (const auto&amp; p : points)
    {
      tf::Vector3 point_vector(p.x, p.y, 0);

      // 2D distance between waypoint and points (obstacle)
      double dt = tf::tfDistance(point_vector, tf_waypoint);
      if (dt &gt; stop_range &amp;&amp; dt &lt; stop_range + deceleration_range)
      {
        decelerate_point_count++;
        geometry_msgs::Point point_temp;
        point_temp.x = p.x;
        point_temp.y = p.y;
        point_temp.z = p.z;
        obstacle_points-&gt;setDeceleratePoint(calcAbsoluteCoordinate(point_temp, localizer_pose.pose));
      }
    }

    // there is an obstacle if the number of points exceeded the threshold
    if (decelerate_point_count &gt; points_threshold)
    {
      decelerate_obstacle_waypoint = i;
      break;
    }

    obstacle_points-&gt;clearDeceleratePoints();

    // check next waypoint...
  }

  return decelerate_obstacle_waypoint;
}

// Detect an obstacle by using pointcloud
EControl pointsDetection(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; points, const int closest_waypoint,
                         const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk, const VelocitySetInfo&amp; vs_info,
                         int* obstacle_waypoint, ObstaclePoints* obstacle_points)
{
  if (points.empty() == true || closest_waypoint &lt; 0)
    return EControl::KEEP;

  int stop_obstacle_waypoint =
      detectStopObstacle(points, closest_waypoint, lane, crosswalk, vs_info.getStopRange(),
                         vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);

  // skip searching deceleration range
  if (vs_info.getDecelerationRange() &lt; 0.01)
  {
    *obstacle_waypoint = stop_obstacle_waypoint;
    return stop_obstacle_waypoint &lt; 0 ? EControl::KEEP : EControl::STOP;
  }

  int decelerate_obstacle_waypoint =
      detectDecelerateObstacle(points, closest_waypoint, lane, vs_info.getStopRange(), vs_info.getDecelerationRange(),
                               vs_info.getPointsThreshold(), vs_info.getLocalizerPose(), obstacle_points);

  // stop obstacle was not found
  if (stop_obstacle_waypoint &lt; 0)
  {
    *obstacle_waypoint = decelerate_obstacle_waypoint;
    return decelerate_obstacle_waypoint &lt; 0 ? EControl::KEEP : EControl::DECELERATE;
  }

  // stop obstacle was found but decelerate obstacle was not found
  if (decelerate_obstacle_waypoint &lt; 0)
  {
    *obstacle_waypoint = stop_obstacle_waypoint;
    return EControl::STOP;
  }

  // about 5.0 meter
  double waypoint_interval =
      getPlaneDistance(lane.waypoints[0].pose.pose.position, lane.waypoints[1].pose.pose.position);
  int stop_decelerate_threshold = 5 / waypoint_interval;

  // both were found
  if (stop_obstacle_waypoint - decelerate_obstacle_waypoint &gt; stop_decelerate_threshold)
  {
    *obstacle_waypoint = decelerate_obstacle_waypoint;
    return EControl::DECELERATE;
  }
  else
  {
    *obstacle_waypoint = stop_obstacle_waypoint;
    return EControl::STOP;
  }
}

EControl obstacleDetection(int closest_waypoint, const autoware_msgs::lane&amp; lane, const CrossWalk&amp; crosswalk,
                           const VelocitySetInfo vs_info, const ros::Publisher&amp; detection_range_pub,
                           const ros::Publisher&amp; obstacle_pub, int* obstacle_waypoint)
{
  ObstaclePoints obstacle_points;
  EControl detection_result = pointsDetection(vs_info.getPoints(), closest_waypoint, lane, crosswalk, vs_info,
                                              obstacle_waypoint, &amp;obstacle_points);
  displayDetectionRange(lane, crosswalk, closest_waypoint, detection_result, *obstacle_waypoint, vs_info.getStopRange(),
                        vs_info.getDecelerationRange(), detection_range_pub);

  static int false_count = 0;
  static EControl prev_detection = EControl::KEEP;
  static int prev_obstacle_waypoint = -1;

  // stop or decelerate because we found obstacles
  if (detection_result == EControl::STOP || detection_result == EControl::DECELERATE)
  {
    displayObstacle(detection_result, obstacle_points, obstacle_pub);
    prev_detection = detection_result;
    false_count = 0;
    prev_obstacle_waypoint = *obstacle_waypoint;
    return detection_result;
  }

  // there are no obstacles, but wait a little for safety
  if (prev_detection == EControl::STOP || prev_detection == EControl::DECELERATE)
  {
    false_count++;

    if (false_count &lt; LOOP_RATE / 2)
    {
      *obstacle_waypoint = prev_obstacle_waypoint;
      displayObstacle(EControl::OTHERS, obstacle_points, obstacle_pub);
      return prev_detection;
    }
  }

  // there are no obstacles, so we move forward
  *obstacle_waypoint = -1;
  false_count = 0;
  prev_detection = EControl::KEEP;
  return detection_result;
}

void changeWaypoints(const VelocitySetInfo&amp; vs_info, const EControl&amp; detection_result, int closest_waypoint,
                     int obstacle_waypoint, const ros::Publisher&amp; final_waypoints_pub, VelocitySetPath* vs_path)
{
  if (detection_result == EControl::STOP)
  {  // STOP for obstacle
    // stop_waypoint is about stop_distance meter away from obstacles
    int stop_waypoint =
        calcWaypointIndexReverse(vs_path-&gt;getPrevWaypoints(), obstacle_waypoint, vs_info.getStopDistance());

    // change waypoints to stop by the stop_waypoint
    vs_path-&gt;changeWaypointsForStopping(stop_waypoint, obstacle_waypoint, closest_waypoint, vs_info.getDeceleration());
    vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
    vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
    vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
    final_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
  }
  else if (detection_result == EControl::DECELERATE)
  {  // DECELERATE for obstacles
    vs_path-&gt;initializeNewWaypoints();
    vs_path-&gt;changeWaypointsForDeceleration(vs_info.getDeceleration(), closest_waypoint, obstacle_waypoint);
    vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
    vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
    vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
    final_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
  }
  else
  {  // ACCELERATE or KEEP
    vs_path-&gt;initializeNewWaypoints();
    vs_path-&gt;avoidSuddenAcceleration(vs_info.getDeceleration(), closest_waypoint);
    vs_path-&gt;avoidSuddenDeceleration(vs_info.getVelocityChangeLimit(), vs_info.getDeceleration(), closest_waypoint);
    vs_path-&gt;setTemporalWaypoints(vs_info.getTemporalWaypointsSize(), closest_waypoint, vs_info.getControlPose());
    final_waypoints_pub.publish(vs_path-&gt;getTemporalWaypoints());
  }
}

}  // end namespace

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;velocity_set&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  bool use_crosswalk_detection;
  bool enable_multiple_crosswalk_detection;
  bool enablePlannerDynamicSwitch;

  std::string points_topic;
  private_nh.param&lt;bool&gt;(&quot;use_crosswalk_detection&quot;, use_crosswalk_detection, true);
  private_nh.param&lt;bool&gt;(&quot;enable_multiple_crosswalk_detection&quot;, enable_multiple_crosswalk_detection, true);
  private_nh.param&lt;bool&gt;(&quot;enablePlannerDynamicSwitch&quot;, enablePlannerDynamicSwitch, true);


  private_nh.param&lt;std::string&gt;(&quot;points_topic&quot;, points_topic, &quot;points_lanes&quot;);

  // class
  CrossWalk crosswalk;
  VelocitySetPath vs_path;
  VelocitySetInfo vs_info;

  // velocity set subscriber
  ros::Subscriber waypoints_sub = nh.subscribe(&quot;safety_waypoints&quot;, 1, &amp;VelocitySetPath::waypointsCallback, &amp;vs_path);
  ros::Subscriber current_vel_sub =
      nh.subscribe(&quot;current_velocity&quot;, 1, &amp;VelocitySetPath::currentVelocityCallback, &amp;vs_path);

  // velocity set info subscriber
  ros::Subscriber config_sub = nh.subscribe(&quot;config/velocity_set&quot;, 1, &amp;VelocitySetInfo::configCallback, &amp;vs_info);
  ros::Subscriber points_sub = nh.subscribe(points_topic, 1, &amp;VelocitySetInfo::pointsCallback, &amp;vs_info);
  ros::Subscriber localizer_sub = nh.subscribe(&quot;localizer_pose&quot;, 1, &amp;VelocitySetInfo::localizerPoseCallback, &amp;vs_info);
  ros::Subscriber control_pose_sub = nh.subscribe(&quot;current_pose&quot;, 1, &amp;VelocitySetInfo::controlPoseCallback, &amp;vs_info);
  // ros::Subscriber closest_waypoint_sub = nh.subscribe(&quot;closest_waypoint&quot;, 1,
  // &amp;VelocitySetInfo::closestWaypointCallback, &amp;vs_info);

  // vector map subscriber
  ros::Subscriber sub_dtlane = nh.subscribe(&quot;vector_map_info/cross_walk&quot;, 1, &amp;CrossWalk::crossWalkCallback, &amp;crosswalk);
  ros::Subscriber sub_area = nh.subscribe(&quot;vector_map_info/area&quot;, 1, &amp;CrossWalk::areaCallback, &amp;crosswalk);
  ros::Subscriber sub_line = nh.subscribe(&quot;vector_map_info/line&quot;, 1, &amp;CrossWalk::lineCallback, &amp;crosswalk);
  ros::Subscriber sub_point = nh.subscribe(&quot;vector_map_info/point&quot;, 1, &amp;CrossWalk::pointCallback, &amp;crosswalk);

  // publisher
  ros::Publisher detection_range_pub = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;detection_range&quot;, 1);
  ros::Publisher obstacle_pub = nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;obstacle&quot;, 1);
  ros::Publisher obstacle_waypoint_pub = nh.advertise&lt;std_msgs::Int32&gt;(&quot;obstacle_waypoint&quot;, 1, true);

  ros::Publisher final_waypoints_pub;
  if(enablePlannerDynamicSwitch){
	  final_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;(&quot;astar/final_waypoints&quot;, 1, true);
  }else{
	  final_waypoints_pub = nh.advertise&lt;autoware_msgs::lane&gt;(&quot;final_waypoints&quot;, 1, true);
  }

  ros::Rate loop_rate(LOOP_RATE);
  while (ros::ok())
  {
    ros::spinOnce();

    int closest_waypoint = 0;

    if (crosswalk.loaded_all &amp;&amp; !crosswalk.set_points)
      crosswalk.setCrossWalkPoints();

    if (!vs_info.getSetPose() || !vs_path.getSetPath())
    {
      loop_rate.sleep();
      continue;
    }

    crosswalk.setMultipleDetectionFlag(enable_multiple_crosswalk_detection);

    if (use_crosswalk_detection)
      crosswalk.setDetectionWaypoint(
          crosswalk.findClosestCrosswalk(closest_waypoint, vs_path.getPrevWaypoints(), STOP_SEARCH_DISTANCE));

    int obstacle_waypoint = -1;
    EControl detection_result = obstacleDetection(closest_waypoint, vs_path.getPrevWaypoints(), crosswalk, vs_info,
                                                  detection_range_pub, obstacle_pub, &amp;obstacle_waypoint);

    changeWaypoints(vs_info, detection_result, closest_waypoint, obstacle_waypoint, final_waypoints_pub, &amp;vs_path);

    vs_info.clearPoints();

    // publish obstacle waypoint index
    std_msgs::Int32 obstacle_waypoint_index;
    obstacle_waypoint_index.data = obstacle_waypoint;
    obstacle_waypoint_pub.publish(obstacle_waypoint_index);

    vs_path.resetFlag();

    loop_rate.sleep();
  }

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="fb9198f8b106b3f6f0760473682f26df86828ce1" fix_time="140,48464">
		<msg>[hotfix] fixes to lidar_tracker package(#787)

-Fixed a typo in the ground_filter launch file from points_preprocessor
-Fixed ID duplication in kf_lidar_tracker
Tested on Ubuntu 14.04 and 16.04</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/kf_lidar_track/KfLidarTracker.cpp" new_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/kf_lidar_track/KfLidarTracker.cpp">
				<diff>@@ -3,7 +3,14 @@
 // ---------------------------------------------------------------------------
 // Tracker. Manage tracks. Create, remove, update.
 // ---------------------------------------------------------------------------
-KfLidarTracker::KfLidarTracker(float in_time_delta,	float in_acceleration_noise_magnitude, float in_distance_threshold, float in_tracker_merging_threshold, size_t maximum_allowed_skipped_frames, size_t maximum_trace_length, bool pose_estimation) :
+KfLidarTracker::KfLidarTracker(float in_time_delta,
+		float in_acceleration_noise_magnitude,
+		float in_distance_threshold,
+		float in_tracker_merging_threshold,
+		size_t maximum_allowed_skipped_frames,
+		size_t maximum_trace_length,
+		bool pose_estimation,
+		size_t maximum_track_id) :
 	time_delta_(in_time_delta),
 	acceleration_noise_magnitude_(in_acceleration_noise_magnitude),
 	distance_threshold_(in_distance_threshold),
@@ -11,7 +18,8 @@ KfLidarTracker::KfLidarTracker(float in_time_delta,	float in_acceleration_noise_
 	maximum_allowed_skipped_frames_(maximum_allowed_skipped_frames),
 	maximum_trace_length_(maximum_trace_length),
 	next_track_id_(0),
-	pose_estimation_(false)
+	pose_estimation_(false),
+	maximum_track_id_(maximum_track_id)
 {
 }
 
@@ -162,25 +170,32 @@ void KfLidarTracker::Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_clu
 										acceleration_noise_magnitude_,
 										next_track_id_++)
 								);
-				if (next_track_id_ &gt; 200)
+				if (next_track_id_ &gt; maximum_track_id_)
 					next_track_id_ = 0;
 				una++;
 			}
 		}
-		//std::cout &lt;&lt; &quot;Trackers added: &quot; &lt;&lt; una &lt;&lt; std::endl;
-
-		//finally check trackers among them
+		//finally check trackers among them. Remove previously merged objects, causing ID duplication
 		for(size_t i=0; i&lt; tracks_.size(); i++)
-			std::cout &lt;&lt; tracks_[i].track_id &lt;&lt; &quot;,&quot;;
-		std::cout &lt;&lt; std::endl &lt;&lt; &quot;Check&quot; &lt;&lt; std::endl;
+		{
+			for (size_t j=0; j&lt; tracks_.size(); j++)
+			{
+				if (i != j &amp;&amp;
+					 (tracks_[i].GetCluster().centroid_point.point.x == tracks_[j].GetCluster().centroid_point.point.x &amp;&amp;
+					  tracks_[i].GetCluster().centroid_point.point.y == tracks_[j].GetCluster().centroid_point.point.y &amp;&amp;
+					  tracks_[i].GetCluster().centroid_point.point.z == tracks_[j].GetCluster().centroid_point.point.z
+					 )
+					)
+				{
+					tracks_.erase(tracks_.begin() + j);
+					j--;
+				}
+			}
+		}
 		CheckAllTrackersForMerge(final_tracks);
 
 		tracks_ = final_tracks;
 
-		for(size_t i=0; i&lt; tracks_.size(); i++)
-			std::cout &lt;&lt; tracks_[i].track_id &lt;&lt; &quot;,&quot;;
-		std::cout &lt;&lt; std::endl;
-
 		//std::cout &lt;&lt; &quot;Final Trackers &quot; &lt;&lt; tracks_.size() &lt;&lt; std::endl;
 	}//endof matching
 
</diff>
				<old_file>#include &quot;KfLidarTracker.h&quot;

// ---------------------------------------------------------------------------
// Tracker. Manage tracks. Create, remove, update.
// ---------------------------------------------------------------------------
KfLidarTracker::KfLidarTracker(float in_time_delta,	float in_acceleration_noise_magnitude, float in_distance_threshold, float in_tracker_merging_threshold, size_t maximum_allowed_skipped_frames, size_t maximum_trace_length, bool pose_estimation) :
	time_delta_(in_time_delta),
	acceleration_noise_magnitude_(in_acceleration_noise_magnitude),
	distance_threshold_(in_distance_threshold),
	tracker_merging_threshold_(in_tracker_merging_threshold),
	maximum_allowed_skipped_frames_(maximum_allowed_skipped_frames),
	maximum_trace_length_(maximum_trace_length),
	next_track_id_(0),
	pose_estimation_(false)
{
}

void KfLidarTracker::CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_points, boost_polygon&amp; out_polygon)
{
	std::vector&lt; boost_point_xy &gt; hull_detection_points;

	for (size_t k=0; k &lt; in_points.points.size()/2; k++)
	{
		hull_detection_points.push_back(
					boost_point_xy(in_points.points[k].x,
							in_points.points[k].y)
					);
	}
	boost::geometry::assign_points(out_polygon, hull_detection_points);
}

void KfLidarTracker::Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_match_method)
{
	size_t num_detections = in_cloud_cluster_array.clusters.size();
	size_t num_tracks = tracks_.size();

	std::vector&lt;size_t&gt; detections_assignments;
	std::vector&lt;double&gt; detections_areas(num_detections, 0.0f);

	std::vector&lt; CTrack &gt; final_tracks;

	// If no trackers, new track for each detection
	if (num_tracks == 0)
	{
		//std::cout &lt;&lt; &quot;New tracks&quot; &lt;&lt; num_detections &lt;&lt; std::endl;
		// If no tracks yet
		for (size_t i = 0; i &lt; num_detections; ++i)
		{
			tracks_.push_back(CTrack(in_cloud_cluster_array.clusters[i],
									time_delta_,
									acceleration_noise_magnitude_,
									next_track_id_++)
							);
		}
		num_tracks = tracks_.size();
	}
	std::vector&lt;int&gt; track_assignments(num_tracks, -1);
	std::vector&lt; std::vector&lt;size_t&gt; &gt; track_assignments_vector(num_tracks);

	//else
	{
		//std::cout &lt;&lt; &quot;Trying to match &quot; &lt;&lt; num_tracks &lt;&lt; &quot; tracks with &quot; &lt;&lt; num_detections &lt;&lt; std::endl;

		//calculate distances between objects
		for (size_t i = 0; i &lt; num_detections; i++)
		{

			float current_distance_threshold = distance_threshold_;

			//detection polygon
			boost_polygon hull_detection_polygon;
			CreatePolygonFromPoints(in_cloud_cluster_array.clusters[i].convex_hull.polygon, hull_detection_polygon);
			detections_areas[i] = boost::geometry::area(hull_detection_polygon);

			for (size_t j = 0; j &lt; num_tracks; j++)
			{
				//float current_distance = tracks_[j].CalculateDistance(cv::Point2f(in_cloud_cluster_array.clusters[i].centroid_point.point.x, in_cloud_cluster_array.clusters[i].centroid_point.point.y));
				float current_distance = sqrt(
												pow(tracks_[j].GetCluster().centroid_point.point.x - in_cloud_cluster_array.clusters[i].centroid_point.point.x, 2) +
												pow(tracks_[j].GetCluster().centroid_point.point.y - in_cloud_cluster_array.clusters[i].centroid_point.point.y, 2)
										);

				//tracker polygon
				boost_polygon hull_track_polygon;
				CreatePolygonFromPoints(tracks_[j].GetCluster().convex_hull.polygon, hull_track_polygon);

				//if(current_distance &lt; current_distance_threshold)
				if (!boost::geometry::disjoint(hull_detection_polygon, hull_track_polygon)
					||  (current_distance &lt; current_distance_threshold)
					)
				{//assign the closest detection or overlapping
					current_distance_threshold = current_distance;
					track_assignments[j] = i;//assign detection i to track j
					track_assignments_vector[j].push_back(i);//add current detection as a match
					detections_assignments.push_back(j);///////////////////////////////////////
				}
			}
		}

		//check assignmets
		for (size_t i = 0; i&lt; num_tracks; i++)
		{
			if (track_assignments[i]&gt;=0) //if this track was assigned, update kalman filter, reset remaining life
			{
				//keep oldest
				tracks_[i].skipped_frames = 0;

				//join all assigned detections to update the tracker
				/*autoware_msgs::CloudClusterPtr summed_cloud_cluster(new autoware_msgs::CloudCluster());
				pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr summed_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
				for (size_t j = 0; j &lt; track_assignments_vector[i].size(); j++)
				{
					pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr current_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
					pcl::fromROSMsg(in_cloud_cluster_array.clusters[track_assignments_vector[i][j]].cloud, *current_cloud_ptr);
					*summed_cloud_ptr += *current_cloud_ptr;
				}
				ClusterPtr merged_cluster(new Cluster());
				std::vector&lt;int&gt; indices(summed_cloud_ptr-&gt;points.size(), 0);
				for (size_t j=0; j&lt;summed_cloud_ptr-&gt;points.size(); j++)
				{
					indices[j]=j;
				}
				merged_cluster-&gt;SetCloud(summed_cloud_ptr, indices, in_cloud_cluster_array.clusters[track_assignments[i]].header, i,255, 255, 255, &quot;&quot;, pose_estimation_);

				merged_cluster-&gt;ToRosMessage(in_cloud_cluster_array.clusters[track_assignments[i]].header, *summed_cloud_cluster);*/

				tracks_[i].Update(in_cloud_cluster_array.clusters[track_assignments[i]],//*summed_cloud_cluster,
								true,
								maximum_trace_length_);
				//detections_assignments.push_back(track_assignments[i]);
			}
			else				     // if not matched continue using predictions, and increase life
			{
				tracks_[i].Update(autoware_msgs::CloudCluster(), //empty cluster
									false, //not matched,
									maximum_trace_length_
								);
				tracks_[i].skipped_frames++;
			}
			tracks_[i].life_span++;
		}

		// If track life is long, remove it.
		for (size_t i = 0; i &lt; tracks_.size(); i++)
		{
			if (tracks_[i].skipped_frames &gt; maximum_allowed_skipped_frames_)
			{
				tracks_.erase(tracks_.begin() + i);
				i--;
			}
		}

		// Search for unassigned detections and start new trackers.
		int una = 0;
		for (size_t i = 0; i &lt; num_detections; ++i)
		{
			std::vector&lt;size_t&gt;::iterator it = find(detections_assignments.begin(), detections_assignments.end(), i);
			if (it == detections_assignments.end())//if detection not found in the already assigned ones, add new tracker
			{
				tracks_.push_back(CTrack(in_cloud_cluster_array.clusters[i],
										time_delta_,
										acceleration_noise_magnitude_,
										next_track_id_++)
								);
				if (next_track_id_ &gt; 200)
					next_track_id_ = 0;
				una++;
			}
		}
		//std::cout &lt;&lt; &quot;Trackers added: &quot; &lt;&lt; una &lt;&lt; std::endl;

		//finally check trackers among them
		for(size_t i=0; i&lt; tracks_.size(); i++)
			std::cout &lt;&lt; tracks_[i].track_id &lt;&lt; &quot;,&quot;;
		std::cout &lt;&lt; std::endl &lt;&lt; &quot;Check&quot; &lt;&lt; std::endl;
		CheckAllTrackersForMerge(final_tracks);

		tracks_ = final_tracks;

		for(size_t i=0; i&lt; tracks_.size(); i++)
			std::cout &lt;&lt; tracks_[i].track_id &lt;&lt; &quot;,&quot;;
		std::cout &lt;&lt; std::endl;

		//std::cout &lt;&lt; &quot;Final Trackers &quot; &lt;&lt; tracks_.size() &lt;&lt; std::endl;
	}//endof matching

}

void KfLidarTracker::CheckTrackerMerge(size_t in_tracker_id, std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;bool&gt;&amp; in_out_visited_trackers, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold)
{
	for(size_t i=0; i&lt; in_trackers.size(); i++)
	{
		if (i != in_tracker_id &amp;&amp; !in_out_visited_trackers[i])
		{
			double distance =  sqrt( pow(in_trackers[in_tracker_id].GetCluster().centroid_point.point.x - in_trackers[i].GetCluster().centroid_point.point.x,2) +
										pow(in_trackers[in_tracker_id].GetCluster().centroid_point.point.y - in_trackers[i].GetCluster().centroid_point.point.y,2)
								);
			boost_polygon in_tracker_poly;
			CreatePolygonFromPoints(in_trackers[in_tracker_id].GetCluster().convex_hull.polygon, in_tracker_poly);
			in_trackers[in_tracker_id].area = boost::geometry::area(in_tracker_poly);

			boost_polygon current_tracker_poly;
			CreatePolygonFromPoints(in_trackers[i].GetCluster().convex_hull.polygon, current_tracker_poly);
			in_trackers[i].area = boost::geometry::area(current_tracker_poly);

			if (!boost::geometry::disjoint(in_tracker_poly, current_tracker_poly)
				|| distance &lt;= in_merge_threshold)
			{
				in_out_visited_trackers[i] = true;
				out_merge_indices.push_back(i);
				CheckTrackerMerge(i, in_trackers, in_out_visited_trackers, out_merge_indices, in_merge_threshold);
			}
		}
	}
}

void KfLidarTracker::MergeTrackers(std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;CTrack&gt;&amp; out_trackers, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_trackers)
{
	size_t oldest_life =0;
	size_t oldest_index = 0;
	double largest_area = 0.0f;
	size_t largest_index = 0;
	for (size_t i=0; i&lt;in_merge_indices.size(); i++)
	{
		if (in_trackers[in_merge_indices[i]].life_span&gt; oldest_life)
		{
			oldest_life = in_trackers[in_merge_indices[i]].life_span;
			oldest_index = in_merge_indices[i];
		}
		if (in_trackers[in_merge_indices[i]].area&gt; largest_area)
		{
			largest_index = in_merge_indices[i];
		}
		in_out_merged_trackers[in_merge_indices[i]] = true;
	}
	bool found=false;
	for(size_t i=0; i&lt; out_trackers.size(); i++){
		found = out_trackers[i].track_id == in_trackers[oldest_index].track_id;
	}
	if (!found)
	{
		out_trackers.push_back(in_trackers[oldest_index]);
		in_out_merged_trackers[oldest_index] = true;
	}
	//out_trackers.back().cluster = in_trackers[largest_index].GetCluster();
}

void KfLidarTracker::CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers)
{
	//std::cout &lt;&lt; &quot;checkAllForMerge&quot; &lt;&lt; std::endl;
	std::vector&lt;bool&gt; visited_trackers(tracks_.size(), false);
	std::vector&lt;bool&gt; merged_trackers(tracks_.size(), false);
	size_t current_index=0;
	for (size_t i = 0; i&lt; tracks_.size(); i++)
	{
		if (!visited_trackers[i])
		{
			visited_trackers[i] = true;
			std::vector&lt;size_t&gt; merge_indices;
			CheckTrackerMerge(i, tracks_, visited_trackers, merge_indices, tracker_merging_threshold_);
			MergeTrackers(tracks_, out_trackers, merge_indices, current_index++, merged_trackers);
		}
	}
	for(size_t i =0; i&lt; tracks_.size(); i++)
	{
		//check for clusters not merged, add them to the output
		if (!merged_trackers[i])
		{
			out_trackers.push_back(tracks_[i]);
		}
	}
	//ClusterPtr cluster(new Cluster());
}
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
/*void KfLidarTracker::Update(
	const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array,
	DistType distType
	)
{
	size_t detections_num = in_cloud_cluster_array.clusters.size();
	// -----------------------------------
	// If there is no tracks yet, then every cv::Point begins its own track.
	// -----------------------------------
	if (tracks_.size() == 0)
	{
		std::cout &lt;&lt; &quot;New track&quot; &lt;&lt; std::endl;
		// If no tracks yet
		for (size_t i = 0; i &lt; detections_num; ++i)
		{
			tracks_.push_back(CTrack(in_cloud_cluster_array.clusters[i],
									time_delta_,
									acceleration_noise_magnitude_,
									next_track_id_++)
							);
		}
	}

	size_t N = tracks_.size();
	size_t M = detections_num;

	std::vector&lt;int&gt; assignment;

	if (!tracks_.empty())
	{
		std::cout &lt;&lt; &quot;Try to match&quot; &lt;&lt; std::endl;
		std::vector&lt;float&gt; cost_matrix(N * M);

		switch (distType)
		{
		case CentersDist:
			for (size_t i = 0; i &lt; tracks_.size(); i++)
			{
				for (size_t j = 0; j &lt; detections_num; j++)
				{
					cost_matrix[i + j * N] = tracks_[i].CalculateDistance(cv::Point2f(in_cloud_cluster_array.clusters[j].centroid_point.point.x, in_cloud_cluster_array.clusters[j].centroid_point.point.y));
				}
			}
			break;

		case RectsDist:
			for (size_t i = 0; i &lt; tracks_.size(); i++)
			{
				for (size_t j = 0; j &lt; detections_num; j++)
				{
					cost_matrix[i + j * N] = tracks_[i].CalculateDistance( cv::Rect_&lt;float&gt;(in_cloud_cluster_array.clusters[i].centroid_point.point.x - in_cloud_cluster_array.clusters[i].bounding_box.dimensions.x/2,
																			in_cloud_cluster_array.clusters[i].centroid_point.point.y - in_cloud_cluster_array.clusters[i].bounding_box.dimensions.y/2,
																			in_cloud_cluster_array.clusters[i].bounding_box.dimensions.x,
																			in_cloud_cluster_array.clusters[i].bounding_box.dimensions.y
																			)
														);
				}
			}
			break;
		}

		// -----------------------------------
		// Solving assignment problem (tracks and predictions of Kalman filter)
		// -----------------------------------
		AssignmentProblemSolver APS;
		std::cout &lt;&lt; &quot;Hungarian Algorithm Start&quot;&lt;&lt; std::endl;
		APS.Solve(cost_matrix, N, M, assignment, AssignmentProblemSolver::optimal);
		std::cout &lt;&lt; &quot;Hungarian Algorithm End&quot;&lt;&lt; std::endl;
		// -----------------------------------
		// clean assignment from pairs with large distance
		// -----------------------------------
		for (size_t i = 0; i &lt; assignment.size(); i++)
		{
			if (assignment[i] != -1)
			{
				if (cost_matrix[i + assignment[i] * N] &gt; distance_threshold_)
				{
					assignment[i] = -1;
					tracks_[i].skipped_frames = 1;
					std::cout &lt;&lt; &quot;Existing track Not matched &quot; &lt;&lt; i &lt;&lt; &quot; Distance:&quot; &lt;&lt; cost_matrix[i + assignment[i] * N] &lt;&lt; std::endl;
				}
			}
			else
			{
				// If track have no assigned detect, then increment skipped frames counter.
				tracks_[i].skipped_frames++;
				std::cout &lt;&lt; &quot;Existing track Not matched &quot; &lt;&lt; i &lt;&lt;&quot;, dying &quot; &lt;&lt; tracks_[i].skipped_frames &lt;&lt; std::endl;
			}
		}

		// -----------------------------------
		// If track didn't get detects long time, remove it.
		// -----------------------------------
		for (size_t i = 0; i &lt; tracks_.size(); i++)
		{
			if (tracks_[i].skipped_frames &gt; maximum_allowed_skipped_frames_)
			{
				tracks_.erase(tracks_.begin() + i);
				assignment.erase(assignment.begin() + i);
				std::cout &lt;&lt; &quot;Died &quot; &lt;&lt; i &lt;&lt; std::endl;
				i--;
			}
		}
	}

	// -----------------------------------
	// Search for unassigned detects and start new tracks for them.
	// -----------------------------------
	for (size_t i = 0; i &lt; detections_num; ++i)
	{
		if (find(assignment.begin(), assignment.end(), i) == assignment.end())
		{
			std::cout &lt;&lt; &quot;New object, Not matched &quot; &lt;&lt; i &lt;&lt; std::endl;
			tracks_.push_back(CTrack(in_cloud_cluster_array.clusters[i],
									time_delta_,
									acceleration_noise_magnitude_,
									next_track_id_++)
							);
		}
	}

	// Update Kalman Filters state
	for (size_t i = 0; i&lt;assignment.size(); i++)
	{
		// If track updated less than one time, than filter state is not correct.

		if (assignment[i] != -1) // If we have assigned detect, then update using its coordinates,
		{
			tracks_[i].skipped_frames = 0;
			std::cout &lt;&lt; &quot;Matched. Kalman Update on &quot; &lt;&lt; i &lt;&lt; std::endl;
			tracks_[i].Update(	in_cloud_cluster_array.clusters[i],
								true,
								maximum_trace_length_);
		}
		else				     // if not continue using predictions
		{
			std::cout &lt;&lt; &quot;Not Matched. Kalman Update on &quot; &lt;&lt; i &lt;&lt; std::endl;
			tracks_[i].Update(autoware_msgs::CloudCluster(), false, maximum_trace_length_);
		}
	}

}*/
// ---------------------------------------------------------------------------
//
// ---------------------------------------------------------------------------
KfLidarTracker::~KfLidarTracker(void)
{
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/kf_lidar_track/includes/KfLidarTracker.h" new_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/kf_lidar_track/includes/KfLidarTracker.h">
				<diff>@@ -102,6 +102,7 @@ class KfLidarTracker
 	size_t maximum_allowed_skipped_frames_;
 	size_t maximum_trace_length_;
 	size_t next_track_id_;
+	size_t maximum_track_id_;
 
 	bool pose_estimation_;
 	void CheckTrackerMerge(size_t in_tracker_id, std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;bool&gt;&amp; in_out_visited_trackers, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold);
@@ -109,7 +110,14 @@ class KfLidarTracker
 	void MergeTrackers(std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;CTrack&gt;&amp; out_trackers, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_trackers);
 	void CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_points, boost_polygon&amp; out_polygon);
 public:
-	KfLidarTracker(float in_time_delta, float accel_noise_mag, float dist_thres = 3, float tracker_merging_threshold=2, size_t maximum_allowed_skipped_frames = 10, size_t max_trace_length = 10, bool in_pose_estimation = false);
+	KfLidarTracker(float in_time_delta,
+					float accel_noise_mag,
+					float dist_thres = 3,
+					float tracker_merging_threshold=2,
+					size_t maximum_allowed_skipped_frames = 10,
+					size_t max_trace_length = 10,
+					bool in_pose_estimation = false,
+					size_t maximum_track_id = 200);
 	~KfLidarTracker(void);
 
 	enum DistType
</diff>
				<old_file>#pragma once
#include &quot;Kalman.h&quot;
#include &quot;HungarianAlg.h&quot;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;memory&gt;
#include &lt;array&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_recognition_msgs/PolygonArray.h&gt;
#include &lt;geometry_msgs/Polygon.h&gt;
#include &lt;geometry_msgs/PolygonStamped.h&gt;
#include &quot;autoware_msgs/CloudCluster.h&quot;
#include &quot;autoware_msgs/CloudClusterArray.h&quot;
#include &lt;tf/tf.h&gt;

#include &lt;boost/assert.hpp&gt;
#include &lt;boost/geometry/geometries/point_xy.hpp&gt;
#include &lt;boost/geometry/geometry.hpp&gt;
#include &lt;boost/geometry/geometries/polygon.hpp&gt;
#include &lt;boost/geometry/algorithms/disjoint.hpp&gt;
#include &lt;boost/assign/std/vector.hpp&gt;

#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl/point_types.h&gt;

#include &quot;Cluster.h&quot;

// --------------------------------------------------------------------------
class CTrack
{

	cv::Point2f prediction_point_;
	TKalmanFilter kf_;
public:
	autoware_msgs::CloudCluster cluster;

	std::vector&lt;cv::Point2f&gt; trace;
	size_t track_id;
	size_t skipped_frames;
	size_t life_span;
	double area;

	CTrack(const autoware_msgs::CloudCluster&amp; in_cluster, float in_time_delta, float in_acceleration_noise_magnitude, size_t in_track_id)
		: kf_(cv::Point2f(in_cluster.centroid_point.point.x, in_cluster.centroid_point.point.y), in_time_delta, in_acceleration_noise_magnitude)
	{
		track_id = in_track_id;
		skipped_frames = 0;
		prediction_point_ = cv::Point2f(in_cluster.centroid_point.point.x, in_cluster.centroid_point.point.y);
		cluster = in_cluster;
		life_span = 0;
		area = 0;
	}

	float CalculateDistance(const cv::Point2f&amp; in_point)
	{
		cv::Point2f diff = prediction_point_ - in_point;
		return sqrt(pow(diff.x, 2) + pow(diff.y, 2));
	}

	float CalculateDistance(const cv::Rect_&lt;float&gt;&amp; in_rect)
	{
		return 0.0f;
	}

	void Update(const autoware_msgs::CloudCluster&amp; in_cluster, bool in_data_correct, size_t in_max_trace_length)
	{
		kf_.GetPrediction();
		prediction_point_ = kf_.Update(cv::Point2f(in_cluster.centroid_point.point.x, in_cluster.centroid_point.point.y), in_data_correct);

		if (in_data_correct
			)
		{
			cluster = in_cluster;
		}

		if (trace.size() &gt; in_max_trace_length)
		{
			trace.erase(trace.begin(), trace.end() - in_max_trace_length);
		}

		trace.push_back(prediction_point_);
	}

	autoware_msgs::CloudCluster GetCluster()
	{
		return cluster;
	}

};

// --------------------------------------------------------------------------
class KfLidarTracker
{
	typedef boost::geometry::model::d2::point_xy&lt;double&gt; boost_point_xy;
	typedef boost::geometry::model::polygon&lt;boost::geometry::model::d2::point_xy&lt;double&gt; &gt; boost_polygon;

	float time_delta_;
	float acceleration_noise_magnitude_;
	float distance_threshold_;
	float tracker_merging_threshold_;

	size_t maximum_allowed_skipped_frames_;
	size_t maximum_trace_length_;
	size_t next_track_id_;

	bool pose_estimation_;
	void CheckTrackerMerge(size_t in_tracker_id, std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;bool&gt;&amp; in_out_visited_trackers, std::vector&lt;size_t&gt;&amp; out_merge_indices, double in_merge_threshold);
	void CheckAllTrackersForMerge(std::vector&lt;CTrack&gt;&amp; out_trackers);
	void MergeTrackers(std::vector&lt;CTrack&gt;&amp; in_trackers, std::vector&lt;CTrack&gt;&amp; out_trackers, std::vector&lt;size_t&gt; in_merge_indices, const size_t&amp; current_index, std::vector&lt;bool&gt;&amp; in_out_merged_trackers);
	void CreatePolygonFromPoints(const geometry_msgs::Polygon&amp; in_points, boost_polygon&amp; out_polygon);
public:
	KfLidarTracker(float in_time_delta, float accel_noise_mag, float dist_thres = 3, float tracker_merging_threshold=2, size_t maximum_allowed_skipped_frames = 10, size_t max_trace_length = 10, bool in_pose_estimation = false);
	~KfLidarTracker(void);

	enum DistType
	{
		CentersDist = 0,
		RectsDist = 1
	};

	std::vector&lt; CTrack &gt; tracks_;//TODO: add GetTracks getter
	void Update(const autoware_msgs::CloudClusterArray&amp; in_cloud_cluster_array, DistType in_disttype);


};
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/kf_lidar_track/kf_lidar_track.cpp" new_path="ros/src/computing/perception/detection/packages/lidar_tracker/nodes/kf_lidar_track/kf_lidar_track.cpp">
				<diff>@@ -5,6 +5,8 @@
  *      Author: ne0
  */
 
+#include &lt;vector&gt;
+
 #include &quot;ros/ros.h&quot;
 
 #include &lt;pcl_ros/transforms.h&gt;
@@ -24,8 +26,6 @@
 #include &lt;jsk_rviz_plugins/PictogramArray.h&gt;
 #include &lt;jsk_recognition_msgs/PolygonArray.h&gt;
 
-#include &lt;vector&gt;
-
 #include &quot;KfLidarTracker.h&quot;
 
 class KfLidarTrackNode
@@ -46,6 +46,7 @@ private:
 
 	bool pose_estimation_;
 	int keep_alive_;
+	int maximum_track_id_;
 
 	boost::shared_ptr&lt;KfLidarTracker&gt; tracker_ptr;
 
@@ -65,10 +66,16 @@ KfLidarTrackNode::KfLidarTrackNode() :
 	pub_jsk_hulls_ = node_handle_.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;(&quot;/cluster_hulls_tracked&quot;,1);
 	pub_jsk_pictograms_ = node_handle_.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;(&quot;/cluster_ids_tracked&quot;,1);
 
-	node_handle_.param(&quot;distance_matching_threshold&quot;, distance_matching_threshold_, 1.5);	ROS_INFO(&quot;distance_matching_threshold: %f&quot;, distance_matching_threshold_);// distance threshold to match objects between scans
-	node_handle_.param(&quot;tracker_merging_threshold&quot;, tracker_merging_threshold_, 1.0);	ROS_INFO(&quot;tracker_merging_threshold: %f&quot;, tracker_merging_threshold_);// distance threshold to match objects between scans
-	node_handle_.param(&quot;pose_estimation&quot;, pose_estimation_, false);	ROS_INFO(&quot;pose_estimation: %d&quot;, pose_estimation_);// whether or not to estimate pose
-	node_handle_.param(&quot;keep_alive&quot;, keep_alive_, 2);	ROS_INFO(&quot;keep_alive: %d&quot;, keep_alive_);// frames to keep an object
+	node_handle_.param(&quot;distance_matching_threshold&quot;, distance_matching_threshold_, 1.5);
+	ROS_INFO(&quot;distance_matching_threshold: %f&quot;, distance_matching_threshold_);// distance threshold to match objects between scans
+	node_handle_.param(&quot;tracker_merging_threshold&quot;, tracker_merging_threshold_, 1.0);
+	ROS_INFO(&quot;tracker_merging_threshold: %f&quot;, tracker_merging_threshold_);// distance threshold to match objects between scans
+	node_handle_.param(&quot;pose_estimation&quot;, pose_estimation_, false);
+	ROS_INFO(&quot;pose_estimation: %d&quot;, pose_estimation_);// whether or not to estimate pose
+	node_handle_.param(&quot;keep_alive&quot;, keep_alive_, 2);
+	ROS_INFO(&quot;keep_alive: %d&quot;, keep_alive_);// frames to keep an object
+	node_handle_.param(&quot;maximum_track_id&quot;, maximum_track_id_, 200);
+	ROS_INFO(&quot;maximum_track_id: %d&quot;, maximum_track_id_);// frames to keep an object
 
 
 
@@ -77,7 +84,8 @@ KfLidarTrackNode::KfLidarTrackNode() :
 							distance_matching_threshold_, 			//matching distance threshold
 							tracker_merging_threshold_, //tracker merging threshold
 							keep_alive_, 				//life span
-							keep_alive_));			//trace length
+							keep_alive_,
+							maximum_track_id_));			//trace length
 }
 
 KfLidarTrackNode::~KfLidarTrackNode()
</diff>
				<old_file>/*
 * kf_track.cpp
 *
 *  Created on: Nov 3, 2016
 *      Author: ne0
 */

#include &quot;ros/ros.h&quot;

#include &lt;pcl_ros/transforms.h&gt;

#include &lt;sensor_msgs/point_cloud_conversion.h&gt;
#include &lt;sensor_msgs/PointCloud.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;

#include &quot;autoware_msgs/CloudCluster.h&quot;
#include &quot;autoware_msgs/CloudClusterArray.h&quot;
#include &quot;autoware_msgs/DetectedObject.h&quot;
#include &quot;autoware_msgs/DetectedObjectArray.h&quot;

#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;jsk_rviz_plugins/Pictogram.h&gt;
#include &lt;jsk_rviz_plugins/PictogramArray.h&gt;
#include &lt;jsk_recognition_msgs/PolygonArray.h&gt;

#include &lt;vector&gt;

#include &quot;KfLidarTracker.h&quot;

class KfLidarTrackNode
{
public:
	KfLidarTrackNode();
	~KfLidarTrackNode();

private:

	ros::NodeHandle node_handle_;
	ros::Subscriber cloud_clusters_sub_;
	ros::Publisher pub_jsk_hulls_;
	ros::Publisher pub_jsk_tracked_objects_;
	ros::Publisher pub_detected_objects_;
	ros::Publisher pub_jsk_boundingboxes_;
	ros::Publisher pub_jsk_pictograms_;

	bool pose_estimation_;
	int keep_alive_;

	boost::shared_ptr&lt;KfLidarTracker&gt; tracker_ptr;

	double distance_matching_threshold_;
	double tracker_merging_threshold_;

	void CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr);
};

KfLidarTrackNode::KfLidarTrackNode() :
		node_handle_(&quot;~&quot;),
		pose_estimation_(false)
{
	cloud_clusters_sub_ = node_handle_.subscribe(&quot;/cloud_clusters_class&quot;, 10, &amp;KfLidarTrackNode::CloudClustersCallback, this);
	pub_detected_objects_ = node_handle_.advertise&lt;autoware_msgs::DetectedObjectArray&gt;( &quot;/detected_objects&quot;, 10);
	pub_jsk_tracked_objects_ = node_handle_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;/bounding_boxes_tracked&quot;,1);
	pub_jsk_hulls_ = node_handle_.advertise&lt;jsk_recognition_msgs::PolygonArray&gt;(&quot;/cluster_hulls_tracked&quot;,1);
	pub_jsk_pictograms_ = node_handle_.advertise&lt;jsk_rviz_plugins::PictogramArray&gt;(&quot;/cluster_ids_tracked&quot;,1);

	node_handle_.param(&quot;distance_matching_threshold&quot;, distance_matching_threshold_, 1.5);	ROS_INFO(&quot;distance_matching_threshold: %f&quot;, distance_matching_threshold_);// distance threshold to match objects between scans
	node_handle_.param(&quot;tracker_merging_threshold&quot;, tracker_merging_threshold_, 1.0);	ROS_INFO(&quot;tracker_merging_threshold: %f&quot;, tracker_merging_threshold_);// distance threshold to match objects between scans
	node_handle_.param(&quot;pose_estimation&quot;, pose_estimation_, false);	ROS_INFO(&quot;pose_estimation: %d&quot;, pose_estimation_);// whether or not to estimate pose
	node_handle_.param(&quot;keep_alive&quot;, keep_alive_, 2);	ROS_INFO(&quot;keep_alive: %d&quot;, keep_alive_);// frames to keep an object



	tracker_ptr = boost::shared_ptr&lt;KfLidarTracker&gt;(new KfLidarTracker(0.2f,  //dt
							0.1f, 			//acceleration_noise
							distance_matching_threshold_, 			//matching distance threshold
							tracker_merging_threshold_, //tracker merging threshold
							keep_alive_, 				//life span
							keep_alive_));			//trace length
}

KfLidarTrackNode::~KfLidarTrackNode()
{
}

void KfLidarTrackNode::CloudClustersCallback(const autoware_msgs::CloudClusterArray::Ptr&amp; in_cloud_cluster_array_ptr)
{

	autoware_msgs::CloudClusterArray final_cloud_cluster_array;
	autoware_msgs::DetectedObjectArray detected_objects;
	detected_objects.header = in_cloud_cluster_array_ptr-&gt;header;


	//std::cout &lt;&lt; &quot;Update start&quot; &lt;&lt; std::endl;
	tracker_ptr-&gt;Update(*in_cloud_cluster_array_ptr, KfLidarTracker::CentersDist);
	//std::cout &lt;&lt; &quot;Update end&quot; &lt;&lt; std::endl;

	jsk_recognition_msgs::BoundingBoxArray tracked_boxes;
	jsk_recognition_msgs::PolygonArray tracked_hulls;
	jsk_rviz_plugins::PictogramArray tracked_ids;

	tracked_hulls.header = in_cloud_cluster_array_ptr-&gt;header;
	tracked_boxes.header = in_cloud_cluster_array_ptr-&gt;header;
	for (unsigned int i = 0; i &lt; tracker_ptr-&gt;tracks_.size(); i++)
	{
		//BBOXES
		jsk_recognition_msgs::BoundingBox tracked_box;
		tracked_box = tracker_ptr-&gt;tracks_[i].GetCluster().bounding_box;
		tracked_box.header = in_cloud_cluster_array_ptr-&gt;header;
		tracked_box.label = tracker_ptr-&gt;tracks_[i].track_id;
		tracked_box.value = tracker_ptr-&gt;tracks_[i].track_id;
		//tracker_ptr-&gt;tracks_[i]-&gt;trace.end();//calculate orientation
		tracked_boxes.boxes.push_back(tracked_box);
		//END BBOXES

		//CONVEx HULL
		geometry_msgs::PolygonStamped hull;
		hull = tracker_ptr-&gt;tracks_[i].GetCluster().convex_hull;
		//std::cout &lt;&lt; &quot;hull size:&quot; &lt;&lt; hull.polygon.points.size() &lt;&lt; std::endl;
		hull.header = in_cloud_cluster_array_ptr-&gt;header;
		tracked_hulls.polygons.push_back(hull);
		tracked_hulls.labels.push_back(tracker_ptr-&gt;tracks_[i].track_id);

		//END HULLS

		//PICTO
		jsk_rviz_plugins::Pictogram tracked_pictogram;
		tracked_pictogram.header = in_cloud_cluster_array_ptr-&gt;header;

		tracked_pictogram.mode = tracked_pictogram.STRING_MODE;
		tracked_pictogram.pose.position.x = tracker_ptr-&gt;tracks_[i].GetCluster().max_point.point.x;
		tracked_pictogram.pose.position.y = tracker_ptr-&gt;tracks_[i].GetCluster().max_point.point.y;
		tracked_pictogram.pose.position.z = tracker_ptr-&gt;tracks_[i].GetCluster().max_point.point.z;
		tf::Quaternion quat(0.0, -0.7, 0.0, 0.7);
		tf::quaternionTFToMsg(quat, tracked_pictogram.pose.orientation);
		tracked_pictogram.size = 4;
		std_msgs::ColorRGBA color;
		color.a = 1; color.r = 1; color.g = 1; color.b = 1;
		tracked_pictogram.color = color;
		tracked_pictogram.character = std::to_string( tracker_ptr-&gt;tracks_[i].track_id );
		tracked_ids.header = in_cloud_cluster_array_ptr-&gt;header;
		tracked_ids.pictograms.push_back(tracked_pictogram);
		//PICTO
	}

	pub_jsk_tracked_objects_.publish(tracked_boxes);
	pub_jsk_hulls_.publish(tracked_hulls);
	pub_jsk_pictograms_.publish(tracked_ids);

	//autoware_msgs::DetectedObjectArray detected_objects;
	//detected_objects.header = in_cloud_cluster_array_ptr-&gt;header;
	//for (auto i = in_cloud_cluster_array_ptr-&gt;clusters.begin(); i != in_cloud_cluster_array_ptr-&gt;clusters.end(); i++)
	//{
	//	autoware_msgs::DetectedObject detected_object;
	//	detected_object.header 		= i-&gt;header;
	//	detected_object.id 			= i-&gt;id;
	//	detected_object.label 		= i-&gt;label;
	//	detected_object.dimensions 	= i-&gt;bounding_box.dimensions;
	//	detected_object.pose 		= i-&gt;bounding_box.pose;

	//	detected_objects.objects.push_back(detected_object);
	//}
	//detected_objects_pub_.publish(detected_objects);
}

int main(int argc, char **argv)
{

	ros::init(argc, argv, &quot;kf_lidar_track&quot;);
	KfLidarTrackNode node;
	ros::spin();

	return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/sensing/filters/packages/points_preprocessor/nodes/ground_filter/ground_filter.cpp" new_path="ros/src/sensing/filters/packages/points_preprocessor/nodes/ground_filter/ground_filter.cpp">
				<diff>@@ -205,7 +205,7 @@ void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::Point
 				}
 				else
 				{//this should never execute due to Sensor specs
-					ROS_ERROR(&quot;GroundFilter: Division by Zero avoided on pair_angle&quot;);
+					ROS_WARN(&quot;GroundFilter: Division by Zero avoided on pair_angle&quot;);
 					pair_angle = 0;
 				}
 				if (
</diff>
				<old_file>/*
 * ground_filter.cpp
 *
 * Created on	: May 19, 2017
 * Author	: Patiphon Narksri
 * @brief Below algorithm is documented here https://github.com/CPFL/Autoware-Manuals/tree/master/en/pdfs/ground_filter.pdf.
 */
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;opencv/cv.h&gt;

enum Label
{
	GROUND,
	VERTICAL,
	UNKNOWN //Initial state, not classified
};

class GroundFilter
{
public:
	
	GroundFilter();

private:

	ros::NodeHandle node_handle_;
	ros::Subscriber points_node_sub_;
	ros::Publisher groundless_points_pub_;
	ros::Publisher ground_points_pub_;

	std::string point_topic_;
	int 		sensor_model_;
	double 		sensor_height_;
	double 		max_slope_;
	int 		min_point_;
	double 		clipping_thres_;
	double 		gap_thres_;
	double		point_distance_;
	bool		floor_removal_;

	int 		vertical_res_;
	int 		horizontal_res_;
	double 		limiting_ratio_;
	cv::Mat 	index_map_;
	Label 		class_label_[64];

	boost::chrono::high_resolution_clock::time_point t1_;
	boost::chrono::high_resolution_clock::time_point t2_;
	boost::chrono::nanoseconds elap_time_;

	const int 	DEFAULT_HOR_RES = 2000;

	void InitLabelArray(int in_model);
	void InitDepthMap(int in_width);
	void PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				int in_indices[], int &amp;in_out_index_size, 
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud);


	void VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg);
	void FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points);

};

GroundFilter::GroundFilter() : node_handle_(&quot;~&quot;)
{
	ROS_INFO(&quot;Inititalizing Ground Filter...&quot;);
	node_handle_.param&lt;std::string&gt;(&quot;point_topic&quot;, point_topic_, &quot;/points_raw&quot;);
	ROS_INFO(&quot;Input Point Cloud: %s&quot;, point_topic_.c_str());
 	node_handle_.param(&quot;remove_floor&quot;,  floor_removal_,  true);
 	ROS_INFO(&quot;Floor Removal: %d&quot;, floor_removal_);
	node_handle_.param(&quot;sensor_model&quot;, sensor_model_, 64);
	ROS_INFO(&quot;Sensor Model: %d&quot;, sensor_model_);
	node_handle_.param(&quot;sensor_height&quot;, sensor_height_, 1.72);
	ROS_INFO(&quot;Sensor Height: %f&quot;, sensor_height_);
	node_handle_.param(&quot;max_slope&quot;, max_slope_, 20.0);
	ROS_INFO(&quot;Max Slope: %f&quot;, max_slope_);
	node_handle_.param(&quot;point_distance&quot;, point_distance_, 0.05);
	ROS_INFO(&quot;Point Distance: %f&quot;, point_distance_);
	node_handle_.param(&quot;min_point&quot;, min_point_, 3);
	ROS_INFO(&quot;Min Points: %d&quot;, min_point_);
	node_handle_.param(&quot;clipping_thres&quot;, clipping_thres_, 0.5);
	ROS_INFO(&quot;Lower Clipping Threshold: %f&quot;, clipping_thres_);
	node_handle_.param(&quot;gap_thres&quot;, gap_thres_, 0.5);
	ROS_INFO(&quot;Point Gap Threshold: %f&quot;, gap_thres_);

	std::string no_ground_topic, ground_topic;
	node_handle_.param&lt;std::string&gt;(&quot;no_ground_point_topic&quot;, no_ground_topic, &quot;/points_no_ground&quot;);
	ROS_INFO(&quot;No Ground Output Point Cloud: %s&quot;, no_ground_topic.c_str());
	node_handle_.param&lt;std::string&gt;(&quot;ground_point_topic&quot;, ground_topic, &quot;/points_ground&quot;);
	ROS_INFO(&quot;Only Ground Output Point Cloud: %s&quot;, ground_topic.c_str());

	int default_horizontal_res;
	switch(sensor_model_)
	{
		case 64:
			default_horizontal_res = 2083;
			break;
		case 32:
			default_horizontal_res = 2250;
			break;
		case 16:
			default_horizontal_res = 1800;
			break;
		default:
			default_horizontal_res = DEFAULT_HOR_RES;
			break;
	}
	node_handle_.param(&quot;horizontal_res&quot;, horizontal_res_, default_horizontal_res);

	points_node_sub_ = node_handle_.subscribe(point_topic_, 2, &amp;GroundFilter::VelodyneCallback, this);
	groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 2);
	ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 2);

	vertical_res_ = sensor_model_;
	InitLabelArray(sensor_model_);
	limiting_ratio_ = tan(max_slope_*M_PI/180);

}

void GroundFilter::InitLabelArray(int in_model)
{
	for(int a = 0; a &lt; vertical_res_; a++)
	{
		class_label_[a] = UNKNOWN;
	}
}

void GroundFilter::InitDepthMap(int in_width)
{
	const int mOne = -1;
	index_map_ = cv::Mat_&lt;int&gt;(vertical_res_, in_width, mOne);
}

void GroundFilter::PublishPointCloud(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
				int in_indices[], int &amp;in_out_index_size, 
				pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;in_cloud)
{
	velodyne_pointcloud::PointXYZIR point;
	for (int i = 0; i &lt; in_out_index_size; i++)
	{
		point.x = in_cloud_msg-&gt;points[in_indices[i]].x;
		point.y = in_cloud_msg-&gt;points[in_indices[i]].y;
		point.z = in_cloud_msg-&gt;points[in_indices[i]].z;
		point.intensity = in_cloud_msg-&gt;points[in_indices[i]].intensity;
		point.ring = in_cloud_msg-&gt;points[in_indices[i]].ring;
		in_cloud.push_back(point);
	}
	in_out_index_size = 0;	
}

void GroundFilter::FilterGround(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg,
			pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_groundless_points,
			pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; &amp;out_ground_points)
{

	velodyne_pointcloud::PointXYZIR point;

	//This line is not necessary
	//horizontal_res_ = int(in_cloud_msg-&gt;points.size() / vertical_res_);
	InitDepthMap(horizontal_res_);

	for (size_t i = 0; i &lt; in_cloud_msg-&gt;points.size(); i++)
	{
		double u = atan2(in_cloud_msg-&gt;points[i].y,in_cloud_msg-&gt;points[i].x) * 180/M_PI;
		if (u &lt; 0) { u = 360 + u; }
		int column = horizontal_res_ - (int)((double)horizontal_res_ * u / 360.0) - 1;
		int row = vertical_res_ - 1 - in_cloud_msg-&gt;points[i].ring;
		index_map_.at&lt;int&gt;(row, column) = i;
	}
	
	for (int i = 0; i &lt; horizontal_res_; i++)
	{
		Label point_class[vertical_res_];
		int unknown_index[vertical_res_];
		int point_index[vertical_res_];
		int unknown_index_size = 0;
		int point_index_size = 0;
		double z_ref = 0;
		double r_ref = 0;
		std::copy(class_label_, class_label_ + vertical_res_, point_class); 

		for (int j = vertical_res_ - 1; j &gt;= 0; j--)
		{
			if (index_map_.at&lt;int&gt;(j,i) &gt; -1 &amp;&amp; point_class[j] == UNKNOWN)
			{
				double x0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].x;
				double y0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].y;
				double z0 = in_cloud_msg-&gt;points[index_map_.at&lt;int&gt;(j, i)].z;
				double r0 = sqrt(x0*x0 + y0*y0);
				double r_diff = r0 - r_ref;
				double z_diff = fabs(z0 - z_ref);
				double pair_angle;

				if (r_diff != 0.)
				{
					pair_angle = z_diff/r_diff;
				}
				else
				{//this should never execute due to Sensor specs
					ROS_ERROR(&quot;GroundFilter: Division by Zero avoided on pair_angle&quot;);
					pair_angle = 0;
				}
				if (
					 (	(pair_angle &gt; 0 &amp;&amp; pair_angle &lt; limiting_ratio_)
						&amp;&amp; z_diff &lt; gap_thres_
						&amp;&amp; z0 &lt; clipping_thres_
					 )
					|| point_index_size == 0
					)
				{
					r_ref = r0;
					z_ref = z0;
					point_index[point_index_size] = j;
					point_index_size++;
				}
				else
				{
					if (point_index_size &gt; min_point_)
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.x = in_cloud_msg-&gt;points[index].x;
							point.y = in_cloud_msg-&gt;points[index].y;
							point.z = in_cloud_msg-&gt;points[index].z;
							point.intensity = in_cloud_msg-&gt;points[index].intensity;
							point.ring = in_cloud_msg-&gt;points[index].ring;
							out_ground_points.push_back(point);
							point_class[point_index[m]] = GROUND;
						}
						point_index_size = 0;
					}
					else
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.z = in_cloud_msg-&gt;points[index].z;
							if (point.z &gt; clipping_thres_ - sensor_height_)
							{
								point.x = in_cloud_msg-&gt;points[index].x;
								point.y = in_cloud_msg-&gt;points[index].y;
								point.intensity = in_cloud_msg-&gt;points[index].intensity;
								point.ring = in_cloud_msg-&gt;points[index].ring;
								out_groundless_points.push_back(point);
								point_class[point_index[m]] = VERTICAL;
							}
							else
							{
								unknown_index[unknown_index_size] = index;
								unknown_index_size++;
							}
						}
						point_index_size = 0;
					}
					//These line were missing
					r_ref = r0;
					z_ref = z0;
					point_index[point_index_size] = j;
					point_index_size++;
				}
			}
			if (j == 0)
			{
				if (point_index_size != 0)
				{
					if (point_index_size &gt; min_point_)
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.x = in_cloud_msg-&gt;points[index].x;
							point.y = in_cloud_msg-&gt;points[index].y;
							point.z = in_cloud_msg-&gt;points[index].z;
							point.intensity = in_cloud_msg-&gt;points[index].intensity;
							point.ring = in_cloud_msg-&gt;points[index].ring;
							out_ground_points.push_back(point);
							point_class[point_index[m]] = GROUND;
						}
						point_index_size = 0;
					}
					else
					{
						for (int m = 0; m &lt; point_index_size; m++)
						{
							int index = index_map_.at&lt;int&gt;(point_index[m],i);
							point.z = in_cloud_msg-&gt;points[index].z;
							if (point.z &gt; clipping_thres_ - sensor_height_)
							{
								point.x = in_cloud_msg-&gt;points[index].x;
								point.y = in_cloud_msg-&gt;points[index].y;
								point.intensity = in_cloud_msg-&gt;points[index].intensity;
								point.ring = in_cloud_msg-&gt;points[index].ring;
								out_groundless_points.push_back(point);
								point_class[point_index[m]] = VERTICAL;
							}
							else
							{
								unknown_index[unknown_index_size] = index;
								unknown_index_size++;
							}
						}
						point_index_size = 0;
					}//end else
				}//end if (point_index_size != 0)

				double centroid = 0;
				int cluster_index[vertical_res_];
				int cluster_index_size = 0;
				for (int m = unknown_index_size - 1; m &gt;= 0; m--)
				{
					double x0 = in_cloud_msg-&gt;points[unknown_index[m]].x;
					double y0 = in_cloud_msg-&gt;points[unknown_index[m]].y;
					double r0 = sqrt(x0*x0 + y0*y0);
					double r_diff = fabs(r0 - centroid);
					if ((r_diff &lt; point_distance_) || cluster_index_size == 0)
					{
						cluster_index[cluster_index_size] = unknown_index[m];
						cluster_index_size++;
						centroid = r0;
						if (m == 0)
						{
							if(cluster_index_size &gt; 1)
							{
								PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
							}
							else
							{
								PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
							}
						}
					}
					else
					{
						if(cluster_index_size &gt; 1)
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
						}
						else
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
						}
						cluster_index[cluster_index_size] = unknown_index[m];
						cluster_index_size++;
						centroid = r0;
					}
					if (m == 0)
					{
						if(cluster_index_size &gt; 1)
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_groundless_points);
						}
						else
						{
							PublishPointCloud(in_cloud_msg, cluster_index, cluster_index_size, out_ground_points);
						}
					}
				}//end for (int m = unknown_index_size - 1; m &gt;= 0; m--)
			}//end if (j == 0)
		}
	}

}

void GroundFilter::VelodyneCallback(const pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt;::ConstPtr &amp;in_cloud_msg)
{

	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; vertical_points;
	pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; ground_points;
	vertical_points.header = in_cloud_msg-&gt;header;
	ground_points.header = in_cloud_msg-&gt;header;
	vertical_points.clear();
	ground_points.clear();

	FilterGround(in_cloud_msg, vertical_points, ground_points);

	if (!floor_removal_)
	{
		vertical_points = *in_cloud_msg;
	} 
	
	groundless_points_pub_.publish(vertical_points);
	ground_points_pub_.publish(ground_points);

}

int main(int argc, char **argv)
{

	ros::init(argc, argv, &quot;ground_filter&quot;);
	GroundFilter node;
	ros::spin();

	return 0;

}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="ece16aae14bf5286ccb705f62be9dda624883155" fix_time="0,0">
		<msg>fixed cmake and package.xml for libvectormap
moved headers into include/libvectormap since otherwise this otherwise can conflict with other files elsewhere.</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/lib/libvectormap/include/Math.h" new_path="ros/src/computing/perception/detection/lib/libvectormap/include/libvectormap/Math.h">
				<diff></diff>
				<old_file></old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/lib/libvectormap/include/vector_map.h" new_path="ros/src/computing/perception/detection/lib/libvectormap/include/libvectormap/vector_map.h">
				<diff></diff>
				<old_file></old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/lib/libvectormap/src/vector_map.cpp" new_path="ros/src/computing/perception/detection/lib/libvectormap/src/vector_map.cpp">
				<diff>@@ -1,12 +1,9 @@
-//#include &quot;ros/ros.h&quot;
-//#include &quot;std_msgs/String.h&quot;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;math.h&gt;
-#include &quot;vector_map.h&quot;
+#include &quot;libvectormap/vector_map.h&quot;
 #include &lt;vector&gt;
 #include &lt;map&gt;
-#include &lt;tf/transform_listener.h&gt;
 
 void VectorMap::load_points(const vector_map::PointArray&amp; msg)
 {
</diff>
				<old_file>//#include &quot;ros/ros.h&quot;
//#include &quot;std_msgs/String.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;math.h&gt;
#include &quot;vector_map.h&quot;
#include &lt;vector&gt;
#include &lt;map&gt;
#include &lt;tf/transform_listener.h&gt;

void VectorMap::load_points(const vector_map::PointArray&amp; msg)
{
  for (const auto&amp; point : msg.data)
    {
      Point tmp;
      tmp.pid	 = point.pid;
      tmp.b      = point.b;
      tmp.l      = point.l;
      tmp.h      = point.h;
      tmp.bx	 = point.ly;
      tmp.ly	 = point.bx;
      tmp.ref	 = point.ref;
      tmp.mcode1 = point.mcode1;
      tmp.mcode2 = point.mcode2;
      tmp.mcode3 = point.mcode3;
      points.insert( std::map&lt;int, Point&gt;::value_type(tmp.pid, tmp) );
    }
  std::cout &lt;&lt; &quot;load points complete. element num: &quot; &lt;&lt; points.size() &lt;&lt; std::endl;
} /* void VectorMap::load_points() */


void VectorMap::load_lines(const vector_map::LineArray&amp; msg)
{
  for (const auto&amp; line : msg.data)
    {
      Line tmp;
      tmp.lid  = line.lid;
      tmp.bpid = line.bpid;
      tmp.fpid = line.fpid;
      tmp.blid = line.blid;
      tmp.flid = line.flid;

      lines.insert( std::map&lt;int, Line&gt;::value_type(tmp.lid, tmp) );
    }
  std::cout &lt;&lt; &quot;load lines complete.&quot; &lt;&lt; std::endl;
} /* void VectorMap::load_lines() */


void VectorMap::load_lanes(const vector_map::LaneArray&amp; msg)
{
  for (const auto&amp; lane : msg.data)
    {
      Lane tmp;
      tmp.lnid    = lane.lnid;
      tmp.did     = lane.did;
      tmp.blid    = lane.blid;
      tmp.flid    = lane.flid;
      tmp.bnid    = lane.bnid;
      tmp.fnid    = lane.fnid;
      tmp.jct     = lane.jct;
      tmp.blid2   = lane.blid2;
      tmp.blid3   = lane.blid3;
      tmp.blid4   = lane.blid4;
      tmp.flid2   = lane.flid2;
      tmp.flid3   = lane.flid3;
      tmp.flid4   = lane.flid4;
      tmp.clossid = lane.clossid;
      tmp.span    = lane.span;
      tmp.lcnt    = lane.lcnt;
      tmp.lno     = lane.lno;

      lanes.insert( std::map&lt;int, Lane&gt;::value_type(tmp.lnid, tmp) );
    }
  std::cout &lt;&lt; &quot;load lanes complete.&quot; &lt;&lt; std::endl;
} /* void VectorMap::load_lanes() */


void VectorMap::load_vectors(const vector_map::VectorArray&amp; msg)
{
  for (const auto&amp; vector : msg.data)
    {
      Vector tmp;
      tmp.vid  = vector.vid;
      tmp.pid  = vector.pid;
      tmp.hang = vector.hang;
      tmp.vang = vector.vang;

      vectors.insert( std::map&lt;int, Vector&gt;::value_type(tmp.vid, tmp) );
    }
  std::cout &lt;&lt; &quot;load vectors complete. element num: &quot; &lt;&lt; vectors.size() &lt;&lt; std::endl;
} /* void VectorMap::load_vectors() */


void VectorMap::load_signals(const vector_map::SignalArray&amp; msg)
{
  for (const auto&amp; signal : msg.data)
    {
      Signal tmp;
      tmp.id     = signal.id;
      tmp.vid    = signal.vid;
      tmp.plid   = signal.plid;
      tmp.type   = signal.type;
      tmp.linkid = signal.linkid;

      signals.insert( std::map&lt;int, Signal&gt;::value_type(tmp.id, tmp) );
    }
  std::cout &lt;&lt; &quot;load signals complete. element num: &quot; &lt;&lt; signals.size() &lt;&lt; std::endl;
} /* void VectorMap::load_signals() */


void VectorMap::load_whitelines(const vector_map::WhiteLineArray&amp; msg)
{
  for (const auto&amp; white_line : msg.data)
    {
      WhiteLine tmp;
      tmp.id     = white_line.id;
      tmp.lid    = white_line.lid;
      tmp.width  = white_line.width;
      tmp.color  = white_line.color;
      tmp.type   = white_line.type;
      tmp.linkid = white_line.linkid;

      whitelines.insert( std::map&lt;int, WhiteLine&gt;::value_type(tmp.id, tmp) );
    }
  std::cout &lt;&lt; &quot;load whitelines complete.&quot; &lt;&lt; std::endl;
} /* void VectorMap::load_whitelines() */


void VectorMap::load_dtlanes(const vector_map::DTLaneArray&amp; msg)
{
  for (const auto&amp; dtlane : msg.data)
    {
      DTLane tmp;
      tmp.did   = dtlane.did;
      tmp.dist  = dtlane.dist;
      tmp.pid   = dtlane.pid;
      tmp.dir   = dtlane.dir;
      tmp.apara = dtlane.apara;
      tmp.r     = dtlane.r;
      tmp.slope = dtlane.slope;
      tmp.cant  = dtlane.cant;
      tmp.lw    = dtlane.lw;
      tmp.rw    = dtlane.rw;

      dtlanes.insert( std::map&lt;int, DTLane&gt;::value_type(tmp.did, tmp) );
    }
  std::cout &lt;&lt; &quot;load dtlanes complete.&quot; &lt;&lt; std::endl;
} /* void VectorMap::load_dtlanes() */

</old_file>
			</file>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp">
				<diff>@@ -9,7 +9,7 @@
 #include &lt;iostream&gt;
 #include &lt;ros/ros.h&gt;
 #include &quot;Rate.h&quot;
-#include &quot;vector_map.h&quot;
+#include &quot;libvectormap/vector_map.h&quot;
 #include &lt;tf/tf.h&gt;
 #include &lt;tf/transform_listener.h&gt;
 #include &lt;sensor_msgs/CameraInfo.h&gt;
@@ -18,7 +18,7 @@
 #include &lt;geometry_msgs/PoseStamped.h&gt;
 #include &lt;signal.h&gt;
 #include &lt;cstdio&gt;
-#include &quot;Math.h&quot;
+#include &quot;libvectormap/Math.h&quot;
 #include &lt;Eigen/Eigen&gt;
 #include &lt;autoware_msgs/Signals.h&gt;
 #include &lt;autoware_msgs/adjust_xy.h&gt;
</diff>
				<old_file>/*
 * signals.cpp
 *
 *  Created on: Apr 9, 2015
 *      Author: sujiwo
 */


#include &lt;iostream&gt;
#include &lt;ros/ros.h&gt;
#include &quot;Rate.h&quot;
#include &quot;vector_map.h&quot;
#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;signal.h&gt;
#include &lt;cstdio&gt;
#include &quot;Math.h&quot;
#include &lt;Eigen/Eigen&gt;
#include &lt;autoware_msgs/Signals.h&gt;
#include &lt;autoware_msgs/adjust_xy.h&gt;
#include &lt;vector_map/vector_map.h&gt;
#include &lt;vector_map_server/GetSignal.h&gt;
#include &lt;autoware_msgs/lane.h&gt;

static std::string camera_id_str;

static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 1000;

static int adjust_proj_x = 0;
static int adjust_proj_y = 0;

typedef struct {
  double thiX;
  double thiY;
  double thiZ;
} Angle;

static VectorMap vmap;
static Angle cameraOrientation; // camera orientation = car's orientation

static Eigen::Vector3f position;
static Eigen::Quaternionf orientation;
static  float fx,
  fy,
  imageWidth,
  imageHeight,
  cx,
  cy;
static tf::StampedTransform trf;

static bool g_use_vector_map_server; // Switch flag whether vecter-map-server function will be used
static ros::ServiceClient g_ros_client;

#define SignalLampRadius 0.3

/* Define utility class to use vector map server */
namespace
{
  class VectorMapClient
  {
  private:
    geometry_msgs::PoseStamped pose_;
    autoware_msgs::lane waypoints_;

  public:
    VectorMapClient()
    {}

    ~VectorMapClient()
    {}

    geometry_msgs::PoseStamped pose() const
    {
      return pose_;
    }

    autoware_msgs::lane waypoints() const
    {
      return waypoints_;
    }

    void set_pose(const geometry_msgs::PoseStamped&amp; pose)
    {
      pose_ = pose;
    }

    void set_waypoints(const autoware_msgs::lane&amp; waypoints)
    {
      waypoints_ = waypoints;
    }
  }; // Class VectorMapClient
} // namespace
static VectorMapClient g_vector_map_client;


/* Callback function to shift projection result */
void adjust_xyCallback (const autoware_msgs::adjust_xy::ConstPtr&amp; config_msg)
{
  adjust_proj_x = config_msg-&gt;x;
  adjust_proj_y = config_msg-&gt;y;
}

void cameraInfoCallback (const sensor_msgs::CameraInfo::ConstPtr camInfoMsg)
{
  fx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[0]);
  fy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[5]);
  imageWidth = camInfoMsg-&gt;width;
  imageHeight = camInfoMsg-&gt;height;
  cx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[2]);
  cy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[6]);
}


/* convert degree value into 0 to 360 range */
static double setDegree0to360(double val)
{
  if (val &lt; 0.0f) {
    return (val + 360.0f);
  }
  else if (360.0f &lt; val) {
    return (val - 360.0f);
  }

  return val;
}


static void get_cameraRollPitchYaw(double* roll,
                                   double* pitch,
                                   double* yaw)
{
  geometry_msgs::Pose cameraPose;
  cameraPose.position.x    = (double)(position.x());
  cameraPose.position.y    = (double)(position.y());
  cameraPose.position.z    = (double)(position.z());
  cameraPose.orientation.x = (double)(orientation.x());
  cameraPose.orientation.y = (double)(orientation.y());
  cameraPose.orientation.z = (double)(orientation.z());
  cameraPose.orientation.w = (double)(orientation.w());

  tf::Quaternion quat;

  tf::quaternionMsgToTF(cameraPose.orientation, quat);
  tf::Matrix3x3(quat).getRPY(*roll, *pitch, *yaw);

  /* convert from radian to degree */
  *roll  = setDegree0to360(*roll  * 180.0f / M_PI);
  *pitch = setDegree0to360(*pitch * 180.0f / M_PI);
  *yaw   = setDegree0to360(*yaw   * 180.0f / M_PI);
}


/*
  check if lower &lt; val &lt; upper
  This function also considers circulation
*/
static bool isRange(const double lower, const double upper, const double val)
{
  if (lower &lt;= upper) {
    if (lower &lt; val &amp;&amp; val &lt; upper) {
      return true;
    }
  }
  else {
    if (val &lt; upper || lower &lt; val) {
      return true;
    }
  }

  return false;
}


void getTransform (Eigen::Quaternionf &amp;ori, Point3 &amp;pos)
{
  static tf::TransformListener listener;

  // target_frame    source_frame
  ros::Time now = ros::Time();
  listener.waitForTransform (camera_id_str, &quot;map&quot;, now, ros::Duration(10.0));
  listener.lookupTransform (camera_id_str, &quot;map&quot;, now, trf);

  tf::Vector3 &amp;p = trf.getOrigin();
  tf::Quaternion o = trf.getRotation();
  pos.x()=p.x(); pos.y()=p.y(); pos.z()=p.z();
  ori.w()=o.w(); ori.x()=o.x(); ori.y()=o.y(); ori.z()=o.z();
}


Point3 transform (const Point3 &amp;psrc, tf::StampedTransform &amp;tfsource)
{
  tf::Vector3 pt3 (psrc.x(), psrc.y(), psrc.z());
  tf::Vector3 pt3s = tfsource * pt3;
  return Point3 (pt3s.x(), pt3s.y(), pt3s.z());
}


/*
 * Project a point from world coordinate to image plane
 */
bool project2 (const Point3 &amp;pt, int &amp;u, int &amp;v, bool useOpenGLCoord=false)
{
  float nearPlane = 1.0;
  float farPlane = 200.0;
  Point3 _pt = transform (pt, trf);
  float _u = _pt.x()*fx/_pt.z() + cx;
  float _v = _pt.y()*fy/_pt.z() + cy;

  u = static_cast&lt;int&gt;(_u);
  v = static_cast&lt;int&gt;(_v);
  if ( u &lt; 0 || imageWidth &lt; u || v &lt; 0 || imageHeight &lt; v || _pt.z() &lt; nearPlane || farPlane &lt; _pt.z() ) {
    u = -1, v = -1;
    return false;
  }

  if (useOpenGLCoord) {
    v = imageHeight - v;
  }

  return true;
}

double ConvertDegreeToRadian(double degree)
{
  return degree * M_PI / 180.0f;
}


double ConvertRadianToDegree(double radian)
{
  return radian * 180.0f / M_PI;
}


double GetSignalAngleInCameraSystem(double hang, double vang)
{
  // Fit the vector map format into ROS style
  double signal_pitch_in_map = ConvertDegreeToRadian(vang - 90);
  double signal_yaw_in_map   = ConvertDegreeToRadian(-hang + 90);

  tf::Quaternion signal_orientation_in_map_system;
  signal_orientation_in_map_system.setRPY(0, signal_pitch_in_map, signal_yaw_in_map);

  tf::Quaternion signal_orientation_in_cam_system = trf * signal_orientation_in_map_system;
  double signal_roll_in_cam;
  double signal_pitch_in_cam;
  double signal_yaw_in_cam;
  tf::Matrix3x3(signal_orientation_in_cam_system).getRPY(signal_roll_in_cam,
                                                         signal_pitch_in_cam,
                                                         signal_yaw_in_cam);

  return ConvertRadianToDegree(signal_pitch_in_cam);   // holizontal angle of camera is represented by pitch
}  // double GetSignalAngleInCameraSystem()


void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
{
  int countPoint = 0;
  autoware_msgs::Signals signalsInFrame;

  /* Get signals on the path if vecter_map_server is enabled */
  if (g_use_vector_map_server) {
    vector_map_server::GetSignal service;
    /* Set server's request */
    service.request.pose = g_vector_map_client.pose();
    service.request.waypoints = g_vector_map_client.waypoints();

    /* Get server's response*/
    if (g_ros_client.call(service)) {
      /* Reset signal data container */
      vmap.signals.clear();

      /* Newle insert signal data on the path */
      for (const auto&amp; response: service.response.objects.data) {
        if (response.id == 0)
          continue;

        Signal signal;
        signal.id = response.id;
        signal.vid = response.vid;
        signal.plid = response.plid;
        signal.type = response.type;
        signal.linkid = response.linkid;

        vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
      }
    }
  }

  for (unsigned int i=1; i&lt;=vmap.signals.size(); i++) {
    Signal signal = vmap.signals[i];
    int pid = vmap.vectors[signal.vid].pid;

    Point3 signalcenter = vmap.getPoint(pid);
    Point3 signalcenterx (signalcenter.x(), signalcenter.y(), signalcenter.z()+SignalLampRadius);

    int u, v;
    if (project2 (signalcenter, u, v, useOpenGLCoord) == true) {
      countPoint++;
      // std::cout &lt;&lt; u &lt;&lt; &quot;, &quot; &lt;&lt; v &lt;&lt; &quot;, &quot; &lt;&lt; std::endl;

      int radius;
      int ux, vx;
      project2 (signalcenterx, ux, vx, useOpenGLCoord);
      radius = (int)distance (ux, vx, u, v);

      autoware_msgs::ExtractedPosition sign;
      sign.signalId = signal.id;

      sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
      sign.v = v + adjust_proj_y; // shift project position by configuration value from runtime manager

      sign.radius = radius;
      sign.x = signalcenter.x(), sign.y = signalcenter.y(), sign.z = signalcenter.z();
      sign.hang = vmap.vectors[signal.vid].hang; // hang is expressed in [0, 360] degree
      sign.type = signal.type, sign.linkId = signal.linkid;
      sign.plId = signal.plid;

      // Get holizontal angle of signal in camera corrdinate system
      double signal_angle = GetSignalAngleInCameraSystem(vmap.vectors[signal.vid].hang + 180.0f,
                                                         vmap.vectors[signal.vid].vang + 180.0f);

      // signal_angle will be zero if signal faces to x-axis
      // Target signal should be face to -50 &lt;= z-axis (= 90 degree) &lt;= +50
      if (isRange(-50, 50, signal_angle - 90)) {
        signalsInFrame.Signals.push_back (sign);
      }
    }
  }

  signalsInFrame.header.stamp = ros::Time::now();
  pub.publish (signalsInFrame);

  // printf (&quot;There are %d out of %u signals in frame\n&quot;, countPoint, static_cast&lt;unsigned int&gt;(vmap.signals.size()));
}


void interrupt (int s)
{
  ros::shutdown();
  exit(1);
}


int main (int argc, char *argv[])
{

  ros::init(argc, argv, &quot;feat_proj&quot;, ros::init_options::NoSigintHandler);
  ros::NodeHandle rosnode;
  ros::NodeHandle private_nh(&quot;~&quot;);
  std::string cameraInfo_topic_name;
  private_nh.param&lt;std::string&gt;(&quot;camera_info_topic&quot;, cameraInfo_topic_name, &quot;/camera/camera_info&quot;);

  /* get camera ID */
  camera_id_str = cameraInfo_topic_name;
  camera_id_str.erase(camera_id_str.find(&quot;/camera/camera_info&quot;));
  if (camera_id_str == &quot;/&quot;) {
    camera_id_str = &quot;camera&quot;;
  }
  
  /* Get Flag wheter vecter_map_server function will be used  */
  private_nh.param&lt;bool&gt;(&quot;use_path_info&quot;, g_use_vector_map_server, false);

  /* load vector map */
  ros::Subscriber sub_point     = rosnode.subscribe(&quot;vector_map_info/point&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_points,
                                                    &amp;vmap);
  ros::Subscriber sub_line      = rosnode.subscribe(&quot;vector_map_info/line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lines,
                                                    &amp;vmap);
  ros::Subscriber sub_lane      = rosnode.subscribe(&quot;vector_map_info/lane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lanes,
                                                    &amp;vmap);
  ros::Subscriber sub_vector    = rosnode.subscribe(&quot;vector_map_info/vector&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_vectors,
                                                    &amp;vmap);
  ros::Subscriber sub_signal    = rosnode.subscribe(&quot;vector_map_info/signal&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_signals,
                                                    &amp;vmap);
  ros::Subscriber sub_whiteline = rosnode.subscribe(&quot;vector_map_info/white_line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_whitelines,
                                                    &amp;vmap);
  ros::Subscriber sub_dtlane    = rosnode.subscribe(&quot;vector_map_info/dtlane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_dtlanes,
                                                    &amp;vmap);

  /* wait until loading all vector map is completed */
  ros::Rate wait_rate(1);
  while(vmap.points.empty() || vmap.lines.empty() || vmap.whitelines.empty() ||
        vmap.lanes.empty() || vmap.dtlanes.empty() || vmap.vectors.empty() || vmap.signals.empty())
    {
      ros::spinOnce();
      wait_rate.sleep();
    }

  vmap.loaded = true;
  std::cout &lt;&lt; &quot;all vector map loaded.&quot; &lt;&lt; std::endl;

  ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
  ros::Subscriber adjust_xySubscriber  = rosnode.subscribe(&quot;/config/adjust_xy&quot;, 100, adjust_xyCallback);
  ros::Subscriber current_pose_subscriber;
  ros::Subscriber waypoint_subscriber;
  if (g_use_vector_map_server) {
    /* Create subscribers which deliver informations requested by server */
    current_pose_subscriber = rosnode.subscribe(&quot;/current_pose&quot;, 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
    waypoint_subscriber     = rosnode.subscribe(&quot;/final_waypoints&quot;, 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);

    /* Create ros client to use Server-Client communication */
    g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;(&quot;vector_map_server/get_signal&quot;);
  }

  ros::Publisher  signalPublisher      = rosnode.advertise &lt;autoware_msgs::Signals&gt; (&quot;roi_signal&quot;, 100);
  signal (SIGINT, interrupt);

  Rate loop (25);
  while (true) {

    ros::spinOnce();

    try {
      getTransform (orientation, position);
    } catch (tf::TransformException &amp;exc) {
    }

    echoSignals2 (signalPublisher, false);
    loop.sleep();
  }


}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="1ef267b18f1164562ca1ad5ca423aefb0d7ae768" fix_time="17,77824">
		<msg>Fixed forgetting to rename(state_machine node to decision_maker node)</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/cross_road_area.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/cross_road_area.hpp">
				<diff>@@ -8,7 +8,7 @@
 
 #include &lt;autoware_msgs/lane.h&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 #define CROSS_ROAD 3232
 class CrossRoadArea
</diff>
				<old_file>#ifndef __CROSS_ROAD_AREA_HPP
#define __CROSS_ROAD_AREA_HPP

#include &lt;vector&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;

#include &lt;autoware_msgs/lane.h&gt;

namespace state_machine
{
#define CROSS_ROAD 3232
class CrossRoadArea
{
public:
  int id;
  int area_id;
  std::vector&lt;geometry_msgs::Point&gt; points;

  jsk_recognition_msgs::BoundingBox bbox;

  CrossRoadArea(void)
  {
    id = 0;
    area_id = 0;
    points.clear();
  }

  static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
                                             std::vector&lt;CrossRoadArea&gt; &amp;intersects);
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/state_machine_node.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp">
				<diff>@@ -1,5 +1,5 @@
-#ifndef __STATE_MACHINE_NODE__
-#define __STATE_MACHINE_NODE__
+#ifndef __DECISION_MAKER_NODE__
+#define __DECISION_MAKER_NODE__
 
 #include &lt;unordered_map&gt;
 
@@ -20,12 +20,18 @@
 
 #include &lt;geometry_msgs/Point.h&gt;
 
+// lib
+#include &lt;euclidean_space.hpp&gt;
+#include &lt;state.hpp&gt;
+#include &lt;state_context.hpp&gt;
+
 #include &lt;cross_road_area.hpp&gt;
 
+
 //#include &lt;dynamic_reconfigure/server.h&gt;
-//#include &lt;state_machine/state_machineConfig.h&gt;
+//#include &lt;decision_maker/decision_makerConfig.h&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 enum class EControl
 {
@@ -46,7 +52,7 @@ inline double mps2kmph(double _mpsval)
   return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
 }
 
-class StateMachineNode
+class DecisionMakerNode
 {
 private:
   ros::NodeHandle nh_;
@@ -124,19 +130,19 @@ private:
 
   // for ros dynamic reconfigure
   // Currently. this feature is not working.
-  // static void callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level);
+  // static void callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level);
 
   // in near future, these function will be deprecate
   CrossRoadArea *findClosestCrossRoad(void);
 
 public:
-  StateContext *ctx;
+  state_machine::StateContext *ctx;
 
-  StateMachineNode(int argc, char **argv)
+  DecisionMakerNode(int argc, char **argv)
   {
     SimulationMode = false;
 
-    ctx = new StateContext();
+    ctx = new state_machine::StateContext();
     this-&gt;initROS(argc, argv);
 
     vector_map_init = false;
@@ -148,6 +154,6 @@ public:
   void run(void);
 };
 
-}  // namespace state_machine
+}  // namespace decision_maker
 
 #endif
</diff>
				<old_file>#ifndef __STATE_MACHINE_NODE__
#define __STATE_MACHINE_NODE__

#include &lt;unordered_map&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;

//#include &lt;vector_map_server/GetCrossRoad.h&gt;

#include &lt;vector_map_msgs/AreaArray.h&gt;
#include &lt;vector_map_msgs/CrossRoadArray.h&gt;
#include &lt;vector_map_msgs/LineArray.h&gt;
#include &lt;vector_map_msgs/PointArray.h&gt;

#include &lt;geometry_msgs/Point.h&gt;

#include &lt;cross_road_area.hpp&gt;

//#include &lt;dynamic_reconfigure/server.h&gt;
//#include &lt;state_machine/state_machineConfig.h&gt;

namespace state_machine
{
enum class EControl
{
  KEEP = -1,
  STOP = 1,
  DECELERATE = 2,
  ACCELERATE = 3,
  OTHERS = 4,
};

inline bool hasvMap(void)
{
  return true;
}

inline double mps2kmph(double _mpsval)
{
  return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
}

class StateMachineNode
{
private:
  ros::NodeHandle nh_;
  // Publishers
  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
  // Subscribers
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;

  // ROS Messages
  std_msgs::String state_string_msg;
  geometry_msgs::PoseStamped current_pose_;

  jsk_rviz_plugins::OverlayText state_text_msg;
  autoware_msgs::lane current_finalwaypoints_;

  std::vector&lt;geometry_msgs::Point&gt; inside_points_;

  vector_map_msgs::AreaArray vMap_Areas;
  vector_map_msgs::PointArray vMap_Points;
  vector_map_msgs::LineArray vMap_Lines;
  vector_map_msgs::CrossRoadArray vMap_CrossRoads;

  // Current way/behavior status
  double current_velocity_;
  double average_velocity_;
  int CurrentTrafficlight;
  CrossRoadArea *ClosestArea_;
  std::string CurrentStateName;
  std::string TextOffset;
  std::vector&lt;CrossRoadArea&gt; intersects;

  // for vectormap server
  // ros::ServiceClient cross_road_cli;
  // vector_map_server::GetCrossRoad cross_road_srv;

  // initialization flags for initialized by callback
  bool vector_map_init;
  bool vMap_Areas_flag;
  bool vMap_Points_flag;
  bool vMap_Lines_flag;
  bool vMap_CrossRoads_flag;
  bool SimulationMode;

  // initialization method
  void initROS(int argc, char **argv);
  void initVectorMap(void);
  void initStateMsgs(void);
  bool initVectorMapClient(void);

  // looping method
  void update(void);
  void update_msgs(void);
  void update_pubsub(void);
  void displayMarker(void);

  //
  bool isInsideArea(geometry_msgs::Point pt);
  bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);

  double calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);

  // callback by topic subscribing
  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg);
  void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
  void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
  void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);

  void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
  void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
  void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
  void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);

  // for ros dynamic reconfigure
  // Currently. this feature is not working.
  // static void callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level);

  // in near future, these function will be deprecate
  CrossRoadArea *findClosestCrossRoad(void);

public:
  StateContext *ctx;

  StateMachineNode(int argc, char **argv)
  {
    SimulationMode = false;

    ctx = new StateContext();
    this-&gt;initROS(argc, argv);

    vector_map_init = false;
    vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;

    ClosestArea_ = nullptr;
  }

  void run(void);
};

}  // namespace state_machine

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/cross_road_area.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/cross_road_area.cpp">
				<diff>@@ -1,7 +1,7 @@
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;euclidean_space.hpp&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 #define TARGET_WAYPOINTS_NUM 15  // need to change rosparam
 CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
</diff>
				<old_file>#include &lt;cross_road_area.hpp&gt;
#include &lt;euclidean_space.hpp&gt;

namespace state_machine
{
#define TARGET_WAYPOINTS_NUM 15  // need to change rosparam
CrossRoadArea *CrossRoadArea::findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
                                                   std::vector&lt;CrossRoadArea&gt; &amp;intersects)
{
  CrossRoadArea *_area = nullptr;

  euclidean_space::point _pa;
  euclidean_space::point _pb;

  double _min_distance = DBL_MAX;

  int _label = 1;

  if (!_finalwaypoints.waypoints.empty())
  {
    _pa.x = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
    _pa.y = _finalwaypoints.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.y;
    _pa.z = 0.0;
  }

  for (size_t i = 0; i &lt; intersects.size(); i++)
  {
    _pb.x = intersects[i].bbox.pose.position.x;
    _pb.y = intersects[i].bbox.pose.position.y;

    _pb.z = 0.0;

    double __temp_dis = euclidean_space::EuclideanSpace::find_distance(&amp;_pa, &amp;_pb);

    intersects[i].bbox.label = 0;
    if (_min_distance &gt;= __temp_dis)
    {
      _area = &amp;intersects[i];
      _min_distance = __temp_dis;  //
    }
  }

  if (_area)
  {
    _area-&gt;bbox.label = 3;
  }

  return _area;
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node.cpp">
				<diff>@@ -10,8 +10,7 @@
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
 
-#include &lt;state_machine_node.hpp&gt;
-
+#include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
 
 #include &lt;autoware_msgs/lane.h&gt;
@@ -25,14 +24,14 @@
 
 // for dynamic reconfigure
 //#include &lt;dynamic_reconfigure/server.h&gt;
-//#include &lt;state_machine/state_machineConfig.h&gt;
+//#include &lt;decision_maker/decision_makerConfig.h&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 #define DOUBLE_MAX 1.7976931348623158e308
 #define TARGET_WAYPOINTS_NUM 14
 
-CrossRoadArea *StateMachineNode::findClosestCrossRoad(void)
+CrossRoadArea *DecisionMakerNode::findClosestCrossRoad(void)
 {
   CrossRoadArea *_area = nullptr;
 
@@ -75,7 +74,7 @@ CrossRoadArea *StateMachineNode::findClosestCrossRoad(void)
   return _area;
 }
 
-bool StateMachineNode::isInsideArea(geometry_msgs::Point pt)
+bool DecisionMakerNode::isInsideArea(geometry_msgs::Point pt)
 {
   // simply implementation
   //
@@ -98,30 +97,30 @@ bool StateMachineNode::isInsideArea(geometry_msgs::Point pt)
   return false;
 }
 
-void StateMachineNode::initStateMsgs(void)
+void DecisionMakerNode::initStateMsgs(void)
 {
 }
 
-void StateMachineNode::initROS(int argc, char **argv)
+void DecisionMakerNode::initROS(int argc, char **argv)
 {
   // status subscriber
-  Subs[&quot;current_pose&quot;] = nh_.subscribe(&quot;current_pose&quot;, 20, &amp;StateMachineNode::callbackFromCurrentPose, this);
+  Subs[&quot;current_pose&quot;] = nh_.subscribe(&quot;current_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
   Subs[&quot;current_velocity&quot;] =
-      nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;StateMachineNode::callbackFromCurrentVelocity, this);
-  Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;StateMachineNode::callbackFromLightColor, this);
-  Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;StateMachineNode::callbackFromPointsRaw, this);
-  Subs[&quot;final_waypoints&quot;] = nh_.subscribe(&quot;final_waypoints&quot;, 100, &amp;StateMachineNode::callbackFromFinalWaypoint, this);
-  Subs[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;StateMachineNode::callbackFromTwistCmd, this);
+      nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
+  Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+  Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
+  Subs[&quot;final_waypoints&quot;] = nh_.subscribe(&quot;final_waypoints&quot;, 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
+  Subs[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
 
   // vector map subscriber
   Subs[&quot;vector_map_area&quot;] =
-      nh_.subscribe(&quot;/vector_map_info/area&quot;, 1, &amp;StateMachineNode::callbackFromVectorMapArea, this);
+      nh_.subscribe(&quot;/vector_map_info/area&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
   Subs[&quot;vector_map_point&quot;] =
-      nh_.subscribe(&quot;/vector_map_info/point&quot;, 1, &amp;StateMachineNode::callbackFromVectorMapPoint, this);
+      nh_.subscribe(&quot;/vector_map_info/point&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
   Subs[&quot;vector_map_line&quot;] =
-      nh_.subscribe(&quot;/vector_map_info/line&quot;, 1, &amp;StateMachineNode::callbackFromVectorMapLine, this);
+      nh_.subscribe(&quot;/vector_map_info/line&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
   Subs[&quot;vector_map_crossroad&quot;] =
-      nh_.subscribe(&quot;/vector_map_info/cross_road&quot;, 1, &amp;StateMachineNode::callbackFromVectorMapCrossRoad, this);
+      nh_.subscribe(&quot;/vector_map_info/cross_road&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
 
   // pub
   Pubs[&quot;state&quot;] = nh_.advertise&lt;std_msgs::String&gt;(&quot;state&quot;, 1);
@@ -135,8 +134,8 @@ void StateMachineNode::initROS(int argc, char **argv)
 
 #if 0
   // dynamic reconfigure
-  dynamic_reconfigure::Server&lt;state_machine::state_machineConfig&gt; dr_server;
-  dynamic_reconfigure::Server&lt;state_machine::state_machineConfig&gt;::CallbackType dr_server_f;
+  dynamic_reconfigure::Server&lt;decision_maker::decision_makerConfig&gt; dr_server;
+  dynamic_reconfigure::Server&lt;decision_maker::decision_makerConfig&gt;::CallbackType dr_server_f;
 
   dr_server_f = boost::bind(&amp;callbackFromDynamicReconfigure, _1, _2);
   dr_server.setCallback(dr_server_f);
@@ -170,7 +169,7 @@ void StateMachineNode::initROS(int argc, char **argv)
   }
 }
 
-void StateMachineNode::run(void)
+void DecisionMakerNode::run(void)
 {
   ros::Rate loop_rate(0.3);
 
@@ -187,13 +186,13 @@ void StateMachineNode::run(void)
   }
 }
 
-void StateMachineNode::update_pubsub(void)
+void DecisionMakerNode::update_pubsub(void)
 {
   // if state machine require to re-subscribe topic,
   // this function will re-definition subscriber.
 }
 
-void StateMachineNode::initVectorMap(void)
+void DecisionMakerNode::initVectorMap(void)
 {
   if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
   {
@@ -258,7 +257,7 @@ void StateMachineNode::initVectorMap(void)
   }
 }
 
-void StateMachineNode::displayMarker(void)
+void DecisionMakerNode::displayMarker(void)
 {
   // vector_map init
   // parse vectormap
@@ -327,7 +326,7 @@ void StateMachineNode::displayMarker(void)
   marker_array.markers.clear();
 }
 
-void StateMachineNode::update_msgs(void)
+void DecisionMakerNode::update_msgs(void)
 {
   if (ctx)
   {
@@ -350,7 +349,7 @@ void StateMachineNode::update_msgs(void)
     std::cerr &lt;&lt; &quot;ctx is not found &quot; &lt;&lt; std::endl;
 }
 
-bool StateMachineNode::initVectorMapClient()
+bool DecisionMakerNode::initVectorMapClient()
 {
 #ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
   // server
@@ -367,7 +366,7 @@ bool StateMachineNode::initVectorMapClient()
 #endif
 }
 
-bool StateMachineNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
+bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
                                                     const geometry_msgs::PoseStamped &amp;pose_msg)
 {
 #ifdef USE_VMAP_SERVER  // this is not successfully run
@@ -392,7 +391,7 @@ bool StateMachineNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;l
 #endif
 }
 
-double StateMachineNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
+double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
                                                const geometry_msgs::PoseStamped &amp;pose_msg)
 {
   if (vMap_CrossRoads_flag)
@@ -468,7 +467,7 @@ double StateMachineNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_m
   }
 }
 
-void StateMachineNode::update(void)
+void DecisionMakerNode::update(void)
 {
   update_msgs();
 }
@@ -476,8 +475,8 @@ void StateMachineNode::update(void)
 
 int main(int argc, char **argv)
 {
-  ros::init(argc, argv, &quot;state_machine&quot;);
-  state_machine::StateMachineNode smn(argc, argv);
+  ros::init(argc, argv, &quot;decision_maker&quot;);
+  decision_maker::DecisionMakerNode smn(argc, argv);
   smn.run();
 
   return 0;
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;

// lib
#include &lt;euclidean_space.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;state_machine_node.hpp&gt;

//#include &lt;vector_map/vector_map.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

// for dynamic reconfigure
//#include &lt;dynamic_reconfigure/server.h&gt;
//#include &lt;state_machine/state_machineConfig.h&gt;

namespace state_machine
{
#define DOUBLE_MAX 1.7976931348623158e308
#define TARGET_WAYPOINTS_NUM 14

CrossRoadArea *StateMachineNode::findClosestCrossRoad(void)
{
  CrossRoadArea *_area = nullptr;

  euclidean_space::point _pa;
  euclidean_space::point _pb;

  double _min_distance = DBL_MAX;

  int _label = 1;

  if (!current_finalwaypoints_.waypoints.empty())
  {
    _pa.x = current_finalwaypoints_.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
    _pa.y = current_finalwaypoints_.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.y;
    _pa.z = 0.0;
  }

  for (size_t i = 0; i &lt; intersects.size(); i++)
  {
    _pb.x = intersects[i].bbox.pose.position.x;
    _pb.y = intersects[i].bbox.pose.position.y;

    _pb.z = 0.0;

    double __temp_dis = euclidean_space::EuclideanSpace::find_distance(&amp;_pa, &amp;_pb);

    intersects[i].bbox.label = 0;
    if (_min_distance &gt;= __temp_dis)
    {
      _area = &amp;intersects[i];
      _min_distance = __temp_dis;  //
    }
  }

  if (_area)
  {
    _area-&gt;bbox.label = 3;
  }

  return _area;
}

bool StateMachineNode::isInsideArea(geometry_msgs::Point pt)
{
  // simply implementation
  //
  if (ClosestArea_ != nullptr)
  {
    double x1 = ClosestArea_-&gt;bbox.pose.position.x - (ClosestArea_-&gt;bbox.dimensions.x / 2);
    double x2 = ClosestArea_-&gt;bbox.pose.position.x + (ClosestArea_-&gt;bbox.dimensions.x / 2);

    double y1 = ClosestArea_-&gt;bbox.pose.position.y - (ClosestArea_-&gt;bbox.dimensions.y / 2);
    double y2 = ClosestArea_-&gt;bbox.pose.position.y + (ClosestArea_-&gt;bbox.dimensions.y / 2);

    if ((x1 &lt;= pt.x &amp;&amp; pt.x &lt;= x2))
    {
      if (y1 &lt;= pt.y &amp;&amp; pt.y &lt;= y2)
      {
        return true;
      }
    }
  }
  return false;
}

void StateMachineNode::initStateMsgs(void)
{
}

void StateMachineNode::initROS(int argc, char **argv)
{
  // status subscriber
  Subs[&quot;current_pose&quot;] = nh_.subscribe(&quot;current_pose&quot;, 20, &amp;StateMachineNode::callbackFromCurrentPose, this);
  Subs[&quot;current_velocity&quot;] =
      nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;StateMachineNode::callbackFromCurrentVelocity, this);
  Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;StateMachineNode::callbackFromLightColor, this);
  Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;StateMachineNode::callbackFromPointsRaw, this);
  Subs[&quot;final_waypoints&quot;] = nh_.subscribe(&quot;final_waypoints&quot;, 100, &amp;StateMachineNode::callbackFromFinalWaypoint, this);
  Subs[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;StateMachineNode::callbackFromTwistCmd, this);

  // vector map subscriber
  Subs[&quot;vector_map_area&quot;] =
      nh_.subscribe(&quot;/vector_map_info/area&quot;, 1, &amp;StateMachineNode::callbackFromVectorMapArea, this);
  Subs[&quot;vector_map_point&quot;] =
      nh_.subscribe(&quot;/vector_map_info/point&quot;, 1, &amp;StateMachineNode::callbackFromVectorMapPoint, this);
  Subs[&quot;vector_map_line&quot;] =
      nh_.subscribe(&quot;/vector_map_info/line&quot;, 1, &amp;StateMachineNode::callbackFromVectorMapLine, this);
  Subs[&quot;vector_map_crossroad&quot;] =
      nh_.subscribe(&quot;/vector_map_info/cross_road&quot;, 1, &amp;StateMachineNode::callbackFromVectorMapCrossRoad, this);

  // pub
  Pubs[&quot;state&quot;] = nh_.advertise&lt;std_msgs::String&gt;(&quot;state&quot;, 1);
  Pubs[&quot;state_overlay&quot;] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;(&quot;/state/overlay_text&quot;, 1);

  Pubs[&quot;state_local_diffdistance&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/val_diff_distance&quot;, 1);

  Pubs[&quot;crossroad_visual&quot;] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;/state/cross_road_marker&quot;, 1);
  Pubs[&quot;crossroad_inside_visual&quot;] = nh_.advertise&lt;visualization_msgs::Marker&gt;(&quot;/state/cross_inside_marker&quot;, 1);
  Pubs[&quot;crossroad_bbox&quot;] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;/state/bbox&quot;, 10);

#if 0
  // dynamic reconfigure
  dynamic_reconfigure::Server&lt;state_machine::state_machineConfig&gt; dr_server;
  dynamic_reconfigure::Server&lt;state_machine::state_machineConfig&gt;::CallbackType dr_server_f;

  dr_server_f = boost::bind(&amp;callbackFromDynamicReconfigure, _1, _2);
  dr_server.setCallback(dr_server_f);
#endif
  // message setup
  state_text_msg.text_size = 18;
  state_text_msg.line_width = 0;
  state_text_msg.font = &quot;DejaVu Sans Mono&quot;;
  state_text_msg.width = 500;
  state_text_msg.height = 50;
  state_text_msg.top = 10;
  state_text_msg.left = 10;
  state_text_msg.text = &quot;UNDEFINED&quot;;

  // initial publishing state message
  update_msgs();

  // to move initial state from start state
  // this part confirm broadcasting tf(map to world)
  {
    std::cout &lt;&lt; &quot;wait for tf of map to world&quot; &lt;&lt; std::endl;
    tf::TransformListener tf;
    tf.waitForTransform(&quot;map&quot;, &quot;world&quot;, ros::Time(), ros::Duration(999));

    if (!ctx-&gt;TFInitialized())
      std::cerr &lt;&lt; &quot;failed initialization &quot; &lt;&lt; std::endl;
  }
  {
    initVectorMapClient();
    displayMarker();
  }
}

void StateMachineNode::run(void)
{
  ros::Rate loop_rate(0.3);

  // for subscribe callback function
  ros::AsyncSpinner spinner(1);
  spinner.start();
  // ros::MultiThreadedSpinner spinner(2);
  // spinner.spin();
  while (ros::ok())
  {
    update();
    displayMarker();
    loop_rate.sleep();
  }
}

void StateMachineNode::update_pubsub(void)
{
  // if state machine require to re-subscribe topic,
  // this function will re-definition subscriber.
}

void StateMachineNode::initVectorMap(void)
{
  if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
  {
    vector_map_init = true;

    int _index = 0;

    for (const auto &amp;cross_road : vMap_CrossRoads.data)
    {
      for (const auto &amp;area : vMap_Areas.data)
      {
        if (cross_road.aid == area.aid)
        {
          CrossRoadArea carea;
          carea.id = _index++;
          carea.area_id = area.aid;

          double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
          double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
          double z = 0.0;

          int points_count = 0;
          for (const auto &amp;line : vMap_Lines.data)
          {
            if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
            {
              for (const auto &amp;point : vMap_Points.data)
              {
                if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
                {
                  geometry_msgs::Point _point;
                  _point.x = point.ly;
                  _point.y = point.bx;
                  _point.z = point.h;

                  x_avg += _point.x;
                  y_avg += _point.y;

                  x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
                  x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
                  y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
                  y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
                  z = _point.z;
                  points_count++;

                  carea.points.push_back(_point);
                }  // if pid
              }    // points iter
            }      // if lid
          }        // line iter
          carea.bbox.pose.position.x = x_avg / (double)points_count;
          carea.bbox.pose.position.y = y_avg / (double)points_count;
          carea.bbox.pose.position.z = z;
          carea.bbox.dimensions.x = x_max - x_min;
          carea.bbox.dimensions.y = y_max - y_min;
          carea.bbox.dimensions.z = 2;
          carea.bbox.label = 1;
          intersects.push_back(carea);
        }
      }
    }
  }
}

void StateMachineNode::displayMarker(void)
{
  // vector_map init
  // parse vectormap
  initVectorMap();

  jsk_recognition_msgs::BoundingBoxArray bbox_array;

  static visualization_msgs::MarkerArray marker_array;
  static visualization_msgs::Marker crossroad_marker;
  static visualization_msgs::Marker inside_marker;

  crossroad_marker.header.frame_id = &quot;/map&quot;;
  crossroad_marker.header.stamp = ros::Time();
  crossroad_marker.id = 1;
  crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
  crossroad_marker.action = visualization_msgs::Marker::ADD;
  crossroad_marker.ns = &quot;crossroad&quot;;

  double scale = 3.0;
  crossroad_marker.scale.x = scale;
  crossroad_marker.scale.y = scale;
  crossroad_marker.scale.z = 0.5;
  crossroad_marker.color.a = 0.15;
  crossroad_marker.color.r = 1.0;
  crossroad_marker.color.g = 0.0;
  /// www.sinet.ad.jp/aboutsinettd::cout &lt;&lt; &quot;x: &quot;&lt;&lt; _point.x &lt;&lt; std::endl;
  crossroad_marker.color.b = 0.0;
  crossroad_marker.frame_locked = true;
  crossroad_marker.lifetime = ros::Duration(0.3);

  inside_marker = crossroad_marker;
  inside_marker.color.a = 0.5;
  inside_marker.color.r = 1.0;
  inside_marker.color.g = 1.0;
  inside_marker.color.b = 0.0;
  inside_marker.ns = &quot;inside&quot;;
  inside_marker.lifetime = ros::Duration();

  bbox_array.header = crossroad_marker.header;

  for (auto &amp;area : intersects)
  {
    for (const auto &amp;p : area.points)
    {
      // if(isInsideArea(p))
      // inside_marker.points.push_back(p);
      crossroad_marker.points.push_back(p);
    }
    area.bbox.header = crossroad_marker.header;
    bbox_array.boxes.push_back(area.bbox);
  }

  Pubs[&quot;crossroad_bbox&quot;].publish(bbox_array);
  bbox_array.boxes.clear();

  // marker_array.markers.push_back(inside_marker);
  marker_array.markers.push_back(crossroad_marker);

  Pubs[&quot;crossroad_visual&quot;].publish(marker_array);

  for (const auto &amp;p : inside_points_)
    inside_marker.points.push_back(p);

  Pubs[&quot;crossroad_inside_visual&quot;].publish(inside_marker);

  marker_array.markers.clear();
}

void StateMachineNode::update_msgs(void)
{
  if (ctx)
  {
    static std::string prevStateName;
    CurrentStateName = *ctx-&gt;getCurrentStateName();

    if (prevStateName != CurrentStateName)
    {
      prevStateName = CurrentStateName;
      update_pubsub();
    }

    state_string_msg.data = CurrentStateName;
    state_text_msg.text = CurrentStateName + &quot;\n&quot; + TextOffset;

    Pubs[&quot;state&quot;].publish(state_string_msg);
    Pubs[&quot;state_overlay&quot;].publish(state_text_msg);
  }
  else
    std::cerr &lt;&lt; &quot;ctx is not found &quot; &lt;&lt; std::endl;
}

bool StateMachineNode::initVectorMapClient()
{
#ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
  // server

  vector_map::VectorMap vmap;
  vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));

  cross_road_srv.request.pose = current_pose_;
  cross_road_srv.request.waypoints = current_finalwaypoints_;

  cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;(&quot;vector_map_server/get_cross_road&quot;);

  return cross_road_cli.call(cross_road_srv);
#endif
}

bool StateMachineNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
                                                    const geometry_msgs::PoseStamped &amp;pose_msg)
{
#ifdef USE_VMAP_SERVER  // this is not successfully run
  cross_road_srv.request.pose = pose_msg;
  cross_road_srv.request.waypoints.waypoints.clear();
  std::cout &lt;&lt; &quot;test&quot; &lt;&lt; std::endl;

  for (int i = 0; i &lt; 50; i++)
  {
    cross_road_srv.request.waypoints.waypoints.push_back(lane_msg.waypoints[i]);
  }
  for (const auto &amp;wayp : lane_msg.waypoints)
    cross_road_srv.request.waypoints.waypoints.push_back(wayp);

  cross_road_cli.call(cross_road_srv);

  for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
  {
    std::cout &lt;&lt; &quot;EEEEEEEEE&quot; &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
  }
#else
#endif
}

double StateMachineNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
                                               const geometry_msgs::PoseStamped &amp;pose_msg)
{
  if (vMap_CrossRoads_flag)
  {
    int FirstPoint = 0;
    int EndPoint = 0;
    int index = 0;
    int PrevPoint = 0;
    double diff = 0.0;
    inside_points_.clear();
    for (int index = 0; index &lt; lane_msg.waypoints.size(); index++)
    {
      if (isInsideArea(lane_msg.waypoints[index].pose.pose.position))
      {
        if (!FirstPoint)
          FirstPoint = index;

        inside_points_.push_back(lane_msg.waypoints[index].pose.pose.position);
      }
      else if (FirstPoint &amp;&amp; !EndPoint)
      {
        EndPoint = PrevPoint;
        break;
      }
      PrevPoint = index;
    }

    if (EndPoint == 0)
    {
      std::cerr &lt;&lt; &quot;Not inside Cross Road&quot; &lt;&lt; std::endl;
    }
    else
    {
      geometry_msgs::Pose _end_point;
      _end_point = lane_msg.waypoints[EndPoint].pose.pose;

      double r, p, y, _y;

      tf::Quaternion quat_end(_end_point.orientation.x, _end_point.orientation.y, _end_point.orientation.z,
                              _end_point.orientation.w);
      tf::Quaternion quat_in(pose_msg.pose.orientation.x, pose_msg.pose.orientation.y, pose_msg.pose.orientation.z,
                             pose_msg.pose.orientation.w);

      tf::Matrix3x3(quat_end).getRPY(r, p, y);
      tf::Matrix3x3(quat_in).getRPY(r, p, _y);

      diff = std::floor(_y - y) * 180.0 / M_PI;
#if 1
      /* DEBUG */
      std::cout &lt;&lt; &quot;Yaw:&quot; &lt;&lt; _y &lt;&lt; &quot;-&quot; &lt;&lt; y &lt;&lt; &quot;:&quot; &lt;&lt; _y - y &lt;&lt; std::endl;
      if (diff &gt; 50)
      {
        std::cout &lt;&lt; &quot;Right Turn!!!!!!&quot; &lt;&lt; diff &lt;&lt; std::endl;
      }
      else if (diff &lt; -50)
      {
        std::cout &lt;&lt; &quot;Left Turn!!!!!!&quot; &lt;&lt; diff &lt;&lt; std::endl;
      }
      else
      {
        std::cout &lt;&lt; &quot;Straight&quot; &lt;&lt; diff &lt;&lt; std::endl;
      }
      std::cout &lt;&lt; &quot;Size:&quot; &lt;&lt; lane_msg.waypoints.size() &lt;&lt; &quot;:&quot;
                &lt;&lt; &quot;First Point = &quot; &lt;&lt; FirstPoint &lt;&lt; &quot;/ End Point = &quot; &lt;&lt; EndPoint &lt;&lt; std::endl;
#endif
    }

    return diff;
  }
  else
  {
    return 0.0;
  }
}

void StateMachineNode::update(void)
{
  update_msgs();
}
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, &quot;state_machine&quot;);
  state_machine::StateMachineNode smn(argc, argv);
  smn.run();

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -11,15 +11,15 @@
 #include &lt;cross_road_area.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
-#include &lt;state_machine_node.hpp&gt;
+#include &lt;decision_maker_node.hpp&gt;
 
-namespace state_machine
+namespace decision_maker
 {
 #define VEL_COUNT 10
-void StateMachineNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
+void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
   geometry_msgs::PoseStamped _pose = current_pose_ = msg;
-  bool initLocalizationFlag = ctx-&gt;isState(INITIAL_LOCATEVEHICLE_STATE);
+  bool initLocalizationFlag = ctx-&gt;isState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
 
   if (initLocalizationFlag &amp;&amp;
       ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
@@ -29,7 +29,7 @@ void StateMachineNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped
   }
 }
 
-void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
+void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
 {
   ROS_INFO(&quot;Light color callback&quot;);
   CurrentTrafficlight = msg.traffic_light;
@@ -37,7 +37,7 @@ void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_light
 }
 
 //
-void StateMachineNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
+void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
   if (ctx-&gt;handlePointsRaw(true))
   {
@@ -45,7 +45,7 @@ void StateMachineNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::Con
   }
 }
 
-void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
+void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 {
   if (!hasvMap())
   {
@@ -56,7 +56,7 @@ void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
   current_finalwaypoints_ = msg;
   ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);
 
-  if (ctx-&gt;inState(DRIVE_STATE))
+  if (ctx-&gt;inState(state_machine::DRIVE_STATE))
   {
     double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
     ctx-&gt;handleIntersection(true, intersect_wayangle);
@@ -85,7 +85,7 @@ void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
 
   std::cout &lt;&lt; &quot;Velocity: &quot; &lt;&lt; current_velocity_ &lt;&lt; &quot; to &quot; &lt;&lt; average_velocity_ &lt;&lt; std::endl;
 }
-void StateMachineNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
+void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
 {
   static bool Twistflag = false;
 
@@ -95,33 +95,33 @@ void StateMachineNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;m
     Twistflag = true;
 }
 
-void StateMachineNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
+void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
 {
   vMap_Areas = msg;
   vMap_Areas_flag = true;
 }
-void StateMachineNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
+void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
 {
   vMap_Points = msg;
   vMap_Points_flag = true;
 }
-void StateMachineNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
+void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
 {
   vMap_Lines = msg;
   vMap_Lines_flag = true;
 }
-void StateMachineNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
+void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
 {
   vMap_CrossRoads = msg;
   vMap_CrossRoads_flag = true;
 }
 
-void StateMachineNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
+void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
 {
   current_velocity_ = mps2kmph(msg.twist.linear.x);
 }
 #if 0
-	void StateMachineNode::callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level){
+	void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
 		ROS_INFO(&quot;Reconfigure Request: %d &quot;, config.TARGET_WAYPOINT_COUNT);
 	}
 #endif
</diff>
				<old_file>#include &lt;stdio.h&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;
#include &lt;state_machine_node.hpp&gt;

namespace state_machine
{
#define VEL_COUNT 10
void StateMachineNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isState(INITIAL_LOCATEVEHICLE_STATE);

  if (initLocalizationFlag &amp;&amp;
      ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                             _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

void StateMachineNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
{
  ROS_INFO(&quot;Light color callback&quot;);
  CurrentTrafficlight = msg.traffic_light;
  ctx-&gt;handleTrafficLight(CurrentTrafficlight);
}

//
void StateMachineNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;handlePointsRaw(true))
  {
    Subs[&quot;points_raw&quot;].shutdown();
  }
}

void StateMachineNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    // return;
  }

  current_finalwaypoints_ = msg;
  ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);

  if (ctx-&gt;inState(DRIVE_STATE))
  {
    double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
    ctx-&gt;handleIntersection(true, intersect_wayangle);
  }

  double _temp_sum = 0;
  for (int i = 0; i &lt; VEL_COUNT; i++)
  {
    _temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
  }

  average_velocity_ = _temp_sum / VEL_COUNT;

  if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
  {
    TextOffset = &quot;Keep&quot;;
  }
  else if (average_velocity_ - current_velocity_)
  {
    TextOffset = &quot;Accelerate&quot;;
  }
  else
  {
    TextOffset = &quot;Decelerate&quot;;
  }

  std::cout &lt;&lt; &quot;Velocity: &quot; &lt;&lt; current_velocity_ &lt;&lt; &quot; to &quot; &lt;&lt; average_velocity_ &lt;&lt; std::endl;
}
void StateMachineNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void StateMachineNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
}
void StateMachineNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
}
void StateMachineNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
}
void StateMachineNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
}

void StateMachineNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = mps2kmph(msg.twist.linear.x);
}
#if 0
	void StateMachineNode::callbackFromDynamicReconfigure(state_machine::state_machineConfig &amp;config, uint32_t level){
		ROS_INFO(&quot;Reconfigure Request: %d &quot;, config.TARGET_WAYPOINT_COUNT);
	}
#endif
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/planner_selector/planner_selector_node.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/planner_selector/planner_selector_node.cpp">
				<diff>@@ -8,85 +8,33 @@
 #include &lt;unordered_map&gt;
 
 #include &lt;euclidean_space.hpp&gt;
+#include &lt;planner_selector.hpp&gt;
 
 namespace decision_maker
 {
-#define DEFAULT_LATENCY_NUM 5
-#define DEFAULT_WAYPOINTS_NUM 3
-#define DEFAULT_CONVERGENCE_NUM 2.0
-class PlannerSelectorNode
-{
-private:
-  ros::NodeHandle nh_;
-
-  std::unordered_map&lt;std::string, autoware_msgs::lane&gt; waypoints_;
-  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
-  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
-
-
-  autoware_msgs::lane final_waypoints_dp_;
-  autoware_msgs::lane final_waypoints_astar_;
-
-  std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
-  int closest_waypoint_astar_;
-  int closest_waypoint_dp_;
-
-  unsigned int way_offset;
-
-  std::mutex _mutex;
-
-  int enableLattice_;
-  bool pastWaypoint;
-  unsigned int 	config_latency_num_;
-  unsigned int 	config_waypoints_num_;
-  double 	config_convergence_num_;
-  double current_velocity_;
-
-  bool existWaypoints(const int _config_waypoints_num); 
-
-public:
-  PlannerSelectorNode()
-  {
-    this-&gt;initROS();
-    enableLattice_ = 0;
-    pastWaypoint = false;
-    config_latency_num_ = DEFAULT_LATENCY_NUM;
-    config_waypoints_num_ = DEFAULT_WAYPOINTS_NUM;
-    config_convergence_num_ = DEFAULT_CONVERGENCE_NUM;
-  }
-
-  void initROS();
-
-  void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
-  void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
-  void callbackFromLattice(const std_msgs::Int32 &amp;msg);
-  void callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg);
-  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
-};
-
-void PlannerSelectorNode::initROS()
+void PlannerSelector::initROS()
 {
   Subs[&quot;/dp/final_waypoints&quot;] =
-      nh_.subscribe(&quot;/dp/final_waypoints&quot;, 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
+      nh_.subscribe(&quot;/dp/final_waypoints&quot;, 1, &amp;PlannerSelector::callbackFromWaypoints, this);
   Subs[&quot;/astar/final_waypoints&quot;] =
-      nh_.subscribe(&quot;/astar/final_waypoints&quot;, 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
-  Subs[&quot;/enableLattice&quot;] = nh_.subscribe(&quot;/enableLattice&quot;, 10, &amp;PlannerSelectorNode::callbackFromLattice, this);
+      nh_.subscribe(&quot;/astar/final_waypoints&quot;, 1, &amp;PlannerSelector::callbackFromWaypoints, this);
+  Subs[&quot;/enableLattice&quot;] = nh_.subscribe(&quot;/enableLattice&quot;, 10, &amp;PlannerSelector::callbackFromLattice, this);
 
   Subs[&quot;/dp/closest_waypoint&quot;] =
-      nh_.subscribe(&quot;/dp/closest_waypoint&quot;, 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
+      nh_.subscribe(&quot;/dp/closest_waypoint&quot;, 1, &amp;PlannerSelector::callbackFromClosest, this);
   Subs[&quot;/astar/closest_waypoint&quot;] =
-      nh_.subscribe(&quot;/astar/closest_waypoint&quot;, 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
+      nh_.subscribe(&quot;/astar/closest_waypoint&quot;, 1, &amp;PlannerSelector::callbackFromClosest, this);
 
-  Subs[&quot;/config/planner_selector&quot;] = nh_.subscribe(&quot;/config/PlannerSelector&quot;, 1, &amp;PlannerSelectorNode::callbackFromConfig, this);
+  Subs[&quot;/config/planner_selector&quot;] = nh_.subscribe(&quot;/config/PlannerSelector&quot;, 1, &amp;PlannerSelector::callbackFromConfig, this);
 
   Subs[&quot;current_velocity&quot;] =
-      nh_.subscribe(&quot;current_velocity&quot;, 3, &amp;PlannerSelectorNode::callbackFromCurrentVelocity, this);
+      nh_.subscribe(&quot;current_velocity&quot;, 3, &amp;PlannerSelector::callbackFromCurrentVelocity, this);
   
 Pubs[&quot;final_waypoints&quot;] = nh_.advertise&lt;autoware_msgs::lane&gt;(&quot;/final_waypoints&quot;, 1);
   Pubs[&quot;closest_waypoint&quot;] = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;/closest_waypoint&quot;, 1);
 }
 
-inline bool PlannerSelectorNode::existWaypoints(const int _config_waypoints_num)
+inline bool PlannerSelector::existWaypoints(const int _config_waypoints_num)
 {
 	bool ret;
 	ret = ( _config_waypoints_num &lt; final_waypoints_dp_.waypoints.size() ) 
@@ -94,7 +42,7 @@ inline bool PlannerSelectorNode::existWaypoints(const int _config_waypoints_num)
 	return ret;
 }
 
-void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
+void PlannerSelector::callbackFromLattice(const std_msgs::Int32 &amp;msg)
 {
   //static int prev[LATENCY_NUM] = { 1 };
   static int counter = 0;  
@@ -168,7 +116,7 @@ inline double mps2kmph(double _mpsval)
   return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
 }
 
-void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
+void PlannerSelector::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
   std::string topic = header.at(&quot;topic&quot;);
@@ -216,12 +164,12 @@ void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware
   _mutex.unlock();
 }
 
-void PlannerSelectorNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
+void PlannerSelector::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
 {
 	current_velocity_ = msg.twist.linear.x;
 }
 
-void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
+void PlannerSelector::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
 {
 	config_latency_num_ = msg.latency_num;
 	config_waypoints_num_ = msg.waypoints_num;
@@ -232,7 +180,7 @@ void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerS
 
 
 
-void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
+void PlannerSelector::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
 {
   const ros::M_string &amp;header = event.getConnectionHeader();
   std::string topic = header.at(&quot;topic&quot;);
@@ -267,10 +215,11 @@ void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::
   Pubs[&quot;closest_waypoint&quot;].publish(msg);
 }
 }
+
 int main(int argc, char **argv)
 {
 	ros::init(argc, argv, &quot;planner_selector&quot;);
 
-	decision_maker::PlannerSelectorNode _psn;
+	decision_maker::PlannerSelector _psn;
 	ros::spin();
 }
</diff>
				<old_file>#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/ConfigPlannerSelector.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Int32.h&gt;

#include &lt;mutex&gt;
#include &lt;thread&gt;
#include &lt;unordered_map&gt;

#include &lt;euclidean_space.hpp&gt;

namespace decision_maker
{
#define DEFAULT_LATENCY_NUM 5
#define DEFAULT_WAYPOINTS_NUM 3
#define DEFAULT_CONVERGENCE_NUM 2.0
class PlannerSelectorNode
{
private:
  ros::NodeHandle nh_;

  std::unordered_map&lt;std::string, autoware_msgs::lane&gt; waypoints_;
  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;


  autoware_msgs::lane final_waypoints_dp_;
  autoware_msgs::lane final_waypoints_astar_;

  std::unordered_map&lt;std::string, int&gt; closest_waypoints_;
  int closest_waypoint_astar_;
  int closest_waypoint_dp_;

  unsigned int way_offset;

  std::mutex _mutex;

  int enableLattice_;
  bool pastWaypoint;
  unsigned int 	config_latency_num_;
  unsigned int 	config_waypoints_num_;
  double 	config_convergence_num_;
  double current_velocity_;

  bool existWaypoints(const int _config_waypoints_num); 

public:
  PlannerSelectorNode()
  {
    this-&gt;initROS();
    enableLattice_ = 0;
    pastWaypoint = false;
    config_latency_num_ = DEFAULT_LATENCY_NUM;
    config_waypoints_num_ = DEFAULT_WAYPOINTS_NUM;
    config_convergence_num_ = DEFAULT_CONVERGENCE_NUM;
  }

  void initROS();

  void callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event);
  void callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event);
  void callbackFromLattice(const std_msgs::Int32 &amp;msg);
  void callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg);
  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
};

void PlannerSelectorNode::initROS()
{
  Subs[&quot;/dp/final_waypoints&quot;] =
      nh_.subscribe(&quot;/dp/final_waypoints&quot;, 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
  Subs[&quot;/astar/final_waypoints&quot;] =
      nh_.subscribe(&quot;/astar/final_waypoints&quot;, 1, &amp;PlannerSelectorNode::callbackFromWaypoints, this);
  Subs[&quot;/enableLattice&quot;] = nh_.subscribe(&quot;/enableLattice&quot;, 10, &amp;PlannerSelectorNode::callbackFromLattice, this);

  Subs[&quot;/dp/closest_waypoint&quot;] =
      nh_.subscribe(&quot;/dp/closest_waypoint&quot;, 1, &amp;PlannerSelectorNode::callbackFromClosest, this);
  Subs[&quot;/astar/closest_waypoint&quot;] =
      nh_.subscribe(&quot;/astar/closest_waypoint&quot;, 1, &amp;PlannerSelectorNode::callbackFromClosest, this);

  Subs[&quot;/config/planner_selector&quot;] = nh_.subscribe(&quot;/config/PlannerSelector&quot;, 1, &amp;PlannerSelectorNode::callbackFromConfig, this);

  Subs[&quot;current_velocity&quot;] =
      nh_.subscribe(&quot;current_velocity&quot;, 3, &amp;PlannerSelectorNode::callbackFromCurrentVelocity, this);
  
Pubs[&quot;final_waypoints&quot;] = nh_.advertise&lt;autoware_msgs::lane&gt;(&quot;/final_waypoints&quot;, 1);
  Pubs[&quot;closest_waypoint&quot;] = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;/closest_waypoint&quot;, 1);
}

inline bool PlannerSelectorNode::existWaypoints(const int _config_waypoints_num)
{
	bool ret;
	ret = ( _config_waypoints_num &lt; final_waypoints_dp_.waypoints.size() ) 
		&amp;&amp; ( _config_waypoints_num &lt; final_waypoints_dp_.waypoints.size() ) ;
	return ret;
}

void PlannerSelectorNode::callbackFromLattice(const std_msgs::Int32 &amp;msg)
{
  //static int prev[LATENCY_NUM] = { 1 };
  static int counter = 0;  
  double _distance = 100.0;

  try{
	  autoware_msgs::waypoint dp_point = final_waypoints_dp_.waypoints.at(config_waypoints_num_);
	  autoware_msgs::waypoint astar_point = final_waypoints_astar_.waypoints.at(config_waypoints_num_);

	  euclidean_space::point p_dp, p_astar;
	  p_dp.x = dp_point.pose.pose.position.x;
	  p_dp.x = dp_point.pose.pose.position.y;
	  p_dp.z = 0.0;

	  p_astar.x = astar_point.pose.pose.position.x;
	  p_astar.x = astar_point.pose.pose.position.y;
	  p_astar.z = 0.0;

	  _distance = euclidean_space::EuclideanSpace::find_distance(&amp;p_dp, &amp;p_astar);
	  //  ROS_INFO(&quot;distance=%f. %d:%d&quot;, _distance, dp_point.dtlane.dist,astar_point.dtlane.dist);
  }catch(const std::out_of_range &amp;ex){
	  ROS_ERROR(&quot;Out of Range:%s&quot;, ex.what() );
  }

#if 0 // delay switch
  _mutex.lock();
  if(enableLattice_){
	  if (msg.data == 0){
		  if(counter++ &gt;= config_latency_num_){
			  enableLattice_ = 0;
			  counter = 0;
		  }
	  }
  }else{
	  enableLattice_ = msg.data;
  }
  ROS_INFO(&quot;msg.data=%d, enableLattice_ = %d&quot;, msg.data, enableLattice_);
  _mutex.unlock();
#else
  _mutex.lock();
  if (msg.data != enableLattice_){
	  if(enableLattice_ == 1 &amp;&amp; msg.data == 0){
		  if(pastWaypoint == false){
			  pastWaypoint  = true;
			  counter = 0;
			  way_offset = config_waypoints_num_;
		  }
	  }
	  enableLattice_ = msg.data;
  }
  if(counter++ &gt;= config_latency_num_)
  {
	  counter = 0;
	  if(way_offset&gt;0){
		  way_offset--;
	  }else{
		  pastWaypoint = false;
	  }
  }



  //ROS_INFO(&quot;msg.data=%d, enableLattice_ = %d&quot;, msg.data, enableLattice_);
  _mutex.unlock();
#endif
  // for debug
  //	ROS_INFO(&quot;\n***** EnableLattice = %d  **** \n&quot;,enableLattice_,msg.data);
}
inline double mps2kmph(double _mpsval)
{
  return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
}

void PlannerSelectorNode::callbackFromWaypoints(const ros::MessageEvent&lt;autoware_msgs::lane const&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);
  const autoware_msgs::lane *waypoints = event.getMessage().get();

  _mutex.lock();

  if (this-&gt;enableLattice_ &amp;&amp; topic.find(&quot;dp&quot;) != std::string::npos)
  {
    Pubs[&quot;final_waypoints&quot;].publish(*waypoints);
    final_waypoints_dp_ = *waypoints;
  }
  else if (!this-&gt;enableLattice_ &amp;&amp; topic.find(&quot;astar&quot;) != std::string::npos)
  {
    if(pastWaypoint){
	    for(int i=0; i &lt; config_waypoints_num_; i++){
		    if(!final_waypoints_astar_.waypoints.empty())
			    final_waypoints_astar_.waypoints.erase(final_waypoints_astar_.waypoints.begin());
		    else{
			    pastWaypoint = false;
			    way_offset=0;
		    }
	    }
#if 0
	    if(final_waypoints_astar_.waypoints.empty()){
		    int _size = final_waypoints_astar_.waypoints.size();
		    _size = _size&gt;=5?5:_size;
		    auto itr = final_waypoints_astar_.waypoints.begin();
		    for(int i=0; i &lt; 5;  i++){
			    itr-&gt;twist.twist.linear.x =  (current_velocity_*2 + itr-&gt;twist.twist.linear.x) / 3;
			    std::cout &lt;&lt; &quot;set linear velocity:&quot; &lt;&lt;  mps2kmph(itr-&gt;twist.twist.linear.x)  &lt;&lt; std::endl; 
			    itr++;
		    }
	    }
#endif
	    Pubs[&quot;final_waypoints&quot;].publish(final_waypoints_astar_);
    }else{
	    Pubs[&quot;final_waypoints&quot;].publish(*waypoints);
    }
    final_waypoints_astar_ = *waypoints;
  }

  //for debug
  //ROS_INFO(&quot;%s, %d-%d-%d&quot;, topic.c_str(), closest_waypoint_dp_, closest_waypoint_astar_, this-&gt;enableLattice_);
  _mutex.unlock();
}

void PlannerSelectorNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
	current_velocity_ = msg.twist.linear.x;
}

void PlannerSelectorNode::callbackFromConfig(const autoware_msgs::ConfigPlannerSelector &amp;msg)
{
	config_latency_num_ = msg.latency_num;
	config_waypoints_num_ = msg.waypoints_num;
	config_convergence_num_ = msg.convergence_num;

	ROS_INFO(&quot;PARAM_SET-latency:%d, waypoints:%d, convergence:%f&quot;, config_latency_num_, config_waypoints_num_, config_convergence_num_);
}



void PlannerSelectorNode::callbackFromClosest(const ros::MessageEvent&lt;std_msgs::Int32&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);

  int temp = event.getMessage().get()-&gt;data;
  std_msgs::Int32 msg;

#if 1
  if (topic.find(&quot;/dp&quot;) == 0)
  {
	  closest_waypoints_[&quot;dp&quot;] = temp;

	  if (closest_waypoints_[&quot;astar&quot;])
	  {
		  msg.data = closest_waypoint_astar_;
	  }
	  closest_waypoint_dp_ = temp;
  }
  else if (topic.find(&quot;/astar&quot;) == 0)
  {
	  closest_waypoints_[&quot;astar&quot;] = temp;
	  closest_waypoint_astar_ = temp;
  }

  //  ROS_INFO(&quot;PastWaypoint:%s-offset:%d, latency:%d, closest:%d&quot;, pastWaypoint?&quot;true&quot;:&quot;false&quot;, way_offset, config_latency_num_,closest_waypoint_astar);
  if(pastWaypoint &amp;&amp;  final_waypoints_astar_.waypoints.size() &gt; closest_waypoint_astar_ + way_offset){
	  msg.data = closest_waypoint_astar_ + way_offset;
  }else{
	  msg.data = closest_waypoint_astar_;
  }
#endif
  Pubs[&quot;closest_waypoint&quot;].publish(msg);
}
}
int main(int argc, char **argv)
{
	ros::init(argc, argv, &quot;planner_selector&quot;);

	decision_maker::PlannerSelectorNode _psn;
	ros::spin();
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="92fef8c0c51cdf136a7dcdaf08044dfffbddca2e" fix_time="12,31221">
		<msg>fix a header dependencies and remove unnecessary part</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp">
				<diff>@@ -10,6 +10,7 @@
 #include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
 #include &lt;jsk_rviz_plugins/OverlayText.h&gt;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
+#include &lt;std_msgs/String.h&gt;
 
 //#include &lt;vector_map_server/GetCrossRoad.h&gt;
 
@@ -33,6 +34,7 @@
 
 namespace decision_maker
 {
+//#define DEBUG_PRINT
 enum class EControl
 {
   KEEP = -1,
@@ -125,6 +127,7 @@ private:
   void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
   void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
   void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
+  void callbackFromStateCmd(const std_msgs::String &amp;msg);
 
   void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
   void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
</diff>
				<old_file>#ifndef __DECISION_MAKER_NODE__
#define __DECISION_MAKER_NODE__

#include &lt;unordered_map&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;

//#include &lt;vector_map_server/GetCrossRoad.h&gt;

#include &lt;vector_map_msgs/AreaArray.h&gt;
#include &lt;vector_map_msgs/CrossRoadArray.h&gt;
#include &lt;vector_map_msgs/LineArray.h&gt;
#include &lt;vector_map_msgs/PointArray.h&gt;

#include &lt;geometry_msgs/Point.h&gt;

// lib
#include &lt;euclidean_space.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;cross_road_area.hpp&gt;


//#include &lt;dynamic_reconfigure/server.h&gt;
//#include &lt;decision_maker/decision_makerConfig.h&gt;

namespace decision_maker
{
enum class EControl
{
  KEEP = -1,
  STOP = 1,
  DECELERATE = 2,
  ACCELERATE = 3,
  OTHERS = 4,
};

inline bool hasvMap(void)
{
  return true;
}

inline double mps2kmph(double _mpsval)
{
  return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
}

class DecisionMakerNode
{
private:
  ros::NodeHandle nh_;
  // Publishers
  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
  // Subscribers
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;

  // ROS Messages
  std_msgs::String state_string_msg;
  geometry_msgs::PoseStamped current_pose_;

  jsk_rviz_plugins::OverlayText state_text_msg;
  autoware_msgs::lane current_finalwaypoints_;

  std::vector&lt;geometry_msgs::Point&gt; inside_points_;

  vector_map_msgs::AreaArray vMap_Areas;
  vector_map_msgs::PointArray vMap_Points;
  vector_map_msgs::LineArray vMap_Lines;
  vector_map_msgs::CrossRoadArray vMap_CrossRoads;

  // Current way/behavior status
  double current_velocity_;
  double average_velocity_;
  int CurrentTrafficlight;
  CrossRoadArea *ClosestArea_;
  std::string CurrentStateName;
  std::string TextOffset;
  std::vector&lt;CrossRoadArea&gt; intersects;
  bool isDisplay;

  // for vectormap server
  // ros::ServiceClient cross_road_cli;
  // vector_map_server::GetCrossRoad cross_road_srv;

  // initialization flags for initialized by callback
  bool vector_map_init;
  bool vMap_Areas_flag;
  bool vMap_Points_flag;
  bool vMap_Lines_flag;
  bool vMap_CrossRoads_flag;
  bool SimulationMode;

  // initialization method
  void initROS(int argc, char **argv);
  void initVectorMap(void);
  void initStateMsgs(void);
  bool initVectorMapClient(void);

  // looping method
  void update(void);
  void update_msgs(void);
  void update_pubsub(void);
  void displayMarker(void);

  void publishToVelocityArray();

  //
  bool isInsideArea(geometry_msgs::Point pt);
  bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);

  double calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);

  // callback by topic subscribing
  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg);
  void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
  void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
  void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);

  void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
  void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
  void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
  void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);

  // for ros dynamic reconfigure
  // Currently. this feature is not working.
  // static void callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level);

  // in near future, these function will be deprecate
  CrossRoadArea *findClosestCrossRoad(void);

public:
  state_machine::StateContext *ctx;

  DecisionMakerNode(int argc, char **argv)
  {
    SimulationMode = false;
    isDisplay = true;

    ctx = new state_machine::StateContext();
    this-&gt;initROS(argc, argv);

    vector_map_init = false;
    vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;

    ClosestArea_ = nullptr;
  }

  void run(void);
};



}  // namespace decision_maker

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -15,7 +15,8 @@
 
 namespace decision_maker
 {
-#define VEL_COUNT 10
+#define VEL_AVERAGE_COUNT 10
+
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
   geometry_msgs::PoseStamped _pose = current_pose_ = msg;
@@ -33,7 +34,7 @@ void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_ligh
 {
   ROS_INFO(&quot;Light color callback&quot;);
   CurrentTrafficlight = msg.traffic_light;
-  ctx-&gt;handleTrafficLight(CurrentTrafficlight);
+  //ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
 
 //
@@ -63,12 +64,12 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   }
 
   double _temp_sum = 0;
-  for (int i = 0; i &lt; VEL_COUNT; i++)
+  for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
   {
     _temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
   }
-
-  average_velocity_ = _temp_sum / VEL_COUNT;
+  average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
+  
   if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
   {
     TextOffset = &quot;Keep&quot;;
</diff>
				<old_file>#include &lt;stdio.h&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;

namespace decision_maker
{
#define VEL_COUNT 10
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isState(state_machine::INITIAL_LOCATEVEHICLE_STATE);

  if (initLocalizationFlag &amp;&amp;
      ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                             _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
{
  ROS_INFO(&quot;Light color callback&quot;);
  CurrentTrafficlight = msg.traffic_light;
  ctx-&gt;handleTrafficLight(CurrentTrafficlight);
}

//
void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;handlePointsRaw(true))
  {
    Subs[&quot;points_raw&quot;].shutdown();
  }
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    // return;
  }

  current_finalwaypoints_ = msg;
  ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);

  if (ctx-&gt;inState(state_machine::DRIVE_STATE))
  {
    double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
    ctx-&gt;handleIntersection(true, intersect_wayangle);
  }

  double _temp_sum = 0;
  for (int i = 0; i &lt; VEL_COUNT; i++)
  {
    _temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
  }

  average_velocity_ = _temp_sum / VEL_COUNT;
  if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
  {
    TextOffset = &quot;Keep&quot;;
  }
  else if (average_velocity_ - current_velocity_)
  {
    TextOffset = &quot;Accelerate&quot;;
  }
  else
  {
    TextOffset = &quot;Decelerate&quot;;
  }

  // for publish plan of velocity
  publishToVelocityArray();

  std::cout &lt;&lt; &quot;Velocity: &quot; &lt;&lt; current_velocity_ &lt;&lt; &quot; to &quot; &lt;&lt; average_velocity_ &lt;&lt; std::endl;
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = mps2kmph(msg.twist.linear.x);
}
#if 0
	void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
		ROS_INFO(&quot;Reconfigure Request: %d &quot;, config.TARGET_WAYPOINT_COUNT);
	}
#endif
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_core.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_core.cpp">
				<diff>@@ -25,6 +25,7 @@
 
 namespace decision_maker
 {
+
 #define DOUBLE_MAX 1.7976931348623158e308
 #define TARGET_WAYPOINTS_NUM 14
 
@@ -95,24 +96,6 @@ bool DecisionMakerNode::isInsideArea(geometry_msgs::Point pt)
 }
 
 
-void DecisionMakerNode::run(void)
-{
-  ros::Rate loop_rate(0.3);
-
-  // for subscribe callback function
-  ros::AsyncSpinner spinner(1);
-  spinner.start();
-  // ros::MultiThreadedSpinner spinner(2);
-  // spinner.spin();
-  while (ros::ok())
-  {
-    update();
-    if(isDisplay)
-	    displayMarker();
-    loop_rate.sleep();
-  }
-}
-
 
 bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
                                                     const geometry_msgs::PoseStamped &amp;pose_msg)
@@ -120,7 +103,6 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
 #ifdef USE_VMAP_SERVER  // this is not successfully run
   cross_road_srv.request.pose = pose_msg;
   cross_road_srv.request.waypoints.waypoints.clear();
-  std::cout &lt;&lt; &quot;test&quot; &lt;&lt; std::endl;
 
   for (int i = 0; i &lt; 50; i++)
   {
@@ -133,9 +115,8 @@ bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;
 
   for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
   {
-    std::cout &lt;&lt; &quot;EEEEEEEEE&quot; &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
+ //   std::cout &lt;&lt; &quot;EEEEEEEEE&quot; &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
   }
-#else
 #endif
 }
 
@@ -187,8 +168,8 @@ double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_
       tf::Matrix3x3(quat_in).getRPY(r, p, _y);
 
       diff = std::floor(_y - y) * 180.0 / M_PI;
-#if 1
-      /* DEBUG */
+
+#ifdef DEBUG_PRINT
       std::cout &lt;&lt; &quot;Yaw:&quot; &lt;&lt; _y &lt;&lt; &quot;-&quot; &lt;&lt; y &lt;&lt; &quot;:&quot; &lt;&lt; _y - y &lt;&lt; std::endl;
       if (diff &gt; 50)
       {
@@ -219,4 +200,20 @@ void DecisionMakerNode::update(void)
 {
   update_msgs();
 }
+
+void DecisionMakerNode::run(void)
+{
+  ros::Rate loop_rate(0.3);
+
+  // for subscribe callback function
+  ros::AsyncSpinner spinner(1);
+  spinner.start();
+  while (ros::ok())
+  {
+    update();
+    if(isDisplay)
+	    displayMarker();
+    loop_rate.sleep();
+  }
+}
 }
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;

// lib
#include &lt;euclidean_space.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;
//#include &lt;vector_map/vector_map.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
#define DOUBLE_MAX 1.7976931348623158e308
#define TARGET_WAYPOINTS_NUM 14

CrossRoadArea *DecisionMakerNode::findClosestCrossRoad(void)
{
  CrossRoadArea *_area = nullptr;

  euclidean_space::point _pa;
  euclidean_space::point _pb;

  double _min_distance = DBL_MAX;

  int _label = 1;

  if (!current_finalwaypoints_.waypoints.empty())
  {
    _pa.x = current_finalwaypoints_.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.x;
    _pa.y = current_finalwaypoints_.waypoints[TARGET_WAYPOINTS_NUM].pose.pose.position.y;
    _pa.z = 0.0;
  }

  for (size_t i = 0; i &lt; intersects.size(); i++)
  {
    _pb.x = intersects[i].bbox.pose.position.x;
    _pb.y = intersects[i].bbox.pose.position.y;

    _pb.z = 0.0;

    double __temp_dis = euclidean_space::EuclideanSpace::find_distance(&amp;_pa, &amp;_pb);

    intersects[i].bbox.label = 0;
    if (_min_distance &gt;= __temp_dis)
    {
      _area = &amp;intersects[i];
      _min_distance = __temp_dis;  //
    }
  }

  if (_area)
  {
    _area-&gt;bbox.label = 3;
  }

  return _area;
}

bool DecisionMakerNode::isInsideArea(geometry_msgs::Point pt)
{
  // simply implementation
  //
  if (ClosestArea_ != nullptr)
  {
    double x1 = ClosestArea_-&gt;bbox.pose.position.x - (ClosestArea_-&gt;bbox.dimensions.x / 2);
    double x2 = ClosestArea_-&gt;bbox.pose.position.x + (ClosestArea_-&gt;bbox.dimensions.x / 2);

    double y1 = ClosestArea_-&gt;bbox.pose.position.y - (ClosestArea_-&gt;bbox.dimensions.y / 2);
    double y2 = ClosestArea_-&gt;bbox.pose.position.y + (ClosestArea_-&gt;bbox.dimensions.y / 2);

    if ((x1 &lt;= pt.x &amp;&amp; pt.x &lt;= x2))
    {
      if (y1 &lt;= pt.y &amp;&amp; pt.y &lt;= y2)
      {
        return true;
      }
    }
  }
  return false;
}


void DecisionMakerNode::run(void)
{
  ros::Rate loop_rate(0.3);

  // for subscribe callback function
  ros::AsyncSpinner spinner(1);
  spinner.start();
  // ros::MultiThreadedSpinner spinner(2);
  // spinner.spin();
  while (ros::ok())
  {
    update();
    if(isDisplay)
	    displayMarker();
    loop_rate.sleep();
  }
}


bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
                                                    const geometry_msgs::PoseStamped &amp;pose_msg)
{
#ifdef USE_VMAP_SERVER  // this is not successfully run
  cross_road_srv.request.pose = pose_msg;
  cross_road_srv.request.waypoints.waypoints.clear();
  std::cout &lt;&lt; &quot;test&quot; &lt;&lt; std::endl;

  for (int i = 0; i &lt; 50; i++)
  {
    cross_road_srv.request.waypoints.waypoints.push_back(lane_msg.waypoints[i]);
  }
  for (const auto &amp;wayp : lane_msg.waypoints)
    cross_road_srv.request.waypoints.waypoints.push_back(wayp);

  cross_road_cli.call(cross_road_srv);

  for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
  {
    std::cout &lt;&lt; &quot;EEEEEEEEE&quot; &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
  }
#else
#endif
}

double DecisionMakerNode::calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg,
                                               const geometry_msgs::PoseStamped &amp;pose_msg)
{
  if (vMap_CrossRoads_flag)
  {
    int FirstPoint = 0;
    int EndPoint = 0;
    int index = 0;
    int PrevPoint = 0;
    double diff = 0.0;
    inside_points_.clear();
    for (int index = 0; index &lt; lane_msg.waypoints.size(); index++)
    {
      if (isInsideArea(lane_msg.waypoints[index].pose.pose.position))
      {
        if (!FirstPoint)
          FirstPoint = index;

        inside_points_.push_back(lane_msg.waypoints[index].pose.pose.position);
      }
      else if (FirstPoint &amp;&amp; !EndPoint)
      {
        EndPoint = PrevPoint;
        break;
      }
      PrevPoint = index;
    }

    if (EndPoint == 0)
    {
      std::cerr &lt;&lt; &quot;Not inside Cross Road&quot; &lt;&lt; std::endl;
    }
    else
    {
      geometry_msgs::Pose _end_point;
      _end_point = lane_msg.waypoints[EndPoint].pose.pose;

      double r, p, y, _y;

      tf::Quaternion quat_end(_end_point.orientation.x, _end_point.orientation.y, _end_point.orientation.z,
                              _end_point.orientation.w);
      tf::Quaternion quat_in(pose_msg.pose.orientation.x, pose_msg.pose.orientation.y, pose_msg.pose.orientation.z,
                             pose_msg.pose.orientation.w);

      tf::Matrix3x3(quat_end).getRPY(r, p, y);
      tf::Matrix3x3(quat_in).getRPY(r, p, _y);

      diff = std::floor(_y - y) * 180.0 / M_PI;
#if 1
      /* DEBUG */
      std::cout &lt;&lt; &quot;Yaw:&quot; &lt;&lt; _y &lt;&lt; &quot;-&quot; &lt;&lt; y &lt;&lt; &quot;:&quot; &lt;&lt; _y - y &lt;&lt; std::endl;
      if (diff &gt; 50)
      {
        std::cout &lt;&lt; &quot;Right Turn!!!!!!&quot; &lt;&lt; diff &lt;&lt; std::endl;
      }
      else if (diff &lt; -50)
      {
        std::cout &lt;&lt; &quot;Left Turn!!!!!!&quot; &lt;&lt; diff &lt;&lt; std::endl;
      }
      else
      {
        std::cout &lt;&lt; &quot;Straight&quot; &lt;&lt; diff &lt;&lt; std::endl;
      }
      std::cout &lt;&lt; &quot;Size:&quot; &lt;&lt; lane_msg.waypoints.size() &lt;&lt; &quot;:&quot;
                &lt;&lt; &quot;First Point = &quot; &lt;&lt; FirstPoint &lt;&lt; &quot;/ End Point = &quot; &lt;&lt; EndPoint &lt;&lt; std::endl;
#endif
    }

    return diff;
  }
  else
  {
    return 0.0;
  }
}

void DecisionMakerNode::update(void)
{
  update_msgs();
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="30661e0ba49576e597de13d6b975b78b721bbb6a" fix_time="24,31079">
		<msg>Fixed configuration of state</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp">
				<diff>@@ -14,30 +14,30 @@ namespace state_machine
 class StartState;
 class InitialState;
 class LocateVehicleState;
+
 class DriveState;
-class DriveMoveFwdState;
-class DriveMoveFwdLeftState;
-class DriveMoveFwdRightState;
-class DriveMoveFwdStraightState;
-class DriveLaneChangeState;
-class DriveLaneChangeLeftState;
-class DriveLaneChangeRightState;
-class DriveLaneChangeRightAvoidanceState;
-class DriveObstacleAvoidanceState;
-class DriveObstacleAvoidanceStaticState;
-class DriveObstacleAvoidanceDynamicState;
-class DriveStopState;
-class DriveStopAvoidanceState;
-class DriveStopStopLineState;
-class DriveStopTrafficLightState;
+ //Accel/Brake subState
+ class DriveAccAccelerationState;
+ class DriveAccDecelerationState;
+ class DriveAccKeepState;
+ class DriveAccStopState;
+ //Steering subState
+ class DriveStrStraightState;
+ class DriveStrLeftTurnState;
+ class DriveStrRightTurnState;
+
+ //Behavior subState
+ class DriveBehaviorLaneChangeLeftState;
+ class DriveBehaviorLaneChangeRightState;
+ class DriveBehaviorObstacleAvoidanceState;
+
+ //Perception subState
+ class DriveDetectObstacleState;
+ class DriveDetectStoplineState;
+ class DriveDetectTrafficlightRedState;
+
 class MissionCompleteState;
 class EmergencyState;
-class EmergencyHWState;
-class EmergencyHWVehicleState;
-class EmergencyHWControllerState;
-class EmergencySWState;
-class EmergencySWAutowareState;
-class EmergencySWControllerState;
 
 // base class
 class BaseState
@@ -47,10 +47,11 @@ public:
   BaseState()
   {
   }
-  virtual void ShowStateName(void) = 0;
-  virtual unsigned long long GetStateTransMask() = 0;
-  virtual unsigned long long GetStateNum() = 0;
-  virtual std::unique_ptr&lt;std::string&gt; GetStateName() = 0;
+  virtual void showStateName(void) = 0;
+  virtual unsigned long long getStateTransMask() = 0;
+  virtual unsigned long long getStateNum() = 0;
+  virtual std::unique_ptr&lt;std::string&gt; getStateName() = 0;
+  virtual unsigned char getStateKind() = 0;
 };
 
 // Interface
@@ -61,34 +62,41 @@ protected:
   std::string StateName = &quot;Base&quot;;
   unsigned long long StateNum;
   unsigned long long StateTransMask;
+  unsigned char StateKind;
 
 public:
   State()
   {
     StateNum = 0;
     StateTransMask = (unsigned long long)STATE_END - 1;
+    StateKind = UNKNOWN_STATE;
   }
-  void ShowStateName(void)
+  void showStateName(void)
   {
     std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
   }
 
-  static T* GetInstance(void)
+  static T* getInstance(void)
   {
     static T singleton;
     return &amp;singleton;
   }
 
-  std::unique_ptr&lt;std::string&gt; GetStateName(void)
+  std::unique_ptr&lt;std::string&gt; getStateName(void)
   {
     return std::unique_ptr&lt;std::string&gt;(new std::string(StateName));
   }
 
-  unsigned long long GetStateTransMask(void)
+  unsigned char getStateKind(void)
+  {
+    return StateKind;
+  }
+
+  unsigned long long getStateTransMask(void)
   {
     return StateTransMask;
   }
-  unsigned long long GetStateNum(void)
+  unsigned long long getStateNum(void)
   {
     return StateNum;
   }
@@ -104,6 +112,7 @@ private:
     StateName = &quot;Start&quot;;
     StateNum = START_STATE;
     StateTransMask = (unsigned long long)STATE_END - 1;
+    StateKind = MAIN_STATE;
   }
 
 public:
@@ -119,6 +128,7 @@ private:
     StateName = &quot;Initial&quot;;
     StateNum = StateTransMask = INITIAL_STATE;
     StateTransMask |= START_STATE | EMERGENCY_STATE | MISSION_COMPLETE_STATE;
+    StateKind = MAIN_STATE;
   }
 
 public:
@@ -132,6 +142,7 @@ private:
     StateName = &quot;Locate Vehicle&quot;;
     StateNum = StateTransMask = INITIAL_LOCATEVEHICLE_STATE;
     StateTransMask |= INITIAL_STATE;
+    StateKind = MAIN_STATE;
   }
 
 public:
@@ -146,6 +157,7 @@ private:
     StateName = &quot;MissionComplete&quot;;
     StateNum = MISSION_COMPLETE_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = MAIN_STATE;
   }
 
 public:
</diff>
				<old_file>#ifndef __STATE_HPP__
#define __STATE_HPP__

#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

#include &quot;state_flags.hpp&quot;

using namespace std;

namespace state_machine
{
class StartState;
class InitialState;
class LocateVehicleState;
class DriveState;
class DriveMoveFwdState;
class DriveMoveFwdLeftState;
class DriveMoveFwdRightState;
class DriveMoveFwdStraightState;
class DriveLaneChangeState;
class DriveLaneChangeLeftState;
class DriveLaneChangeRightState;
class DriveLaneChangeRightAvoidanceState;
class DriveObstacleAvoidanceState;
class DriveObstacleAvoidanceStaticState;
class DriveObstacleAvoidanceDynamicState;
class DriveStopState;
class DriveStopAvoidanceState;
class DriveStopStopLineState;
class DriveStopTrafficLightState;
class MissionCompleteState;
class EmergencyState;
class EmergencyHWState;
class EmergencyHWVehicleState;
class EmergencyHWControllerState;
class EmergencySWState;
class EmergencySWAutowareState;
class EmergencySWControllerState;

// base class
class BaseState
{
protected:
public:
  BaseState()
  {
  }
  virtual void ShowStateName(void) = 0;
  virtual unsigned long long GetStateTransMask() = 0;
  virtual unsigned long long GetStateNum() = 0;
  virtual std::unique_ptr&lt;std::string&gt; GetStateName() = 0;
};

// Interface
template &lt;class T&gt;
class State : public BaseState
{
protected:
  std::string StateName = &quot;Base&quot;;
  unsigned long long StateNum;
  unsigned long long StateTransMask;

public:
  State()
  {
    StateNum = 0;
    StateTransMask = (unsigned long long)STATE_END - 1;
  }
  void ShowStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }

  static T* GetInstance(void)
  {
    static T singleton;
    return &amp;singleton;
  }

  std::unique_ptr&lt;std::string&gt; GetStateName(void)
  {
    return std::unique_ptr&lt;std::string&gt;(new std::string(StateName));
  }

  unsigned long long GetStateTransMask(void)
  {
    return StateTransMask;
  }
  unsigned long long GetStateNum(void)
  {
    return StateNum;
  }
};

// StartState
class StartState : public State&lt;StartState&gt;
{
private:
  friend class State&lt;StartState&gt;;
  StartState(void)
  {
    StateName = &quot;Start&quot;;
    StateNum = START_STATE;
    StateTransMask = (unsigned long long)STATE_END - 1;
  }

public:
};

// InitialState
class InitialState : public State&lt;InitialState&gt;
{
private:
  friend class State&lt;InitialState&gt;;
  InitialState(void)
  {
    StateName = &quot;Initial&quot;;
    StateNum = StateTransMask = INITIAL_STATE;
    StateTransMask |= START_STATE | EMERGENCY_STATE | MISSION_COMPLETE_STATE;
  }

public:
};
class LocateVehicleState : public State&lt;LocateVehicleState&gt;
{
private:
  friend class State&lt;LocateVehicleState&gt;;
  LocateVehicleState(void)
  {
    StateName = &quot;Locate Vehicle&quot;;
    StateNum = StateTransMask = INITIAL_LOCATEVEHICLE_STATE;
    StateTransMask |= INITIAL_STATE;
  }

public:
};
// MissionCompleteState
class MissionCompleteState : public State&lt;MissionCompleteState&gt;
{
private:
  friend class State&lt;MissionCompleteState&gt;;
  MissionCompleteState(void)
  {
    StateName = &quot;MissionComplete&quot;;
    StateNum = MISSION_COMPLETE_STATE;
    StateTransMask = DRIVE_STATE;
  }

public:
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp">
				<diff>@@ -15,63 +15,59 @@ namespace state_machine
 class StateContext
 {
 private:
-  BaseState *state_;
-  BaseState *sub_state;
-  BaseState *sub_sub_state;
+	class StateHolder{
+		public:
+			BaseState *MainState;
+			BaseState *AccState;
+			BaseState *StrState;
+			BaseState *BehaviorState;
+			BaseState *PerceptionState;
+			BaseState *OtherState;
+	} current_state_;
+
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
-  unsigned long long st;
+  
+  bool enableForceSetState;
   unsigned long long ChangeStateFlags;
   std::atomic&lt;bool&gt; thread_loop;
 
   std::thread *thr_state_dec;
 
-  void ShowStateMove(unsigned long long _state_num)
+  void showStateMove(unsigned long long _state_num)
   {
-    std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; *StateStores[_state_num]-&gt;GetStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
+    std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; *StateStores[_state_num]-&gt;getStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
   }
 
 public:
-  void debug_next_state()
-  {
-    if (st &gt;= STATE_END)
-      st = 1;
-    state_ = StateStores[st];
-    st = st &lt;&lt; 1;
-  }
   StateContext(void)
   {
-    st = 1;
-    state_ = nullptr;
-    sub_state = nullptr;
-    sub_sub_state = nullptr;
-
-    StateStores[START_STATE] = StartState::GetInstance();
-    StateStores[INITIAL_STATE] = InitialState::GetInstance();
-    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::GetInstance();
-    StateStores[DRIVE_STATE] = DriveState::GetInstance();
-    StateStores[DRIVE_MOVEFWD_STATE] = DriveMoveFwdState::GetInstance();
-    StateStores[DRIVE_MOVEFWD_LEFT_STATE] = DriveMoveFwdLeftState::GetInstance();
-    StateStores[DRIVE_MOVEFWD_RIGHT_STATE] = DriveMoveFwdRightState::GetInstance();
-    StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE] = DriveMoveFwdStraightState::GetInstance();
-    StateStores[DRIVE_LANECHANGE_STATE] = DriveLaneChangeState::GetInstance();
-    StateStores[DRIVE_LANECHANGE_LEFT_STATE] = DriveLaneChangeLeftState::GetInstance();
-    StateStores[DRIVE_LANECHANGE_RIGHT_STATE] = DriveLaneChangeRightState::GetInstance();
-    StateStores[DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE] = DriveLaneChangeRightAvoidanceState::GetInstance();
-    StateStores[DRIVE_OBSTACLE_AVOIDANCE_STATE] = DriveObstacleAvoidanceState::GetInstance();
-    StateStores[DRIVE_OBSTACLE_AVOIDANCE_STATIC_STATE] = DriveObstacleAvoidanceStaticState::GetInstance();
-    StateStores[DRIVE_OBSTACLE_AVOIDANCE_DYNAMIC_STATE] = DriveObstacleAvoidanceDynamicState::GetInstance();
-    StateStores[DRIVE_STOP_STATE] = DriveStopState::GetInstance();
-    StateStores[DRIVE_STOP_AVOIDANCE_STATE] = DriveStopAvoidanceState::GetInstance();
-    StateStores[DRIVE_STOP_STOPLINE_STATE] = DriveStopStopLineState::GetInstance();
-    StateStores[DRIVE_STOP_TRAFFICLIGHT_STATE] = DriveStopTrafficLightState::GetInstance();
-    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::GetInstance();
-    StateStores[EMERGENCY_STATE] = EmergencyState::GetInstance();
-    StateStores[EMERGENCY_HW_STATE] = EmergencyHWState::GetInstance();
-    StateStores[EMERGENCY_HWVEHICLE_STATE] = EmergencyHWVehicleState::GetInstance();
-    StateStores[EMERGENCY_HWCONTROLLER_STATE] = EmergencyHWControllerState::GetInstance();
-    StateStores[EMERGENCY_SW_STATE] = EmergencySWState::GetInstance();
-    StateStores[EMERGENCY_SWAUTOWARE_STATE] = EmergencySWAutowareState::GetInstance();
-    StateStores[EMERGENCY_SWCONTROLLER_STATE] = EmergencySWControllerState::GetInstance();
+
+    StateStores[START_STATE] = StartState::getInstance();
+    StateStores[INITIAL_STATE] = InitialState::getInstance();
+    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
+    StateStores[DRIVE_STATE] = DriveState::getInstance();
+    StateStores[DRIVE_ACC_ACCELERATION_STATE] = DriveAccAccelerationState::getInstance();
+    StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
+    StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
+    StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
+    StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
+    StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
+    StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
+    StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
+    StateStores[DRIVE_DETECT_OBSTACLE_STATE] = DriveDetectObstacleState::getInstance();
+    StateStores[DRIVE_DETECT_STOPLINE_STATE] = DriveDetectStoplineState::getInstance();
+    StateStores[DRIVE_DETECT_TRAFFICLIGHT_RED_STATE] = DriveDetectTrafficlightRedState::getInstance();
+    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
+    StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
+    
+    current_state_.MainState = nullptr;
+    current_state_.AccState = nullptr;
+    current_state_.StrState = nullptr;
+    current_state_.BehaviorState = nullptr;
+    current_state_.PerceptionState = nullptr;
+    current_state_.OtherState = nullptr;
 
     ChangeStateFlags = 0;
     thread_loop = true;
@@ -86,16 +82,18 @@ public:
   bool isState(unsigned long long _state_num);
   bool inState(unsigned long long _state_num);
 
-  void StateDecider(void);
+  void stateDecider(void);
 
   bool setCurrentState(BaseState *state);
   bool setCurrentState(BaseState *state, BaseState *substate);
   bool setCurrentState(BaseState *state, BaseState *substate, BaseState *subsubstate);
 
+  BaseState *getCurrentMainState(void);
   BaseState *getCurrentState(void);
   std::unique_ptr&lt;std::string&gt; getCurrentStateName(void);
   void showCurrentStateName(void);
 
+  bool setEnableForceSetState(bool force_flag);
   BaseState *getStateObject(unsigned long long _state_num);
   void InitContext(void);
 
</diff>
				<old_file>#ifndef __STATE_CONTEXT_HPP__
#define __STATE_CONTEXT_HPP__

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &quot;state.hpp&quot;
#include &quot;state_drive.hpp&quot;
#include &quot;state_emg.hpp&quot;

namespace state_machine
{
class StateContext
{
private:
  BaseState *state_;
  BaseState *sub_state;
  BaseState *sub_sub_state;
  std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
  unsigned long long st;
  unsigned long long ChangeStateFlags;
  std::atomic&lt;bool&gt; thread_loop;

  std::thread *thr_state_dec;

  void ShowStateMove(unsigned long long _state_num)
  {
    std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; *StateStores[_state_num]-&gt;GetStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }

public:
  void debug_next_state()
  {
    if (st &gt;= STATE_END)
      st = 1;
    state_ = StateStores[st];
    st = st &lt;&lt; 1;
  }
  StateContext(void)
  {
    st = 1;
    state_ = nullptr;
    sub_state = nullptr;
    sub_sub_state = nullptr;

    StateStores[START_STATE] = StartState::GetInstance();
    StateStores[INITIAL_STATE] = InitialState::GetInstance();
    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::GetInstance();
    StateStores[DRIVE_STATE] = DriveState::GetInstance();
    StateStores[DRIVE_MOVEFWD_STATE] = DriveMoveFwdState::GetInstance();
    StateStores[DRIVE_MOVEFWD_LEFT_STATE] = DriveMoveFwdLeftState::GetInstance();
    StateStores[DRIVE_MOVEFWD_RIGHT_STATE] = DriveMoveFwdRightState::GetInstance();
    StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE] = DriveMoveFwdStraightState::GetInstance();
    StateStores[DRIVE_LANECHANGE_STATE] = DriveLaneChangeState::GetInstance();
    StateStores[DRIVE_LANECHANGE_LEFT_STATE] = DriveLaneChangeLeftState::GetInstance();
    StateStores[DRIVE_LANECHANGE_RIGHT_STATE] = DriveLaneChangeRightState::GetInstance();
    StateStores[DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE] = DriveLaneChangeRightAvoidanceState::GetInstance();
    StateStores[DRIVE_OBSTACLE_AVOIDANCE_STATE] = DriveObstacleAvoidanceState::GetInstance();
    StateStores[DRIVE_OBSTACLE_AVOIDANCE_STATIC_STATE] = DriveObstacleAvoidanceStaticState::GetInstance();
    StateStores[DRIVE_OBSTACLE_AVOIDANCE_DYNAMIC_STATE] = DriveObstacleAvoidanceDynamicState::GetInstance();
    StateStores[DRIVE_STOP_STATE] = DriveStopState::GetInstance();
    StateStores[DRIVE_STOP_AVOIDANCE_STATE] = DriveStopAvoidanceState::GetInstance();
    StateStores[DRIVE_STOP_STOPLINE_STATE] = DriveStopStopLineState::GetInstance();
    StateStores[DRIVE_STOP_TRAFFICLIGHT_STATE] = DriveStopTrafficLightState::GetInstance();
    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::GetInstance();
    StateStores[EMERGENCY_STATE] = EmergencyState::GetInstance();
    StateStores[EMERGENCY_HW_STATE] = EmergencyHWState::GetInstance();
    StateStores[EMERGENCY_HWVEHICLE_STATE] = EmergencyHWVehicleState::GetInstance();
    StateStores[EMERGENCY_HWCONTROLLER_STATE] = EmergencyHWControllerState::GetInstance();
    StateStores[EMERGENCY_SW_STATE] = EmergencySWState::GetInstance();
    StateStores[EMERGENCY_SWAUTOWARE_STATE] = EmergencySWAutowareState::GetInstance();
    StateStores[EMERGENCY_SWCONTROLLER_STATE] = EmergencySWControllerState::GetInstance();

    ChangeStateFlags = 0;
    thread_loop = true;

    this-&gt;InitContext();
  }
  ~StateContext()
  {
    thread_loop = false;
  }

  bool isState(unsigned long long _state_num);
  bool inState(unsigned long long _state_num);

  void StateDecider(void);

  bool setCurrentState(BaseState *state);
  bool setCurrentState(BaseState *state, BaseState *substate);
  bool setCurrentState(BaseState *state, BaseState *substate, BaseState *subsubstate);

  BaseState *getCurrentState(void);
  std::unique_ptr&lt;std::string&gt; getCurrentStateName(void);
  void showCurrentStateName(void);

  BaseState *getStateObject(unsigned long long _state_num);
  void InitContext(void);

  bool TFInitialized(void);

  void handleTrafficLight(uint32_t _light_color);
  bool handleCurrentPose(double x, double y, double z, double roll, double pitch, double yaw);
  bool handlePointsRaw(bool _hasLidarData);

  bool handleIntersection(bool _hasIntersection, double _angle);
  bool handleTwistCmd(bool _hasTwistCmd);
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_drive.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_drive.hpp">
				<diff>@@ -23,20 +23,22 @@ private:
     StateName = &quot;Drive&quot;;
     StateNum = StateTransMask = DRIVE_STATE;
     StateTransMask |= INITIAL_LOCATEVEHICLE_STATE;
+    StateKind = MAIN_STATE;
   }
 
 public:
 };
 
-class DriveMoveFwdState : public State&lt;DriveMoveFwdState&gt;
+class DriveAccAccelerationState : public State&lt;DriveAccAccelerationState&gt;
 {
 private:
-  friend class State&lt;DriveMoveFwdState&gt;;
-  DriveMoveFwdState(void)
+  friend class State&lt;DriveAccAccelerationState&gt;;
+  DriveAccAccelerationState(void)
   {
-    StateName = &quot;MoveFwd&quot;;
-    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
-    StateTransMask = 0;
+    StateName = &quot;Acceleration&quot;;
+    StateNum = DRIVE_STATE | DRIVE_ACC_ACCELERATION_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
 
 public:
@@ -46,195 +48,189 @@ public:
   }
 };
 
-class DriveMoveFwdLeftState : public State&lt;DriveMoveFwdLeftState&gt;
+class DriveAccDecelerationState : public State&lt;DriveAccDecelerationState&gt;
 {
 private:
-  friend class State&lt;DriveMoveFwdLeftState&gt;;
-  DriveMoveFwdLeftState(void)
+  friend class State&lt;DriveAccDecelerationState&gt;;
+  DriveAccDecelerationState(void)
   {
-    StateName = &quot;MoveFwdLeft&quot;;
-    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_LEFT_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
+    StateName = &quot;Deceleration&quot;;
+    StateNum = DRIVE_STATE | DRIVE_ACC_DECELERATION_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
 
 public:
-};
-class DriveMoveFwdRightState : public State&lt;DriveMoveFwdRightState&gt;
-{
-private:
-  friend class State&lt;DriveMoveFwdRightState&gt;;
-  DriveMoveFwdRightState(void)
+  void ShowStateName(void)
   {
-    StateName = &quot;MoveFwdRight&quot;;
-    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE | DRIVE_MOVEFWD_RIGHT_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
+    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
   }
-
-public:
 };
-class DriveMoveFwdStraightState : public State&lt;DriveMoveFwdStraightState&gt;
+
+class DriveAccKeepState : public State&lt;DriveAccKeepState&gt;
 {
 private:
-  friend class State&lt;DriveMoveFwdStraightState&gt;;
-  DriveMoveFwdStraightState(void)
+  friend class State&lt;DriveAccKeepState&gt;;
+  DriveAccKeepState(void)
   {
-    StateName = &quot;MoveFwdStraight&quot;;
-    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE | DRIVE_MOVEFWD_STRAIGHT_STATE;
+    StateName = &quot;Keep&quot;;
+    StateNum = DRIVE_STATE | DRIVE_ACC_KEEP_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
 
 public:
+  void ShowStateName(void)
+  {
+    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
+  }
 };
 
-class DriveLaneChangeState : public State&lt;DriveLaneChangeState&gt;
+class DriveAccStopState : public State&lt;DriveAccStopState&gt;
 {
 private:
-  friend class State&lt;DriveLaneChangeState&gt;;
-  DriveLaneChangeState(void)
+  friend class State&lt;DriveAccStopState&gt;;
+  DriveAccStopState(void)
   {
-    StateName = &quot;LaneChange&quot;;
-    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
+    StateName = &quot;Stop&quot;;
+    StateNum = DRIVE_STATE | DRIVE_ACC_STOP_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = ACC_STATE;
   }
 
 public:
-};
-
-class DriveLaneChangeLeftState : public State&lt;DriveLaneChangeLeftState&gt;
-{
-private:
-  friend class State&lt;DriveLaneChangeLeftState&gt;;
-  DriveLaneChangeLeftState(void)
+  void ShowStateName(void)
   {
-    StateName = &quot;LaneChangeLeft&quot;;
-    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_LEFT_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
+    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
   }
-
-public:
 };
 
-class DriveLaneChangeRightState : public State&lt;DriveLaneChangeRightState&gt;
+class DriveStrLeftState : public State&lt;DriveStrLeftState&gt;
 {
 private:
-  friend class State&lt;DriveLaneChangeRightState&gt;;
-  DriveLaneChangeRightState(void)
+  friend class State&lt;DriveStrLeftState&gt;;
+  DriveStrLeftState(void)
   {
-    StateName = &quot;LaneChangeRight&quot;;
-    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_RIGHT_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
+    StateName = &quot;Left Turn&quot;;
+    StateNum = DRIVE_STATE | DRIVE_STR_LEFT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = STR_STATE;
   }
 
 public:
 };
-
-class DriveLaneChangeRightAvoidanceState : public State&lt;DriveLaneChangeRightAvoidanceState&gt;
+class DriveStrRightState : public State&lt;DriveStrRightState&gt;
 {
 private:
-  friend class State&lt;DriveLaneChangeRightAvoidanceState&gt;;
-  DriveLaneChangeRightAvoidanceState(void)
+  friend class State&lt;DriveStrRightState&gt;;
+  DriveStrRightState(void)
   {
-    StateName = &quot;LaneChangeRightAvoidanceState&quot;;
-    StateNum =
-        DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_RIGHT_STATE | DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE;
-    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
+    StateName = &quot;Right Turn&quot;;
+    StateNum = DRIVE_STATE | DRIVE_STR_RIGHT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = STR_STATE;
   }
 
 public:
 };
-
-class DriveObstacleAvoidanceState : public State&lt;DriveObstacleAvoidanceState&gt;
+class DriveStrStraightState : public State&lt;DriveStrStraightState&gt;
 {
 private:
-  friend class State&lt;DriveObstacleAvoidanceState&gt;;
-  DriveObstacleAvoidanceState(void)
+  friend class State&lt;DriveStrStraightState&gt;;
+  DriveStrStraightState(void)
   {
-    StateName = &quot;ObstacleAvoidance&quot;;
-    StateTransMask = 0;
+    StateName = &quot;Straight&quot;;
+    StateNum = DRIVE_STATE | DRIVE_STR_STRAIGHT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = STR_STATE;
   }
 
 public:
 };
 
-class DriveObstacleAvoidanceStaticState : public State&lt;DriveObstacleAvoidanceStaticState&gt;
+class DriveBehaviorLaneChangeLeftState : public State&lt;DriveBehaviorLaneChangeLeftState&gt;
 {
 private:
-  friend class State&lt;DriveObstacleAvoidanceStaticState&gt;;
-  DriveObstacleAvoidanceStaticState(void)
+  friend class State&lt;DriveBehaviorLaneChangeLeftState&gt;;
+  DriveBehaviorLaneChangeLeftState(void)
   {
-    StateName = &quot;ObstacleAvoidanceStatic&quot;;
-    StateTransMask = 0;
+    StateName = &quot;LaneChangeLeft&quot;;
+    StateNum = DRIVE_STATE | DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = BEHAVIOR_STATE;
   }
 
 public:
 };
 
-class DriveObstacleAvoidanceDynamicState : public State&lt;DriveObstacleAvoidanceDynamicState&gt;
+class DriveBehaviorLaneChangeRightState : public State&lt;DriveBehaviorLaneChangeRightState&gt;
 {
 private:
-  friend class State&lt;DriveObstacleAvoidanceDynamicState&gt;;
-  DriveObstacleAvoidanceDynamicState(void)
+  friend class State&lt;DriveBehaviorLaneChangeRightState&gt;;
+  DriveBehaviorLaneChangeRightState(void)
   {
-    StateName = &quot;ObstacleAvoidanceDynamic&quot;;
-    StateTransMask = 0;
+    StateName = &quot;LaneChangeRight&quot;;
+    StateNum = DRIVE_STATE | DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE;
+    StateTransMask = DRIVE_STATE;
+    StateKind = BEHAVIOR_STATE;
   }
 
 public:
 };
 
-// DriveStopState
-class DriveStopState : public State&lt;DriveStopState&gt;
+class DriveBehaviorObstacleAvoidanceState : public State&lt;DriveBehaviorObstacleAvoidanceState&gt;
 {
 private:
-  friend class State&lt;DriveStopState&gt;;
-  DriveStopState(void)
+  friend class State&lt;DriveBehaviorObstacleAvoidanceState&gt;;
+  DriveBehaviorObstacleAvoidanceState(void)
   {
-    StateName = &quot;DriveStop&quot;;
-    StateNum = DRIVE_STATE | DRIVE_STOP_STATE;
+    StateName = &quot;ObstacleAvoidance&quot;;
     StateTransMask = DRIVE_STATE;
+    StateKind = BEHAVIOR_STATE;
   }
-
 public:
 };
 
-// DriveStopAvoidanceState
-class DriveStopAvoidanceState : public State&lt;DriveStopAvoidanceState&gt;
+class DriveDetectObstacleState : public State&lt;DriveDetectObstacleState&gt;
 {
 private:
-  friend class State&lt;DriveStopAvoidanceState&gt;;
-  DriveStopAvoidanceState(void)
+  friend class State&lt;DriveDetectObstacleState&gt;;
+  DriveDetectObstacleState(void)
   {
-    StateName = &quot;DriveStopAvoidance&quot;;
-    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_AVOIDANCE_STATE;
+    StateName = &quot;DetectObstacle&quot;;
+    StateNum = DRIVE_STATE | DRIVE_DETECT_OBSTACLE_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = PERCEPTION_STATE;
   }
 
 public:
 };
 
-// DriveStopStopLineState
-class DriveStopStopLineState : public State&lt;DriveStopStopLineState&gt;
+class DriveDetectStoplineState : public State&lt;DriveDetectStoplineState&gt;
 {
 private:
-  friend class State&lt;DriveStopStopLineState&gt;;
-  DriveStopStopLineState(void)
+  friend class State&lt;DriveDetectStoplineState&gt;;
+  DriveDetectStoplineState(void)
   {
-    StateName = &quot;DriveStopStopLine&quot;;
-    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_STOPLINE_STATE;
+    StateName = &quot;DetectStopline&quot;;
+    StateNum = DRIVE_STATE | DRIVE_DETECT_STOPLINE_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = PERCEPTION_STATE;
   }
 
 public:
 };
-class DriveStopTrafficLightState : public State&lt;DriveStopTrafficLightState&gt;
+
+class DriveDetectTrafficlightRedState : public State&lt;DriveDetectTrafficlightRedState&gt;
 {
 private:
-  friend class State&lt;DriveStopTrafficLightState&gt;;
-  DriveStopTrafficLightState(void)
+  friend class State&lt;DriveDetectTrafficlightRedState&gt;;
+  DriveDetectTrafficlightRedState(void)
   {
-    StateName = &quot;DriveStopTrafficLight&quot;;
-    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_TRAFFICLIGHT_STATE;
+    StateName = &quot;DetectTrafficLightRed&quot;;
+    StateNum = DRIVE_STATE | DRIVE_DETECT_TRAFFICLIGHT_RED_STATE;
     StateTransMask = DRIVE_STATE;
+    StateKind = PERCEPTION_STATE;
   }
 
 public:
</diff>
				<old_file>#ifndef __STATE_DRIVE_HPP__
#define __STATE_DRIVE_HPP__

/**
 * @file state_drive.hpp
 * @brief Declaration drive state
 * @author Yusuke Fujii
 * @date 2017/07/27
 */

#include &quot;state.hpp&quot;

namespace state_machine
{
// DriveState
class DriveState : public State&lt;DriveState&gt;
{
private:
  friend class State&lt;DriveState&gt;;

  DriveState(void)
  {
    StateName = &quot;Drive&quot;;
    StateNum = StateTransMask = DRIVE_STATE;
    StateTransMask |= INITIAL_LOCATEVEHICLE_STATE;
  }

public:
};

class DriveMoveFwdState : public State&lt;DriveMoveFwdState&gt;
{
private:
  friend class State&lt;DriveMoveFwdState&gt;;
  DriveMoveFwdState(void)
  {
    StateName = &quot;MoveFwd&quot;;
    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
    StateTransMask = 0;
  }

public:
  void ShowStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }
};

class DriveMoveFwdLeftState : public State&lt;DriveMoveFwdLeftState&gt;
{
private:
  friend class State&lt;DriveMoveFwdLeftState&gt;;
  DriveMoveFwdLeftState(void)
  {
    StateName = &quot;MoveFwdLeft&quot;;
    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_LEFT_STATE;
    StateTransMask = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
  }

public:
};
class DriveMoveFwdRightState : public State&lt;DriveMoveFwdRightState&gt;
{
private:
  friend class State&lt;DriveMoveFwdRightState&gt;;
  DriveMoveFwdRightState(void)
  {
    StateName = &quot;MoveFwdRight&quot;;
    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE | DRIVE_MOVEFWD_RIGHT_STATE;
    StateTransMask = DRIVE_STATE | DRIVE_MOVEFWD_STATE;
  }

public:
};
class DriveMoveFwdStraightState : public State&lt;DriveMoveFwdStraightState&gt;
{
private:
  friend class State&lt;DriveMoveFwdStraightState&gt;;
  DriveMoveFwdStraightState(void)
  {
    StateName = &quot;MoveFwdStraight&quot;;
    StateNum = DRIVE_STATE | DRIVE_MOVEFWD_STATE | DRIVE_MOVEFWD_STRAIGHT_STATE;
    StateTransMask = DRIVE_STATE;
  }

public:
};

class DriveLaneChangeState : public State&lt;DriveLaneChangeState&gt;
{
private:
  friend class State&lt;DriveLaneChangeState&gt;;
  DriveLaneChangeState(void)
  {
    StateName = &quot;LaneChange&quot;;
    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
    StateTransMask = DRIVE_STATE;
  }

public:
};

class DriveLaneChangeLeftState : public State&lt;DriveLaneChangeLeftState&gt;
{
private:
  friend class State&lt;DriveLaneChangeLeftState&gt;;
  DriveLaneChangeLeftState(void)
  {
    StateName = &quot;LaneChangeLeft&quot;;
    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_LEFT_STATE;
    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
  }

public:
};

class DriveLaneChangeRightState : public State&lt;DriveLaneChangeRightState&gt;
{
private:
  friend class State&lt;DriveLaneChangeRightState&gt;;
  DriveLaneChangeRightState(void)
  {
    StateName = &quot;LaneChangeRight&quot;;
    StateNum = DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_RIGHT_STATE;
    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
  }

public:
};

class DriveLaneChangeRightAvoidanceState : public State&lt;DriveLaneChangeRightAvoidanceState&gt;
{
private:
  friend class State&lt;DriveLaneChangeRightAvoidanceState&gt;;
  DriveLaneChangeRightAvoidanceState(void)
  {
    StateName = &quot;LaneChangeRightAvoidanceState&quot;;
    StateNum =
        DRIVE_STATE | DRIVE_LANECHANGE_STATE | DRIVE_LANECHANGE_RIGHT_STATE | DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE;
    StateTransMask = DRIVE_STATE | DRIVE_LANECHANGE_STATE;
  }

public:
};

class DriveObstacleAvoidanceState : public State&lt;DriveObstacleAvoidanceState&gt;
{
private:
  friend class State&lt;DriveObstacleAvoidanceState&gt;;
  DriveObstacleAvoidanceState(void)
  {
    StateName = &quot;ObstacleAvoidance&quot;;
    StateTransMask = 0;
  }

public:
};

class DriveObstacleAvoidanceStaticState : public State&lt;DriveObstacleAvoidanceStaticState&gt;
{
private:
  friend class State&lt;DriveObstacleAvoidanceStaticState&gt;;
  DriveObstacleAvoidanceStaticState(void)
  {
    StateName = &quot;ObstacleAvoidanceStatic&quot;;
    StateTransMask = 0;
  }

public:
};

class DriveObstacleAvoidanceDynamicState : public State&lt;DriveObstacleAvoidanceDynamicState&gt;
{
private:
  friend class State&lt;DriveObstacleAvoidanceDynamicState&gt;;
  DriveObstacleAvoidanceDynamicState(void)
  {
    StateName = &quot;ObstacleAvoidanceDynamic&quot;;
    StateTransMask = 0;
  }

public:
};

// DriveStopState
class DriveStopState : public State&lt;DriveStopState&gt;
{
private:
  friend class State&lt;DriveStopState&gt;;
  DriveStopState(void)
  {
    StateName = &quot;DriveStop&quot;;
    StateNum = DRIVE_STATE | DRIVE_STOP_STATE;
    StateTransMask = DRIVE_STATE;
  }

public:
};

// DriveStopAvoidanceState
class DriveStopAvoidanceState : public State&lt;DriveStopAvoidanceState&gt;
{
private:
  friend class State&lt;DriveStopAvoidanceState&gt;;
  DriveStopAvoidanceState(void)
  {
    StateName = &quot;DriveStopAvoidance&quot;;
    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_AVOIDANCE_STATE;
    StateTransMask = DRIVE_STATE;
  }

public:
};

// DriveStopStopLineState
class DriveStopStopLineState : public State&lt;DriveStopStopLineState&gt;
{
private:
  friend class State&lt;DriveStopStopLineState&gt;;
  DriveStopStopLineState(void)
  {
    StateName = &quot;DriveStopStopLine&quot;;
    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_STOPLINE_STATE;
    StateTransMask = DRIVE_STATE;
  }

public:
};
class DriveStopTrafficLightState : public State&lt;DriveStopTrafficLightState&gt;
{
private:
  friend class State&lt;DriveStopTrafficLightState&gt;;
  DriveStopTrafficLightState(void)
  {
    StateName = &quot;DriveStopTrafficLight&quot;;
    StateNum = DRIVE_STATE | DRIVE_STOP_STATE | DRIVE_STOP_TRAFFICLIGHT_STATE;
    StateTransMask = DRIVE_STATE;
  }

public:
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_flags.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_flags.hpp">
				<diff>@@ -10,30 +10,33 @@ enum StateFlags
   INITIAL_STATE = 1 &lt;&lt; 2,
   INITIAL_LOCATEVEHICLE_STATE = 1 &lt;&lt; 3,
   DRIVE_STATE = 1 &lt;&lt; 4,
-  DRIVE_MOVEFWD_STATE = 1 &lt;&lt; 5,
-  DRIVE_MOVEFWD_LEFT_STATE = 1 &lt;&lt; 6,
-  DRIVE_MOVEFWD_RIGHT_STATE = 1 &lt;&lt; 7,
-  DRIVE_MOVEFWD_STRAIGHT_STATE = 1 &lt;&lt; 8,
-  DRIVE_LANECHANGE_STATE = 1 &lt;&lt; 9,
-  DRIVE_LANECHANGE_LEFT_STATE = 1 &lt;&lt; 10,
-  DRIVE_LANECHANGE_RIGHT_STATE = 1 &lt;&lt; 11,
-  DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE = 1 &lt;&lt; 12,
-  DRIVE_OBSTACLE_AVOIDANCE_STATE = 1 &lt;&lt; 13,
-  DRIVE_OBSTACLE_AVOIDANCE_STATIC_STATE = 1 &lt;&lt; 14,
-  DRIVE_OBSTACLE_AVOIDANCE_DYNAMIC_STATE = 1 &lt;&lt; 15,
-  DRIVE_STOP_STATE = 1 &lt;&lt; 16,
-  DRIVE_STOP_AVOIDANCE_STATE = 1 &lt;&lt; 17,
-  DRIVE_STOP_STOPLINE_STATE = 1 &lt;&lt; 18,
-  DRIVE_STOP_TRAFFICLIGHT_STATE = 1 &lt;&lt; 19,
-  MISSION_COMPLETE_STATE = 1 &lt;&lt; 20,
-  EMERGENCY_STATE = 1 &lt;&lt; 21,
-  EMERGENCY_HW_STATE = 1 &lt;&lt; 22,
-  EMERGENCY_HWVEHICLE_STATE = 1 &lt;&lt; 23,
-  EMERGENCY_HWCONTROLLER_STATE = 1 &lt;&lt; 24,
-  EMERGENCY_SW_STATE = 1 &lt;&lt; 25,
-  EMERGENCY_SWAUTOWARE_STATE = 1 &lt;&lt; 26,
-  EMERGENCY_SWCONTROLLER_STATE = 1 &lt;&lt; 27,
-  STATE_END = 1 &lt;&lt; 28,
+  DRIVE_ACC_ACCELERATION_STATE = 1 &lt;&lt; 5,
+  DRIVE_ACC_DECELERATION_STATE = 1 &lt;&lt; 6,
+  DRIVE_ACC_KEEP_STATE = 1 &lt;&lt; 7,
+  DRIVE_ACC_STOP_STATE = 1 &lt;&lt; 8,
+  DRIVE_STR_STRAIGHT_STATE = 1 &lt;&lt; 9,
+  DRIVE_STR_LEFT_STATE = 1 &lt;&lt; 10,
+  DRIVE_STR_RIGHT_STATE = 1 &lt;&lt; 11,
+  DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE = 1 &lt;&lt; 12,
+  DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE = 1 &lt;&lt; 13,
+  DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE = 1 &lt;&lt; 13,
+  DRIVE_DETECT_OBSTACLE_STATE = 1 &lt;&lt; 14,
+  DRIVE_DETECT_STOPLINE_STATE = 1 &lt;&lt; 15,
+  DRIVE_DETECT_TRAFFICLIGHT_RED_STATE = 1 &lt;&lt; 16,
+  MISSION_COMPLETE_STATE = 1 &lt;&lt; 17,
+  EMERGENCY_STATE = 1 &lt;&lt; 18,
+  STATE_END = 1 &lt;&lt; 19,
+};
+
+enum StateKinds
+{
+  MAIN_STATE,
+  ACC_STATE,
+  STR_STATE,
+  BEHAVIOR_STATE,
+  PERCEPTION_STATE,
+  OTHER_STATE,
+  UNKNOWN_STATE,
 };
 
 enum TrafficLightColors
</diff>
				<old_file>#ifndef __STATE_FLAGS_HPP__
#define __STATE_FLAGS_HPP__

namespace state_machine
{
enum StateFlags
{
  NULL_STATE = 1 &lt;&lt; 0,
  START_STATE = 1 &lt;&lt; 1,
  INITIAL_STATE = 1 &lt;&lt; 2,
  INITIAL_LOCATEVEHICLE_STATE = 1 &lt;&lt; 3,
  DRIVE_STATE = 1 &lt;&lt; 4,
  DRIVE_MOVEFWD_STATE = 1 &lt;&lt; 5,
  DRIVE_MOVEFWD_LEFT_STATE = 1 &lt;&lt; 6,
  DRIVE_MOVEFWD_RIGHT_STATE = 1 &lt;&lt; 7,
  DRIVE_MOVEFWD_STRAIGHT_STATE = 1 &lt;&lt; 8,
  DRIVE_LANECHANGE_STATE = 1 &lt;&lt; 9,
  DRIVE_LANECHANGE_LEFT_STATE = 1 &lt;&lt; 10,
  DRIVE_LANECHANGE_RIGHT_STATE = 1 &lt;&lt; 11,
  DRIVE_LANECHANGE_RIGHT_AVOIDANCE_STATE = 1 &lt;&lt; 12,
  DRIVE_OBSTACLE_AVOIDANCE_STATE = 1 &lt;&lt; 13,
  DRIVE_OBSTACLE_AVOIDANCE_STATIC_STATE = 1 &lt;&lt; 14,
  DRIVE_OBSTACLE_AVOIDANCE_DYNAMIC_STATE = 1 &lt;&lt; 15,
  DRIVE_STOP_STATE = 1 &lt;&lt; 16,
  DRIVE_STOP_AVOIDANCE_STATE = 1 &lt;&lt; 17,
  DRIVE_STOP_STOPLINE_STATE = 1 &lt;&lt; 18,
  DRIVE_STOP_TRAFFICLIGHT_STATE = 1 &lt;&lt; 19,
  MISSION_COMPLETE_STATE = 1 &lt;&lt; 20,
  EMERGENCY_STATE = 1 &lt;&lt; 21,
  EMERGENCY_HW_STATE = 1 &lt;&lt; 22,
  EMERGENCY_HWVEHICLE_STATE = 1 &lt;&lt; 23,
  EMERGENCY_HWCONTROLLER_STATE = 1 &lt;&lt; 24,
  EMERGENCY_SW_STATE = 1 &lt;&lt; 25,
  EMERGENCY_SWAUTOWARE_STATE = 1 &lt;&lt; 26,
  EMERGENCY_SWCONTROLLER_STATE = 1 &lt;&lt; 27,
  STATE_END = 1 &lt;&lt; 28,
};

enum TrafficLightColors
{
  RED,
  YELLOW,
  GREEN,
  COLOR_ERROR
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp" new_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp">
				<diff>@@ -12,8 +12,6 @@
 #include &lt;state.hpp&gt;
 #include &lt;state_common.hpp&gt;
 
-using namespace std;
-
 /**
  *
  * @file StateContext.cpp
@@ -33,70 +31,78 @@ namespace state_machine
  */
 void StateContext::showCurrentStateName(void)
 {
-  state_-&gt;ShowStateName();
+  current_state_.MainState-&gt;showStateName();
+#if 0
   if (sub_state)
-    sub_state-&gt;ShowStateName();
+    sub_state-&gt;showStateName();
   if (sub_sub_state)
-    sub_sub_state-&gt;ShowStateName();
+    sub_sub_state-&gt;showStateName();
+#endif
   std::cout &lt;&lt; std::endl;
 }
 
 std::unique_ptr&lt;std::string&gt; StateContext::getCurrentStateName(void)
 {
-  return state_-&gt;GetStateName();
+  return current_state_.MainState-&gt;getStateName();
 }
 
 /**
  * @fn
- * set to current state, substate, subsubstate
+ * set to current state
  * @brief standard out a state name
  * @param (state) Setting class
  * @return void
  */
 bool StateContext::setCurrentState(BaseState *_state)
 {
-  return _state ? this-&gt;setCurrentState(_state, nullptr, nullptr) : false;
-}
-
-bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate)
-{
-  return _state ? this-&gt;setCurrentState(_state, _substate, nullptr) : false;
-}
-
-bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate, BaseState *_subsubstate)
-{
-  BaseState *prevState = state_;
+  BaseState *prevState = current_state_.MainState;
 
-  if (!state_)
+  if (!prevState)
   {
-    state_ = _state;
-
+    current_state_.MainState = _state;
     std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
               &lt;&lt; &quot;NULL&quot;
-              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; &quot;/&quot;
+              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
               &lt;&lt; &quot;NULL&quot;
-              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
+              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
   }
   else
   {
-    if (_state &amp;&amp; (_state-&gt;GetStateTransMask() &amp; state_-&gt;GetStateNum()))
+    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
     {
-      if (!(state_ == _state))
-      {
-        state_ = _state;
-        sub_state = _substate;
-        sub_sub_state = _subsubstate;
-
-        std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; *prevState-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; to \&quot;&quot;
-                  &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; &quot;/&quot;
-                  &lt;&lt; prevState-&gt;GetStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
+	switch(_state-&gt;getStateKind()){
+		case MAIN_STATE:
+			current_state_.MainState = _state;
+			current_state_.AccState = nullptr;
+			current_state_.StrState = nullptr;
+			current_state_.BehaviorState = nullptr;
+			current_state_.PerceptionState = nullptr;
+			current_state_.OtherState = nullptr;
+			break;
+		case ACC_STATE:
+			current_state_.AccState = _state;
+			break;
+		case STR_STATE:
+			current_state_.StrState = _state;
+			break;
+		case BEHAVIOR_STATE:
+			current_state_.BehaviorState = _state;
+			break;
+		case PERCEPTION_STATE:
+			current_state_.PerceptionState = _state;
+			break;
+		case OTHER_STATE:
+			current_state_.OtherState = _state;
+			break;
+	}
+        std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; *prevState-&gt;getStateName().get() &lt;&lt; &quot;\&quot; to \&quot;&quot;
+                  &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
+                  &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
       }
-    }
-    else
-    {
-      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; *state_-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; to \&quot;&quot;
-                &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; &quot;/&quot;
-                &lt;&lt; state_-&gt;GetStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
+    else{
+      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; *current_state_.MainState-&gt;getStateName().get() &lt;&lt; &quot;\&quot; to \&quot;&quot;
+                &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
+                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
       prevState = nullptr;
       return false;
     }
@@ -104,39 +110,31 @@ bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate, Base
   return true;
 }
 
-BaseState *StateContext::getCurrentState(void)
+
+bool StateContext::setEnableForceSetState(bool force_flag)
+{
+	enableForceSetState = force_flag;
+	return true;
+}
+
+BaseState *StateContext::getCurrentMainState(void)
 {
-  return state_;
+  return current_state_.MainState;
 }
 
 BaseState *StateContext::getStateObject(unsigned long long _state_num)
 {
   return StateStores[_state_num];
 }
+
 bool StateContext::isState(unsigned long long _state_num)
 {
-  return state_-&gt;GetStateNum() == _state_num;
+  return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num:false;
 }
 
 bool StateContext::inState(unsigned long long _state_num)
 {
-  return state_-&gt;GetStateNum() &amp; _state_num;
-}
-
-void StateContext::handleTrafficLight(uint32_t _light_color)
-{
-  switch (_light_color)
-  {
-    case RED:
-    case YELLOW:
-      setCurrentState(StateStores[DRIVE_STOP_TRAFFICLIGHT_STATE]);
-      break;
-    case GREEN:
-      break;
-
-    default:
-      break;
-  }
+  return current_state_.MainState?current_state_.MainState-&gt;getStateNum() &amp; _state_num:false;
 }
 
 #define ANGLE_STRAIGHT 50.0
@@ -151,7 +149,7 @@ bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
     // first-waypoint
     // and end-waypoint in intersection area.
     int temp = (int)std::floor(_angle + 360.0) % 360;
-
+#if 0
     if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
       return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE]);
     else if (temp &lt;= ANGLE_RIGHT)
@@ -160,6 +158,7 @@ bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
       return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_LEFT_STATE]);
     else
       return false;
+#endif
   }
   else
   {
@@ -170,7 +169,7 @@ bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
 bool StateContext::handleTwistCmd(bool _hasTwistCmd)
 {
   if (_hasTwistCmd)
-    return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STATE]);
+    return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
   else
     return false;
 }
@@ -223,7 +222,7 @@ bool StateContext::handleCurrentPose(double _x, double _y, double _z, double _ro
   }
 }
 
-void StateContext::StateDecider(void)
+void StateContext::stateDecider(void)
 {
   while (thread_loop)
   {
@@ -244,10 +243,9 @@ void StateContext::StateDecider(void)
 
 void StateContext::InitContext(void)
 {
-  thr_state_dec = new std::thread(&amp;StateContext::StateDecider, this);
+  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
   thr_state_dec-&gt;detach();
   this-&gt;setCurrentState(StateStores[START_STATE]);
-
   return;
 }
 bool StateContext::TFInitialized(void)
</diff>
				<old_file>#include &lt;sched.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

#include &lt;cassert&gt;

#include &lt;euclidean_space.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;state.hpp&gt;
#include &lt;state_common.hpp&gt;

using namespace std;

/**
 *
 * @file StateContext.cpp
 * @brief state context class
 * @author Yusuke Fujii
 * @date  2017/07/25
 *
 **/

namespace state_machine
{
/**
 * @fn
 *
 * @brief
 * @return
 */
void StateContext::showCurrentStateName(void)
{
  state_-&gt;ShowStateName();
  if (sub_state)
    sub_state-&gt;ShowStateName();
  if (sub_sub_state)
    sub_sub_state-&gt;ShowStateName();
  std::cout &lt;&lt; std::endl;
}

std::unique_ptr&lt;std::string&gt; StateContext::getCurrentStateName(void)
{
  return state_-&gt;GetStateName();
}

/**
 * @fn
 * set to current state, substate, subsubstate
 * @brief standard out a state name
 * @param (state) Setting class
 * @return void
 */
bool StateContext::setCurrentState(BaseState *_state)
{
  return _state ? this-&gt;setCurrentState(_state, nullptr, nullptr) : false;
}

bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate)
{
  return _state ? this-&gt;setCurrentState(_state, _substate, nullptr) : false;
}

bool StateContext::setCurrentState(BaseState *_state, BaseState *_substate, BaseState *_subsubstate)
{
  BaseState *prevState = state_;

  if (!state_)
  {
    state_ = _state;

    std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; &quot;/&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }
  else
  {
    if (_state &amp;&amp; (_state-&gt;GetStateTransMask() &amp; state_-&gt;GetStateNum()))
    {
      if (!(state_ == _state))
      {
        state_ = _state;
        sub_state = _substate;
        sub_sub_state = _subsubstate;

        std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; *prevState-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; to \&quot;&quot;
                  &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; &quot;/&quot;
                  &lt;&lt; prevState-&gt;GetStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
      }
    }
    else
    {
      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; *state_-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; to \&quot;&quot;
                &lt;&lt; *_state-&gt;GetStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;GetStateTransMask() &lt;&lt; &quot;/&quot;
                &lt;&lt; state_-&gt;GetStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;GetStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
      prevState = nullptr;
      return false;
    }
  }
  return true;
}

BaseState *StateContext::getCurrentState(void)
{
  return state_;
}

BaseState *StateContext::getStateObject(unsigned long long _state_num)
{
  return StateStores[_state_num];
}
bool StateContext::isState(unsigned long long _state_num)
{
  return state_-&gt;GetStateNum() == _state_num;
}

bool StateContext::inState(unsigned long long _state_num)
{
  return state_-&gt;GetStateNum() &amp; _state_num;
}

void StateContext::handleTrafficLight(uint32_t _light_color)
{
  switch (_light_color)
  {
    case RED:
    case YELLOW:
      setCurrentState(StateStores[DRIVE_STOP_TRAFFICLIGHT_STATE]);
      break;
    case GREEN:
      break;

    default:
      break;
  }
}

#define ANGLE_STRAIGHT 50.0
#define ANGLE_LEFT 360.0
#define ANGLE_RIGHT 180.0
bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
{
  if (_hasIntersection)
  {
    // *Temporary implementation*
    // To straight/left/right recognition by using angle between
    // first-waypoint
    // and end-waypoint in intersection area.
    int temp = (int)std::floor(_angle + 360.0) % 360;

    if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE]);
    else if (temp &lt;= ANGLE_RIGHT)
      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_RIGHT_STATE]);
    else if (temp &lt;= ANGLE_LEFT)
      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_LEFT_STATE]);
    else
      return false;
  }
  else
  {
    return false;
  }
}

bool StateContext::handleTwistCmd(bool _hasTwistCmd)
{
  if (_hasTwistCmd)
    return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STATE]);
  else
    return false;
}

bool StateContext::handlePointsRaw(bool _hasLidarData)
{
  return _hasLidarData ? this-&gt;setCurrentState(StateStores[INITIAL_LOCATEVEHICLE_STATE]) : false;
}

#define CONV_NUM 10
#define CONVERGENCE_THRESHOLD 0.01

bool StateContext::handleCurrentPose(double _x, double _y, double _z, double _roll, double _pitch, double _yaw)
{
  static int _init_count = 0;
  static euclidean_space::point *a = new euclidean_space::point();
  static euclidean_space::point *b = new euclidean_space::point();

  static double distances[CONV_NUM] = { 0.0 };
  double avg_distances = 0.0;

  for (int i = 1; i &lt; CONV_NUM; i++)
  {
    distances[i] = distances[i - 1];
    avg_distances += distances[i];
  }

  a-&gt;x = b-&gt;x;
  a-&gt;y = b-&gt;y;
  a-&gt;z = b-&gt;z;

  b-&gt;x = _x;
  b-&gt;y = _y;
  b-&gt;z = _z;

  distances[0] = euclidean_space::EuclideanSpace::find_distance(a, b);

  if (++_init_count &lt;= CONV_NUM)
  {
    return false;
  }
  else
  {
    avg_distances = (avg_distances + distances[0]) / CONV_NUM;

    if (avg_distances &lt;= CONVERGENCE_THRESHOLD)
      return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
    else
      return false;
  }
}

void StateContext::StateDecider(void)
{
  while (thread_loop)
  {
    if (ChangeStateFlags)
      for (unsigned long long l = 1; l &lt; STATE_END; l = l * 2)
      {
        if (ChangeStateFlags &amp; l &amp;&amp; StateStores[l])
        {
          setCurrentState(StateStores[l]);
          ChangeStateFlags -= l;
        }
      }
    std::this_thread::sleep_for(std::chrono::microseconds(1000));
  }
  std::cerr &lt;&lt; &quot;StateDecider thread will be closed&quot; &lt;&lt; std::endl;
  return;
}

void StateContext::InitContext(void)
{
  thr_state_dec = new std::thread(&amp;StateContext::StateDecider, this);
  thr_state_dec-&gt;detach();
  this-&gt;setCurrentState(StateStores[START_STATE]);

  return;
}
bool StateContext::TFInitialized(void)
{
  return this-&gt;setCurrentState(StateStores[INITIAL_STATE]);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="e1bff467a567469917124433fa8617cfa3e0937d" fix_time="6,28368">
		<msg>fix bug and change mqtt library</msg>
		<modified_files>
			<file old_path="ros/src/socket/packages/mqtt_socket/include/mqtt_socket/mqtt_setting.hpp" new_path="ros/src/socket/packages/mqtt_socket/include/mqtt_socket/mqtt_setting.hpp">
				<diff>@@ -1,12 +1,13 @@
 #include &quot;std_msgs/String.h&quot;
 
 #define VEHICLEID       &quot;1&quot;
-#define ADDRESS         &quot;tcp://localhost:1883&quot;
+#define MQTT_ADDRESS    &quot;localhost&quot;
+#define MQTT_PORT       1883
 #define CLIENTID        &quot;vehicle&quot;
 #define SENDER_TOPIC    &quot;vehicle/&quot;
 #define RECIEVER_TOPIC  &quot;vehicle/&quot;
 #define PAYLOAD         &quot;Autoware&quot;
-#define QOS             1
+#define QOS             0
 #define TIMEOUT         10000L
 #define AUTO_MODE       1
 #define REMOTE_MODE     2
</diff>
				<old_file>#include &quot;std_msgs/String.h&quot;

#define VEHICLEID       &quot;1&quot;
#define ADDRESS         &quot;tcp://localhost:1883&quot;
#define CLIENTID        &quot;vehicle&quot;
#define SENDER_TOPIC    &quot;vehicle/&quot;
#define RECIEVER_TOPIC  &quot;vehicle/&quot;
#define PAYLOAD         &quot;Autoware&quot;
#define QOS             1
#define TIMEOUT         10000L
#define AUTO_MODE       1
#define REMOTE_MODE     2
#define NORMAL_MODE     0
#define EMERGENCY_MODE  1
#define ACCEL_MAX_VAL   5 // km/h
#define BRAKE_MAX_VAL   10000
#define STEER_MAX_VAL   0.6
#define DOWNSAMPLE      0.1
</old_file>
			</file>
			<file old_path="ros/src/socket/packages/mqtt_socket/nodes/mqtt_sender/mqtt_sender.cpp" new_path="ros/src/socket/packages/mqtt_socket/nodes/mqtt_sender/mqtt_sender.cpp">
				<diff>@@ -32,9 +32,12 @@
 #include &quot;std_msgs/String.h&quot;
 #include &quot;stdlib.h&quot;
 #include &quot;string.h&quot;
-#include &quot;MQTTClient.h&quot;
 #include &quot;mqtt_socket/mqtt_setting.hpp&quot;
 #include &quot;autoware_msgs/CanInfo.h&quot;
+#include &lt;std_msgs/Float64MultiArray.h&gt;
+#include &lt;geometry_msgs/TwistStamped.h&gt;
+#include &lt;unordered_map&gt;
+#include &lt;mosquitto.h&gt;
 
 class MqttSender
 {
@@ -42,15 +45,18 @@ public:
   MqttSender();
   ~MqttSender();
   void canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg);
+  static void on_connect(struct mosquitto *mosq, void *obj, int result);
+  static void on_disconnect(struct mosquitto *mosq, void *obj, int rc);
+  static void on_publish(struct mosquitto *mosq, void *userdata, int mid);
 
 private:
   std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
   ros::NodeHandle node_handle_;
-  MQTTClient_message pubmsg_;
-  MQTTClient_deliveryToken deliveredtoken_;
 
-  MQTTClient mqtt_client_;
+  // MQTT
+  struct mosquitto *mqtt_client_ = NULL;
   std::string mqtt_address_;
+  int mqtt_port_;
   std::string mqtt_topic_;
   std::string mqtt_client_id_;
   int mqtt_qos_;
@@ -63,7 +69,7 @@ private:
   geometry_msgs::TwistStamped current_twist_cmd_; //mps
   double current_target_velocity_; // mps2kmph(current_twist_cmd_.twist.twist.linear.x);
   std_msgs::String current_state_;
-  
+
   void targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;msg);
   void twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg);
   void stateCallback(const std_msgs::String &amp;msg);
@@ -79,48 +85,58 @@ MqttSender::MqttSender() :
     node_handle_(&quot;~&quot;)
 {
   // ROS Subscriber
-  Subs[&quot;can_info&quot;] = node_handle_.subscribe(&quot;/can_info&quot;, 1000, &amp;MqttSender::canInfoCallback, this);
+  Subs[&quot;can_info&quot;] = node_handle_.subscribe(&quot;/can_info&quot;, 100, &amp;MqttSender::canInfoCallback, this);
   Subs[&quot;target_velocity_array&quot;] = node_handle_.subscribe(&quot;/target_velocity_array&quot;, 1, &amp;MqttSender::targetVelocityArrayCallback, this);
   Subs[&quot;twist_cmd&quot;] = node_handle_.subscribe(&quot;/twist_cmd&quot;, 1, &amp;MqttSender::twistCmdCallback, this);
-  Subs[&quot;state&quot;] = node_handle_.subscribe(&quot;/state&quot;, 1, &amp;MqttSender::stateCallback, this)
+  Subs[&quot;state&quot;] = node_handle_.subscribe(&quot;/state&quot;, 1, &amp;MqttSender::stateCallback, this);
 
   // MQTT PARAMS
-  pubmsg_ = MQTTClient_message_initializer;
-  mqtt_address_ = ADDRESS;
+  mosquitto_lib_init();
+
+  mqtt_address_ = MQTT_ADDRESS;
+  mqtt_port_ = MQTT_PORT;
   mqtt_topic_ = std::string(SENDER_TOPIC) + std::string(VEHICLEID) + &quot;/can_info&quot;;
   mqtt_client_id_ = std::string(CLIENTID) + &quot;_&quot; + std::string(VEHICLEID) + &quot;_snd&quot;;
   mqtt_qos_ = QOS;
   mqtt_timeout_ = TIMEOUT;
   mqtt_downsample_ = DOWNSAMPLE;
   callback_counter_ = 0;
+
   node_handle_.param(&quot;/confing/mqtt/address&quot;, mqtt_address_, mqtt_address_);
+  node_handle_.param(&quot;/confing/mqtt/port&quot;, mqtt_port_, mqtt_port_);
   node_handle_.param(&quot;/confing/mqtt/topic&quot;, mqtt_topic_, mqtt_topic_);
   node_handle_.param(&quot;/confing/mqtt/client_id&quot;, mqtt_client_id_, mqtt_client_id_);
   node_handle_.param(&quot;/confing/mqtt/qos&quot;, mqtt_qos_, mqtt_qos_);
   node_handle_.param(&quot;/confing/mqtt/timeout&quot;, mqtt_timeout_, mqtt_timeout_);
   node_handle_.param(&quot;/confing/mqtt/downsample&quot;, mqtt_downsample_, mqtt_downsample_);
-  ROS_INFO(&quot;MQTT Sender ADDR: %s, TOPIC: %s, ID: %s, DOWNSAMPLE: %f\n&quot;, mqtt_address_.c_str(), mqtt_topic_.c_str(), mqtt_client_id_.c_str(), mqtt_downsample_);
-  MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;
-  int rc;
-
-  MQTTClient_create(&amp;mqtt_client_, mqtt_address_.c_str(), mqtt_client_id_.c_str(),
-      MQTTCLIENT_PERSISTENCE_NONE, NULL);
-  conn_opts.keepAliveInterval = 20;
-  conn_opts.cleansession = 1;
-
-  if ((rc = MQTTClient_connect(mqtt_client_, &amp;conn_opts)) != MQTTCLIENT_SUCCESS)
-  {
-      ROS_INFO(&quot;Failed to connect, return code %d\n&quot;, rc);
-      exit(EXIT_FAILURE);
+  ROS_INFO(&quot;MQTT Sender ADDR: %s:%d, TOPIC: %s, ID: %s, DOWNSAMPLE: %f\n&quot;, mqtt_address_.c_str(), mqtt_port_, mqtt_topic_.c_str(), mqtt_client_id_.c_str(), mqtt_downsample_);
+
+  mqtt_client_ = mosquitto_new(mqtt_client_id_.c_str(), true, NULL);
+  mosquitto_connect_callback_set(mqtt_client_, &amp;MqttSender::on_connect);
+  mosquitto_disconnect_callback_set(mqtt_client_, &amp;MqttSender::on_disconnect);
+
+  if(mosquitto_connect_bind(mqtt_client_, mqtt_address_.c_str(), mqtt_port_, mqtt_timeout_, NULL)){
+    ROS_INFO(&quot;Failed to connect broker.\n&quot;);
+    mosquitto_lib_cleanup();
+    exit(EXIT_FAILURE);
   }
 }
 
 MqttSender::~MqttSender()
 {
-  MQTTClient_disconnect(mqtt_client_, 10000);
-  MQTTClient_destroy(&amp;mqtt_client_);
+  mosquitto_destroy(mqtt_client_);
+  mosquitto_lib_cleanup();
 }
 
+void MqttSender::on_connect(struct mosquitto *mosq, void *obj, int result)
+{
+    ROS_INFO(&quot;on_connect: %s(%d)\n&quot;, __FUNCTION__, __LINE__);
+}
+
+void MqttSender::on_disconnect(struct mosquitto *mosq, void *obj, int rc)
+{
+    ROS_INFO(&quot;on_disconnect: %s(%d)\n&quot;, __FUNCTION__, __LINE__);
+}
 
 void MqttSender::targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;msg)
 {
@@ -130,12 +146,13 @@ void MqttSender::targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;
 void MqttSender::twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg)
 {
   current_twist_cmd_ = msg;
-  current_target_velocity_ = mps2kmph(msg.twist.twist.linear.x);
+  current_target_velocity_ = mps2kmph(msg.twist.linear.x);
 }
 
 void MqttSender::stateCallback(const std_msgs::String &amp;msg)
 {
-  current_state_ = msg.data;
+  ROS_INFO(&quot;State: %s\n&quot;, msg.data);
+  // current_state_ = msg.data;
 }
 
 void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
@@ -199,13 +216,16 @@ void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
 
     // std::ostringstream publish_msg = create_message(msg);
     std::string publish_msg_str = publish_msg.str();
+    int ret = mosquitto_publish(
+      mqtt_client_,
+      NULL,
+      mqtt_topic_.c_str(),
+      strlen(publish_msg_str.c_str()),
+      publish_msg_str.c_str(),
+      mqtt_qos_,
+      false
+    );
 
-    pubmsg_.payload = publish_msg_str.c_str();
-    pubmsg_.payloadlen = strlen(publish_msg_str.c_str());
-    pubmsg_.qos = mqtt_qos_;
-    pubmsg_.retained = 0;
-    MQTTClient_publishMessage(mqtt_client_, mqtt_topic_.c_str(), &amp;pubmsg_, &amp;deliveredtoken_);
-    int rc = MQTTClient_waitForCompletion(mqtt_client_, deliveredtoken_, mqtt_timeout_);
     callback_counter_ = 0;
   }
   else {
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Tier IV, Inc.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/String.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;string.h&quot;
#include &quot;MQTTClient.h&quot;
#include &quot;mqtt_socket/mqtt_setting.hpp&quot;
#include &quot;autoware_msgs/CanInfo.h&quot;

class MqttSender
{
public:
  MqttSender();
  ~MqttSender();
  void canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg);

private:
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;
  ros::NodeHandle node_handle_;
  MQTTClient_message pubmsg_;
  MQTTClient_deliveryToken deliveredtoken_;

  MQTTClient mqtt_client_;
  std::string mqtt_address_;
  std::string mqtt_topic_;
  std::string mqtt_client_id_;
  int mqtt_qos_;
  int mqtt_timeout_;
  double mqtt_downsample_;
  int callback_counter_;

  // current behavior/status
  std_msgs::Float64MultiArray current_target_velocity_array_; //kmph
  geometry_msgs::TwistStamped current_twist_cmd_; //mps
  double current_target_velocity_; // mps2kmph(current_twist_cmd_.twist.twist.linear.x);
  std_msgs::String current_state_;
  
  void targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;msg);
  void twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg);
  void stateCallback(const std_msgs::String &amp;msg);

};

inline double mps2kmph(double _mpsval)
{
	return (_mpsval * 60 * 60) / 1000; // mps * 60sec * 60 minute / 1000m
}

MqttSender::MqttSender() :
    node_handle_(&quot;~&quot;)
{
  // ROS Subscriber
  Subs[&quot;can_info&quot;] = node_handle_.subscribe(&quot;/can_info&quot;, 1000, &amp;MqttSender::canInfoCallback, this);
  Subs[&quot;target_velocity_array&quot;] = node_handle_.subscribe(&quot;/target_velocity_array&quot;, 1, &amp;MqttSender::targetVelocityArrayCallback, this);
  Subs[&quot;twist_cmd&quot;] = node_handle_.subscribe(&quot;/twist_cmd&quot;, 1, &amp;MqttSender::twistCmdCallback, this);
  Subs[&quot;state&quot;] = node_handle_.subscribe(&quot;/state&quot;, 1, &amp;MqttSender::stateCallback, this)

  // MQTT PARAMS
  pubmsg_ = MQTTClient_message_initializer;
  mqtt_address_ = ADDRESS;
  mqtt_topic_ = std::string(SENDER_TOPIC) + std::string(VEHICLEID) + &quot;/can_info&quot;;
  mqtt_client_id_ = std::string(CLIENTID) + &quot;_&quot; + std::string(VEHICLEID) + &quot;_snd&quot;;
  mqtt_qos_ = QOS;
  mqtt_timeout_ = TIMEOUT;
  mqtt_downsample_ = DOWNSAMPLE;
  callback_counter_ = 0;
  node_handle_.param(&quot;/confing/mqtt/address&quot;, mqtt_address_, mqtt_address_);
  node_handle_.param(&quot;/confing/mqtt/topic&quot;, mqtt_topic_, mqtt_topic_);
  node_handle_.param(&quot;/confing/mqtt/client_id&quot;, mqtt_client_id_, mqtt_client_id_);
  node_handle_.param(&quot;/confing/mqtt/qos&quot;, mqtt_qos_, mqtt_qos_);
  node_handle_.param(&quot;/confing/mqtt/timeout&quot;, mqtt_timeout_, mqtt_timeout_);
  node_handle_.param(&quot;/confing/mqtt/downsample&quot;, mqtt_downsample_, mqtt_downsample_);
  ROS_INFO(&quot;MQTT Sender ADDR: %s, TOPIC: %s, ID: %s, DOWNSAMPLE: %f\n&quot;, mqtt_address_.c_str(), mqtt_topic_.c_str(), mqtt_client_id_.c_str(), mqtt_downsample_);
  MQTTClient_connectOptions conn_opts = MQTTClient_connectOptions_initializer;
  int rc;

  MQTTClient_create(&amp;mqtt_client_, mqtt_address_.c_str(), mqtt_client_id_.c_str(),
      MQTTCLIENT_PERSISTENCE_NONE, NULL);
  conn_opts.keepAliveInterval = 20;
  conn_opts.cleansession = 1;

  if ((rc = MQTTClient_connect(mqtt_client_, &amp;conn_opts)) != MQTTCLIENT_SUCCESS)
  {
      ROS_INFO(&quot;Failed to connect, return code %d\n&quot;, rc);
      exit(EXIT_FAILURE);
  }
}

MqttSender::~MqttSender()
{
  MQTTClient_disconnect(mqtt_client_, 10000);
  MQTTClient_destroy(&amp;mqtt_client_);
}


void MqttSender::targetVelocityArrayCallback(const std_msgs::Float64MultiArray &amp;msg)
{
  current_target_velocity_array_ = msg;
}

void MqttSender::twistCmdCallback(const geometry_msgs::TwistStamped &amp;msg)
{
  current_twist_cmd_ = msg;
  current_target_velocity_ = mps2kmph(msg.twist.twist.linear.x);
}

void MqttSender::stateCallback(const std_msgs::String &amp;msg)
{
  current_state_ = msg.data;
}

void MqttSender::canInfoCallback(const autoware_msgs::CanInfoConstPtr &amp;msg)
{

  if(callback_counter_ &gt; mqtt_downsample_ * 100) {
    std::ostringstream publish_msg;

    publish_msg &lt;&lt; msg-&gt;tm &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;devmode) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;drvcontmode) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;drvoverridemode) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;drvservo) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;drivepedal) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;targetpedalstr) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;inputpedalstr) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;targetveloc) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;speed) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;driveshift) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;targetshift) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;inputshift) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;strmode) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;strcontmode) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;stroverridemode) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;strservo) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;targettorque) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;torque) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;angle) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;targetangle) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;bbrakepress) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;brakepedal) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;brtargetpedalstr) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;brinputpedalstr) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;battery) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;voltage) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;anp) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;battmaxtemparature) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;battmintemparature) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;maxchgcurrent) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;maxdischgcurrent) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;sideacc) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;accellfromp) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;anglefromp) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;brakepedalfromp) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;speedfr) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;speedfl) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;speedrr) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;speedrl) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;velocfromp2) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;drvmode) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;devpedalstrfromp) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;rpm) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;velocflfromp) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;ev_mode) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;temp) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;shiftfrmprius) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;light) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;gaslevel) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;door) &lt;&lt; &quot;,&quot;;
    publish_msg &lt;&lt; std::to_string(msg-&gt;cluise);

    // std::ostringstream publish_msg = create_message(msg);
    std::string publish_msg_str = publish_msg.str();

    pubmsg_.payload = publish_msg_str.c_str();
    pubmsg_.payloadlen = strlen(publish_msg_str.c_str());
    pubmsg_.qos = mqtt_qos_;
    pubmsg_.retained = 0;
    MQTTClient_publishMessage(mqtt_client_, mqtt_topic_.c_str(), &amp;pubmsg_, &amp;deliveredtoken_);
    int rc = MQTTClient_waitForCompletion(mqtt_client_, deliveredtoken_, mqtt_timeout_);
    callback_counter_ = 0;
  }
  else {
    callback_counter_++;
  }
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, &quot;mqtt_sender&quot;);
  MqttSender node;
  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="8b07ef3bfc99fe6cd1100623be82710b2e1b42c4" fix_time="8,59163">
		<msg>Fix a build error for libstate</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp">
				<diff>@@ -3,6 +3,7 @@
 
 #include &lt;atomic&gt;
 #include &lt;iostream&gt;
+#include &lt;queue&gt;
 #include &lt;thread&gt;
 #include &lt;unordered_map&gt;
 #include &lt;utility&gt;
@@ -71,7 +72,7 @@ public:
     HolderList.push_back(&amp;current_state_.StrState); 
     HolderList.push_back(&amp;current_state_.BehaviorState); 
     HolderList.push_back(&amp;current_state_.PerceptionState); 
- e   HolderList.push_back(&amp;current_state_.OtherState); 
+    HolderList.push_back(&amp;current_state_.OtherState); 
     
     for(auto &amp;&amp;p : HolderList){
       *p = nullptr;
@@ -98,6 +99,7 @@ public:
 
   void stateDecider(void);
 
+  bool setCurrentState(StateFlags flag);
   bool setCurrentState(BaseState *state);
   bool setCurrentState(BaseState *state, BaseState *substate);
   bool setCurrentState(BaseState *state, BaseState *substate, BaseState *subsubstate);
</diff>
				<old_file>#ifndef __STATE_CONTEXT_HPP__
#define __STATE_CONTEXT_HPP__

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;
#include &quot;state.hpp&quot;
#include &quot;state_drive.hpp&quot;
#include &quot;state_emg.hpp&quot;

namespace state_machine
{
class StateContext
{
private:
	class StateHolder{
		public:
			BaseState *MainState;
			BaseState *AccState;
			BaseState *StrState;
			BaseState *BehaviorState;
			BaseState *PerceptionState;
			BaseState *OtherState;
	} current_state_;
	
  std::vector&lt;BaseState **&gt; HolderList;


  std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
  
  bool enableForceSetState;
  //unsigned long long ChangeStateFlags;
  std::queue&lt;unsigned long long&gt; ChangeStateFlags;
  std::atomic&lt;bool&gt; thread_loop;

  std::thread *thr_state_dec;

  void showStateMove(unsigned long long _state_num)
  {
    std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; *StateStores[_state_num]-&gt;getStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }

public:
  StateContext(void)
  {

    StateStores[START_STATE] = StartState::getInstance();
    StateStores[INITIAL_STATE] = InitialState::getInstance();
    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
    StateStores[DRIVE_STATE] = DriveState::getInstance();
    StateStores[DRIVE_ACC_ACCELERATION_STATE] = DriveAccAccelerationState::getInstance();
    StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
    StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
    StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
    StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
    StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
    StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
    StateStores[DRIVE_DETECT_OBSTACLE_STATE] = DriveDetectObstacleState::getInstance();
    StateStores[DRIVE_DETECT_STOPLINE_STATE] = DriveDetectStoplineState::getInstance();
    StateStores[DRIVE_DETECT_TRAFFICLIGHT_RED_STATE] = DriveDetectTrafficlightRedState::getInstance();
    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
    StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();

    HolderList.push_back(&amp;current_state_.MainState); 
    HolderList.push_back(&amp;current_state_.AccState); 
    HolderList.push_back(&amp;current_state_.StrState); 
    HolderList.push_back(&amp;current_state_.BehaviorState); 
    HolderList.push_back(&amp;current_state_.PerceptionState); 
 e   HolderList.push_back(&amp;current_state_.OtherState); 
    
    for(auto &amp;&amp;p : HolderList){
      *p = nullptr;
    }
#if 0
    current_state_.MainState = nullptr;
    current_state_.AccState = nullptr;
    current_state_.StrState = nullptr;
    current_state_.BehaviorState = nullptr;
    current_state_.PerceptionState = nullptr;
    current_state_.OtherState = nullptr;
#endif
    thread_loop = true;

    this-&gt;InitContext();
  }
  ~StateContext()
  {
    thread_loop = false;
  }

  bool isState(unsigned long long _state_num);
  bool inState(unsigned long long _state_num);

  void stateDecider(void);

  bool setCurrentState(BaseState *state);
  bool setCurrentState(BaseState *state, BaseState *substate);
  bool setCurrentState(BaseState *state, BaseState *substate, BaseState *subsubstate);

  BaseState *getCurrentMainState(void);
  BaseState *getCurrentState(void);
  std::unique_ptr&lt;std::string&gt; getCurrentStateName(void);
  void showCurrentStateName(void);

  bool setEnableForceSetState(bool force_flag);
  BaseState *getStateObject(unsigned long long _state_num);
  void InitContext(void);

  bool TFInitialized(void);

  void handleTrafficLight(uint32_t _light_color);
  bool handleCurrentPose(double x, double y, double z, double roll, double pitch, double yaw);
  bool handlePointsRaw(bool _hasLidarData);

  bool handleIntersection(bool _hasIntersection, double _angle);
  bool handleTwistCmd(bool _hasTwistCmd);
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp" new_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp">
				<diff>@@ -188,12 +188,11 @@ void StateContext::stateDecider(void)
 // not running
   while (thread_loop)
   {
-    if (!ChangeStateFlags.empty())
-	  setCurrentState(StateStores[ChangeStateFlags.front()]);
-          ChangeStateFlags.pop();
-        }
-      }
-    std::this_thread::sleep_for(std::chrono::microseconds(1000));
+	  if (!ChangeStateFlags.empty()){
+		  this-&gt;setCurrentState(StateStores[ChangeStateFlags.front()]);
+		  ChangeStateFlags.pop();
+	  }
+	  std::this_thread::sleep_for(std::chrono::microseconds(1000));
   }
   std::cerr &lt;&lt; &quot;StateDecider thread will be closed&quot; &lt;&lt; std::endl;
   return;
</diff>
				<old_file>#include &lt;sched.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

#include &lt;cassert&gt;

#include &lt;euclidean_space.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;state.hpp&gt;
#include &lt;state_common.hpp&gt;

/**
 *
 * @file StateContext.cpp
 * @brief state context class
 * @author Yusuke Fujii
 * @date  2017/07/25
 *
 **/

namespace state_machine
{
/**
 * @fn
 *
 * @brief
 * @return
 */
void StateContext::showCurrentStateName(void)
{
  for(auto &amp;&amp;p : HolderList){
    if(*p){
	(*p)-&gt;showStateName();
    }
  }

#if 0
  if (sub_state)
    sub_state-&gt;showStateName();
  if (sub_sub_state)
    sub_sub_state-&gt;showStateName();
#endif
  std::cout &lt;&lt; std::endl;
}

std::unique_ptr&lt;std::string&gt; StateContext::getCurrentStateName(void)
{
  return current_state_.MainState-&gt;getStateName();
}

/**
 * @fn
 * set to current state
 * @brief standard out a state name
 * @param (state) Setting class
 * @return void
 */
bool StateContext::setCurrentState(BaseState *_state)
{
  BaseState *prevState = current_state_.MainState;

  if (!prevState)
  {
    current_state_.MainState = _state;
    std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }
  else
  {
    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
    {
	switch(_state-&gt;getStateKind()){
		case MAIN_STATE:
			current_state_.MainState = _state;
			current_state_.AccState = nullptr;
			current_state_.StrState = nullptr;
			current_state_.BehaviorState = nullptr;
			current_state_.PerceptionState = nullptr;
			current_state_.OtherState = nullptr;
			break;
		case ACC_STATE:
			current_state_.AccState = _state;
			break;
		case STR_STATE:
			current_state_.StrState = _state;
			break;
		case BEHAVIOR_STATE:
			current_state_.BehaviorState = _state;
			break;
		case PERCEPTION_STATE:
			current_state_.PerceptionState = _state;
			break;
		case OTHER_STATE:
			current_state_.OtherState = _state;
			break;
	}
        std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; *prevState-&gt;getStateName().get() &lt;&lt; &quot;\&quot; to \&quot;&quot;
                  &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
                  &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
      }
    else{
      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; *current_state_.MainState-&gt;getStateName().get() &lt;&lt; &quot;\&quot; to \&quot;&quot;
                &lt;&lt; *_state-&gt;getStateName().get() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
      prevState = nullptr;
      return false;
    }
  }
  return true;
}

bool StateContext::setCurrentState(StateFlags flag)
{
   this-&gt;setCurrentState(StateStores[flag]);
}
bool StateContext::setEnableForceSetState(bool force_flag)
{
	enableForceSetState = force_flag;
	return true;
}

BaseState *StateContext::getCurrentMainState(void)
{
  return current_state_.MainState;
}

BaseState *StateContext::getStateObject(unsigned long long _state_num)
{
  return StateStores[_state_num];
}

bool StateContext::isState(unsigned long long _state_num)
{
  return current_state_.MainState?current_state_.MainState-&gt;getStateNum() == _state_num:false;
}

bool StateContext::inState(unsigned long long _state_num)
{
  return current_state_.MainState?current_state_.MainState-&gt;getStateNum() &amp; _state_num:false;
}

#define ANGLE_STRAIGHT 50.0
#define ANGLE_LEFT 360.0
#define ANGLE_RIGHT 180.0
bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
{
  if (_hasIntersection)
  {
    // *Temporary implementation*
    // To straight/left/right recognition by using angle between
    // first-waypoint
    // and end-waypoint in intersection area.
    int temp = (int)std::floor(_angle + 360.0) % 360;
#if 0
    if (std::abs(temp) &lt;= ANGLE_STRAIGHT)
      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_STRAIGHT_STATE]);
    else if (temp &lt;= ANGLE_RIGHT)
      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_RIGHT_STATE]);
    else if (temp &lt;= ANGLE_LEFT)
      return this-&gt;setCurrentState(StateStores[DRIVE_MOVEFWD_LEFT_STATE]);
    else
      return false;
#endif
  }
  else
  {
    return false;
  }
}

bool StateContext::handleTwistCmd(bool _hasTwistCmd)
{
  if (_hasTwistCmd)
    return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
  else
    return false;
}


void StateContext::stateDecider(void)
{
// not running
  while (thread_loop)
  {
    if (!ChangeStateFlags.empty())
	  setCurrentState(StateStores[ChangeStateFlags.front()]);
          ChangeStateFlags.pop();
        }
      }
    std::this_thread::sleep_for(std::chrono::microseconds(1000));
  }
  std::cerr &lt;&lt; &quot;StateDecider thread will be closed&quot; &lt;&lt; std::endl;
  return;
}

void StateContext::InitContext(void)
{
  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
  thr_state_dec-&gt;detach();
  this-&gt;setCurrentState(StateStores[START_STATE]);
  return;
}
bool StateContext::TFInitialized(void)
{
  return this-&gt;setCurrentState(StateStores[INITIAL_STATE]);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="dcdd4e66d42fb83d3a5f59f29e17412dbfede389" fix_time="16,75396">
		<msg>Fix a build error for decision maker node</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp">
				<diff>@@ -68,19 +68,20 @@ private:
   geometry_msgs::PoseStamped current_pose_;
 
   jsk_rviz_plugins::OverlayText state_text_msg;
-  autoware_msgs::lane current_finalwaypoints_;
-
-  std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
+  // ROS Messages(Autoware)
+  autoware_msgs::lane current_finalwaypoints_;
   vector_map_msgs::AreaArray vMap_Areas;
   vector_map_msgs::PointArray vMap_Points;
   vector_map_msgs::LineArray vMap_Lines;
   vector_map_msgs::CrossRoadArray vMap_CrossRoads;
+  
+  std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
   // Current way/behavior status
   double current_velocity_;
   double average_velocity_;
-  int CurrentTrafficlight;
+  int current_traffic_light;
   CrossRoadArea *ClosestArea_;
   std::string CurrentStateName;
   std::string TextOffset;
@@ -113,9 +114,11 @@ private:
 
   void publishToVelocityArray();
 
-  //
+  // judge method
+  // in near future, these methods will be deprecate to decision_maker library 
   bool isInsideArea(geometry_msgs::Point pt);
   bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
+  bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
 
   double calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
 
@@ -138,7 +141,7 @@ private:
   // Currently. this feature is not working.
   // static void callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level);
 
-  // in near future, these function will be deprecate
+  // in near future, these methods will be deprecate to ADAS library 
   CrossRoadArea *findClosestCrossRoad(void);
 
 public:
</diff>
				<old_file>#ifndef __DECISION_MAKER_NODE__
#define __DECISION_MAKER_NODE__

#include &lt;unordered_map&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;std_msgs/String.h&gt;

//#include &lt;vector_map_server/GetCrossRoad.h&gt;

#include &lt;vector_map_msgs/AreaArray.h&gt;
#include &lt;vector_map_msgs/CrossRoadArray.h&gt;
#include &lt;vector_map_msgs/LineArray.h&gt;
#include &lt;vector_map_msgs/PointArray.h&gt;

#include &lt;geometry_msgs/Point.h&gt;

// lib
#include &lt;euclidean_space.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;cross_road_area.hpp&gt;


//#include &lt;dynamic_reconfigure/server.h&gt;
//#include &lt;decision_maker/decision_makerConfig.h&gt;

namespace decision_maker
{
//#define DEBUG_PRINT
enum class EControl
{
  KEEP = -1,
  STOP = 1,
  DECELERATE = 2,
  ACCELERATE = 3,
  OTHERS = 4,
};

inline bool hasvMap(void)
{
  return true;
}

inline double mps2kmph(double _mpsval)
{
  return (_mpsval * 60 * 60) / 1000;  // mps * 60sec * 60m / 1000m
}

class DecisionMakerNode
{
private:
  ros::NodeHandle nh_;
  // Publishers
  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
  // Subscribers
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;

  // ROS Messages
  std_msgs::String state_string_msg;
  geometry_msgs::PoseStamped current_pose_;

  jsk_rviz_plugins::OverlayText state_text_msg;
  autoware_msgs::lane current_finalwaypoints_;

  std::vector&lt;geometry_msgs::Point&gt; inside_points_;

  vector_map_msgs::AreaArray vMap_Areas;
  vector_map_msgs::PointArray vMap_Points;
  vector_map_msgs::LineArray vMap_Lines;
  vector_map_msgs::CrossRoadArray vMap_CrossRoads;

  // Current way/behavior status
  double current_velocity_;
  double average_velocity_;
  int CurrentTrafficlight;
  CrossRoadArea *ClosestArea_;
  std::string CurrentStateName;
  std::string TextOffset;
  std::vector&lt;CrossRoadArea&gt; intersects;
  bool isDisplay;

  // for vectormap server
  // ros::ServiceClient cross_road_cli;
  // vector_map_server::GetCrossRoad cross_road_srv;

  // initialization flags for initialized by callback
  bool vector_map_init;
  bool vMap_Areas_flag;
  bool vMap_Points_flag;
  bool vMap_Lines_flag;
  bool vMap_CrossRoads_flag;
  bool SimulationMode;

  // initialization method
  void initROS(int argc, char **argv);
  void initVectorMap(void);
  void initStateMsgs(void);
  bool initVectorMapClient(void);

  // looping method
  void update(void);
  void update_msgs(void);
  void update_pubsub(void);
  void displayMarker(void);

  void publishToVelocityArray();

  //
  bool isInsideArea(geometry_msgs::Point pt);
  bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);

  double calcIntersectWayAngle(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);

  // callback by topic subscribing
  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg);
  void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
  void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
  void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromStateCmd(const std_msgs::String &amp;msg);

  void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
  void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
  void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
  void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);

  // for ros dynamic reconfigure
  // Currently. this feature is not working.
  // static void callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level);

  // in near future, these function will be deprecate
  CrossRoadArea *findClosestCrossRoad(void);

public:
  state_machine::StateContext *ctx;

  DecisionMakerNode(int argc, char **argv)
  {
    SimulationMode = false;
    isDisplay = true;

    ctx = new state_machine::StateContext();
    this-&gt;initROS(argc, argv);

    vector_map_init = false;
    vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;

    ClosestArea_ = nullptr;
  }

  void run(void);
};



}  // namespace decision_maker

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -52,37 +52,20 @@ bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _
   {
     avg_distances = (avg_distances + distances[0]) / CONV_NUM;
     if (avg_distances &lt;= CONVERGENCE_THRESHOLD){
-      return this-&gt;setCurrentState(StateStores[state_machine::DRIVE_STATE]);
+      return ctx-&gt;setCurrentState(state_machine::DRIVE_STATE);
     }else
     {
       return false;
     }
   }
 }
-
-void StateContext::stateDecider(void)
-{
-// not running
-  while (thread_loop)
-  {
-    if (!ChangeStateFlags.empty())
-	  setCurrentState(StateStores[ChangeStateFlags.front()]);
-          ChangeStateFlags.pop();
-        }
-      }
-    std::this_thread::sleep_for(std::chrono::microseconds(1000));
-  }
-  std::cerr &lt;&lt; &quot;StateDecider thread will be closed&quot; &lt;&lt; std::endl;
-  return;
     
-
-}
 void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
 {
   geometry_msgs::PoseStamped _pose = current_pose_ = msg;
   bool initLocalizationFlag = ctx-&gt;isState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
   if (initLocalizationFlag &amp;&amp;
-      ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
+      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                              _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
   {
     ROS_INFO(&quot;Localization was convergence&quot;);
@@ -92,9 +75,9 @@ void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped
 void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
 {
   ROS_INFO(&quot;Light color callback&quot;);
-  CurrentTrafficlight = msg.traffic_light;
-  if(CurrentTrafficLight == state_machine::E_RED ||
-	CurrentTrafficLight == state_machine::E_YELLOW ){
+  current_traffic_light = msg.traffic_light;
+  if(current_traffic_light == state_machine::E_RED ||
+	current_traffic_light == state_machine::E_YELLOW ){
 	ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
   //ctx-&gt;handleTrafficLight(CurrentTrafficlight);
@@ -103,8 +86,8 @@ void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_ligh
 //
 void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
-  if(ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATE_VEHICLE_STATE]);
-  Subs[&quot;points_raw&quot;].shutdown();
+	if(ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
+		Subs[&quot;points_raw&quot;].shutdown();
 }
 
 void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
</diff>
				<old_file>#include &lt;stdio.h&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;euclidean_space.hpp&gt;

namespace decision_maker
{
#define VEL_AVERAGE_COUNT 10
#define CONV_NUM 10
#define CONVERGENCE_THRESHOLD 0.01

bool DecisionMakerNode::isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw)
{
  static int _init_count = 0;
  static euclidean_space::point *a = new euclidean_space::point();
  static euclidean_space::point *b = new euclidean_space::point();

  static double distances[CONV_NUM] = { 0.0 };
  double avg_distances = 0.0;

  for (int i = 1; i &lt; CONV_NUM; i++)
  {
    distances[i] = distances[i - 1];
    avg_distances += distances[i];
  }

  a-&gt;x = b-&gt;x;
  a-&gt;y = b-&gt;y;
  a-&gt;z = b-&gt;z;

  b-&gt;x = _x;
  b-&gt;y = _y;
  b-&gt;z = _z;

  distances[0] = euclidean_space::EuclideanSpace::find_distance(a, b);

  if (++_init_count &lt;= CONV_NUM)
  {
    return false;
  }else
  {
    avg_distances = (avg_distances + distances[0]) / CONV_NUM;
    if (avg_distances &lt;= CONVERGENCE_THRESHOLD){
      return this-&gt;setCurrentState(StateStores[state_machine::DRIVE_STATE]);
    }else
    {
      return false;
    }
  }
}

void StateContext::stateDecider(void)
{
// not running
  while (thread_loop)
  {
    if (!ChangeStateFlags.empty())
	  setCurrentState(StateStores[ChangeStateFlags.front()]);
          ChangeStateFlags.pop();
        }
      }
    std::this_thread::sleep_for(std::chrono::microseconds(1000));
  }
  std::cerr &lt;&lt; &quot;StateDecider thread will be closed&quot; &lt;&lt; std::endl;
  return;
    

}
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      ctx-&gt;handleCurrentPose(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                             _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

void DecisionMakerNode::callbackFromLightColor(const autoware_msgs::traffic_light &amp;msg)
{
  ROS_INFO(&quot;Light color callback&quot;);
  CurrentTrafficlight = msg.traffic_light;
  if(CurrentTrafficLight == state_machine::E_RED ||
	CurrentTrafficLight == state_machine::E_YELLOW ){
	ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  //ctx-&gt;handleTrafficLight(CurrentTrafficlight);
}

//
void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if(ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATE_VEHICLE_STATE]);
  Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    // return;
  }

  current_finalwaypoints_ = msg;
  ClosestArea_ = CrossRoadArea::findClosestCrossRoad(current_finalwaypoints_, intersects);

  if (ctx-&gt;inState(state_machine::DRIVE_STATE))
  {
    double intersect_wayangle = calcIntersectWayAngle(current_finalwaypoints_, current_pose_);
    ctx-&gt;handleIntersection(true, intersect_wayangle);
  }

  double _temp_sum = 0;
  for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
  {
    _temp_sum += mps2kmph(msg.waypoints[i].twist.twist.linear.x);
  }
  average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
  
  if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
  {
    TextOffset = &quot;Keep&quot;;
  }
  else if (average_velocity_ - current_velocity_)
  {
    TextOffset = &quot;Accelerate&quot;;
  }
  else
  {
    TextOffset = &quot;Decelerate&quot;;
  }

  // for publish plan of velocity
  publishToVelocityArray();

  std::cout &lt;&lt; &quot;Velocity: &quot; &lt;&lt; current_velocity_ &lt;&lt; &quot; to &quot; &lt;&lt; average_velocity_ &lt;&lt; std::endl;
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = mps2kmph(msg.twist.linear.x);
}
#if 0
	void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
		ROS_INFO(&quot;Reconfigure Request: %d &quot;, config.TARGET_WAYPOINT_COUNT);
	}
#endif
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="68c3d6df8ee0036eb8364e131752093e8aabe191" fix_time="7,13366">
		<msg>fix bug and refactor code</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/motion/packages/waypoint_follower/nodes/twist_gate/twist_gate.cpp" new_path="ros/src/computing/planning/motion/packages/waypoint_follower/nodes/twist_gate/twist_gate.cpp">
				<diff>@@ -133,13 +133,25 @@ void TwistGate::watchdog_timer()
   while(1)
   {
     ros::Time now_time = ros::Time::now();
+    bool emergency_flag = false;
 
-    if(now_time - remote_cmd_time_ &gt;  timeout_period_
-       || emergency_stop_msg_.data == true)
+    // if lost Communication
+    if(command_mode_ == CommandMode::REMOTE &amp;&amp; now_time - remote_cmd_time_ &gt;  timeout_period_) {
+      emergency_flag = true;
+      std::cout &lt;&lt; &quot;Lost Communication!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; std::endl;
+    }
+
+    if(emergency_stop_msg_.data == true)
     {
-        command_mode_ = CommandMode::AUTO;
-    //    emergency_stop_msg_.data = true;
-    //    emergency_stop_pub_.publish(emergency_stop_msg_);
+      emergency_flag = true;
+      std::cout &lt;&lt; &quot;Emergency Mode!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; std::endl;
+    }
+
+    if(emergency_flag) {
+      command_mode_ = CommandMode::AUTO;
+      emergency_stop_msg_.data = true;
+      emergency_stop_pub_.publish(emergency_stop_msg_);
+      std::cout &lt;&lt; &quot;Emergency Stop!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; std::endl;
     }
 
     std::this_thread::sleep_for(std::chrono::milliseconds(10));
@@ -159,28 +171,29 @@ void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
 
   if(command_mode_ == CommandMode::REMOTE)
   {
+    std::cout &lt;&lt; &quot;Remote Comannd!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; std::endl;
     twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
     twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
     twist_gate_msg_.header.seq++;
     twist_gate_msg_.linear_x = input_msg-&gt;accel;
-    //twist_gate_msg_.angular_z = input_msg-&gt;steer;
+    twist_gate_msg_.angular_z = input_msg-&gt;steer;
     twist_gate_msg_.steering_angle = input_msg-&gt;steer;
-    // twist_gate_msg_.accel = input_msg-&gt;accel;
-    // twist_gate_msg_.brake = input_msg-&gt;brake;
-    // twist_gate_msg_.steer = input_msg-&gt;steer;
-    //twist_gate_msg_.gear = input_msg-&gt;gear;
+    twist_gate_msg_.accel = input_msg-&gt;accel;
+    twist_gate_msg_.brake = input_msg-&gt;brake;
+    twist_gate_msg_.steer = input_msg-&gt;steer;
+    // twist_gate_msg_.gear = input_msg-&gt;gear;
     twist_gate_msg_.gear = 0;
     // twist_gate_msg_.mode = input_msg-&gt;mode;
     twist_gate_msg_.mode = 0;
     twist_gate_msg_.emergency = input_msg-&gt;emergency;
     select_cmd_pub_.publish(twist_gate_msg_);
   }
-  if(twist_gate_msg_.emergency == 1)
-  {
-    emergency_stop_msg_.data = true;
-    emergency_stop_pub_.publish(emergency_stop_msg_);
-    std::cout &lt;&lt; &quot;emergency_stop!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; std::endl;
-  }
+  // if(twist_gate_msg_.emergency == 1)
+  // {
+  //   emergency_stop_msg_.data = true;
+  //   emergency_stop_pub_.publish(emergency_stop_msg_);
+  //   std::cout &lt;&lt; &quot;emergency_stop!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; std::endl;
+  // }
 }
 
 void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg)
@@ -267,6 +280,7 @@ void TwistGate::auto_cmd_ctrl_cmd_callback(const autoware_msgs::ControlCommandSt
     twist_gate_msg_.linear_velocity = input_msg-&gt;cmd.linear_velocity;
     twist_gate_msg_.steering_angle = input_msg-&gt;cmd.steering_angle;
     select_cmd_pub_.publish(twist_gate_msg_);
+    std::cout &lt;&lt; &quot;Control Comannd!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; std::endl;
   }
 }
 
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Tier IV, Inc.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;map&gt;

#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;

#include &quot;autoware_msgs/RemoteCmd.h&quot;
#include &quot;autoware_msgs/TwistGate.h&quot;
#include &quot;tablet_socket_msgs/mode_cmd.h&quot;
#include &quot;tablet_socket_msgs/gear_cmd.h&quot;
#include &quot;autoware_msgs/accel_cmd.h&quot;
#include &quot;autoware_msgs/brake_cmd.h&quot;
#include &quot;autoware_msgs/steer_cmd.h&quot;
#include &quot;autoware_msgs/ControlCommandStamped.h&quot;

class TwistGate
{
  using remote_msgs_t = autoware_msgs::RemoteCmd;
  using twist_gate_msgs_t = autoware_msgs::TwistGate;

  public:
    TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh);
    ~TwistGate();
  private:
    void watchdog_timer();
    void remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg);
    void auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg);
    void auto_cmd_mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg);
    void auto_cmd_gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg);
    void auto_cmd_accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg);
    void auto_cmd_steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg);
    void auto_cmd_brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg);
    void auto_cmd_ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg);

    void reset_select_cmd_msg();

    ros::NodeHandle nh_;
    ros::NodeHandle private_nh_;
    ros::Publisher emergency_stop_pub_;
    ros::Publisher select_cmd_pub_;
    ros::Subscriber remote_cmd_sub_;
    std::map&lt;std::string , ros::Subscriber&gt; auto_cmd_sub_stdmap_;

    twist_gate_msgs_t twist_gate_msg_;
    std_msgs::Bool emergency_stop_msg_;
    ros::Time remote_cmd_time_;
    ros::Duration timeout_period_;

    std::thread watchdog_timer_thread_;
    enum class CommandMode{AUTO=3, REMOTE=4} command_mode_;
};

TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh) :
     nh_(nh)
    ,private_nh_(private_nh)
    ,timeout_period_(1.0)
    ,command_mode_(CommandMode::REMOTE)
{
  emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;(&quot;/emergency_stop&quot;, 1, true);
  select_cmd_pub_ = nh_.advertise&lt;twist_gate_msgs_t&gt;(&quot;/select_cmd&quot;, 1, true);

  remote_cmd_sub_ = nh_.subscribe(&quot;/remote_cmd&quot;, 1, &amp;TwistGate::remote_cmd_callback, this);

  auto_cmd_sub_stdmap_[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;/twist_cmd&quot;, 1, &amp;TwistGate::auto_cmd_twist_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;mode_cmd&quot;] = nh_.subscribe(&quot;/mode_cmd&quot;, 1, &amp;TwistGate::auto_cmd_mode_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;gear_cmd&quot;] = nh_.subscribe(&quot;/gear_cmd&quot;, 1, &amp;TwistGate::auto_cmd_gear_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;accel_cmd&quot;] = nh_.subscribe(&quot;/accel_cmd&quot;, 1, &amp;TwistGate::auto_cmd_accel_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;steer_cmd&quot;] = nh_.subscribe(&quot;/steer_cmd&quot;, 1, &amp;TwistGate::auto_cmd_steer_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;brake_cmd&quot;] = nh_.subscribe(&quot;/brake_cmd&quot;, 1, &amp;TwistGate::auto_cmd_brake_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;ctrl_cmd&quot;] = nh_.subscribe(&quot;/ctrl_cmd&quot;, 1, &amp;TwistGate::auto_cmd_ctrl_cmd_callback, this);

  twist_gate_msg_.header.seq = 0;

  emergency_stop_msg_.data = false;

  remote_cmd_time_ = ros::Time::now();
  watchdog_timer_thread_ = std::thread(&amp;TwistGate::watchdog_timer, this);
  watchdog_timer_thread_.detach();
}

TwistGate::~TwistGate()
{
}

void TwistGate::reset_select_cmd_msg()
{
  twist_gate_msg_.linear_x        = 0;
  twist_gate_msg_.angular_z       = 0;
  twist_gate_msg_.mode            = 0;
  twist_gate_msg_.gear            = 0;
  twist_gate_msg_.accel           = 0;
  twist_gate_msg_.brake           = 0;
  twist_gate_msg_.steer           = 0;
  twist_gate_msg_.linear_velocity = -1;
  twist_gate_msg_.steering_angle  = 0;
}

void TwistGate::watchdog_timer()
{
  while(1)
  {
    ros::Time now_time = ros::Time::now();

    if(now_time - remote_cmd_time_ &gt;  timeout_period_
       || emergency_stop_msg_.data == true)
    {
        command_mode_ = CommandMode::AUTO;
    //    emergency_stop_msg_.data = true;
    //    emergency_stop_pub_.publish(emergency_stop_msg_);
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::cout &lt;&lt; &quot;c_mode:&quot;     &lt;&lt; static_cast&lt;int&gt;(command_mode_)
              &lt;&lt; &quot; e_stop:&quot;    &lt;&lt; static_cast&lt;bool&gt;(emergency_stop_msg_.data)
              &lt;&lt; &quot; diff_time:&quot; &lt;&lt; (now_time - remote_cmd_time_).toSec()
              &lt;&lt; std::endl;
  }
}

void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
{
  command_mode_ = static_cast&lt;CommandMode&gt;(input_msg-&gt;mode);
  twist_gate_msg_.mode = input_msg-&gt;mode;
  emergency_stop_msg_.data = static_cast&lt;bool&gt;(input_msg-&gt;emergency);
  remote_cmd_time_ = ros::Time::now();

  if(command_mode_ == CommandMode::REMOTE)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.linear_x = input_msg-&gt;accel;
    //twist_gate_msg_.angular_z = input_msg-&gt;steer;
    twist_gate_msg_.steering_angle = input_msg-&gt;steer;
    // twist_gate_msg_.accel = input_msg-&gt;accel;
    // twist_gate_msg_.brake = input_msg-&gt;brake;
    // twist_gate_msg_.steer = input_msg-&gt;steer;
    //twist_gate_msg_.gear = input_msg-&gt;gear;
    twist_gate_msg_.gear = 0;
    // twist_gate_msg_.mode = input_msg-&gt;mode;
    twist_gate_msg_.mode = 0;
    twist_gate_msg_.emergency = input_msg-&gt;emergency;
    select_cmd_pub_.publish(twist_gate_msg_);
  }
  if(twist_gate_msg_.emergency == 1)
  {
    emergency_stop_msg_.data = true;
    emergency_stop_pub_.publish(emergency_stop_msg_);
    std::cout &lt;&lt; &quot;emergency_stop!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot; &lt;&lt; std::endl;
  }
}

void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.linear_x = input_msg-&gt;twist.linear.x;
    twist_gate_msg_.angular_z = input_msg-&gt;twist.angular.z;
    select_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::auto_cmd_mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    //TODO:check this if statement
    if(input_msg-&gt;mode == -1 || input_msg-&gt;mode == 0){
      reset_select_cmd_msg();
    }
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.mode = input_msg-&gt;mode;
    select_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::auto_cmd_gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.gear = input_msg-&gt;gear;
    select_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::auto_cmd_accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.accel = input_msg-&gt;accel;
    select_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::auto_cmd_steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.steer = input_msg-&gt;steer;
    select_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::auto_cmd_brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.brake = input_msg-&gt;brake;
    select_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::auto_cmd_ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.linear_velocity = input_msg-&gt;cmd.linear_velocity;
    twist_gate_msg_.steering_angle = input_msg-&gt;cmd.steering_angle;
    select_cmd_pub_.publish(twist_gate_msg_);
  }
}


int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;twist_gate&quot;);
  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  TwistGate twist_gate(nh, private_nh);

  ros::spin();
  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/socket/packages/mqtt_socket/nodes/mqtt_receiver/mqtt_receiver.cpp" new_path="ros/src/socket/packages/mqtt_socket/nodes/mqtt_receiver/mqtt_receiver.cpp">
				<diff>@@ -128,8 +128,10 @@ static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const st
     msg.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
     msg.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
     msg.gear = std::stoi(cmds[3]);
-    msg.mode = std::stoi(cmds[4]);
-    msg.emergency = std::stoi(cmds[5]);
+    int blinker = std::stoi(cmds[4]);
+    msg.mode = std::stoi(cmds[5]);
+    int hev_mode = std::stoi(cmds[6]);
+    msg.emergency = std::stoi(cmds[7]);
     remote_cmd_pub_.publish(msg);
   }
 }
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Tier IV, Inc.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/String.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;string.h&quot;
#include &quot;mqtt_socket/mqtt_setting.hpp&quot;
#include &quot;autoware_msgs/RemoteCmd.h&quot;
#include &lt;mosquitto.h&gt;
#include &lt;vector&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;string&gt;

static struct mosquitto *mqtt_client_ = NULL;
static std::string mqtt_topic_;
static int mqtt_qos_;
static ros::Publisher remote_cmd_pub_;

class MqttReceiver
{
public:
  MqttReceiver();
  ~MqttReceiver();
  static void on_connect(struct mosquitto *mosq, void *obj, int result);
  static void on_disconnect(struct mosquitto *mosq, void *obj, int rc);
  static void on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message);

private:
  ros::NodeHandle node_handle_;

  // MQTT
  std::string mqtt_address_;
  int mqtt_port_;
  std::string mqtt_client_id_;
  int mqtt_timeout_;
};

MqttReceiver::MqttReceiver() :
    node_handle_(&quot;~&quot;)
{
  // ROS Publisher
  remote_cmd_pub_ = node_handle_.advertise&lt;autoware_msgs::RemoteCmd&gt;(&quot;/remote_cmd&quot;, 5);

  // MQTT PARAMS
  mosquitto_lib_init();

  mqtt_address_ = MQTT_ADDRESS;
  mqtt_port_ = MQTT_PORT;
  mqtt_topic_ = std::string(RECIEVER_TOPIC) + std::string(VEHICLEID) + &quot;/remote_cmd&quot;;
  mqtt_client_id_ = std::string(CLIENTID) + &quot;_&quot; + std::string(VEHICLEID) + &quot;_rcv&quot;;
  mqtt_qos_ = QOS;

  node_handle_.param(&quot;/confing/mqtt/address&quot;, mqtt_address_, mqtt_address_);
  node_handle_.param(&quot;/confing/mqtt/port&quot;, mqtt_port_, mqtt_port_);
  node_handle_.param(&quot;/confing/mqtt/topic&quot;, mqtt_topic_, mqtt_topic_);
  node_handle_.param(&quot;/confing/mqtt/client_id&quot;, mqtt_client_id_, mqtt_client_id_);
  node_handle_.param(&quot;/confing/mqtt/qos&quot;, mqtt_qos_, mqtt_qos_);
  node_handle_.param(&quot;/confing/mqtt/timeout&quot;, mqtt_timeout_, mqtt_timeout_);
  ROS_INFO(&quot;MQTT Receiver ADDR: %s:%d, TOPIC: %s, ID: %s\n&quot;, mqtt_address_.c_str(), mqtt_port_, mqtt_topic_.c_str(), mqtt_client_id_.c_str());

  mqtt_client_ = mosquitto_new(mqtt_client_id_.c_str(), true, NULL);
  mosquitto_connect_callback_set(mqtt_client_, &amp;MqttReceiver::on_connect);
  mosquitto_disconnect_callback_set(mqtt_client_, &amp;MqttReceiver::on_disconnect);
  mosquitto_message_callback_set(mqtt_client_, &amp;MqttReceiver::on_message);

  if(mosquitto_connect_bind(mqtt_client_, mqtt_address_.c_str(), mqtt_port_, mqtt_timeout_, NULL)){
    ROS_INFO(&quot;Failed to connect broker.\n&quot;);
    mosquitto_lib_cleanup();
    exit(EXIT_FAILURE);
  }
}

MqttReceiver::~MqttReceiver()
{
  ROS_INFO(&quot;Launch MqttReceiver&quot;);
}

static void MqttReceiver::on_connect(struct mosquitto *mosq, void *obj, int result)
{
  ROS_INFO(&quot;on_connect: %s(%d)\n&quot;, __FUNCTION__, __LINE__);
  mosquitto_subscribe(mqtt_client_, NULL, mqtt_topic_.c_str(), mqtt_qos_);
}

static void MqttReceiver::on_disconnect(struct mosquitto *mosq, void *obj, int rc)
{
  ROS_INFO(&quot;on_disconnect: %s(%d)\n&quot;, __FUNCTION__, __LINE__);
}

static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message)
{
  if(message-&gt;payloadlen) {
    ROS_INFO(&quot;%s &quot;, message-&gt;topic);
    std::string delim (&quot;,&quot;);
    std::string msg_str((char *)message-&gt;payload, message-&gt;payloadlen);
    std::vector&lt;std::string&gt; cmds;
    boost::algorithm::split(cmds, msg_str, boost::is_any_of(&quot;,&quot;));

    autoware_msgs::RemoteCmd msg;
    msg.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
    msg.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
    msg.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
    msg.gear = std::stoi(cmds[3]);
    msg.mode = std::stoi(cmds[4]);
    msg.emergency = std::stoi(cmds[5]);
    remote_cmd_pub_.publish(msg);
  }
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, &quot;mqtt_receiver&quot;);
  MqttReceiver node;
  ros::spinOnce();

  int ret = mosquitto_loop_forever(mqtt_client_, -1, 1);

  mosquitto_destroy(mqtt_client_);
  mosquitto_lib_cleanup();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="c125c4fbcf899d18af0285fdc001dd6039474764" fix_time="7,85316">
		<msg>fix bug of non stopping</msg>
		<modified_files>
			<file old_path="ros/src/socket/packages/mqtt_socket/nodes/mqtt_receiver/mqtt_receiver.cpp" new_path="ros/src/socket/packages/mqtt_socket/nodes/mqtt_receiver/mqtt_receiver.cpp">
				<diff>@@ -38,11 +38,18 @@
 #include &lt;vector&gt;
 #include &lt;boost/algorithm/string.hpp&gt;
 #include &lt;string&gt;
+#include &lt;signal.h&gt;
 
 static struct mosquitto *mqtt_client_ = NULL;
 static std::string mqtt_topic_;
 static int mqtt_qos_;
 static ros::Publisher remote_cmd_pub_;
+sig_atomic_t volatile g_request_shutdown = 0;
+
+void mySigIntHandler(int sig)
+{
+  g_request_shutdown = 1;
+}
 
 class MqttReceiver
 {
@@ -96,11 +103,17 @@ MqttReceiver::MqttReceiver() :
     mosquitto_lib_cleanup();
     exit(EXIT_FAILURE);
   }
+
+  // Start Subscribe
+  int ret = mosquitto_loop(mqtt_client_, -1, 1);
+  ret = mosquitto_loop_start(mqtt_client_);
 }
 
 MqttReceiver::~MqttReceiver()
 {
-  ROS_INFO(&quot;Launch MqttReceiver&quot;);
+  int ret = mosquitto_loop_stop(mqtt_client_, 1);
+  mosquitto_destroy(mqtt_client_);
+  mosquitto_lib_cleanup();
 }
 
 static void MqttReceiver::on_connect(struct mosquitto *mosq, void *obj, int result)
@@ -138,14 +151,14 @@ static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const st
 
 int main(int argc, char **argv)
 {
-  ros::init(argc, argv, &quot;mqtt_receiver&quot;);
+  ros::init(argc, argv, &quot;mqtt_receiver&quot;, ros::init_options::NoSigintHandler);
+  signal(SIGINT, mySigIntHandler);
   MqttReceiver node;
-  ros::spinOnce();
-
-  int ret = mosquitto_loop_forever(mqtt_client_, -1, 1);
 
-  mosquitto_destroy(mqtt_client_);
-  mosquitto_lib_cleanup();
+  while (!g_request_shutdown)
+  {
+    sleep(1);
+  }
 
   return 0;
 }
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Tier IV, Inc.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/String.h&quot;
#include &quot;stdlib.h&quot;
#include &quot;string.h&quot;
#include &quot;mqtt_socket/mqtt_setting.hpp&quot;
#include &quot;autoware_msgs/RemoteCmd.h&quot;
#include &lt;mosquitto.h&gt;
#include &lt;vector&gt;
#include &lt;boost/algorithm/string.hpp&gt;
#include &lt;string&gt;

static struct mosquitto *mqtt_client_ = NULL;
static std::string mqtt_topic_;
static int mqtt_qos_;
static ros::Publisher remote_cmd_pub_;

class MqttReceiver
{
public:
  MqttReceiver();
  ~MqttReceiver();
  static void on_connect(struct mosquitto *mosq, void *obj, int result);
  static void on_disconnect(struct mosquitto *mosq, void *obj, int rc);
  static void on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message);

private:
  ros::NodeHandle node_handle_;

  // MQTT
  std::string mqtt_address_;
  int mqtt_port_;
  std::string mqtt_client_id_;
  int mqtt_timeout_;
};

MqttReceiver::MqttReceiver() :
    node_handle_(&quot;~&quot;)
{
  // ROS Publisher
  remote_cmd_pub_ = node_handle_.advertise&lt;autoware_msgs::RemoteCmd&gt;(&quot;/remote_cmd&quot;, 5);

  // MQTT PARAMS
  mosquitto_lib_init();

  mqtt_address_ = MQTT_ADDRESS;
  mqtt_port_ = MQTT_PORT;
  mqtt_topic_ = std::string(RECIEVER_TOPIC) + std::string(VEHICLEID) + &quot;/remote_cmd&quot;;
  mqtt_client_id_ = std::string(CLIENTID) + &quot;_&quot; + std::string(VEHICLEID) + &quot;_rcv&quot;;
  mqtt_qos_ = QOS;

  node_handle_.param(&quot;/confing/mqtt/address&quot;, mqtt_address_, mqtt_address_);
  node_handle_.param(&quot;/confing/mqtt/port&quot;, mqtt_port_, mqtt_port_);
  node_handle_.param(&quot;/confing/mqtt/topic&quot;, mqtt_topic_, mqtt_topic_);
  node_handle_.param(&quot;/confing/mqtt/client_id&quot;, mqtt_client_id_, mqtt_client_id_);
  node_handle_.param(&quot;/confing/mqtt/qos&quot;, mqtt_qos_, mqtt_qos_);
  node_handle_.param(&quot;/confing/mqtt/timeout&quot;, mqtt_timeout_, mqtt_timeout_);
  ROS_INFO(&quot;MQTT Receiver ADDR: %s:%d, TOPIC: %s, ID: %s\n&quot;, mqtt_address_.c_str(), mqtt_port_, mqtt_topic_.c_str(), mqtt_client_id_.c_str());

  mqtt_client_ = mosquitto_new(mqtt_client_id_.c_str(), true, NULL);
  mosquitto_connect_callback_set(mqtt_client_, &amp;MqttReceiver::on_connect);
  mosquitto_disconnect_callback_set(mqtt_client_, &amp;MqttReceiver::on_disconnect);
  mosquitto_message_callback_set(mqtt_client_, &amp;MqttReceiver::on_message);

  if(mosquitto_connect_bind(mqtt_client_, mqtt_address_.c_str(), mqtt_port_, mqtt_timeout_, NULL)){
    ROS_INFO(&quot;Failed to connect broker.\n&quot;);
    mosquitto_lib_cleanup();
    exit(EXIT_FAILURE);
  }
}

MqttReceiver::~MqttReceiver()
{
  ROS_INFO(&quot;Launch MqttReceiver&quot;);
}

static void MqttReceiver::on_connect(struct mosquitto *mosq, void *obj, int result)
{
  ROS_INFO(&quot;on_connect: %s(%d)\n&quot;, __FUNCTION__, __LINE__);
  mosquitto_subscribe(mqtt_client_, NULL, mqtt_topic_.c_str(), mqtt_qos_);
}

static void MqttReceiver::on_disconnect(struct mosquitto *mosq, void *obj, int rc)
{
  ROS_INFO(&quot;on_disconnect: %s(%d)\n&quot;, __FUNCTION__, __LINE__);
}

static void MqttReceiver::on_message(struct mosquitto *mosq, void *obj, const struct mosquitto_message *message)
{
  if(message-&gt;payloadlen) {
    ROS_INFO(&quot;%s &quot;, message-&gt;topic);
    std::string delim (&quot;,&quot;);
    std::string msg_str((char *)message-&gt;payload, message-&gt;payloadlen);
    std::vector&lt;std::string&gt; cmds;
    boost::algorithm::split(cmds, msg_str, boost::is_any_of(&quot;,&quot;));

    autoware_msgs::RemoteCmd msg;
    msg.steer = std::stof(cmds[0]) * STEER_MAX_VAL;
    msg.accel = std::stof(cmds[1]) * ACCEL_MAX_VAL;
    msg.brake = std::stof(cmds[2]) * BRAKE_MAX_VAL;
    msg.gear = std::stoi(cmds[3]);
    int blinker = std::stoi(cmds[4]);
    msg.mode = std::stoi(cmds[5]);
    int hev_mode = std::stoi(cmds[6]);
    msg.emergency = std::stoi(cmds[7]);
    remote_cmd_pub_.publish(msg);
  }
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, &quot;mqtt_receiver&quot;);
  MqttReceiver node;
  ros::spinOnce();

  int ret = mosquitto_loop_forever(mqtt_client_, -1, 1);

  mosquitto_destroy(mqtt_client_);
  mosquitto_lib_cleanup();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="083ff4863b3d173a2ed6ead8b81dd99fd9b7c4df" fix_time="0,0">
		<msg>Release/1.5.1 (#816)

* fix a build error by gcc version

* fix build error for older indigo version

* update changelog for v1.5.1

* 1.5.1</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/motion/packages/dp_planner/nodes/dp_planner_core.cpp" new_path="ros/src/computing/planning/motion/packages/dp_planner/nodes/dp_planner_core.cpp">
				<diff>@@ -1068,7 +1068,11 @@ void PlannerX::PlannerMainLoop()
 				enableLattice.data = 1;
 			}else{
 				visualization_msgs::Marker delMarker;
+#ifndef ROS_KINETIC
+				delMarker.action = visualization_msgs::Marker::DELETE;
+#else
 				delMarker.action = visualization_msgs::Marker::DELETEALL;
+#endif
 				delMarker.ns = &quot;global_lane_array_marker_dynamic&quot;;
 				all_rollOuts_dynamic.markers.push_back(delMarker);
 				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
</diff>
				<old_file>/*
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include &quot;dp_planner_core.h&quot;

#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &quot;geo_pos_conv.hh&quot;


#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &quot;UtilityH.h&quot;
#include &quot;MatrixOperations.h&quot;

namespace PlannerXNS
{

PlannerX::PlannerX()
{

	clock_gettime(0, &amp;m_Timer);
	m_counter = 0;
	m_frequency = 0;

	m_nTrackObjects = 0;
	m_nContourPoints = 0;
	m_nOriginalPoints = 0;
	m_TrackingTime = 0;
	bInitPos = false;
	bNewCurrentPos = false;
	bNewClusters = false;
	bNewBoxes = false;
	bVehicleState = false;
	bNewEmergency = false;
	m_bEmergencyStop = 0;
	bNewTrafficLigh = false;
	m_bGreenLight = false; UtilityHNS::UtilityH::GetTickCount(m_TrafficLightTimer);
	bNewOutsideControl = false;
	m_bOutsideControl = 0;
	bNewAStarPath = false;
	UtilityHNS::UtilityH::GetTickCount(m_AStartPlanningTimer);
	bWayPlannerPath = false;
	bKmlMapLoaded = false;
	m_bEnableTracking = true;
	m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 2.0;
	m_ObstacleTracking.m_MAX_TRACKS_AFTER_LOSING = 5;
	m_ObstacleTracking.m_DT = 0.12;
	m_ObstacleTracking.m_bUseCenterOnly = true;

	enablePlannerDynamicSwitch = false;


	int iSource = 0;
	nh.getParam(&quot;/dp_planner/mapSource&quot;, iSource);
	if(iSource == 0)
		m_MapSource = MAP_AUTOWARE;
	else if (iSource == 1)
		m_MapSource = MAP_FOLDER;
	else if(iSource == 2)
		m_MapSource = MAP_KML_FILE;

	nh.getParam(&quot;/dp_planner/mapFileName&quot;, m_KmlMapPath);

	UpdatePlanningParams();

	tf::StampedTransform transform;
	RosHelpers::GetTransformFromTF(&quot;map&quot;, &quot;world&quot;, transform);
	m_OriginPos.position.x  = transform.getOrigin().x();
	m_OriginPos.position.y  = transform.getOrigin().y();
	m_OriginPos.position.z  = transform.getOrigin().z();


	std::string topic_prefix;
	nh.getParam(&quot;/dp_planner/enablePlannerDynamicSwitch&quot;, enablePlannerDynamicSwitch);
	if(enablePlannerDynamicSwitch){
		topic_prefix = &quot;/dp&quot;;
		pub_LocalTrajectoriesRviz_dynamic = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;local_trajectories_dynamic&quot;, 1);
		pub_EnableLattice = nh.advertise&lt;std_msgs::Int32&gt;(&quot;enableLattice&quot;, 1);
	}

	pub_LocalPath = nh.advertise&lt;autoware_msgs::lane&gt;(topic_prefix + &quot;/final_waypoints&quot;, 100,true);
	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::lane&gt;(topic_prefix + &quot;/base_waypoints&quot;, 100,true);
	pub_ClosestIndex = nh.advertise&lt;std_msgs::Int32&gt;(topic_prefix + &quot;/closest_waypoint&quot;, 100,true);

	pub_BehaviorState = nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;current_behavior&quot;, 1);
	pub_GlobalPlanNodes = nh.advertise&lt;geometry_msgs::PoseArray&gt;(&quot;global_plan_nodes&quot;, 1);
	pub_StartPoint = nh.advertise&lt;geometry_msgs::PoseWithCovarianceStamped&gt;(&quot;GlobalStartpose&quot;, 1);
	pub_GoalPoint = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;GlobalGoalPose&quot;, 1);
	pub_AStarStartPoint = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;global_plan_start&quot;, 1);
	pub_AStarGoalPoint = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;global_plan_goal&quot;, 1);

	pub_DetectedPolygonsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;detected_polygons&quot;, 1, true);
	pub_TrackedObstaclesRviz = nh.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;dp_planner_tracked_boxes&quot;, 1);
	pub_LocalTrajectoriesRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;local_trajectories&quot;, 1);
	
	pub_TestLineRviz	= nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;testing_line&quot;, 1);
	pub_BehaviorStateRviz = nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;behavior_state&quot;, 1);
	pub_SafetyBorderRviz  = nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;safety_border&quot;, 1);
	pub_cluster_cloud = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;simu_points_cluster&quot;,1);
	pub_SimuBoxPose	  = nh.advertise&lt;geometry_msgs::PoseArray&gt;(&quot;sim_box_pose_ego&quot;, 100);


	sub_initialpose 	= nh.subscribe(&quot;/initialpose&quot;, 				1,		&amp;PlannerX::callbackGetInitPose, 		this);
	sub_current_pose 	= nh.subscribe(&quot;/current_pose&quot;, 			1,		&amp;PlannerX::callbackGetCurrentPose, 		this);
	sub_cluster_cloud 	= nh.subscribe(&quot;/cloud_clusters&quot;,			1,		&amp;PlannerX::callbackGetCloudClusters, 	this);
	sub_bounding_boxs  	= nh.subscribe(&quot;/bounding_boxes&quot;,			1,		&amp;PlannerX::callbackGetBoundingBoxes, 	this);
	sub_WayPlannerPaths = nh.subscribe(&quot;/realtime_cost_map&quot;,		1,		&amp;PlannerX::callbackGetCostMap, 	this);

#ifdef DATASET_GENERATION_BLOCK

	m_iRecordNumber = 0;
//	tf::StampedTransform base_transform;
//	int nFailedCounter = 0;
//	while (1)
//	{
//		try
//		{
//			m_Transformation.lookupTransform(&quot;base_link&quot;, &quot;world&quot;, ros::Time(0), base_transform);
//			break;
//		}
//		catch (tf::TransformException&amp; ex)
//		{
//			if(nFailedCounter &gt; 2)
//			{
//				ROS_ERROR(&quot;%s&quot;, ex.what());
//			}
//			ros::Duration(1.0).sleep();
//			nFailedCounter ++;
//		}
//	}

	m_ImagesVectors.open(&quot;/home/user/data/db/input.csv&quot;);
	m_TrajVectors.open(&quot;/home/user/data/db/output.csv&quot;);

	sub_image_reader = nh.subscribe(&quot;/image_raw&quot;, 1, &amp;PlannerX::callbackReadImage, 		this);
#endif

	/**
	 * @todo This works only in simulation (Autoware or ff_Waypoint_follower), twist_cmd should be changed, consult team
	 */
	int bVelSource = 1;
	nh.getParam(&quot;/dp_planner/enableOdometryStatus&quot;, bVelSource);
	if(bVelSource == 0)
		sub_robot_odom 			= nh.subscribe(&quot;/odom&quot;, 					100,	&amp;PlannerX::callbackGetRobotOdom, 	this);
	else if(bVelSource == 1)
		sub_current_velocity 	= nh.subscribe(&quot;/current_velocity&quot;,		100,	&amp;PlannerX::callbackGetVehicleStatus, 	this);
	else if(bVelSource == 2)
		sub_can_info 			= nh.subscribe(&quot;/can_info&quot;,		100,	&amp;PlannerX::callbackGetCanInfo, 	this);



	sub_EmergencyStop 	= nh.subscribe(&quot;/emergency_stop_signal&quot;, 	100,	&amp;PlannerX::callbackGetEmergencyStop, 	this);
	sub_TrafficLight 	= nh.subscribe(&quot;/traffic_signal_info&quot;, 		10,		&amp;PlannerX::callbackGetTrafficLight, 	this);

	if(m_bEnableOutsideControl)
		sub_OutsideControl 	= nh.subscribe(&quot;/usb_controller_r_signal&quot;, 	10,		&amp;PlannerX::callbackGetOutsideControl, 	this);
	else
		m_bOutsideControl = 1;

	sub_AStarPath 		= nh.subscribe(&quot;/astar_path&quot;, 				10,		&amp;PlannerX::callbackGetAStarPath, 		this);
	sub_WayPlannerPaths = nh.subscribe(&quot;/lane_waypoints_array&quot;, 	1,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);

	if(m_MapSource == MAP_AUTOWARE)
	{
		sub_map_points 	= nh.subscribe(&quot;/vector_map_info/point&quot;, 		1, &amp;PlannerX::callbackGetVMPoints, 		this);
		sub_map_lanes 	= nh.subscribe(&quot;/vector_map_info/lane&quot;, 		1, &amp;PlannerX::callbackGetVMLanes, 		this);
		sub_map_nodes 	= nh.subscribe(&quot;/vector_map_info/node&quot;, 		1, &amp;PlannerX::callbackGetVMNodes, 		this);
		sup_stop_lines 	= nh.subscribe(&quot;/vector_map_info/stop_line&quot;,	1, &amp;PlannerX::callbackGetVMStopLines, 	this);
		sub_dtlanes 	= nh.subscribe(&quot;/vector_map_info/dtlane&quot;, 		1, &amp;PlannerX::callbackGetVMCenterLines,	this);
	}

	sub_simulated_obstacle_pose_rviz = nh.subscribe(&quot;/clicked_point&quot;, 		1, &amp;PlannerX::callbackGetRvizPoint,	this);
}

PlannerX::~PlannerX()
{
#ifdef OPENPLANNER_ENABLE_LOGS
	UtilityHNS::DataRW::WriteLogData(UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::StatesLogFolderName, &quot;MainLog&quot;,
			&quot;time,dt,Behavior State,behavior,num_Tracked_Objects,num_Cluster_Points,num_Contour_Points,t_Tracking,t_Calc_Cost, t_Behavior_Gen, t_Roll_Out_Gen, num_RollOuts, Full_Block, idx_Central_traj, iTrajectory, Stop Sign, Traffic Light, Min_Stop_Distance, follow_distance, follow_velocity, Velocity, Steering, X, Y, Z, heading,&quot;
			, m_LogData);
#endif

#ifdef DATASET_GENERATION_BLOCK
	m_ImagesVectors.close();
	m_TrajVectors.close();
#endif
}

#ifdef DATASET_GENERATION_BLOCK
void PlannerX::callbackReadImage(const sensor_msgs::ImageConstPtr&amp; img)
{
	//std::cout &lt;&lt; &quot;Reading Image Data ... &quot; &lt;&lt; std::endl;
	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::BGR8);
	m_CurrImage = cv_image-&gt;image;

}

void PlannerX::ExtractPathFromDriveData(double max_extraction)
{
	double d = 0;
	DataPairs dp;

	for(int i = m_DrivePoints.size()-1; i &gt;= 0 ; i--)
	{
		d += m_DrivePoints.at(i).currentPos.cost;

		if(d &gt;= 30)
		{
			dp.image =  m_DrivePoints.at(i).image.clone();
			dp.currentPos =  m_DrivePoints.at(i).currentPos;
			dp.vehicleState = m_DrivePoints.at(i).vehicleState;
			cv::Mat gray_image;
			cvtColor( dp.image, gray_image, cv::COLOR_BGR2GRAY);
			cv::Rect roi;
			roi.x = 0;
			roi.y = gray_image.rows/3;
			roi.width = gray_image.cols;
			roi.height = gray_image.rows - gray_image.rows/3;
			cv::Mat halfImg = gray_image(roi);

			std::ostringstream image_name;
			image_name &lt;&lt; &quot;/home/user/data/db/vis/image_&quot; &lt;&lt; m_iRecordNumber &lt;&lt; &quot;.png&quot;;
			std::ostringstream half_image_name;
			half_image_name &lt;&lt;  &quot;/home/user/data/db/img/img_&quot;  &lt;&lt; m_iRecordNumber &lt;&lt; &quot;.png&quot;;
			std::ostringstream label_name ;
			label_name &lt;&lt; &quot;/home/user/data/db/csv/lbl_&quot; &lt;&lt; m_iRecordNumber &lt;&lt; &quot;.csv&quot;;


			PlannerHNS::Mat3 rotationMat(-dp.currentPos.pos.a);
			PlannerHNS::Mat3 translationMat(-dp.currentPos.pos.x, -dp.currentPos.pos.y);
			for(unsigned int ip=0; ip &lt; dp.path.size(); ip++)
			{
				dp.path.at(ip).pos = translationMat*dp.path.at(ip).pos;
				dp.path.at(ip).pos = rotationMat*dp.path.at(ip).pos;
			}

			PlannerHNS::PlanningHelpers::SmoothPath(dp.path, 0.45, 0.3, 0.01);
			PlannerHNS::PlanningHelpers::FixPathDensity(dp.path, d/20.0);
			PlannerHNS::PlanningHelpers::SmoothPath(dp.path, 0.45, 0.35, 0.01);

			for(unsigned int ip=0; ip &lt;dp.path.size()-1; ip++)
			{
				cv::Point p1;
				p1.y = dp.image.rows - (fabs(dp.path.at(ip).pos.x) *  halfImg.rows  / 40.0);
				p1.x = halfImg.cols/2 + (-dp.path.at(ip).pos.y * halfImg.cols / 20.0);

				cv::Point p2;
				p2.y = dp.image.rows - (fabs(dp.path.at(ip+1).pos.x) *  halfImg.rows  / 40.0);
				p2.x = halfImg.cols/2 + (-dp.path.at(ip+1).pos.y * halfImg.cols / 20.0);

				cv::line(dp.image, p1, p2,  cv::Scalar( 0, 255, 0 ), 2, 8);
			}

			WritePathCSV(label_name.str(), dp.path);
			imwrite(image_name.str(),  dp.image);
			imwrite(half_image_name.str(),  halfImg);

			WriteImageAndPathCSV(halfImg.clone(), dp.path);

			for(int j = 0; j &lt;= i; j++)
				if(m_DrivePoints.size() &gt; 0)
					m_DrivePoints.erase(m_DrivePoints.begin()+0);

			m_iRecordNumber++;
			std::cout &lt;&lt; &quot;Extract Data: &quot; &lt;&lt; &quot;Cost: &quot; &lt;&lt; d &lt;&lt; &quot;, Index: &quot; &lt;&lt; i &lt;&lt; &quot;, Path Size: &quot; &lt;&lt; dp.path.size() &lt;&lt; std::endl;
			return;
		}

		dp.path.insert(dp.path.begin(), m_DrivePoints.at(i).currentPos);
	}
}

void PlannerX::WriteImageAndPathCSV(cv::Mat img,std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
{
	if(m_ImagesVectors.is_open())
	{
		ostringstream str_img;
		str_img.precision(0);
		for(int c=0; c&lt;img.cols; c++)
		{
			for(int r=0; r&lt;img.rows; r++)
			{
				short x = img.at&lt;uchar&gt;(r, c);
				str_img &lt;&lt; x &lt;&lt; ',';
			}
		}

		m_ImagesVectors &lt;&lt; str_img.str() &lt;&lt; &quot;\r\n&quot;;
	}

	if(m_TrajVectors.is_open())
	{
		ostringstream strwp;
		 for(unsigned int i=0; i&lt;path.size(); i++)
		 {
			 strwp &lt;&lt; path.at(i).pos.x&lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).pos.y &lt;&lt; &quot;,&quot;;
		 }
		m_TrajVectors &lt;&lt; strwp.str() &lt;&lt; &quot;\r\n&quot;;
	}
}

void PlannerX::WritePathCSV(const std::string&amp; fName, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
{
	vector&lt;string&gt; dataList;
	 for(unsigned int i=0; i&lt;path.size(); i++)
	 {
		 ostringstream strwp;
		 strwp &lt;&lt; path.at(i).pos.x&lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).pos.y &lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).v &lt;&lt; &quot;,&quot;;
		 dataList.push_back(strwp.str());
	 }

	 std::ofstream f(fName.c_str());

	if(f.is_open())
	{
		for(unsigned int i = 0 ; i &lt; dataList.size(); i++)
			f &lt;&lt; dataList.at(i) &lt;&lt; &quot;\r\n&quot;;
	}

	f.close();
}

#endif

void PlannerX::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Points&quot;);
	m_AwMap.points = msg;
	m_AwMap.bPoints = true;
}

void PlannerX::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Lane Array&quot;);
	m_AwMap.lanes = msg;
	m_AwMap.bLanes = true;
}

void PlannerX::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
{
}

void PlannerX::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
{
}

void PlannerX::callbackGetVMCenterLines(const vector_map_msgs::DTLaneArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Center Lines&quot;);
	m_AwMap.dtlanes = msg;
	m_AwMap.bDtLanes = true;
}

void PlannerX::UpdatePlanningParams()
{
	PlannerHNS::PlanningParams params;

	nh.getParam(&quot;/dp_planner/enableSwerving&quot;, params.enableSwerving);
	if(params.enableSwerving)
		params.enableFollowing = true;
	else
		nh.getParam(&quot;/dp_planner/enableFollowing&quot;, params.enableFollowing);

	nh.getParam(&quot;/dp_planner/enableHeadingSmoothing&quot;, params.enableHeadingSmoothing);
	nh.getParam(&quot;/dp_planner/enableTrafficLightBehavior&quot;, params.enableTrafficLightBehavior);
	nh.getParam(&quot;/dp_planner/enableStopSignBehavior&quot;, params.enableStopSignBehavior);

	nh.getParam(&quot;/dp_planner/maxVelocity&quot;, params.maxSpeed);
	nh.getParam(&quot;/dp_planner/minVelocity&quot;, params.minSpeed);
	nh.getParam(&quot;/dp_planner/maxLocalPlanDistance&quot;, params.microPlanDistance);
	nh.getParam(&quot;/dp_planner/samplingTipMargin&quot;, params.carTipMargin);
	nh.getParam(&quot;/dp_planner/samplingOutMargin&quot;, params.rollInMargin);
	nh.getParam(&quot;/dp_planner/samplingSpeedFactor&quot;, params.rollInSpeedFactor);

	nh.getParam(&quot;/dp_planner/pathDensity&quot;, params.pathDensity);
	nh.getParam(&quot;/dp_planner/rollOutDensity&quot;, params.rollOutDensity);
	if(params.enableSwerving)
		nh.getParam(&quot;/dp_planner/rollOutsNumber&quot;, params.rollOutNumber);
	else
		params.rollOutNumber = 0;

	nh.getParam(&quot;/dp_planner/horizonDistance&quot;, params.horizonDistance);
	nh.getParam(&quot;/dp_planner/minFollowingDistance&quot;, params.minFollowingDistance);
	nh.getParam(&quot;/dp_planner/minDistanceToAvoid&quot;, params.minDistanceToAvoid);
	nh.getParam(&quot;/dp_planner/maxDistanceToAvoid&quot;, params.maxDistanceToAvoid);
	nh.getParam(&quot;/dp_planner/speedProfileFactor&quot;, params.speedProfileFactor);

	nh.getParam(&quot;/dp_planner/horizontalSafetyDistance&quot;, params.horizontalSafetyDistancel);
	nh.getParam(&quot;/dp_planner/verticalSafetyDistance&quot;, params.verticalSafetyDistance);

	nh.getParam(&quot;/dp_planner/enableLaneChange&quot;, params.enableLaneChange);
	nh.getParam(&quot;/dp_planner/enabTrajectoryVelocities&quot;, params.enabTrajectoryVelocities);

	nh.getParam(&quot;/dp_planner/enableObjectTracking&quot;, m_bEnableTracking);
	nh.getParam(&quot;/dp_planner/enableOutsideControl&quot;, m_bEnableOutsideControl);


	PlannerHNS::ControllerParams controlParams;
	controlParams.Steering_Gain = PlannerHNS::PID_CONST(0.07, 0.02, 0.01);
	controlParams.Velocity_Gain = PlannerHNS::PID_CONST(0.1, 0.005, 0.1);
	nh.getParam(&quot;/dp_planner/steeringDelay&quot;, controlParams.SteeringDelay);
	nh.getParam(&quot;/dp_planner/minPursuiteDistance&quot;, controlParams.minPursuiteDistance );

	PlannerHNS::CAR_BASIC_INFO vehicleInfo;

	nh.getParam(&quot;/dp_planner/width&quot;, vehicleInfo.width);
	nh.getParam(&quot;/dp_planner/length&quot;, vehicleInfo.length);
	nh.getParam(&quot;/dp_planner/wheelBaseLength&quot;, vehicleInfo.wheel_base);
	nh.getParam(&quot;/dp_planner/turningRadius&quot;, vehicleInfo.turning_radius);
	nh.getParam(&quot;/dp_planner/maxSteerAngle&quot;, vehicleInfo.max_steer_angle);
	vehicleInfo.max_speed_forward = params.maxSpeed;
	vehicleInfo.min_speed_forward = params.minSpeed;

	m_LocalPlanner.m_SimulationSteeringDelayFactor = controlParams.SimulationSteeringDelay;
	m_LocalPlanner.Init(controlParams, params, vehicleInfo);
	m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_Behavior = PlannerHNS::INITIAL_STATE;

}

void PlannerX::callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg)
{
	if(!bInitPos)
	{
		PlannerHNS::WayPoint p;
		ROS_INFO(&quot;init Simulation Rviz Pose Data: x=%f, y=%f, z=%f, freq=%d&quot;, msg-&gt;pose.pose.position.x, msg-&gt;pose.pose.position.y, msg-&gt;pose.pose.position.z, m_frequency);
		m_InitPos = PlannerHNS::WayPoint(msg-&gt;pose.pose.position.x+m_OriginPos.position.x,
				msg-&gt;pose.pose.position.y+m_OriginPos.position.y,
				msg-&gt;pose.pose.position.z+m_OriginPos.position.z,
				tf::getYaw(msg-&gt;pose.pose.orientation));
		m_CurrentPos = m_InitPos;
		bInitPos = true;
	}
}

void PlannerX::callbackGetCostMap(const nav_msgs::OccupancyGrid&amp; msg)
{
}

void PlannerX::callbackGetRvizPoint(const geometry_msgs::PointStampedConstPtr&amp; msg)
{
	//Add Simulated Obstacle polygon
	timespec t;
	UtilityHNS::UtilityH::GetTickCount(t);
	srand(t.tv_nsec);
	double width = SIMU_OBSTACLE_WIDTH;//((double)(rand()%10)/10.0) * 1.5 + 0.25;
	double length = SIMU_OBSTACLE_LENGTH;//((double)(rand()%10)/10.0) * 0.5 + 0.25;
	double height = SIMU_OBSTACLE_HEIGHT;

	geometry_msgs::PointStamped point;
	point.point.x = msg-&gt;point.x+m_OriginPos.position.x;
	point.point.y = msg-&gt;point.y+m_OriginPos.position.y;
	point.point.z = msg-&gt;point.z+m_OriginPos.position.z;

	autoware_msgs::CloudClusterArray clusters_array;
	clusters_array.clusters.push_back(GenerateSimulatedObstacleCluster(width, length, height, 50, point));
	m_OriginalClusters.clear();
	int nNum1, nNum2;
	RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_LocalPlanner.m_CarInfo, clusters_array, m_OriginalClusters, nNum1, nNum2);
	m_TrackedClusters = m_OriginalClusters;

	pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
	pcl::fromROSMsg(clusters_array.clusters.at(0).cloud, point_cloud);
	sensor_msgs::PointCloud2 cloud_msg;
	pcl::toROSMsg(point_cloud, cloud_msg);
	cloud_msg.header.frame_id = &quot;map&quot;;
	pub_cluster_cloud.publish(cloud_msg);

	if(m_TrackedClusters.size()&gt;0)
	{
		jsk_recognition_msgs::BoundingBoxArray boxes_array;
		boxes_array.header.frame_id = &quot;map&quot;;
		boxes_array.header.stamp  = ros::Time();
		jsk_recognition_msgs::BoundingBox box;
		box.header.frame_id = &quot;map&quot;;
		box.header.stamp = ros::Time();
		box.pose.position.x = m_TrackedClusters.at(0).center.pos.x;
		box.pose.position.y = m_TrackedClusters.at(0).center.pos.y;
		box.pose.position.z = m_TrackedClusters.at(0).center.pos.z;

		box.value = 0.9;

		//box.pose.orientation = detectedPolygons.markers.at(0)
		box.dimensions.x = SIMU_OBSTACLE_WIDTH;
		box.dimensions.y = SIMU_OBSTACLE_LENGTH;
		box.dimensions.z = SIMU_OBSTACLE_HEIGHT;
		boxes_array.boxes.push_back(box);

		pub_TrackedObstaclesRviz.publish(boxes_array);
	}

//	if(m_LocalPlanner.m_TotalPath.size() &gt; 0)
//	{
//		vector&lt;PlannerHNS::WayPoint&gt; line;
//		PlannerHNS::WayPoint p1(msg-&gt;point.x+m_OriginPos.position.x, msg-&gt;point.y+m_OriginPos.position.y, msg-&gt;point.z+m_OriginPos.position.z, 0);
//
//		//int index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_LocalPlanner.m_TotalPath.at(0), p1);
////		PlannerHNS::WayPoint p_prev = m_LocalPlanner.m_TotalPath.at(0).at(index);
////		if(index &gt; 0)
////			p_prev = m_LocalPlanner.m_TotalPath.at(0).at(index-1);
////
////
////		double distance = 0;
////		PlannerHNS::WayPoint p2 = PlannerHNS::PlanningHelpers::GetPerpendicularOnTrajectory(m_LocalPlanner.m_TotalPath.at(0), p1, distance);
////
////		double perpDistance = PlannerHNS::PlanningHelpers::GetPerpDistanceToTrajectorySimple(m_LocalPlanner.m_TotalPath.at(0), p1);
////
////		double back_distance = hypot(p2.pos.y - p_prev.pos.y, p2.pos.x - p_prev.pos.x);
////		double direct_distance = hypot(p2.pos.y - p1.pos.y, p2.pos.x - p1.pos.x);
//
//
//		PlannerHNS::RelativeInfo info;
//		bool ret = PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_TotalPath.at(0), p1, info);
//		PlannerHNS::WayPoint p_prev = m_LocalPlanner.m_TotalPath.at(0).at(info.iBack);
//
//		std::cout &lt;&lt; &quot;Perp D: &quot; &lt;&lt; info.perp_distance &lt;&lt; &quot;, F D: &quot;&lt;&lt; info.to_front_distance &lt;&lt; &quot;, B D: &quot; &lt;&lt; info.from_back_distance &lt;&lt; &quot;, F Index: &quot;&lt;&lt; info.iFront &lt;&lt; &quot;, B Index: &quot; &lt;&lt; info.iBack &lt;&lt; &quot;, Size: &quot;&lt;&lt; m_LocalPlanner.m_TotalPath.at(0).size() &lt;&lt; std::endl;
//
//		line.push_back(p1);
//		line.push_back(info.perp_point);
//		line.push_back(p_prev);
//
//		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; lines;
//		lines.push_back(line);
//		visualization_msgs::MarkerArray line_vis;
//		RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(lines, line_vis);
//		pub_TestLineRviz.publish(line_vis);
//	}
}

void PlannerX::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg)
{
	m_counter++;
	double dt = UtilityHNS::UtilityH::GetTimeDiffNow(m_Timer);
	if(dt &gt;= 1.0)
	{
		m_frequency = m_counter;
		m_counter = 0;
		clock_gettime(0, &amp;m_Timer);
	}

	m_CurrentPos = PlannerHNS::WayPoint(msg-&gt;pose.position.x, msg-&gt;pose.position.y,
					msg-&gt;pose.position.z, tf::getYaw(msg-&gt;pose.orientation));

	m_InitPos = m_CurrentPos;

	bNewCurrentPos = true;
	bInitPos = true;
#ifdef DATASET_GENERATION_BLOCK

	PlannerHNS::WayPoint p(m_CurrentPos.pos.x, m_CurrentPos.pos.y, 0, m_CurrentPos.pos.a);
	p.v = m_VehicleState.speed;

	DataPairs dp;
	if(m_DrivePoints.size() == 0)
	{
		dp.image = m_CurrImage;
		dp.currentPos = p;
		dp.vehicleState = m_VehicleState;
		m_DrivePoints.push_back(dp);
	}
	else
	{
		p.cost = hypot(p.pos.y - m_DrivePoints.at(m_DrivePoints.size()-1).currentPos.pos.y, p.pos.x - m_DrivePoints.at(m_DrivePoints.size()-1).currentPos.pos.x);
		if(p.cost &gt;= 0.25 &amp;&amp; p.cost &lt;= 3.0)
		{
			dp.image = m_CurrImage;
			dp.currentPos = p;
			dp.vehicleState = m_VehicleState;
			m_DrivePoints.push_back(dp);
			//std::cout &lt;&lt; &quot;Insert Pose: &quot; &lt;&lt; &quot;Cost: &quot; &lt;&lt; p.cost &lt;&lt; &quot;, Speed: &quot; &lt;&lt; p.v &lt;&lt; &quot;, Size: &quot; &lt;&lt; m_DrivePoints.size() &lt;&lt; std::endl;
		}
		else
		{
			//std::cout &lt;&lt; &quot;Miss Pose: &quot; &lt;&lt; &quot;Cost: &quot; &lt;&lt; p.cost &lt;&lt; &quot;, Speed: &quot; &lt;&lt; p.v &lt;&lt; &quot;, Size: &quot; &lt;&lt; m_DrivePoints.size() &lt;&lt; std::endl;
			if(m_DrivePoints.size() == 1)
				m_DrivePoints.clear();
		}
	}


	if(m_DrivePoints.size() &gt;= 20)
		ExtractPathFromDriveData();

#endif
}

autoware_msgs::CloudCluster PlannerX::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::PointStamped&amp; centerPose)
{
	autoware_msgs::CloudCluster cluster;
	cluster.centroid_point.point = centerPose.point;
	cluster.dimensions.x = x_rand;
	cluster.dimensions.y = y_rand;
	cluster.dimensions.z = z_rand;
	pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;

	timespec t;
	for(int i=1; i &lt; nPoints; i++)
	{
		UtilityHNS::UtilityH::GetTickCount(t);
		pcl::PointXYZ p;
		srand(t.tv_nsec/i);
		double x = (double)(rand()%100)/100.0 - 0.5;

		srand(t.tv_nsec/i*i);
		double y = (double)(rand()%100)/100.0 - 0.5;

		srand(t.tv_nsec);
		double z = (double)(rand()%100)/100.0 - 0.5;

		p.x = centerPose.point.x + x*x_rand;
		p.y = centerPose.point.y + y*y_rand;
		p.z = centerPose.point.z + z*z_rand;
		point_cloud.points.push_back(p);
	}

	pcl::toROSMsg(point_cloud, cluster.cloud);

	return cluster;
}

void PlannerX::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg)
{
	timespec timerTemp;
	UtilityHNS::UtilityH::GetTickCount(timerTemp);

	m_OriginalClusters.clear();
	RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_LocalPlanner.m_CarInfo, *msg, m_OriginalClusters, m_nOriginalPoints, m_nContourPoints);
	if(m_bEnableTracking)
	{
		m_ObstacleTracking.DoOneStep(m_CurrentPos, m_OriginalClusters);
		m_TrackedClusters = m_ObstacleTracking.m_DetectedObjects;
	}
	else
		m_TrackedClusters = m_OriginalClusters;

	m_nTrackObjects = m_TrackedClusters.size();
	m_TrackingTime = UtilityHNS::UtilityH::GetTimeDiffNow(timerTemp);
	bNewClusters = true;
}

void PlannerX::callbackGetBoundingBoxes(const jsk_recognition_msgs::BoundingBoxArrayConstPtr&amp; msg)
{
//	std::cout &lt;&lt; &quot; Number of Detected Boxes =&quot; &lt;&lt; msg-&gt;boxes.size() &lt;&lt; std::endl;
//	RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(*msg, m_DetectedBoxes);
//	bNewBoxes = true;
}

void PlannerX::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg)
{
	m_VehicleState.speed = msg-&gt;twist.linear.x;

	if(msg-&gt;twist.linear.x != 0)
		m_VehicleState.steer = atan(m_LocalPlanner.m_CarInfo.wheel_base * msg-&gt;twist.angular.z/msg-&gt;twist.linear.x);

	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);

	// If steering is in angular velocity
	//m_VehicleState.steer = atan(m_State.m_CarInfo.wheel_base * msg-&gt;twist.angular.z/msg-&gt;twist.linear.x);
//	if(msg-&gt;vector.z == 0x00)
//		m_VehicleState.shift = AW_SHIFT_POS_BB;
//	else if(msg-&gt;vector.z == 0x10)
//		m_VehicleState.shift = AW_SHIFT_POS_DD;
//	else if(msg-&gt;vector.z == 0x20)
//		m_VehicleState.shift = AW_SHIFT_POS_NN;
//	else if(msg-&gt;vector.z == 0x40)
//		m_VehicleState.shift = AW_SHIFT_POS_RR;

	//std::cout &lt;&lt; &quot;PlannerX: Read Status Twist_cmd (&quot;&lt;&lt; m_VehicleState.speed &lt;&lt; &quot;, &quot; &lt;&lt; m_VehicleState.steer&lt;&lt;&quot;)&quot; &lt;&lt; std::endl;
}

void PlannerX::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
{
	m_VehicleState.speed = msg-&gt;speed/3.6;
	m_VehicleState.steer = msg-&gt;angle * m_LocalPlanner.m_CarInfo.max_steer_angle / m_LocalPlanner.m_CarInfo.max_steer_value;
	std::cout &lt;&lt; &quot;Can Info, Speed: &quot;&lt;&lt; m_VehicleState.speed &lt;&lt; &quot;, Steering: &quot; &lt;&lt; m_VehicleState.steer  &lt;&lt; std::endl;
}

void PlannerX::callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg)
{
	m_VehicleState.speed = msg-&gt;twist.twist.linear.x;
	m_VehicleState.steer += atan(m_LocalPlanner.m_CarInfo.wheel_base * msg-&gt;twist.twist.angular.z/msg-&gt;twist.twist.linear.x);

	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);
//	if(msg-&gt;vector.z == 0x00)
//		m_VehicleState.shift = AW_SHIFT_POS_BB;
//	else if(msg-&gt;vector.z == 0x10)
//		m_VehicleState.shift = AW_SHIFT_POS_DD;
//	else if(msg-&gt;vector.z == 0x20)
//		m_VehicleState.shift = AW_SHIFT_POS_NN;
//	else if(msg-&gt;vector.z == 0x40)
//		m_VehicleState.shift = AW_SHIFT_POS_RR;

	//std::cout &lt;&lt; &quot;PlannerX: Read Odometry (&quot;&lt;&lt; m_VehicleState.speed &lt;&lt; &quot;, &quot; &lt;&lt; m_VehicleState.steer&lt;&lt;&quot;)&quot; &lt;&lt; std::endl;
}

void PlannerX::callbackGetEmergencyStop(const std_msgs::Int8&amp; msg)
{
	//std::cout &lt;&lt; &quot;Received Emergency Stop : &quot; &lt;&lt; msg.data &lt;&lt; std::endl;
	bNewEmergency  = true;
	m_bEmergencyStop = msg.data;
}

void PlannerX::callbackGetTrafficLight(const std_msgs::Int8&amp; msg)
{
	std::cout &lt;&lt; &quot;Received Traffic Light : &quot; &lt;&lt; msg.data &lt;&lt; std::endl;
	bNewTrafficLigh = true;
	if(msg.data == 2)
		m_bGreenLight = true;
	else
		m_bGreenLight = false;
}

void PlannerX::callbackGetOutsideControl(const std_msgs::Int8&amp; msg)
{
	std::cout &lt;&lt; &quot;Received Outside Control : &quot; &lt;&lt; msg.data &lt;&lt; std::endl;
	bNewOutsideControl = true;
	m_bOutsideControl  = msg.data;
}

void PlannerX::callbackGetAStarPath(const autoware_msgs::LaneArrayConstPtr&amp; msg)
{
	if(msg-&gt;lanes.size() &gt; 0)
	{
		m_AStarPath.clear();
		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
		{
			for(unsigned int j = 0 ; j &lt; msg-&gt;lanes.at(i).waypoints.size(); j++)
			{
				PlannerHNS::WayPoint wp(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.x,
						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.y,
						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.z,
						tf::getYaw(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.orientation));
				wp.v = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.x;
				//wp.bDir = msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir;
				m_AStarPath.push_back(wp);
			}
		}
		bNewAStarPath = true;
		m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = true;
	}
}

void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg)
{
	if(msg-&gt;lanes.size() &gt; 0)
	{
		m_WayPlannerPaths.clear();
		bool bOldGlobalPath = m_LocalPlanner.m_TotalPath.size() == msg-&gt;lanes.size();
		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
		{
			std::vector&lt;PlannerHNS::WayPoint&gt; path;
			PlannerHNS::Lane* pPrevValid = 0;
			for(unsigned int j = 0 ; j &lt; msg-&gt;lanes.at(i).waypoints.size(); j++)
			{
				PlannerHNS::WayPoint wp(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.x,
						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.y,
						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.z,
						tf::getYaw(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.orientation));
				wp.v = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.x;
				wp.laneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.y;
				wp.stopLineID = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.z;
				wp.laneChangeCost = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.x;
				wp.LeftLaneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.y;
				wp.RightLaneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.z;

				if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 0)
					wp.bDir = PlannerHNS::FORWARD_DIR;
				else if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 1)
					wp.bDir = PlannerHNS::FORWARD_LEFT_DIR;
				else if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 2)
					wp.bDir = PlannerHNS::FORWARD_RIGHT_DIR;

				PlannerHNS::Lane* pLane = 0;
				pLane = PlannerHNS::MappingHelpers::GetLaneById(wp.laneId, m_Map);
				if(!pLane)
				{
					pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMapDirectionBased(wp, m_Map, 1);

					if(!pLane &amp;&amp; !pPrevValid)
					{
						ROS_ERROR(&quot;Map inconsistency between Global Path add Lal Planer, Can't identify current lane.&quot;);
						return;
					}

					if(!pLane)
						wp.pLane = pPrevValid;
					else
					{
						wp.pLane = pLane;
						pPrevValid = pLane ;
					}

					wp.laneId = wp.pLane-&gt;id;
				}
				else
					wp.pLane = pLane;

				path.push_back(wp);
			}

			PlannerHNS::PlanningHelpers::CalcAngleAndCost(path);

//			int prevStopID = -1;
//			for(unsigned int k= 0; k &lt; path.size(); k++)
//			{
//				if(path.at(k).pLane)
//				{
//					for(unsigned int si = 0; si &lt; path.at(k).pLane-&gt;stopLines.size(); si++)
//					{
//						if(prevStopID != path.at(k).pLane-&gt;stopLines.at(si).id)
//						{
//							PlannerHNS::WayPoint stopLineWP;
//							stopLineWP.pos = path.at(k).pLane-&gt;stopLines.at(si).points.at(0);
//							PlannerHNS::RelativeInfo info;
//							PlannerHNS::PlanningHelpers::GetRelativeInfo(path, stopLineWP, info, k);
//
//							path.at(info.iFront).stopLineID = path.at(k).pLane-&gt;stopLines.at(si).id;
//							prevStopID = path.at(info.iFront).stopLineID;
//						}
//					}
//				}
//			}

			m_WayPlannerPaths.push_back(path);

			if(bOldGlobalPath)
			{
				bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(path, m_LocalPlanner.m_TotalPath.at(i));
			}
		}


		if(!bOldGlobalPath)
		{
			bWayPlannerPath = true;
			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = true;
			//m_CurrentGoal = m_WayPlannerPaths.at(0).at(m_WayPlannerPaths.at(0).size()-1);
			m_LocalPlanner.m_TotalPath = m_WayPlannerPaths;

			cout &lt;&lt; &quot;Global Lanes Size = &quot; &lt;&lt; msg-&gt;lanes.size() &lt;&lt;&quot;, Conv Size= &quot; &lt;&lt; m_WayPlannerPaths.size() &lt;&lt; &quot;, First Lane Size: &quot; &lt;&lt; m_WayPlannerPaths.at(0).size() &lt;&lt; endl;

//			for(unsigned int k= 0; k &lt; m_WayPlannerPaths.at(0).size(); k++)
//			{
//				if(m_WayPlannerPaths.at(0).at(k).stopLineID &gt; 0 &amp;&amp; m_WayPlannerPaths.at(0).at(k).pLane &amp;&amp; m_WayPlannerPaths.at(0).at(k).pLane-&gt;stopLines.size()&gt;0)
//				{
//					cout &lt;&lt; &quot;Stop Line IDs: &quot; &lt;&lt; m_WayPlannerPaths.at(0).at(k).stopLineID &lt;&lt; &quot;, Lane: &quot; &lt;&lt; m_WayPlannerPaths.at(0).at(k).pLane &lt;&lt; &quot;, Stop Lines: &quot;&lt;&lt; m_WayPlannerPaths.at(0).at(k).pLane-&gt;stopLines.size() &lt;&lt; endl;
//				}
//			}
		}
	}
}

void PlannerX::PlannerMainLoop()
{
	ros::Rate loop_rate(100);

	timespec trackingTimer;
	UtilityHNS::UtilityH::GetTickCount(trackingTimer);
	PlannerHNS::WayPoint prevState, state_change;

	while (ros::ok())
	{
		timespec iterationTime;
		UtilityHNS::UtilityH::GetTickCount(iterationTime);

		ros::spinOnce();

		if(m_MapSource == MAP_KML_FILE &amp;&amp; !bKmlMapLoaded)
		{
			bKmlMapLoaded = true;
			PlannerHNS::MappingHelpers::LoadKML(m_KmlMapPath, m_Map);
			//sub_WayPlannerPaths = nh.subscribe(&quot;/lane_waypoints_array&quot;, 	10,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);
		}
		else if(m_MapSource == MAP_FOLDER &amp;&amp; !bKmlMapLoaded)
		{
			bKmlMapLoaded = true;
			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_KmlMapPath, m_Map, true);
		}
		else if(m_MapSource == MAP_AUTOWARE)
		{
			 if(m_AwMap.bDtLanes &amp;&amp; m_AwMap.bLanes &amp;&amp; m_AwMap.bPoints)
			 {
				timespec timerTemp;
				UtilityHNS::UtilityH::GetTickCount(timerTemp);
				 m_AwMap.bDtLanes = m_AwMap.bLanes = m_AwMap.bPoints = false;
				 RosHelpers::UpdateRoadMap(m_AwMap,m_Map);
				 std::cout &lt;&lt; &quot;Converting Vector Map Time : &quot; &lt;&lt;UtilityHNS::UtilityH::GetTimeDiffNow(timerTemp) &lt;&lt; std::endl;
				 //sub_WayPlannerPaths = nh.subscribe(&quot;/lane_waypoints_array&quot;, 	10,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);
			 }
		}

		int iDirection = 0;
		if(bInitPos &amp;&amp; m_LocalPlanner.m_TotalPath.size()&gt;0)
		{
//			bool bMakeNewPlan = false;
//			double drift = hypot(m_LocalPlanner.state.pos.y-m_CurrentPos.pos.y, m_LocalPlanner.state .pos.x-m_CurrentPos.pos.x);
//			if(drift &gt; 10)
//				bMakeNewPlan = true;

			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = m_bOutsideControl;
			m_LocalPlanner.state = m_CurrentPos;

			double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(m_PlanningTimer);
			UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);

			m_CurrentBehavior = m_LocalPlanner.DoOneStep(dt, m_VehicleState, m_TrackedClusters, 1, m_Map, m_bEmergencyStop, m_bGreenLight, true);

			visualization_msgs::Marker behavior_rviz;

			if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &gt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
				iDirection = 1;
			else if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
				iDirection = -1;

			RosHelpers::VisualizeBehaviorState(m_CurrentPos, m_CurrentBehavior, m_bGreenLight, iDirection, behavior_rviz);

			pub_BehaviorStateRviz.publish(behavior_rviz);

			if(m_CurrentBehavior.state != m_PrevBehavior.state)
			{
				//std::cout &lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;ToString(m_CurrentBehavior.state) &lt;&lt; &quot;, Speed : &quot; &lt;&lt; m_CurrentBehavior.maxVelocity &lt;&lt; std::endl;
				m_PrevBehavior = m_CurrentBehavior;
			}


			geometry_msgs::Twist t;
			geometry_msgs::TwistStamped behavior;
			t.linear.x = m_CurrentBehavior.followDistance;
			t.linear.y = m_CurrentBehavior.stopDistance;
			t.linear.z = (int)m_CurrentBehavior.indicator;

			t.angular.x = m_CurrentBehavior.followVelocity;
			t.angular.y = m_CurrentBehavior.maxVelocity;
			t.angular.z = (int)m_CurrentBehavior.state;

			behavior.twist = t;
			behavior.header.stamp = ros::Time::now();

			pub_BehaviorState.publish(behavior);

			visualization_msgs::MarkerArray detectedPolygons;
			RosHelpers::ConvertFromPlannerObstaclesToAutoware(m_CurrentPos, m_TrackedClusters, detectedPolygons);
			pub_DetectedPolygonsRviz.publish(detectedPolygons);

			visualization_msgs::Marker safety_box;
			RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_LocalPlanner.m_TrajectoryCostsCalculatotor.m_SafetyBorder.points, safety_box);
			pub_SafetyBorderRviz.publish(safety_box);

			geometry_msgs::PoseArray sim_data;
			geometry_msgs::Pose p_id, p_pose, p_box;


			sim_data.header.frame_id = &quot;map&quot;;
			sim_data.header.stamp = ros::Time();

			p_id.position.x = 0;

			p_pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(m_LocalPlanner.state.pos.a));
			p_pose.position.x = m_LocalPlanner.state.pos.x;
			p_pose.position.y = m_LocalPlanner.state.pos.y;
			p_pose.position.z = m_LocalPlanner.state.pos.z;



			p_box.position.x = m_LocalPlanner.m_CarInfo.width;
			p_box.position.y = m_LocalPlanner.m_CarInfo.length;
			p_box.position.z = 2.2;

			sim_data.poses.push_back(p_id);
			sim_data.poses.push_back(p_pose);
			sim_data.poses.push_back(p_box);

			pub_SimuBoxPose.publish(sim_data);

			timespec log_t;
			UtilityHNS::UtilityH::GetTickCount(log_t);
			std::ostringstream dataLine;
			std::ostringstream dataLineToOut;
			dataLine &lt;&lt; UtilityHNS::UtilityH::GetLongTime(log_t) &lt;&lt;&quot;,&quot; &lt;&lt; dt &lt;&lt; &quot;,&quot; &lt;&lt; m_CurrentBehavior.state &lt;&lt; &quot;,&quot;&lt;&lt; RosHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; &quot;,&quot; &lt;&lt;
					m_nTrackObjects &lt;&lt; &quot;,&quot; &lt;&lt; m_nOriginalPoints &lt;&lt; &quot;,&quot; &lt;&lt; m_nContourPoints &lt;&lt; &quot;,&quot; &lt;&lt; m_TrackingTime &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_CostCalculationTime &lt;&lt; &quot;,&quot; &lt;&lt; m_LocalPlanner.m_BehaviorGenTime &lt;&lt; &quot;,&quot; &lt;&lt; m_LocalPlanner.m_RollOutsGenerationTime &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bFullyBlock &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_iSafeTrajectory &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;currentStopSignID &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;currentTrafficLightID &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;minStoppingDistance &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;distanceToNext &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;velocityOfNext &lt;&lt; &quot;,&quot; &lt;&lt;
					m_VehicleState.speed &lt;&lt; &quot;,&quot; &lt;&lt;
					m_VehicleState.steer &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.state.pos.x &lt;&lt; &quot;,&quot; &lt;&lt; m_LocalPlanner.state.pos.y &lt;&lt; &quot;,&quot; &lt;&lt; m_LocalPlanner.state.pos.z &lt;&lt; &quot;,&quot; &lt;&lt; UtilityHNS::UtilityH::SplitPositiveAngle(m_LocalPlanner.state.pos.a)+M_PI &lt;&lt; &quot;,&quot;;
			m_LogData.push_back(dataLine.str());

//			dataLineToOut &lt;&lt; RosHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bFullyBlock &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_iSafeTrajectory &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;minStoppingDistance &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;distanceToNext &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;velocityOfNext &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;currentStopSignID &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;currentTrafficLightID &lt;&lt; &quot;,&quot;;
//
//			cout &lt;&lt; dataLineToOut.str() &lt;&lt; endl;


		}
		else
		{
			UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
			sub_WayPlannerPaths = nh.subscribe(&quot;/lane_waypoints_array&quot;, 	1,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);
		}


		autoware_msgs::lane current_trajectory;
		std_msgs::Int32 closest_waypoint;
		PlannerHNS::RelativeInfo info;
		PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_Path, m_LocalPlanner.state, info);
		RosHelpers::ConvertFromPlannerHToAutowarePathFormat(m_LocalPlanner.m_Path, info.iBack, current_trajectory);
		closest_waypoint.data = 1;
		pub_ClosestIndex.publish(closest_waypoint);
		pub_LocalBasePath.publish(current_trajectory);
		pub_LocalPath.publish(current_trajectory);
		visualization_msgs::MarkerArray all_rollOuts;

	
		RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(m_LocalPlanner.m_Path, m_LocalPlanner.m_RollOuts, m_LocalPlanner, all_rollOuts);
		pub_LocalTrajectoriesRviz.publish(all_rollOuts);

		//Publish markers that visualize only when avoiding objects
		if(enablePlannerDynamicSwitch){
			visualization_msgs::MarkerArray all_rollOuts_dynamic;
			std_msgs::Int32 enableLattice;
			if(iDirection != 0) { // if obstacle avoidance state,
				all_rollOuts_dynamic = all_rollOuts;
		   		
			     	for(auto &amp;ro : all_rollOuts_dynamic.markers){
					ro.ns = &quot;global_lane_array_marker_dynamic&quot;;
				}
				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
				enableLattice.data = 1;
			}else{
				visualization_msgs::Marker delMarker;
				delMarker.action = visualization_msgs::Marker::DELETEALL;
				delMarker.ns = &quot;global_lane_array_marker_dynamic&quot;;
				all_rollOuts_dynamic.markers.push_back(delMarker);
				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
				enableLattice.data = 0;
			}
			pub_EnableLattice.publish(enableLattice); //Publish flag of object avoidance
		}


		if(m_CurrentBehavior.bNewPlan)
		{
			std::ostringstream str_out;
			str_out &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory();
			str_out &lt;&lt; UtilityHNS::DataRW::LoggingMainfolderName;
			str_out &lt;&lt; UtilityHNS::DataRW::PathLogFolderName;
			str_out &lt;&lt; &quot;LocalPath_&quot;;
			PlannerHNS::PlanningHelpers::WritePathToFile(str_out.str(), m_LocalPlanner.m_Path);
		}


		//Traffic Light Simulation Part
		if(m_bGreenLight &amp;&amp; UtilityHNS::UtilityH::GetTimeDiffNow(m_TrafficLightTimer) &gt; 5)
		{
			m_bGreenLight = false;
			UtilityHNS::UtilityH::GetTickCount(m_TrafficLightTimer);
		}
		else if(!m_bGreenLight &amp;&amp; UtilityHNS::UtilityH::GetTimeDiffNow(m_TrafficLightTimer) &gt; 10.0)
		{
			m_bGreenLight = true;
			UtilityHNS::UtilityH::GetTickCount(m_TrafficLightTimer);
		}

		loop_rate.sleep();

		//double onePassTime = UtilityHNS::UtilityH::GetTimeDiffNow(iterationTime);
//		if(onePassTime &gt; 0.1)
//			std::cout &lt;&lt; &quot;Slow Iteration Time = &quot; &lt;&lt; onePassTime &lt;&lt; &quot; , for Obstacles : (&quot; &lt;&lt; m_TrackedClusters.size() &lt;&lt; &quot;, &quot; &lt;&lt; m_OriginalClusters.size() &lt;&lt; &quot;)&quot; &lt;&lt;  std::endl;
	}
}

}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="ee29bf64c31a51d6751fac47de8521be62c469de" fix_time="4,76086">
		<msg>bug fix on output filename.</msg>
		<modified_files>
			<file old_path="ros/src/util/packages/map_tools/nodes/map_extender/map_extender.cpp" new_path="ros/src/util/packages/map_tools/nodes/map_extender/map_extender.cpp">
				<diff>@@ -92,7 +92,7 @@ static ros::Publisher ndt_map_pub;
 static bool _get_height = false;
 static bool hasMapSet = false;
 
-static std::string input_pcd;
+static std::string input_pcd, output_pcd, output_pcd_rgb;
 
 static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
 {
@@ -157,15 +157,9 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
   msg_ptr-&gt;header.frame_id = &quot;/map&quot;;
   ndt_map_pub.publish(*msg_ptr);
 
-  // Writing Point Cloud data to PCD file
-  int tmp = input_pcd.find_last_of(&quot;/&quot;);
-  std::string prefix = &quot;extended_&quot;;
-  std::string prefix_rgb = &quot;extended_rgb_&quot;;
-  std::string output = input_pcd.insert(tmp+1, prefix);
-  std::string output_rgb = input_pcd.insert(tmp+1, prefix_rgb);
 
-  pcl::io::savePCDFileBinary(output, *transformed_additional_map_ptr);
-  std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; output &lt;&lt; &quot;: &quot; &lt;&lt; transformed_additional_map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
+  pcl::io::savePCDFileBinary(output_pcd, *transformed_additional_map_ptr);
+  std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; output_pcd &lt;&lt; &quot;: &quot; &lt;&lt; transformed_additional_map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
 
   pcl::PointCloud&lt;pcl::PointXYZRGB&gt; cloud_rgb;
   cloud_rgb.width = transformed_additional_map_ptr-&gt;width;
@@ -179,8 +173,8 @@ static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped:
     cloud_rgb.points[i].rgb = 255 &lt;&lt; 16 | 255 &lt;&lt; 8 | 255;
   }
 
-  pcl::io::savePCDFileBinary(output_rgb, cloud_rgb);
-  std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; output_rgb &lt;&lt; &quot;: &quot; &lt;&lt;  cloud_rgb.points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
+  pcl::io::savePCDFileBinary(output_pcd_rgb, cloud_rgb);
+  std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; output_pcd_rgb &lt;&lt; &quot;: &quot; &lt;&lt;  cloud_rgb.points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
 
   std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
   std::cout &lt;&lt; &quot;Sequence number: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
@@ -219,7 +213,15 @@ int main(int argc, char **argv)
     ros::init(argc, argv, &quot;map_extender&quot;);
     ros::NodeHandle n;
 
-    input_pcd = argv[1];
+    input_pcd = output_pcd = output_pcd_rgb = argv[1];
+    int tmp = input_pcd.find_last_of(&quot;/&quot;);
+    std::string prefix = &quot;extended_&quot;;
+    std::string prefix_rgb = &quot;extended_rgb_&quot;;
+    output_pcd.insert(tmp+1, prefix);
+    output_pcd_rgb.insert(tmp+1, prefix_rgb);
+    std::cout &lt;&lt; input_pcd &lt;&lt; std::endl;
+    std::cout &lt;&lt; output_pcd &lt;&lt; std::endl;
+    std::cout &lt;&lt; output_pcd_rgb &lt;&lt; std::endl;
 
     if(pcl::io::loadPCDFile&lt;pcl::PointXYZI&gt; (input_pcd, *additional_map_ptr) == -1){
       std::cout &lt;&lt; &quot;Couldn't read &quot; &lt;&lt; input_pcd &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;

#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;tf/transform_listener.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/registration/ndt.h&gt;
#include &lt;pcl/filters/approximate_voxel_grid.h&gt;
#include &lt;pcl/filters/voxel_grid.h&gt;

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

//Can't load if typed &quot;pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;&quot;
static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;
static pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr;
pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr additional_map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_additional_map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);

static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;

// Default values
static int iter = 1000; // Maximum iterations
static float ndt_res = 1.0; // Resolution
static double step_size = 0.05; // Step size
static double trans_eps = 0.005; // Transformation epsilon
static double voxel_leaf_size = 1.0;

static ros::Publisher ndt_map_pub;

static bool _get_height = false;
static bool hasMapSet = false;

static std::string input_pcd;

static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
{

  pose guess_pose;

  tf::TransformListener listener;
  tf::StampedTransform transform;
  try
  {
    ros::Time now = ros::Time(0);
    listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
    listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, transform);
  }
  catch (tf::TransformException&amp; ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
  }

  tf::Quaternion q(input-&gt;pose.pose.orientation.x, input-&gt;pose.pose.orientation.y, input-&gt;pose.pose.orientation.z, input-&gt;pose.pose.orientation.w);
  tf::Matrix3x3 m(q);

  guess_pose.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
  guess_pose.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
  guess_pose.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
  m.getRPY(guess_pose.roll, guess_pose.pitch, guess_pose.yaw);

  if (_get_height == true)
  {
    double min_distance = DBL_MAX;
    double nearest_z = guess_pose.z;
    for (const auto&amp; p : map)
    {
      double distance = hypot(guess_pose.x - p.x, guess_pose.y - p.y);
      if (distance &lt; min_distance)
      {
        min_distance = distance;
        nearest_z = p.z;
      }
    }
    guess_pose.z = nearest_z;
  }

  Eigen::Translation3f init_translation(guess_pose.x, guess_pose.y, guess_pose.z);
  Eigen::AngleAxisf init_rotation_x(guess_pose.roll, Eigen::Vector3f::UnitX());
  Eigen::AngleAxisf init_rotation_y(guess_pose.pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf init_rotation_z(guess_pose.yaw, Eigen::Vector3f::UnitZ());

  Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix();

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
  ndt.align(*output_cloud, init_guess);

  Eigen::Matrix4f t = ndt.getFinalTransformation();

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_additional_map_ptr (new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  transformed_additional_map_ptr-&gt;header.frame_id = &quot;/map&quot;;
  pcl::transformPointCloud(*additional_map_ptr, *transformed_additional_map_ptr, t);
  sensor_msgs::PointCloud2::Ptr msg_ptr(new sensor_msgs::PointCloud2);

  pcl::toROSMsg(*transformed_additional_map_ptr, *msg_ptr);
  msg_ptr-&gt;header.frame_id = &quot;/map&quot;;
  ndt_map_pub.publish(*msg_ptr);

  // Writing Point Cloud data to PCD file
  int tmp = input_pcd.find_last_of(&quot;/&quot;);
  std::string prefix = &quot;extended_&quot;;
  std::string prefix_rgb = &quot;extended_rgb_&quot;;
  std::string output = input_pcd.insert(tmp+1, prefix);
  std::string output_rgb = input_pcd.insert(tmp+1, prefix_rgb);

  pcl::io::savePCDFileBinary(output, *transformed_additional_map_ptr);
  std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; output &lt;&lt; &quot;: &quot; &lt;&lt; transformed_additional_map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;

  pcl::PointCloud&lt;pcl::PointXYZRGB&gt; cloud_rgb;
  cloud_rgb.width = transformed_additional_map_ptr-&gt;width;
  cloud_rgb.height = transformed_additional_map_ptr-&gt;height;
  cloud_rgb.points.resize(cloud_rgb.width * cloud_rgb.height);

  for(size_t i = 0; i &lt; cloud_rgb.points.size(); i++){
    cloud_rgb.points[i].x = transformed_additional_map_ptr-&gt;points[i].x;
    cloud_rgb.points[i].y = transformed_additional_map_ptr-&gt;points[i].y;
    cloud_rgb.points[i].z = transformed_additional_map_ptr-&gt;points[i].z;
    cloud_rgb.points[i].rgb = 255 &lt;&lt; 16 | 255 &lt;&lt; 8 | 255;
  }

  pcl::io::savePCDFileBinary(output_rgb, cloud_rgb);
  std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; output_rgb &lt;&lt; &quot;: &quot; &lt;&lt;  cloud_rgb.points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Sequence number: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of scan points: &quot; &lt;&lt; additional_map_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of filtered scan points: &quot; &lt;&lt; filtered_additional_map_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; ndt.hasConverged() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Fitness score: &quot; &lt;&lt; ndt.getFitnessScore() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of iteration: &quot; &lt;&lt; ndt.getFinalNumIteration() &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Transformation Matrix:&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; t &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
}

static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (hasMapSet == false) {
    pcl::fromROSMsg(*input, map);

    pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));

    ndt.setResolution(ndt_res);
    ndt.setInputTarget(map_ptr);

    hasMapSet = true;
    std::cout &lt;&lt; &quot;Points Map: &quot; &lt;&lt; map_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  }
}

int main(int argc, char **argv)
{
    if(argc != 2){
      std::cout &lt;&lt; &quot;Usage: rosrun map_tools map_extender \&quot;input\&quot;&quot; &lt;&lt; std::endl;
      exit(1);
    }

    ros::init(argc, argv, &quot;map_extender&quot;);
    ros::NodeHandle n;

    input_pcd = argv[1];

    if(pcl::io::loadPCDFile&lt;pcl::PointXYZI&gt; (input_pcd, *additional_map_ptr) == -1){
      std::cout &lt;&lt; &quot;Couldn't read &quot; &lt;&lt; input_pcd &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      return(-1);
    }
    std::cout &lt;&lt; input_pcd &lt;&lt; &quot;: &quot; &lt;&lt; additional_map_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;

    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
    voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
    voxel_grid_filter.setInputCloud(additional_map_ptr);
    voxel_grid_filter.filter(*filtered_additional_map_ptr);

    ndt.setInputSource(filtered_additional_map_ptr);
    ndt.setMaximumIterations(iter);
    ndt.setStepSize(step_size);
    ndt.setTransformationEpsilon(trans_eps);

    ndt_map_pub = n.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/extended_map&quot;, 10, true);

    ros::Subscriber map_sub = n.subscribe(&quot;points_map&quot;, 10, map_callback);
    ros::Subscriber initialpose_sub = n.subscribe(&quot;initialpose&quot;, 10, initialpose_callback);

    ros::spin();

    return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="c8da6ef868845f5af8b6609cf9fd46a8b77254df" fix_time="0,0">
		<msg>Added Compilation fix for Kinect</msg>
		<modified_files>
			<file old_path="ros/src/sensing/filters/packages/points_preprocessor/nodes/ray_ground_filter/ray_ground_filter.cpp" new_path="ros/src/sensing/filters/packages/points_preprocessor/nodes/ray_ground_filter/ray_ground_filter.cpp">
				<diff>@@ -42,6 +42,8 @@
 #include &lt;pcl/filters/extract_indices.h&gt;
 #include &lt;velodyne_pointcloud/point_types.h&gt;
 #include &quot;autoware_msgs/ConfigRayGroundFilter.h&quot;
+
+#include &lt;opencv2/core/version.hpp&gt;
 #if (CV_MAJOR_VERSION == 3)
 	#include &quot;gencolors.cpp&quot;
 #else
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ********************
 *  v1.0: amc-nu (abrahammonrroy@yahoo.com)
*/
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl/features/normal_3d.h&gt;
#include &lt;pcl/features/normal_3d_omp.h&gt;
#include &lt;pcl/filters/extract_indices.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &quot;autoware_msgs/ConfigRayGroundFilter.h&quot;
#if (CV_MAJOR_VERSION == 3)
	#include &quot;gencolors.cpp&quot;
#else
	#include &lt;opencv2/contrib/contrib.hpp&gt;
#endif


class RayGroundFilter
{
private:

	ros::NodeHandle     node_handle_;
	ros::Subscriber     points_node_sub_;
	ros::Subscriber     config_node_sub_;
	ros::Publisher      groundless_points_pub_;
	ros::Publisher      ground_points_pub_;

	std::string         input_point_topic_;

	double              sensor_height_;//meters
	double              general_max_slope_;//degrees
	double              local_max_slope_;//degrees
	double              radial_divider_angle_;//distance in rads between dividers
	double              concentric_divider_distance_;//distance in meters between concentric divisions
	double              min_height_threshold_;//minimum height threshold regardless the slope, useful for close points
	double              clipping_height_; //the points higher than this will be removed from the input cloud.
	double              min_point_distance_;//minimum distance from the origin to consider a point as valid
	double              reclass_distance_threshold_;//distance between points at which re classification will occur

	size_t              radial_dividers_num_;
	size_t              concentric_dividers_num_;

	std::vector&lt;cv::Scalar&gt; colors_;
	const size_t        color_num_ = 60;//different number of color to generate

	struct PointXYZIRTColor
	{
		pcl::PointXYZI point;

		float radius;       //cylindric coords on XY Plane
		float theta;        //angle deg on XY plane

		size_t radial_div;  //index of the radial divsion to which this point belongs to
		size_t concentric_div;//index of the concentric division to which this points belongs to

		size_t red;         //Red component  [0-255]
		size_t green;       //Green Component[0-255]
		size_t blue;        //Blue component [0-255]

		size_t original_index; //index of this point in the source pointcloud
	};
	typedef std::vector&lt;PointXYZIRTColor&gt; PointCloudXYZIRTColor;

	void update_config_params(const autoware_msgs::ConfigRayGroundFilter::ConstPtr&amp; param)
	{
		sensor_height_          = param-&gt;sensor_height;
		general_max_slope_      = param-&gt;general_max_slope;
		local_max_slope_        = param-&gt;local_max_slope;
		radial_divider_angle_   = param-&gt;radial_divider_angle;
		concentric_divider_distance_ = param-&gt;concentric_divider_distance;
		min_height_threshold_   = param-&gt;min_height_threshold;
		clipping_height_        = param-&gt;clipping_height;
		min_point_distance_     = param-&gt;min_point_distance;
		reclass_distance_threshold_ = param-&gt;reclass_distance_threshold;
	}

	void publish_cloud(const ros::Publisher&amp; in_publisher,
	                         const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_to_publish_ptr,
	                         const std_msgs::Header&amp; in_header)
	{
		sensor_msgs::PointCloud2 cloud_msg;
		pcl::toROSMsg(*in_cloud_to_publish_ptr, cloud_msg);
		cloud_msg.header = in_header;
		in_publisher.publish(cloud_msg);
	}

	/*!
	 *
	 * @param[in] in_cloud Input Point Cloud to be organized in radial segments
	 * @param[out] out_organized_points Custom Point Cloud filled with XYZRTZColor data
	 * @param[out] out_radial_divided_indices Indices of the points in the original cloud for each radial segment
	 * @param[out] out_radial_ordered_clouds Vector of Points Clouds, each element will contain the points ordered
	 */
	void ConvertXYZIToRTZColor(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud,
	                           PointCloudXYZIRTColor&amp; out_organized_points,
	                           std::vector&lt;pcl::PointIndices&gt;&amp; out_radial_divided_indices,
	                           std::vector&lt;PointCloudXYZIRTColor&gt;&amp; out_radial_ordered_clouds)
	{
		out_organized_points.resize(in_cloud-&gt;points.size());
		out_radial_divided_indices.clear();
		out_radial_divided_indices.resize(radial_dividers_num_);
		out_radial_ordered_clouds.resize(radial_dividers_num_);

		for(size_t i=0; i&lt; in_cloud-&gt;points.size(); i++)
		{
			PointXYZIRTColor new_point;
			auto radius         = (float) sqrt(
								 in_cloud-&gt;points[i].x*in_cloud-&gt;points[i].x
								+ in_cloud-&gt;points[i].y*in_cloud-&gt;points[i].y
								);
			auto theta          = (float) atan2(in_cloud-&gt;points[i].y, in_cloud-&gt;points[i].x) * 180 / M_PI;
			if (theta &lt; 0){ theta+=360; }

			auto radial_div     = (size_t) floor(theta/radial_divider_angle_);
			auto concentric_div = (size_t) floor(fabs(radius/concentric_divider_distance_));

			new_point.point    = in_cloud-&gt;points[i];
			new_point.radius   = radius;
			new_point.theta    = theta;
			new_point.radial_div = radial_div;
			new_point.concentric_div = concentric_div;
			new_point.red      = (size_t) colors_[new_point.radial_div % color_num_].val[0];
			new_point.green    = (size_t) colors_[new_point.radial_div % color_num_].val[1];
			new_point.blue     = (size_t) colors_[new_point.radial_div % color_num_].val[2];
			new_point.original_index = i;

			out_organized_points[i] = new_point;

			//radial divisions
			out_radial_divided_indices[radial_div].indices.push_back(i);

			out_radial_ordered_clouds[radial_div].push_back(new_point);

		}//end for

		//order radial points on each division
		#pragma omp for
		for(size_t i=0; i&lt; radial_dividers_num_; i++)
		{
			std::sort(out_radial_ordered_clouds[i].begin(), out_radial_ordered_clouds[i].end(),
			          [](const PointXYZIRTColor&amp; a, const PointXYZIRTColor&amp; b){ return a.radius &lt; b.radius; });
		}
	}

	/*!
	 * Classifies Points in the PointCoud as Ground and Not Ground
	 * @param in_radial_ordered_clouds Vector of an Ordered PointsCloud ordered by radial distance from the origin
	 * @param out_ground_indices Returns the indices of the points classified as ground in the original PointCloud
	 * @param out_no_ground_indices Returns the indices of the points classified as not ground in the original PointCloud
	 */
	void ClassifyPointCloud(std::vector&lt;PointCloudXYZIRTColor&gt;&amp; in_radial_ordered_clouds,
	                        pcl::PointIndices&amp; out_ground_indices,
	                        pcl::PointIndices&amp; out_no_ground_indices)
	{
		out_ground_indices.indices.clear();
		out_no_ground_indices.indices.clear();
		#pragma omp for
		for (size_t i=0; i &lt; in_radial_ordered_clouds.size(); i++)//sweep through each radial division
		{
			float prev_radius = 0.f;
			float prev_height = - sensor_height_;
			bool prev_ground = false;
			bool current_ground = false;
			for (size_t j=0; j &lt; in_radial_ordered_clouds[i].size(); j++)//loop through each point in the radial div
			{
				float points_distance = in_radial_ordered_clouds[i][j].radius - prev_radius;
				float height_threshold = tan(DEG2RAD(local_max_slope_)) * points_distance;
				float current_height = in_radial_ordered_clouds[i][j].point.z;
				float general_height_threshold = tan(DEG2RAD(general_max_slope_)) * in_radial_ordered_clouds[i][j].radius;

				//for points which are very close causing the height threshold to be tiny, set a minimum value
				if (points_distance &gt; concentric_divider_distance_ &amp;&amp; height_threshold &lt; min_height_threshold_)
					{ height_threshold = min_height_threshold_; }

				//check current point height against the LOCAL threshold (previous point)
				if (current_height &lt;= (prev_height + height_threshold)
				    &amp;&amp; current_height &gt;= (prev_height - height_threshold)
					)
				{
					//Check again using general geometry (radius from origin) if previous points wasn't ground
					if (!prev_ground)
					{
						if(current_height &lt;= (-sensor_height_ + general_height_threshold)
						   &amp;&amp; current_height &gt;= (-sensor_height_ - general_height_threshold))
						{
							current_ground = true;
						}
						else
							{current_ground = false;}
					}
					else
					{
						current_ground = true;
					}
				}
				else
				{
					//check if previous point is too far from previous one, if so classify again
					if (points_distance &gt; reclass_distance_threshold_ &amp;&amp;
							(current_height &lt;= (-sensor_height_ + height_threshold)
							 &amp;&amp; current_height &gt;= (-sensor_height_ - height_threshold))
						)
					{
						current_ground = true;
					}
					else
						{current_ground = false;}
				}

				if (current_ground)
				{
					out_ground_indices.indices.push_back(in_radial_ordered_clouds[i][j].original_index);
					prev_ground=true;
				}
				else
				{
					out_no_ground_indices.indices.push_back(in_radial_ordered_clouds[i][j].original_index);
					prev_ground = false;
				}

				prev_radius = in_radial_ordered_clouds[i][j].radius;
				prev_height = in_radial_ordered_clouds[i][j].point.z;
			}
		}
	}

	/*!
	 * Removes the points higher than a threshold
	 * @param in_cloud_ptr PointCloud to perform Clipping
	 * @param in_clip_height Maximum allowed height in the cloud
	 * @param out_clipped_cloud_ptr Resultung PointCloud with the points removed
	 */
	void ClipCloud(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
	               double in_clip_height,
	               pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_clipped_cloud_ptr)
	{
		pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extractor;
		extractor.setInputCloud (in_cloud_ptr);
		pcl::PointIndices indices;

		#pragma omp for
		for (size_t i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
		{
			if (in_cloud_ptr-&gt;points[i].z &gt; in_clip_height)
			{
				indices.indices.push_back(i);
			}
		}
		extractor.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(indices));
		extractor.setNegative(true);//true removes the indices, false leaves only the indices
		extractor.filter(*out_clipped_cloud_ptr);
	}

	/*!
	 * Returns the resulting complementary PointCloud, one with the points kept and the other removed as indicated
	 * in the indices
	 * @param in_cloud_ptr Input PointCloud to which the extraction will be performed
	 * @param in_indices Indices of the points to be both removed and kept
	 * @param out_only_indices_cloud_ptr Resulting PointCloud with the indices kept
	 * @param out_removed_indices_cloud_ptr Resulting PointCloud with the indices removed
	 */
	void ExtractPointsIndices(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
	                          const pcl::PointIndices&amp; in_indices,
	                          pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_only_indices_cloud_ptr,
	                          pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_removed_indices_cloud_ptr)
	{
		pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extract_ground;
		extract_ground.setInputCloud (in_cloud_ptr);
		extract_ground.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(in_indices));

		extract_ground.setNegative(false);//true removes the indices, false leaves only the indices
		extract_ground.filter(*out_only_indices_cloud_ptr);

		extract_ground.setNegative(true);//true removes the indices, false leaves only the indices
		extract_ground.filter(*out_removed_indices_cloud_ptr);
	}

	/*!
	 * Removes points up to a certain distance in the XY Plane
	 * @param in_cloud_ptr Input PointCloud
	 * @param in_min_distance Minimum valid distance, points closer than this will be removed.
	 * @param out_filtered_cloud_ptr Resulting PointCloud with the invalid points removed.
	 */
	void RemovePointsUpTo(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr in_cloud_ptr,
	                      double in_min_distance,
	                      pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr out_filtered_cloud_ptr)
	{
		pcl::ExtractIndices&lt;pcl::PointXYZI&gt; extractor;
		extractor.setInputCloud (in_cloud_ptr);
		pcl::PointIndices indices;

		#pragma omp for
		for (size_t i=0; i&lt; in_cloud_ptr-&gt;points.size(); i++)
		{
			if (sqrt(in_cloud_ptr-&gt;points[i].x*in_cloud_ptr-&gt;points[i].x +
			         in_cloud_ptr-&gt;points[i].y*in_cloud_ptr-&gt;points[i].y)
			            &lt; in_min_distance)
			{
				indices.indices.push_back(i);
			}
		}
		extractor.setIndices(boost::make_shared&lt;pcl::PointIndices&gt;(indices));
		extractor.setNegative(true);//true removes the indices, false leaves only the indices
		extractor.filter(*out_filtered_cloud_ptr);
	}

	void CloudCallback(const sensor_msgs::PointCloud2ConstPtr &amp;in_sensor_cloud)
	{
		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr current_sensor_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
		pcl::fromROSMsg(*in_sensor_cloud, *current_sensor_cloud_ptr);

		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr clipped_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);

		//remove points above certain point
		ClipCloud(current_sensor_cloud_ptr, clipping_height_, clipped_cloud_ptr);

		//remove closer points than a threshold
		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
		RemovePointsUpTo(clipped_cloud_ptr, min_point_distance_,filtered_cloud_ptr);

		//GetCloud Normals
		//pcl::PointCloud&lt;pcl::PointXYZINormal&gt;::Ptr cloud_with_normals_ptr (new pcl::PointCloud&lt;pcl::PointXYZINormal&gt;);
		//GetCloudNormals(current_sensor_cloud_ptr, cloud_with_normals_ptr, 5.0);

		PointCloudXYZIRTColor organized_points;
		std::vector&lt;pcl::PointIndices&gt; radial_division_indices;
		std::vector&lt;pcl::PointIndices&gt; closest_indices;
		std::vector&lt;PointCloudXYZIRTColor&gt; radial_ordered_clouds;

		radial_dividers_num_ = ceil(360 / radial_divider_angle_);

		ConvertXYZIToRTZColor(filtered_cloud_ptr,
		                      organized_points,
		                      radial_division_indices,
		                      radial_ordered_clouds);

		pcl::PointIndices ground_indices, no_ground_indices;

		ClassifyPointCloud(radial_ordered_clouds, ground_indices, no_ground_indices);

		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr ground_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
		pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr no_ground_cloud_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);

		ExtractPointsIndices(filtered_cloud_ptr, ground_indices, ground_cloud_ptr, no_ground_cloud_ptr);

		publish_cloud(ground_points_pub_, ground_cloud_ptr, in_sensor_cloud-&gt;header);
		publish_cloud(groundless_points_pub_, no_ground_cloud_ptr, in_sensor_cloud-&gt;header);

	}

public:
	RayGroundFilter():node_handle_(&quot;~&quot;)
	{
	}
	void Run()
	{
		//Model   |   Horizontal   |   Vertical   | FOV(Vertical)    degrees / rads
		//----------------------------------------------------------
		//HDL-64  |0.08-0.35(0.32) |     0.4      |  -24.9 &lt;=x&lt;=2.0   (26.9  / 0.47)
		//HDL-32  |     0.1-0.4    |     1.33     |  -30.67&lt;=x&lt;=10.67 (41.33 / 0.72)
		//VLP-16  |     0.1-0.4    |     2.0      |  -15.0&lt;=x&lt;=15.0   (30    / 0.52)
		//VLP-16HD|     0.1-0.4    |     1.33     |  -10.0&lt;=x&lt;=10.0   (20    / 0.35)
		ROS_INFO(&quot;Initializing Ground Filter, please wait...&quot;);
		node_handle_.param&lt;std::string&gt;(&quot;input_point_topic&quot;, input_point_topic_, &quot;/points_raw&quot;);
		ROS_INFO(&quot;Input point_topic: %s&quot;, input_point_topic_.c_str());

		node_handle_.param(&quot;sensor_height&quot;, sensor_height_, 1.7);
		ROS_INFO(&quot;sensor_height[meters]: %f&quot;, sensor_height_);

		node_handle_.param(&quot;general_max_slope&quot;, general_max_slope_, 3.0);
		ROS_INFO(&quot;general_max_slope[deg]: %f&quot;, general_max_slope_);

		node_handle_.param(&quot;local_max_slope&quot;, local_max_slope_, 5.0);
		ROS_INFO(&quot;local_max_slope[deg]: %f&quot;, local_max_slope_);

		node_handle_.param(&quot;radial_divider_angle&quot;, radial_divider_angle_, 0.1); //1 degree default
		ROS_INFO(&quot;radial_divider_angle[deg]: %f&quot;, radial_divider_angle_);
		node_handle_.param(&quot;concentric_divider_distance&quot;, concentric_divider_distance_, 0.01);//0.1 meters default
		ROS_INFO(&quot;concentric_divider_distance[meters]: %f&quot;, concentric_divider_distance_);
		node_handle_.param(&quot;min_height_threshold&quot;, min_height_threshold_, 0.05);//0.05 meters default
		ROS_INFO(&quot;min_height_threshold[meters]: %f&quot;, min_height_threshold_);
		node_handle_.param(&quot;clipping_height&quot;, clipping_height_, 0.2);//0.2 meters default above the car
		ROS_INFO(&quot;clipping_height[meters]: %f&quot;, clipping_height_);
		node_handle_.param(&quot;min_point_distance&quot;, min_point_distance_, 1.85);//1.85 meters default
		ROS_INFO(&quot;min_point_distance[meters]: %f&quot;, min_point_distance_);
		node_handle_.param(&quot;reclass_distance_threshold&quot;, reclass_distance_threshold_, 0.2);//0.5 meters default
		ROS_INFO(&quot;reclass_distance_threshold[meters]: %f&quot;, reclass_distance_threshold_);


#if (CV_MAJOR_VERSION == 3)
		generateColors(colors_, color_num_);
#else
		cv::generateColors(colors_, color_num_);
#endif

		radial_dividers_num_ = ceil(360 / radial_divider_angle_);
		ROS_INFO(&quot;Radial Divisions: %d&quot;, (int)radial_dividers_num_);

		std::string no_ground_topic, ground_topic;
		node_handle_.param&lt;std::string&gt;(&quot;no_ground_point_topic&quot;, no_ground_topic, &quot;/points_no_ground&quot;);
		ROS_INFO(&quot;No Ground Output Point Cloud no_ground_point_topic: %s&quot;, no_ground_topic.c_str());
		node_handle_.param&lt;std::string&gt;(&quot;ground_point_topic&quot;, ground_topic, &quot;/points_ground&quot;);
		ROS_INFO(&quot;Only Ground Output Point Cloud ground_topic: %s&quot;, ground_topic.c_str());

		ROS_INFO(&quot;Subscribing to... %s&quot;, input_point_topic_.c_str());
		points_node_sub_ = node_handle_.subscribe(input_point_topic_, 1, &amp;RayGroundFilter::CloudCallback, this);

		config_node_sub_ = node_handle_.subscribe(&quot;/config/ray_ground_filter&quot;, 1, &amp;RayGroundFilter::update_config_params, this);

		groundless_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(no_ground_topic, 2);
		ground_points_pub_ = node_handle_.advertise&lt;sensor_msgs::PointCloud2&gt;(ground_topic, 2);

		ROS_INFO(&quot;Ready&quot;);

		ros::spin();

	}

};

int main(int argc, char **argv)
{
	ros::init(argc, argv, &quot;ray_ground_filter&quot;);
	RayGroundFilter app;

	app.Run();

	return 0;

}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="32c60d5ddf7d8a0090aa915831f1f1bbdfa43cc7" fix_time="0,0">
		<msg>fix path of runtime manager for web</msg>
		<modified_files>
			<file old_path="ui/web/app/views/index.html" new_path="ui/web/runtime_manager/app/views/index.html">
				<diff></diff>
				<old_file></old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="d067f668cc26820420c508923ec99a2226093a23" fix_time="650,72412">
		<msg>fix calculation of ndt_pose from localizer_pose</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp">
				<diff>@@ -190,7 +190,7 @@ static autoware_msgs::ndt_stat ndt_stat_msg;
 static double predict_pose_error = 0.0;
 
 static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
-static Eigen::Matrix4f tf_btol, tf_ltob;
+static Eigen::Matrix4f tf_btol;
 
 static std::string _localizer = &quot;velodyne&quot;;
 static std::string _offset = &quot;linear&quot;;  // linear, zero, quadratic
@@ -805,7 +805,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 
 
     t = ndt.getFinalTransformation();  // localizer
-    t2 = t * tf_ltob;                  // base_link
+    t2 = t * tf_btol.inverse();                  // base_link
 
     iteration = ndt.getFinalNumIteration();
 #ifdef USE_FAST_PCL
@@ -1336,12 +1336,6 @@ int main(int argc, char** argv)
   Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
   tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();
 
-  Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
-  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
-  Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
-  Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
-  tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();
-
   // Updated in initialpose_callback or gnss_callback
   initial_pose.x = 0.0;
   initial_pose.y = 0.0;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;
#include &lt;chrono&gt;

#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;

#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;tf/transform_listener.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#ifdef USE_FAST_PCL
#include &lt;fast_pcl/registration/ndt.h&gt;
#else
#include &lt;pcl/registration/ndt.h&gt;
#endif

#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_ros/transforms.h&gt;

#include &lt;autoware_msgs/ConfigNdt.h&gt;

#include &lt;autoware_msgs/ndt_stat.h&gt;

#define PREDICT_POSE_THRESHOLD 0.5

#define Wa 0.4
#define Wb 0.3
#define Wc 0.3

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose, ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose, previous_gnss_pose,
    current_gnss_pose;

static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw; 
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch, offset_imu_odom_yaw;

// Can't load if typed &quot;pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;&quot;
static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;

// If the map is loaded, map_loaded will be 1.
static int map_loaded = 0;
static int _use_gnss = 1;
static int init_pos_set = 0;

static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
// Default values
static int max_iter = 30;        // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

static ros::Publisher predict_pose_pub;
static geometry_msgs::PoseStamped predict_pose_msg;

static ros::Publisher predict_pose_imu_pub;
static geometry_msgs::PoseStamped predict_pose_imu_msg;

static ros::Publisher predict_pose_odom_pub;
static geometry_msgs::PoseStamped predict_pose_odom_msg;

static ros::Publisher predict_pose_imu_odom_pub;
static geometry_msgs::PoseStamped predict_pose_imu_odom_msg;

static ros::Publisher ndt_pose_pub;
static geometry_msgs::PoseStamped ndt_pose_msg;

// current_pose is published by vel_pose_mux
/*
static ros::Publisher current_pose_pub;
static geometry_msgs::PoseStamped current_pose_msg;
*/

static ros::Publisher localizer_pose_pub;
static geometry_msgs::PoseStamped localizer_pose_msg;

static ros::Publisher estimate_twist_pub;
static geometry_msgs::TwistStamped estimate_twist_msg;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double exe_time = 0.0;
static int iteration = 0;
static double fitness_score = 0.0;
static double trans_probability = 0.0;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;

static double current_velocity = 0.0, previous_velocity = 0.0, previous_previous_velocity = 0.0;  // [m/s]
static double current_velocity_x = 0.0, previous_velocity_x = 0.0;
static double current_velocity_y = 0.0, previous_velocity_y = 0.0;
static double current_velocity_z = 0.0, previous_velocity_z = 0.0;
// static double current_velocity_yaw = 0.0, previous_velocity_yaw = 0.0;
static double current_velocity_smooth = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static double current_accel = 0.0, previous_accel = 0.0;  // [m/s^2]
static double current_accel_x = 0.0;
static double current_accel_y = 0.0;
static double current_accel_z = 0.0;
// static double current_accel_yaw = 0.0;

static double angular_velocity = 0.0;

static int use_predict_pose = 0;

static ros::Publisher estimated_vel_mps_pub, estimated_vel_kmph_pub, estimated_vel_pub;
static std_msgs::Float32 estimated_vel_mps, estimated_vel_kmph, previous_estimated_vel_kmph;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; matching_start, matching_end;

static ros::Publisher time_ndt_matching_pub;
static std_msgs::Float32 time_ndt_matching;

static int _queue_size = 1000;

static ros::Publisher ndt_stat_pub;
static autoware_msgs::ndt_stat ndt_stat_msg;

static double predict_pose_error = 0.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol, tf_ltob;

static std::string _localizer = &quot;velodyne&quot;;
static std::string _offset = &quot;linear&quot;;  // linear, zero, quadratic

static ros::Publisher ndt_reliability_pub;
static std_msgs::Float32 ndt_reliability;

static bool _use_openmp = false;
static bool _get_height = false;
static bool _use_local_transform = false;
static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;

static std::ofstream ofs;
static std::string filename;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;


// static tf::TransformListener local_transform_listener;
static tf::StampedTransform local_transform;

static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
{
  if (_use_gnss != input-&gt;init_pos_gnss)
  {
    init_pos_set = 0;
  }
  else if (_use_gnss == 0 &amp;&amp;
           (initial_pose.x != input-&gt;x || initial_pose.y != input-&gt;y || initial_pose.z != input-&gt;z ||
            initial_pose.roll != input-&gt;roll || initial_pose.pitch != input-&gt;pitch || initial_pose.yaw != input-&gt;yaw))
  {
    init_pos_set = 0;
  }

  _use_gnss = input-&gt;init_pos_gnss;

  // Setting parameters
  if (input-&gt;resolution != ndt_res)
  {
    ndt_res = input-&gt;resolution;
    ndt.setResolution(ndt_res);
  }
  if (input-&gt;step_size != step_size)
  {
    step_size = input-&gt;step_size;
    ndt.setStepSize(step_size);
  }
  if (input-&gt;trans_epsilon != trans_eps)
  {
    trans_eps = input-&gt;trans_epsilon;
    ndt.setTransformationEpsilon(trans_eps);
  }
  if (input-&gt;max_iterations != max_iter)
  {
    max_iter = input-&gt;max_iterations;
    ndt.setMaximumIterations(max_iter);
  }

  if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
  {
    initial_pose.x = input-&gt;x;
    initial_pose.y = input-&gt;y;
    initial_pose.z = input-&gt;z;
    initial_pose.roll = input-&gt;roll;
    initial_pose.pitch = input-&gt;pitch;
    initial_pose.yaw = input-&gt;yaw;

    if (_use_local_transform == true)
    {
      tf::Vector3 v(input-&gt;x, input-&gt;y, input-&gt;z);
      tf::Quaternion q;
      q.setRPY(input-&gt;roll, input-&gt;pitch, input-&gt;yaw);
      tf::Transform transform(q, v);
      initial_pose.x = (local_transform.inverse() * transform).getOrigin().getX();
      initial_pose.y = (local_transform.inverse() * transform).getOrigin().getY();
      initial_pose.z = (local_transform.inverse() * transform).getOrigin().getZ();

      tf::Matrix3x3 m(q);
      m.getRPY(initial_pose.roll, initial_pose.pitch, initial_pose.yaw);

      std::cout &lt;&lt; &quot;initial_pose.x: &quot; &lt;&lt; initial_pose.x &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.y: &quot; &lt;&lt; initial_pose.y &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.z: &quot; &lt;&lt; initial_pose.z &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.roll: &quot; &lt;&lt; initial_pose.roll &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.pitch: &quot; &lt;&lt; initial_pose.pitch &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.yaw: &quot; &lt;&lt; initial_pose.yaw &lt;&lt; std::endl;
    }

    // Setting position and posture for the first time.
    localizer_pose.x = initial_pose.x;
    localizer_pose.y = initial_pose.y;
    localizer_pose.z = initial_pose.z;
    localizer_pose.roll = initial_pose.roll;
    localizer_pose.pitch = initial_pose.pitch;
    localizer_pose.yaw = initial_pose.yaw;

    previous_pose.x = initial_pose.x;
    previous_pose.y = initial_pose.y;
    previous_pose.z = initial_pose.z;
    previous_pose.roll = initial_pose.roll;
    previous_pose.pitch = initial_pose.pitch;
    previous_pose.yaw = initial_pose.yaw;

    current_pose.x = initial_pose.x;
    current_pose.y = initial_pose.y;
    current_pose.z = initial_pose.z;
    current_pose.roll = initial_pose.roll;
    current_pose.pitch = initial_pose.pitch;
    current_pose.yaw = initial_pose.yaw;

    current_velocity = 0;
    current_velocity_x = 0;
    current_velocity_y = 0;
    current_velocity_z = 0;
    angular_velocity = 0;

    current_pose_imu.x = 0;
    current_pose_imu.y = 0;
    current_pose_imu.z = 0;
    current_pose_imu.roll = 0;
    current_pose_imu.pitch = 0;
    current_pose_imu.yaw = 0;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;
    init_pos_set = 1;
  }
}

static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 0)
  {
    // Convert the data type(from sensor_msgs to pcl).
    pcl::fromROSMsg(*input, map);

    if (_use_local_transform == true)
    {
      tf::TransformListener local_transform_listener;
      try
      {
        ros::Time now = ros::Time(0);
        local_transform_listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
        local_transform_listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, local_transform);
      }
      catch (tf::TransformException&amp; ex)
      {
        ROS_ERROR(&quot;%s&quot;, ex.what());
      }

      pcl_ros::transformPointCloud(map, map, local_transform.inverse());
    }

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
    // Setting point cloud to be aligned to.
    ndt.setInputTarget(map_ptr);

    // Setting NDT parameters to default values
    ndt.setMaximumIterations(max_iter);
    ndt.setResolution(ndt_res);
    ndt.setStepSize(step_size);
    ndt.setTransformationEpsilon(trans_eps);

    map_loaded = 1;
  }
}

static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
{
  tf::Quaternion gnss_q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z,
                        input-&gt;pose.orientation.w);
  tf::Matrix3x3 gnss_m(gnss_q);
  current_gnss_pose.x = input-&gt;pose.position.x;
  current_gnss_pose.y = input-&gt;pose.position.y;
  current_gnss_pose.z = input-&gt;pose.position.z;
  gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);

  if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= 500.0)
  {
    previous_pose.x = previous_gnss_pose.x;
    previous_pose.y = previous_gnss_pose.y;
    previous_pose.z = previous_gnss_pose.z;
    previous_pose.roll = previous_gnss_pose.roll;
    previous_pose.pitch = previous_gnss_pose.pitch;
    previous_pose.yaw = previous_gnss_pose.yaw;

    current_pose.x = current_gnss_pose.x;
    current_pose.y = current_gnss_pose.y;
    current_pose.z = current_gnss_pose.z;
    current_pose.roll = current_gnss_pose.roll;
    current_pose.pitch = current_gnss_pose.pitch;
    current_pose.yaw = current_gnss_pose.yaw;

    current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;

    offset_x = current_pose.x - previous_pose.x;
    offset_y = current_pose.y - previous_pose.y;
    offset_z = current_pose.z - previous_pose.z;
    offset_yaw = current_pose.yaw - previous_pose.yaw;

    init_pos_set = 1;
  }

  previous_gnss_pose.x = current_gnss_pose.x;
  previous_gnss_pose.y = current_gnss_pose.y;
  previous_gnss_pose.z = current_gnss_pose.z;
  previous_gnss_pose.roll = current_gnss_pose.roll;
  previous_gnss_pose.pitch = current_gnss_pose.pitch;
  previous_gnss_pose.yaw = current_gnss_pose.yaw;
}

static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
{
  tf::TransformListener listener;
  tf::StampedTransform transform;
  try
  {
    ros::Time now = ros::Time(0);
    listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
    listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, transform);
  }
  catch (tf::TransformException&amp; ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
  }

  tf::Quaternion q(input-&gt;pose.pose.orientation.x, input-&gt;pose.pose.orientation.y, input-&gt;pose.pose.orientation.z,
                   input-&gt;pose.pose.orientation.w);
  tf::Matrix3x3 m(q);

  if (_use_local_transform == true)
  {
    current_pose.x = input-&gt;pose.pose.position.x;
    current_pose.y = input-&gt;pose.pose.position.y;
    current_pose.z = input-&gt;pose.pose.position.z;
  }
  else
  {
    current_pose.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
    current_pose.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
    current_pose.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
  }
  m.getRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);

  if (_get_height == true &amp;&amp; map_loaded == 1)
  {
    double min_distance = DBL_MAX;
    double nearest_z = current_pose.z;
    for (const auto&amp; p : map)
    {
      double distance = hypot(current_pose.x - p.x, current_pose.y - p.y);
      if (distance &lt; min_distance)
      {
        min_distance = distance;
        nearest_z = p.z;
      }
    }
    current_pose.z = nearest_z;
  }
  
  current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  offset_x = 0.0;
  offset_y = 0.0;
  offset_z = 0.0;
  offset_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;

}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll  += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw   += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance*cos(-current_pose_imu_odom.pitch)*cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance*cos(-current_pose_imu_odom.pitch)*sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance*sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll  += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw   += diff_imu_yaw;

  predict_pose_imu_odom.x     = previous_pose.x     + offset_imu_odom_x;
  predict_pose_imu_odom.y     = previous_pose.y     + offset_imu_odom_y;
  predict_pose_imu_odom.z     = previous_pose.z     + offset_imu_odom_z;
  predict_pose_imu_odom.roll  = previous_pose.roll  + offset_imu_odom_roll;
  predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  predict_pose_imu_odom.yaw   = previous_pose.yaw   + offset_imu_odom_yaw;
 
  previous_time = current_time;
}


static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll  = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw   = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll  += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw   += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance*cos(-current_pose_odom.pitch)*cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance*cos(-current_pose_odom.pitch)*sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance*sin(-current_pose_odom.pitch);

  offset_odom_roll  += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw   += diff_odom_yaw;

  predict_pose_odom.x     = previous_pose.x     + offset_odom_x;
  predict_pose_odom.y     = previous_pose.y     + offset_odom_y;
  predict_pose_odom.z     = previous_pose.z     + offset_odom_z;
  predict_pose_odom.roll  = previous_pose.roll  + offset_odom_roll;
  predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  predict_pose_odom.yaw   = previous_pose.yaw   + offset_odom_yaw;
 
  previous_time = current_time;

}

static void imu_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll  = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw   = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y
                -std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y
                +std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll  += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw   += diff_imu_yaw;

  predict_pose_imu.x     = previous_pose.x     + offset_imu_x;
  predict_pose_imu.y     = previous_pose.y     + offset_imu_y;
  predict_pose_imu.z     = previous_pose.z     + offset_imu_z;
  predict_pose_imu.roll  = previous_pose.roll  + offset_imu_roll;
  predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  predict_pose_imu.yaw   = previous_pose.yaw   + offset_imu_yaw;  

  previous_time = current_time;
}


static const double wrapToPm(double a_num, const double a_max)
{
    if (a_num &gt;= a_max)
    {
        a_num -= 2.0 * a_max;
    }
    return a_num;
}

static const double wrapToPmPi(double a_angle_rad)
{
    return wrapToPm(a_angle_rad, M_PI);
}


static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}

static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll  *= -1;
  input_pitch *= -1;
  input_yaw   *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}

static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  //std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if(_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time =  (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll  = imu_roll  - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if(fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if(imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI*2;
    else
      diff_imu_yaw = -M_PI*2 - (imu_yaw - previous_imu_yaw);
  }
  else
  diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  //imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  //imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if(diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll  / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw   / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll  = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw   = imu_yaw;
}

static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
  {
    matching_start = std::chrono::system_clock::now();

    static tf::TransformBroadcaster br;
    tf::Transform transform;
    tf::Quaternion predict_q, ndt_q, current_q, localizer_q;

    pcl::PointXYZ p;
    pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;

    current_scan_time = input-&gt;header.stamp;

    pcl::fromROSMsg(*input, filtered_scan);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan));
    int scan_points_num = filtered_scan_ptr-&gt;size();

    Eigen::Matrix4f t(Eigen::Matrix4f::Identity());   // base_link
    Eigen::Matrix4f t2(Eigen::Matrix4f::Identity());  // localizer

    std::chrono::time_point&lt;std::chrono::system_clock&gt; align_start, align_end, getFitnessScore_start,
        getFitnessScore_end;
    static double align_time, getFitnessScore_time = 0.0;

    // Setting point cloud to be aligned.
    ndt.setInputSource(filtered_scan_ptr);

    // Guess the initial gross estimation of the transformation
    predict_pose.x = previous_pose.x + offset_x;
    predict_pose.y = previous_pose.y + offset_y;
    predict_pose.z = previous_pose.z + offset_z;
    predict_pose.roll = previous_pose.roll;
    predict_pose.pitch = previous_pose.pitch;
    predict_pose.yaw = previous_pose.yaw + offset_yaw;


    if (_use_imu == true &amp;&amp; _use_odom == true)
      imu_odom_calc(current_scan_time);
    if (_use_imu == true &amp;&amp; _use_odom == false)
      imu_calc(current_scan_time);
    if (_use_imu == false &amp;&amp; _use_odom == true)
      odom_calc(current_scan_time);
    
    pose predict_pose_for_ndt;
    if (_use_imu == true &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_imu_odom;
    else if (_use_imu == true &amp;&amp; _use_odom == false)
      predict_pose_for_ndt = predict_pose_imu;
    else if (_use_imu == false &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_odom;
    else
      predict_pose_for_ndt = predict_pose;

    Eigen::Translation3f init_translation(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z);
    Eigen::AngleAxisf init_rotation_x(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
    Eigen::AngleAxisf init_rotation_y(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
    Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;




    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
#ifdef USE_FAST_PCL
    if (_use_openmp == true)
    {
      align_start = std::chrono::system_clock::now();
      ndt.omp_align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();
    }
    else
    {
#endif
      align_start = std::chrono::system_clock::now();
      ndt.align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();
#ifdef USE_FAST_PCL
    }
#endif

    align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;


    t = ndt.getFinalTransformation();  // localizer
    t2 = t * tf_ltob;                  // base_link

    iteration = ndt.getFinalNumIteration();
#ifdef USE_FAST_PCL
    if (_use_openmp == true)
    {
      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.omp_getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();
    }
    else
    {
#endif
      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();
#ifdef USE_FAST_PCL
    }
#endif
    getFitnessScore_time =
        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() /
        1000.0;


    trans_probability = ndt.getTransformationProbability();

    tf::Matrix3x3 mat_l;  // localizer
    mat_l.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)),
                   static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)),
                   static_cast&lt;double&gt;(t(2, 0)), static_cast&lt;double&gt;(t(2, 1)), static_cast&lt;double&gt;(t(2, 2)));

    // Update localizer_pose
    localizer_pose.x = t(0, 3);
    localizer_pose.y = t(1, 3);
    localizer_pose.z = t(2, 3);
    mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

    tf::Matrix3x3 mat_b;  // base_link
    mat_b.setValue(static_cast&lt;double&gt;(t2(0, 0)), static_cast&lt;double&gt;(t2(0, 1)), static_cast&lt;double&gt;(t2(0, 2)),
                   static_cast&lt;double&gt;(t2(1, 0)), static_cast&lt;double&gt;(t2(1, 1)), static_cast&lt;double&gt;(t2(1, 2)),
                   static_cast&lt;double&gt;(t2(2, 0)), static_cast&lt;double&gt;(t2(2, 1)), static_cast&lt;double&gt;(t2(2, 2)));

    // Update ndt_pose
    ndt_pose.x = t2(0, 3);
    ndt_pose.y = t2(1, 3);
    ndt_pose.z = t2(2, 3);
    mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

    // Calculate the difference between ndt_pose and predict_pose
    predict_pose_error = sqrt((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) +
                              (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) +
                              (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));

    if (predict_pose_error &lt;= PREDICT_POSE_THRESHOLD)
    {
      use_predict_pose = 0;
    }
    else
    {
      use_predict_pose = 1;
    }
    use_predict_pose = 0;


    if (use_predict_pose == 0)
    {
      current_pose.x = ndt_pose.x;
      current_pose.y = ndt_pose.y;
      current_pose.z = ndt_pose.z;
      current_pose.roll = ndt_pose.roll;
      current_pose.pitch = ndt_pose.pitch;
      current_pose.yaw = ndt_pose.yaw;
    }
    else
    {
      current_pose.x = predict_pose_for_ndt.x;
      current_pose.y = predict_pose_for_ndt.y;
      current_pose.z = predict_pose_for_ndt.z;
      current_pose.roll = predict_pose_for_ndt.roll;
      current_pose.pitch = predict_pose_for_ndt.pitch;
      current_pose.yaw = predict_pose_for_ndt.yaw;
    }


    // Compute the velocity and acceleration
    scan_duration = current_scan_time - previous_scan_time;
    double secs = scan_duration.toSec();
    diff_x = current_pose.x - previous_pose.x;
    diff_y = current_pose.y - previous_pose.y;
    diff_z = current_pose.z - previous_pose.z;
    diff_yaw = current_pose.yaw - previous_pose.yaw;
    diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

    current_velocity = diff / secs;
    current_velocity_x = diff_x / secs;
    current_velocity_y = diff_y / secs;
    current_velocity_z = diff_z / secs;
    angular_velocity = diff_yaw / secs;

    current_pose_imu.x = current_pose.x;
    current_pose_imu.y = current_pose.y;
    current_pose_imu.z = current_pose.z;
    current_pose_imu.roll = current_pose.roll;
    current_pose_imu.pitch = current_pose.pitch;
    current_pose_imu.yaw = current_pose.yaw;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;


    current_pose_odom.x = current_pose.x;
    current_pose_odom.y = current_pose.y;
    current_pose_odom.z = current_pose.z;
    current_pose_odom.roll = current_pose.roll;
    current_pose_odom.pitch = current_pose.pitch;
    current_pose_odom.yaw = current_pose.yaw;

    current_pose_imu_odom.x = current_pose.x;
    current_pose_imu_odom.y = current_pose.y;
    current_pose_imu_odom.z = current_pose.z;
    current_pose_imu_odom.roll = current_pose.roll;
    current_pose_imu_odom.pitch = current_pose.pitch;
    current_pose_imu_odom.yaw = current_pose.yaw;

    current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
    if (current_velocity_smooth &lt; 0.2)
    {
      current_velocity_smooth = 0.0;
    }

    current_accel = (current_velocity - previous_velocity) / secs;
    current_accel_x = (current_velocity_x - previous_velocity_x) / secs;
    current_accel_y = (current_velocity_y - previous_velocity_y) / secs;
    current_accel_z = (current_velocity_z - previous_velocity_z) / secs;

    estimated_vel_mps.data = current_velocity;
    estimated_vel_kmph.data = current_velocity * 3.6;

    estimated_vel_mps_pub.publish(estimated_vel_mps);
    estimated_vel_kmph_pub.publish(estimated_vel_kmph);

    // Set values for publishing pose
    predict_q.setRPY(predict_pose.roll, predict_pose.pitch, predict_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(predict_pose.x, predict_pose.y, predict_pose.z);
      tf::Transform transform(predict_q, v);
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      predict_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      predict_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      predict_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      predict_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      predict_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      predict_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = predict_pose.x;
      predict_pose_msg.pose.position.y = predict_pose.y;
      predict_pose_msg.pose.position.z = predict_pose.z;
      predict_pose_msg.pose.orientation.x = predict_q.x();
      predict_pose_msg.pose.orientation.y = predict_q.y();
      predict_pose_msg.pose.orientation.z = predict_q.z();
      predict_pose_msg.pose.orientation.w = predict_q.w();
    }

    tf::Quaternion predict_q_imu;
    predict_q_imu.setRPY(predict_pose_imu.roll, predict_pose_imu.pitch, predict_pose_imu.yaw);
    predict_pose_imu_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_msg.pose.position.x = predict_pose_imu.x;
    predict_pose_imu_msg.pose.position.y = predict_pose_imu.y;
    predict_pose_imu_msg.pose.position.z = predict_pose_imu.z;
    predict_pose_imu_msg.pose.orientation.x = predict_q_imu.x();
    predict_pose_imu_msg.pose.orientation.y = predict_q_imu.y();
    predict_pose_imu_msg.pose.orientation.z = predict_q_imu.z();
    predict_pose_imu_msg.pose.orientation.w = predict_q_imu.w();
    predict_pose_imu_pub.publish(predict_pose_imu_msg);

    tf::Quaternion predict_q_odom;
    predict_q_odom.setRPY(predict_pose_odom.roll, predict_pose_odom.pitch, predict_pose_odom.yaw);
    predict_pose_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_odom_msg.pose.position.x = predict_pose_odom.x;
    predict_pose_odom_msg.pose.position.y = predict_pose_odom.y;
    predict_pose_odom_msg.pose.position.z = predict_pose_odom.z;
    predict_pose_odom_msg.pose.orientation.x = predict_q_odom.x();
    predict_pose_odom_msg.pose.orientation.y = predict_q_odom.y();
    predict_pose_odom_msg.pose.orientation.z = predict_q_odom.z();
    predict_pose_odom_msg.pose.orientation.w = predict_q_odom.w();
    predict_pose_odom_pub.publish(predict_pose_odom_msg);


    tf::Quaternion predict_q_imu_odom;
    predict_q_imu_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
    predict_pose_imu_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_odom_msg.pose.position.x = predict_pose_imu_odom.x;
    predict_pose_imu_odom_msg.pose.position.y = predict_pose_imu_odom.y;
    predict_pose_imu_odom_msg.pose.position.z = predict_pose_imu_odom.z;
    predict_pose_imu_odom_msg.pose.orientation.x = predict_q_imu_odom.x();
    predict_pose_imu_odom_msg.pose.orientation.y = predict_q_imu_odom.y();
    predict_pose_imu_odom_msg.pose.orientation.z = predict_q_imu_odom.z();
    predict_pose_imu_odom_msg.pose.orientation.w = predict_q_imu_odom.w();
    predict_pose_imu_odom_pub.publish(predict_pose_imu_odom_msg);

    ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(ndt_pose.x, ndt_pose.y, ndt_pose.z);
      tf::Transform transform(ndt_q, v);
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      ndt_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      ndt_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      ndt_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      ndt_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      ndt_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      ndt_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = ndt_pose.x;
      ndt_pose_msg.pose.position.y = ndt_pose.y;
      ndt_pose_msg.pose.position.z = ndt_pose.z;
      ndt_pose_msg.pose.orientation.x = ndt_q.x();
      ndt_pose_msg.pose.orientation.y = ndt_q.y();
      ndt_pose_msg.pose.orientation.z = ndt_q.z();
      ndt_pose_msg.pose.orientation.w = ndt_q.w();
    }

    current_q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
    // current_pose is published by vel_pose_mux
    /*
    current_pose_msg.header.frame_id = &quot;/map&quot;;
    current_pose_msg.header.stamp = current_scan_time;
    current_pose_msg.pose.position.x = current_pose.x;
    current_pose_msg.pose.position.y = current_pose.y;
    current_pose_msg.pose.position.z = current_pose.z;
    current_pose_msg.pose.orientation.x = current_q.x();
    current_pose_msg.pose.orientation.y = current_q.y();
    current_pose_msg.pose.orientation.z = current_q.z();
    current_pose_msg.pose.orientation.w = current_q.w();
    */

    localizer_q.setRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(localizer_pose.x, localizer_pose.y, localizer_pose.z);
      tf::Transform transform(localizer_q, v);
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      localizer_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      localizer_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      localizer_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      localizer_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      localizer_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      localizer_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = localizer_pose.x;
      localizer_pose_msg.pose.position.y = localizer_pose.y;
      localizer_pose_msg.pose.position.z = localizer_pose.z;
      localizer_pose_msg.pose.orientation.x = localizer_q.x();
      localizer_pose_msg.pose.orientation.y = localizer_q.y();
      localizer_pose_msg.pose.orientation.z = localizer_q.z();
      localizer_pose_msg.pose.orientation.w = localizer_q.w();
    }

    predict_pose_pub.publish(predict_pose_msg);
    ndt_pose_pub.publish(ndt_pose_msg);
    // current_pose is published by vel_pose_mux
    //    current_pose_pub.publish(current_pose_msg);
    localizer_pose_pub.publish(localizer_pose_msg);

    // Send TF &quot;/base_link&quot; to &quot;/map&quot;
    transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
    transform.setRotation(current_q);
    //    br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    if (_use_local_transform == true)
    {
      br.sendTransform(tf::StampedTransform(local_transform * transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }
    else
    {
      br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }

    matching_end = std::chrono::system_clock::now();
    exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
    time_ndt_matching.data = exe_time;
    time_ndt_matching_pub.publish(time_ndt_matching);

    // Set values for /estimate_twist
    estimate_twist_msg.header.stamp = current_scan_time;
    estimate_twist_msg.header.frame_id = &quot;/base_link&quot;;
    estimate_twist_msg.twist.linear.x = current_velocity;
    estimate_twist_msg.twist.linear.y = 0.0;
    estimate_twist_msg.twist.linear.z = 0.0;
    estimate_twist_msg.twist.angular.x = 0.0;
    estimate_twist_msg.twist.angular.y = 0.0;
    estimate_twist_msg.twist.angular.z = angular_velocity;

    estimate_twist_pub.publish(estimate_twist_msg);

    geometry_msgs::Vector3Stamped estimate_vel_msg;
    estimate_vel_msg.header.stamp = current_scan_time;
    estimate_vel_msg.vector.x = current_velocity;
    estimated_vel_pub.publish(estimate_vel_msg);

    // Set values for /ndt_stat
    ndt_stat_msg.header.stamp = current_scan_time;
    ndt_stat_msg.exe_time = time_ndt_matching.data;
    ndt_stat_msg.iteration = iteration;
    ndt_stat_msg.score = fitness_score;
    ndt_stat_msg.velocity = current_velocity;
    ndt_stat_msg.acceleration = current_accel;
    ndt_stat_msg.use_predict_pose = 0;

    ndt_stat_pub.publish(ndt_stat_msg);

    /* Compute NDT_Reliability */
    ndt_reliability.data = Wa * (exe_time / 100.0) * 100.0 + Wb * (iteration / 10.0) * 100.0 +
                           Wc * ((2.0 - trans_probability) / 2.0) * 100.0;
    ndt_reliability_pub.publish(ndt_reliability);


    // Write log
    if (!ofs)
    {
      std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      exit(1);
    }
    static ros::Time start_time = input-&gt;header.stamp;

    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; &quot;,&quot; &lt;&lt; scan_points_num &lt;&lt; &quot;,&quot; &lt;&lt; step_size &lt;&lt; &quot;,&quot; &lt;&lt; trans_eps &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed
        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.pitch
        &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.y &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.z &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose_error &lt;&lt; &quot;,&quot; &lt;&lt; iteration &lt;&lt; &quot;,&quot; &lt;&lt; fitness_score &lt;&lt; &quot;,&quot; &lt;&lt; trans_probability &lt;&lt; &quot;,&quot;
        &lt;&lt; ndt_reliability.data &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity_smooth &lt;&lt; &quot;,&quot; &lt;&lt; current_accel
        &lt;&lt; &quot;,&quot; &lt;&lt; angular_velocity &lt;&lt; &quot;,&quot; &lt;&lt; time_ndt_matching.data &lt;&lt; &quot;,&quot; &lt;&lt; align_time &lt;&lt; &quot;,&quot; &lt;&lt; getFitnessScore_time
        &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Sequence: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Timestamp: &quot; &lt;&lt; input-&gt;header.stamp &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Frame ID: &quot; &lt;&lt; input-&gt;header.frame_id &lt;&lt; std::endl;
    //		std::cout &lt;&lt; &quot;Number of Scan Points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Filtered Scan Points: &quot; &lt;&lt; scan_points_num &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; ndt.hasConverged() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Fitness Score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Probability: &quot; &lt;&lt; ndt.getTransformationProbability() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Execution Time: &quot; &lt;&lt; exe_time &lt;&lt; &quot; ms.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Iterations: &quot; &lt;&lt; ndt.getFinalNumIteration() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT Reliability: &quot; &lt;&lt; ndt_reliability.data &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw): &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
              &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Matrix: &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; t &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

    // Update offset
    if (_offset == &quot;linear&quot;)
    {
      offset_x = diff_x;
      offset_y = diff_y;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;quadratic&quot;)
    {
      offset_x = (current_velocity_x + current_accel_x * secs) * secs;
      offset_y = (current_velocity_y + current_accel_y * secs) * secs;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;zero&quot;)
    {
      offset_x = 0.0;
      offset_y = 0.0;
      offset_z = 0.0;
      offset_yaw = 0.0;
    }
   
    offset_imu_x = 0.0;
    offset_imu_y = 0.0;
    offset_imu_z = 0.0;
    offset_imu_roll = 0.0;
    offset_imu_pitch = 0.0;
    offset_imu_yaw = 0.0;

    offset_odom_x = 0.0;
    offset_odom_y = 0.0;
    offset_odom_z = 0.0;
    offset_odom_roll = 0.0;
    offset_odom_pitch = 0.0;
    offset_odom_yaw = 0.0;

    offset_imu_odom_x = 0.0;
    offset_imu_odom_y = 0.0;
    offset_imu_odom_z = 0.0;
    offset_imu_odom_roll = 0.0;
    offset_imu_odom_pitch = 0.0;
    offset_imu_odom_yaw = 0.0;

    // Update previous_***
    previous_pose.x = current_pose.x;
    previous_pose.y = current_pose.y;
    previous_pose.z = current_pose.z;
    previous_pose.roll = current_pose.roll;
    previous_pose.pitch = current_pose.pitch;
    previous_pose.yaw = current_pose.yaw;

    previous_scan_time.sec = current_scan_time.sec;
    previous_scan_time.nsec = current_scan_time.nsec;

    previous_previous_velocity = previous_velocity;
    previous_velocity = current_velocity;
    previous_velocity_x = current_velocity_x;
    previous_velocity_y = current_velocity_y;
    previous_velocity_z = current_velocity_z;
    previous_accel = current_accel;

    previous_estimated_vel_kmph.data = estimated_vel_kmph.data;
  }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;ndt_matching&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  // Set log file name.
  char buffer[80];
  std::time_t now = std::time(NULL);
  std::tm* pnow = std::localtime(&amp;now);
  std::strftime(buffer, 80, &quot;%Y%m%d_%H%M%S&quot;, pnow);
  filename = &quot;ndt_matching_&quot; + std::string(buffer) + &quot;.csv&quot;;
  ofs.open(filename.c_str(), std::ios::app);

  // Geting parameters
  private_nh.getParam(&quot;use_gnss&quot;, _use_gnss);
  private_nh.getParam(&quot;queue_size&quot;, _queue_size);
  private_nh.getParam(&quot;offset&quot;, _offset);
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
  private_nh.getParam(&quot;get_height&quot;, _get_height);
  private_nh.getParam(&quot;use_local_transform&quot;, _use_local_transform);
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

  if (nh.getParam(&quot;localizer&quot;, _localizer) == false)
  {
    std::cout &lt;&lt; &quot;localizer is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Log file: &quot; &lt;&lt; filename &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_gnss: &quot; &lt;&lt; _use_gnss &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;queue_size: &quot; &lt;&lt; _queue_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;offset: &quot; &lt;&lt; _offset &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;get_height: &quot; &lt;&lt; _get_height &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_local_transform: &quot; &lt;&lt; _use_local_transform &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;localizer: &quot; &lt;&lt; _localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
  Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
  tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();

  // Updated in initialpose_callback or gnss_callback
  initial_pose.x = 0.0;
  initial_pose.y = 0.0;
  initial_pose.z = 0.0;
  initial_pose.roll = 0.0;
  initial_pose.pitch = 0.0;
  initial_pose.yaw = 0.0;

  // Publishers
  predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose&quot;, 1000);
  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu&quot;, 1000);
  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_odom&quot;, 1000);
  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu_odom&quot;, 1000);
  ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/ndt_pose&quot;, 1000);
  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);
  localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/localizer_pose&quot;, 1000);
  estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;/estimate_twist&quot;, 1000);
  estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_mps&quot;, 1000);
  estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_kmph&quot;, 1000);
  estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;(&quot;/estimated_vel&quot;, 1000);
  time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/time_ndt_matching&quot;, 1000);
  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;(&quot;/ndt_stat&quot;, 1000);
  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/ndt_reliability&quot;, 1000);

  // Subscribers
  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt&quot;, 10, param_callback);
  ros::Subscriber gnss_sub = nh.subscribe(&quot;gnss_pose&quot;, 10, gnss_callback);
  ros::Subscriber map_sub = nh.subscribe(&quot;points_map&quot;, 10, map_callback);
  ros::Subscriber initialpose_sub = nh.subscribe(&quot;initialpose&quot;, 1000, initialpose_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;filtered_points&quot;, _queue_size, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, _queue_size*10, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size*10, imu_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="69f3c6294eaa9c70c95360f718965fea160cb4dd" fix_time="1,715">
		<msg>Fix publishing msg type</msg>
		<modified_files>
			<file old_path="ros/src/actuation/vehicles/packages/as/nodes/pacmod_interface/pacmod_interface.cpp" new_path="ros/src/actuation/vehicles/packages/as/nodes/pacmod_interface/pacmod_interface.cpp">
				<diff>@@ -60,7 +60,7 @@ void PacmodInterface::initForROS()
 
   // setup publisher
   steer_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;(&quot;/as/arbitrated_steering_commands&quot;, 10);
-  speed_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;(&quot;/as/arbitrated_speed_commands&quot;, 10);
+  speed_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SpeedMode&gt;(&quot;/as/arbitrated_speed_commands&quot;, 10);
   current_twist_pub_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;as_current_twist&quot;, 10);
 }
 
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University

 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;pacmod_interface.h&quot;

namespace pacmod
{
// Constructor
PacmodInterface::PacmodInterface() :
    private_nh_(&quot;~&quot;),
    control_mode_(false)
{
  initForROS();
}

// Destructor
PacmodInterface::~PacmodInterface()
{
}

void PacmodInterface::initForROS()
{
  // ros parameter settings
  private_nh_.param&lt;double&gt;(&quot;acceleration_limit&quot;, acceleration_limit_, 3.0);
  private_nh_.param&lt;double&gt;(&quot;deceleration_limit&quot;, deceleration_limit_, 3.0);
  private_nh_.param&lt;double&gt;(&quot;max_curvature_rate&quot;, max_curvature_rate_, 0.75);

  // setup subscriber
  twist_cmd_sub_    = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;PacmodInterface::callbackFromTwistCmd, this);
  control_mode_sub_ = nh_.subscribe(&quot;/as/control_mode&quot;, 10, &amp;PacmodInterface::callbackFromControlMode, this);
  speed_sub_        = nh_.subscribe(&quot;/vehicle/steering_report&quot;, 10, &amp;PacmodInterface::callbackFromTwistCmd, this);

  // setup publisher
  steer_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;(&quot;/as/arbitrated_steering_commands&quot;, 10);
  speed_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;(&quot;/as/arbitrated_speed_commands&quot;, 10);
  current_twist_pub_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;as_current_twist&quot;, 10);
}

void PacmodInterface::run()
{
  ros::spin();
}


void PacmodInterface::callbackFromTwistCmd(const geometry_msgs::TwistStampedConstPtr &amp;msg)
{
  int mode;
  if (control_mode_)
  {
    mode = 1;
  }
  else
  {
    mode = 0;
  }

  module_comm_msgs::SpeedMode speed_mode;
  speed_mode.header = msg-&gt;header;
  speed_mode.mode = mode;
  speed_mode.speed = msg-&gt;twist.linear.x;
  speed_mode.acceleration_limit = 3.0;
  speed_mode.deceleration_limit = 3.0;

  module_comm_msgs::SteerMode steer_mode;
  steer_mode.header = msg-&gt;header;
  steer_mode.mode = mode;
  double curvature = msg-&gt;twist.angular.z / msg-&gt;twist.linear.x;
  steer_mode.curvature = msg-&gt;twist.linear.x &lt;= 0 ? 0 : curvature;
  steer_mode.max_curvature_rate = 0.75;

  std::cout &lt;&lt; &quot;mode: &quot;  &lt;&lt; mode &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;speed: &quot; &lt;&lt; speed_mode.speed &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;steer: &quot; &lt;&lt; steer_mode.curvature &lt;&lt; std::endl;

  speed_mode_pub_.publish(speed_mode);
  steer_mode_pub_.publish(steer_mode);
}

void PacmodInterface::callbackFromControlMode(const std_msgs::BoolConstPtr &amp;msg)
{
  control_mode_ = msg-&gt;data;
}

void PacmodInterface::callbackFromSteeringReport(const dbw_mkz_msgs::SteeringReportConstPtr &amp;msg)
{
  geometry_msgs::TwistStamped ts;
  std_msgs::Header header;
  header.stamp = ros::Time::now();
  ts.header = header;
  ts.twist.linear.x = msg-&gt;speed; // [m/sec]
  // Can we get angular velocity?

  current_twist_pub_.publish(ts);
}

}  // pacmod
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="e5d6b0d409c2019c3b77969a5dc1ec4d55e8870e" fix_time="6,10888">
		<msg>Use correct callback function</msg>
		<modified_files>
			<file old_path="ros/src/actuation/vehicles/packages/as/nodes/pacmod_interface/pacmod_interface.cpp" new_path="ros/src/actuation/vehicles/packages/as/nodes/pacmod_interface/pacmod_interface.cpp">
				<diff>@@ -55,7 +55,7 @@ void PacmodInterface::initForROS()
   // setup subscriber
   twist_cmd_sub_    = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;PacmodInterface::callbackFromTwistCmd, this);
   control_mode_sub_ = nh_.subscribe(&quot;/as/control_mode&quot;, 10, &amp;PacmodInterface::callbackFromControlMode, this);
-  speed_sub_        = nh_.subscribe(&quot;/vehicle/steering_report&quot;, 10, &amp;PacmodInterface::callbackFromTwistCmd, this);
+  speed_sub_        = nh_.subscribe(&quot;/vehicle/steering_report&quot;, 10, &amp;PacmodInterface::callbackFromSteeringReport, this);
 
   // setup publisher
   steer_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;(&quot;/as/arbitrated_steering_commands&quot;, 10);
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;pacmod_interface.h&quot;

namespace pacmod
{
// Constructor
PacmodInterface::PacmodInterface() :
    private_nh_(&quot;~&quot;),
    control_mode_(false)
{
  initForROS();
}

// Destructor
PacmodInterface::~PacmodInterface()
{
}

void PacmodInterface::initForROS()
{
  // ros parameter settings
  private_nh_.param&lt;double&gt;(&quot;acceleration_limit&quot;, acceleration_limit_, 3.0);
  private_nh_.param&lt;double&gt;(&quot;deceleration_limit&quot;, deceleration_limit_, 3.0);
  private_nh_.param&lt;double&gt;(&quot;max_curvature_rate&quot;, max_curvature_rate_, 0.75);

  // setup subscriber
  twist_cmd_sub_    = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;PacmodInterface::callbackFromTwistCmd, this);
  control_mode_sub_ = nh_.subscribe(&quot;/as/control_mode&quot;, 10, &amp;PacmodInterface::callbackFromControlMode, this);
  speed_sub_        = nh_.subscribe(&quot;/vehicle/steering_report&quot;, 10, &amp;PacmodInterface::callbackFromTwistCmd, this);

  // setup publisher
  steer_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SteerMode&gt;(&quot;/as/arbitrated_steering_commands&quot;, 10);
  speed_mode_pub_    = nh_.advertise&lt;module_comm_msgs::SpeedMode&gt;(&quot;/as/arbitrated_speed_commands&quot;, 10);
  current_twist_pub_ = nh_.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;as_current_twist&quot;, 10);
}

void PacmodInterface::run()
{
  ros::spin();
}


void PacmodInterface::callbackFromTwistCmd(const geometry_msgs::TwistStampedConstPtr &amp;msg)
{
  int mode;
  if (control_mode_)
  {
    mode = 1;
  }
  else
  {
    mode = 0;
  }

  module_comm_msgs::SpeedMode speed_mode;
  speed_mode.header = msg-&gt;header;
  speed_mode.mode = mode;
  speed_mode.speed = msg-&gt;twist.linear.x;
  speed_mode.acceleration_limit = 3.0;
  speed_mode.deceleration_limit = 3.0;

  module_comm_msgs::SteerMode steer_mode;
  steer_mode.header = msg-&gt;header;
  steer_mode.mode = mode;
  double curvature = msg-&gt;twist.angular.z / msg-&gt;twist.linear.x;
  steer_mode.curvature = msg-&gt;twist.linear.x &lt;= 0 ? 0 : curvature;
  steer_mode.max_curvature_rate = 0.75;

  std::cout &lt;&lt; &quot;mode: &quot;  &lt;&lt; mode &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;speed: &quot; &lt;&lt; speed_mode.speed &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;steer: &quot; &lt;&lt; steer_mode.curvature &lt;&lt; std::endl;

  speed_mode_pub_.publish(speed_mode);
  steer_mode_pub_.publish(steer_mode);
}

void PacmodInterface::callbackFromControlMode(const std_msgs::BoolConstPtr &amp;msg)
{
  control_mode_ = msg-&gt;data;
}

void PacmodInterface::callbackFromSteeringReport(const dbw_mkz_msgs::SteeringReportConstPtr &amp;msg)
{
  geometry_msgs::TwistStamped ts;
  std_msgs::Header header;
  header.stamp = ros::Time::now();
  ts.header = header;
  ts.twist.linear.x = msg-&gt;speed; // [m/sec]
  // Can we get angular velocity?

  current_twist_pub_.publish(ts);
}

}  // pacmod
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="091e9a032cd71f2abbd226acc1a9433b193ed4a7" fix_time="784,17337">
		<msg>[Feature] Updates to Pointgrey package/Ladybug node (#852)

* Added support for FindXerces on Indigo (and Cmake less than 3.1.3)
Changed default scaling value to 20% of original image size (to improve performance)
Changed published image format from RGB to Bayer(to reduce bag size)

* Tested on real camera, updated</msg>
		<modified_files>
			<file old_path="ros/src/sensing/drivers/camera/packages/pointgrey/nodes/ladybug/ladybug.cpp" new_path="ros/src/sensing/drivers/camera/packages/pointgrey/nodes/ladybug/ladybug.cpp">
				<diff>@@ -269,7 +269,7 @@ LadybugError unlock_image( unsigned int bufferIndex )
 int main (int argc, char **argv)
 {
 	////ROS STUFF
-	ros::init(argc, argv, &quot;lady_bug&quot;);
+	ros::init(argc, argv, &quot;ladybug_camera&quot;);
 	ros::NodeHandle n;
 	ros::NodeHandle private_nh(&quot;~&quot;);
 
@@ -316,8 +316,8 @@ int main (int argc, char **argv)
 	}
 	else
 	{
-		ROS_INFO(&quot;Ladybug ImageScale scale must be (0,100]. Defaulting to 100 &quot;);
-		image_scale=100;
+		ROS_INFO(&quot;Ladybug ImageScale scale must be (0,100]. Defaulting to 20 &quot;);
+		image_scale=20;
 	}
 
 	ros::Publisher camera_info_pub;
@@ -358,11 +358,12 @@ int main (int argc, char **argv)
 			std::ostringstream out;
 			out &lt;&lt; &quot;image&quot; &lt;&lt; i;
 			cv::Mat rawImage(size, CV_8UC1, currentImage.pData + (i * size.width*size.height));
-			//cv::flip(mat, mat, -1);
 			cv::Mat image(size, CV_8UC3);
 			cv::cvtColor(rawImage, image, cv::COLOR_BayerBG2RGB);
 			cv::resize(image,image,cv::Size(size.width*image_scale/100, size.height*image_scale/100));
+			//
 			cv::transpose(image, image);
+
 			if (i==0)
 				image.copyTo(full_size);
 			else
@@ -375,18 +376,17 @@ int main (int argc, char **argv)
 		}
 		//publish stitched one
 		publishImage(full_size, pub[0], count);
-
 		ros::spinOnce();
 		loop_rate.sleep();
 		count++;
 	}
 
-	cout &lt;&lt; &quot;Stopping ladybug...&quot; &lt;&lt; endl;
+	cout &lt;&lt; &quot;Stopping ladybug_camera...&quot; &lt;&lt; endl;
 
 	// Shutdown
 	stop_camera();
 
-	ROS_INFO(&quot;ladybug stopped&quot;);
+	ROS_INFO(&quot;ladybug_camera stopped&quot;);
 
 	return 0;
 }
</diff>
				<old_file>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &quot;ladybug.h&quot;
#include &quot;ladybugstream.h&quot;
#include &lt;stdexcept&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;sensor_msgs/Image.h&gt;

#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;

#include &quot;opencv2/core/core.hpp&quot;
#include &quot;opencv2/highgui/highgui.hpp&quot;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

#include &quot;ladybug.h&quot;

using namespace std;

static volatile int running_ = 1;


LadybugContext m_context;
LadybugDataFormat m_dataFormat;
//camera config settings
float m_frameRate;
bool m_isFrameRateAuto;
unsigned int m_jpegQualityPercentage;

ros::Publisher pub[LADYBUG_NUM_CAMERAS + 1];

static void signalHandler(int)
{
	running_ = 0;
	ros::shutdown();
}

void parseCameraInfo(const cv::Mat  &amp;camMat,
						const cv::Mat  &amp;disCoeff,
						const cv::Size &amp;imgSize,
						sensor_msgs::CameraInfo &amp;msg)
{
	msg.header.frame_id = &quot;camera&quot;;

	msg.height = imgSize.height;
	msg.width  = imgSize.width;

	for (int row=0; row&lt;3; row++)
	{
		for (int col=0; col&lt;3; col++)
		{
			msg.K[row * 3 + col] = camMat.at&lt;double&gt;(row, col);
		}
	}

	for (int row=0; row&lt;3; row++)
	{
		for (int col=0; col&lt;4; col++)
		{
			if (col == 3)
			{
				msg.P[row * 4 + col] = 0.0f;
			} else
			{
				msg.P[row * 4 + col] = camMat.at&lt;double&gt;(row, col);
			}
		}
	}

	for (int row=0; row&lt;disCoeff.rows; row++)
	{
		for (int col=0; col&lt;disCoeff.cols; col++)
		{
			msg.D.push_back(disCoeff.at&lt;double&gt;(row, col));
		}
	}
}

void GetMatricesFromFile(ros::NodeHandle nh, sensor_msgs::CameraInfo &amp;camerainfo_msg)
{
	//////////////////CAMERA INFO/////////////////////////////////////////
	cv::Mat  cameraExtrinsicMat;
	cv::Mat  cameraMat;
	cv::Mat  distCoeff;
	cv::Size imageSize;
	std::string filename;

	if (nh.getParam(&quot;calibrationfile&quot;, filename) &amp;&amp; filename!=&quot;&quot;)
	{
		ROS_INFO(&quot;Trying to parse calibrationfile :&quot;);
		ROS_INFO(&quot;&gt; %s&quot;, filename.c_str());
	}
	else
	{
		ROS_INFO(&quot;No calibrationfile param was received&quot;);
		return;
	}

	cv::FileStorage fs(filename, cv::FileStorage::READ);
	if (!fs.isOpened())
	{
		ROS_INFO(&quot;Cannot open %s&quot;, filename.c_str());;
		return;
	}
	else
	{
		fs[&quot;CameraMat&quot;] &gt;&gt; cameraMat;
		fs[&quot;DistCoeff&quot;] &gt;&gt; distCoeff;
		fs[&quot;ImageSize&quot;] &gt;&gt; imageSize;
	}
	parseCameraInfo(cameraMat, distCoeff, imageSize, camerainfo_msg);
}

void publishImage(cv::Mat&amp; image, ros::Publisher&amp; image_pub, long int&amp; count)
{
	sensor_msgs::Image msg;
	//publish*******************
	msg.header.seq = count;
	msg.header.frame_id = &quot;camera&quot;;
	msg.header.stamp.sec = ros::Time::now().sec; msg.header.stamp.nsec = ros::Time::now().nsec;
	msg.height = image.size().height; msg.width  = image.size().width;
	msg.encoding = &quot;rgb8&quot;;
	msg.step = image.cols * image.elemSize();
	size_t image_size = image.rows * image.cols * image.elemSize();

	msg.data.resize(image_size);
	memcpy(msg.data.data(), image.data, image_size);

	image_pub.publish(msg);
}

LadybugError init_camera()
{
	LadybugError error;
	error = ladybugCreateContext(&amp;m_context);
	if (error != LADYBUG_OK)
	{
		throw std::runtime_error(&quot;Unable to create Ladybug context.&quot;);
	}

	LadybugCameraInfo enumeratedCameras[16];
	unsigned int numCameras = 16;

	error = ladybugBusEnumerateCameras(m_context, enumeratedCameras, &amp;numCameras);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	cout &lt;&lt; &quot;Cameras detected: &quot; &lt;&lt; numCameras &lt;&lt; endl &lt;&lt; endl;

	if (numCameras == 0)
	{
		ROS_INFO(&quot;Insufficient number of cameras detected. &quot;);
		return LADYBUG_FAILED;
	}

	error = ladybugInitializeFromIndex(m_context, 0);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	LadybugCameraInfo camInfo;
	error = ladybugGetCameraInfo(m_context, &amp;camInfo);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	ROS_INFO(&quot;Camera information: &quot;);

	ROS_INFO(&quot;Base s/n: %d&quot;, camInfo.serialBase );
	ROS_INFO(&quot;Head s/n: %d&quot;, camInfo.serialHead );
	ROS_INFO(&quot;Model: %s&quot;, camInfo.pszModelName );
	ROS_INFO(&quot;Sensor: %s&quot;, camInfo.pszSensorInfo);
	ROS_INFO(&quot;Vendor: %s&quot;, camInfo.pszVendorName);
	ROS_INFO(&quot;Bus / Node: %d ,%d&quot; , camInfo.iBusNum , camInfo.iNodeNum );

	switch (camInfo.deviceType)
	{
		case LADYBUG_DEVICE_LADYBUG3:
		{
			m_dataFormat = LADYBUG_DATAFORMAT_RAW8;
			m_frameRate = 16.0f;
			m_isFrameRateAuto = true;
			m_jpegQualityPercentage = 80;
		}
		break;

		case LADYBUG_DEVICE_LADYBUG5:
		{
			m_dataFormat = LADYBUG_DATAFORMAT_RAW8;
			m_frameRate = 10.0f;
			m_isFrameRateAuto = true;
			m_jpegQualityPercentage = 80;
		}
		break;

		default: assert(false); break;
	}

	return error;
}

LadybugError start_camera()
{
	LadybugError error;
	error = ladybugStartLockNext(m_context, m_dataFormat);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	error = ladybugSetAbsPropertyEx(m_context, LADYBUG_FRAME_RATE, false, true, m_isFrameRateAuto, m_frameRate);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	error = ladybugSetJPEGQuality(m_context, m_jpegQualityPercentage);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	// Perform a quick test to make sure images can be successfully acquired
	for (int i=0; i &lt; 10; i++)
	{
		LadybugImage tempImage;
		error = ladybugLockNext(m_context, &amp;tempImage);
	}

	error = ladybugUnlockAll(m_context);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	return error;
}

LadybugError stop_camera()
{
    const LadybugError cameraError = ladybugStop(m_context);
    if (cameraError != LADYBUG_OK)
    {
        ROS_INFO(&quot;Error: Unable to stop camera (%s)&quot;, ladybugErrorToString(cameraError) );
    }
    return cameraError;
}

LadybugError acquire_image( LadybugImage&amp; image )
{
    return ladybugLockNext(m_context, &amp;image);
}

LadybugError unlock_image( unsigned int bufferIndex )
{
    return ladybugUnlock(m_context, bufferIndex);
}

int main (int argc, char **argv)
{
	////ROS STUFF
	ros::init(argc, argv, &quot;lady_bug&quot;);
	ros::NodeHandle n;
	ros::NodeHandle private_nh(&quot;~&quot;);

	signal(SIGTERM, signalHandler);//detect closing

	/////////////////////////////
	//Config camera
	m_dataFormat = LADYBUG_DATAFORMAT_RAW8;
	m_frameRate = 10;
	m_isFrameRateAuto = true;
	m_jpegQualityPercentage = 80;

	// Initialize ladybug camera
	const LadybugError grabberInitError = init_camera();
	if (LADYBUG_OK != init_camera())
	{
		ROS_INFO(&quot;Error: Failed to initialize camera (%s). Terminating...&quot;, ladybugErrorToString(grabberInitError) );
		return -1;
	}

	LadybugCameraInfo camInfo;
	if (LADYBUG_OK != ladybugGetCameraInfo(m_context, &amp;camInfo))
	{
		ROS_INFO(&quot;Error: Failed to get camera information. Terminating...&quot;);
		return -1;
	}

	const LadybugError startError = start_camera();
	if (startError != LADYBUG_OK)
	{
		ROS_INFO(&quot;Error: Failed to start camera (%s). Terminating...&quot;, ladybugErrorToString(startError) );
		return -1;
	}
	/////////////////////
	//ROS
	// Get the camera information
	///////calibration data
	sensor_msgs::CameraInfo camerainfo_msg;
	GetMatricesFromFile(private_nh, camerainfo_msg);
	int image_scale = 100;
	if (private_nh.getParam(&quot;scale&quot;, image_scale) &amp;&amp; image_scale&gt;0 &amp;&amp; image_scale&lt;100)
	{
		ROS_INFO(&quot;Ladybug ImageScale &gt; %i%%&quot;, image_scale);
	}
	else
	{
		ROS_INFO(&quot;Ladybug ImageScale scale must be (0,100]. Defaulting to 100 &quot;);
		image_scale=100;
	}

	ros::Publisher camera_info_pub;

	camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(&quot;/camera/camera_info&quot;, 1, true);
	ROS_INFO(&quot;Successfully started ladybug camera and stream&quot;);
	for (int i = 0; i &lt; LADYBUG_NUM_CAMERAS + 1; i++) {
		std::string topic(std::string(&quot;image_raw&quot;));

			topic = &quot;camera&quot; + std::to_string(i) + &quot;/&quot; + topic;

		pub[i] = n.advertise&lt;sensor_msgs::Image&gt;(topic, 100);
		ROS_INFO(&quot;Publishing.. %s&quot;, topic.c_str());
	}
	//////////////////

	//start camera
	ros::Rate loop_rate(10); // Hz Ladybug works at 10fps
	long int count = 0;
	while (running_ &amp;&amp; ros::ok())
	{
		LadybugImage currentImage;

		const LadybugError acquisitionError = acquire_image(currentImage);
		if (acquisitionError != LADYBUG_OK)
		{
			ROS_INFO(&quot;Failed to acquire image. Error (%s). Trying to continue..&quot;, ladybugErrorToString(acquisitionError) );
			continue;
		}

		// convert to OpenCV Mat
		//receive Bayer Image, convert to Color 3 channels
		cv::Size size(currentImage.uiFullCols, currentImage.uiFullRows);

		cv::Mat full_size;
		for(size_t i =0;i&lt;LADYBUG_NUM_CAMERAS; i++)
		{
			std::ostringstream out;
			out &lt;&lt; &quot;image&quot; &lt;&lt; i;
			cv::Mat rawImage(size, CV_8UC1, currentImage.pData + (i * size.width*size.height));
			//cv::flip(mat, mat, -1);
			cv::Mat image(size, CV_8UC3);
			cv::cvtColor(rawImage, image, cv::COLOR_BayerBG2RGB);
			cv::resize(image,image,cv::Size(size.width*image_scale/100, size.height*image_scale/100));
			cv::transpose(image, image);
			if (i==0)
				image.copyTo(full_size);
			else
				cv::hconcat(image, full_size, full_size);

			unlock_image(currentImage.uiBufferIndex);

			publishImage(image, pub[LADYBUG_NUM_CAMERAS - i], count);

		}
		//publish stitched one
		publishImage(full_size, pub[0], count);

		ros::spinOnce();
		loop_rate.sleep();
		count++;
	}

	cout &lt;&lt; &quot;Stopping ladybug...&quot; &lt;&lt; endl;

	// Shutdown
	stop_camera();

	ROS_INFO(&quot;ladybug stopped&quot;);

	return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="ce8d2ac564a8ae12f05180e982009485e5dc7097" fix_time="51,19452">
		<msg>[fix] NDT_GPU ndt_localizer (#854)

* fix CMakeLists.txt of ndt_localizer

* Fixed CUDA/FAST_PCL conflict

* Fixed ndt_matching</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_mapping/ndt_mapping.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_mapping/ndt_mapping.cpp">
				<diff>@@ -58,15 +58,16 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#if defined(USE_FAST_PCL) &amp;&amp; defined(CUDA_FOUND)
-#include &lt;fast_pcl/filters/voxel_grid.h&gt;
-#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
-#include &lt;fast_pcl/registration/ndt.h&gt;
+#ifdef USE_FAST_PCL
+  #include &lt;fast_pcl/filters/voxel_grid.h&gt;
+  #include &lt;fast_pcl/registration/ndt.h&gt;
+#else
+  #include &lt;pcl/filters/voxel_grid.h&gt;
+  #include &lt;pcl/registration/ndt.h&gt;
 #endif
 
-#ifndef USE_FAST_PCL
-#include &lt;pcl/filters/voxel_grid.h&gt;
-#include &lt;pcl/registration/ndt.h&gt;
+#ifdef CUDA_FOUND
+  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
 
 #include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
@@ -617,7 +618,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
   {
     ndt.omp_align(*output_cloud, init_guess);
     t_localizer = ndt.getFinalTransformation();
-    has_converged = ndt.hasConverged;
+    has_converged = ndt.hasConverged();
     fitness_score = ndt.omp_getFitnessScore();
     final_num_iteration = ndt.getFinalNumIteration();
   }
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization and mapping program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#define OUTPUT  // If you want to output &quot;position_log.txt&quot;, &quot;#define OUTPUT&quot;.

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#if defined(USE_FAST_PCL) &amp;&amp; defined(CUDA_FOUND)
#include &lt;fast_pcl/filters/voxel_grid.h&gt;
#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
#include &lt;fast_pcl/registration/ndt.h&gt;
#endif

#ifndef USE_FAST_PCL
#include &lt;pcl/filters/voxel_grid.h&gt;
#include &lt;pcl/registration/ndt.h&gt;
#endif

#include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
#include &lt;autoware_msgs/ConfigNdtMappingOutput.h&gt;

#include &lt;time.h&gt;

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

// global variables
static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom, current_pose,
    current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;  // current_pose - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
    offset_imu_odom_yaw;

static double current_velocity_x = 0.0;
static double current_velocity_y = 0.0;
static double current_velocity_z = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;

// Added for GPU ndt
#ifdef CUDA_FOUND
static gpu::GNormalDistributionsTransform gpu_ndt;
#endif
static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
// end of adding

// Default values
static int max_iter = 30;        // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

// Leaf size of VoxelGrid filter.
static double voxel_leaf_size = 2.0;

static ros::Time callback_start, callback_end, t1_start, t1_end, t2_start, t2_end, t3_start, t3_end, t4_start, t4_end,
    t5_start, t5_end;
static ros::Duration d_callback, d1, d2, d3, d4, d5;

static ros::Publisher ndt_map_pub;
static ros::Publisher current_pose_pub;
static ros::Publisher guess_pose_linaer_pub;
static geometry_msgs::PoseStamped current_pose_msg, guess_pose_msg;

static ros::Publisher ndt_stat_pub;
static std_msgs::Bool ndt_stat_msg;

static int initial_scan_loaded = 0;

static Eigen::Matrix4f gnss_transform = Eigen::Matrix4f::Identity();

static double min_scan_range = 5.0;
static double min_add_scan_shift = 1.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol, tf_ltob;

static bool isMapUpdate = true;

#ifdef USE_FAST_PCL
static bool _use_openmp = false;
#endif
#ifdef CUDA_FOUND
static bool _use_gpu = false;
#endif

static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;

static double fitness_score;
static bool has_converged;
static int final_num_iteration;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;

static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; input)
{
  ndt_res = input-&gt;resolution;
  step_size = input-&gt;step_size;
  trans_eps = input-&gt;trans_epsilon;
  max_iter = input-&gt;max_iterations;
  voxel_leaf_size = input-&gt;leaf_size;
  min_scan_range = input-&gt;min_scan_range;
  min_add_scan_shift = input-&gt;min_add_scan_shift;

  std::cout &lt;&lt; &quot;param_callback&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;ndt_res: &quot; &lt;&lt; ndt_res &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;step_size: &quot; &lt;&lt; step_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;trans_epsilon: &quot; &lt;&lt; trans_eps &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;max_iter: &quot; &lt;&lt; max_iter &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;voxel_leaf_size: &quot; &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;min_scan_range: &quot; &lt;&lt; min_scan_range &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;min_add_scan_shift: &quot; &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
}

static void output_callback(const autoware_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
{
  double filter_res = input-&gt;filter_res;
  std::string filename = input-&gt;filename;
  std::cout &lt;&lt; &quot;output_callback&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;filter_res: &quot; &lt;&lt; filter_res &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;filename: &quot; &lt;&lt; filename &lt;&lt; std::endl;

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_filtered(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  map_ptr-&gt;header.frame_id = &quot;map&quot;;
  map_filtered-&gt;header.frame_id = &quot;map&quot;;
  sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);

  // Apply voxelgrid filter
  if (filter_res == 0.0)
  {
    std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    pcl::toROSMsg(*map_ptr, *map_msg_ptr);
  }
  else
  {
    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
    voxel_grid_filter.setLeafSize(filter_res, filter_res, filter_res);
    voxel_grid_filter.setInputCloud(map_ptr);
    voxel_grid_filter.filter(*map_filtered);
    std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Filtered: &quot; &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    pcl::toROSMsg(*map_filtered, *map_msg_ptr);
  }

  ndt_map_pub.publish(*map_msg_ptr);

  // Writing Point Cloud data to PCD file
  if (filter_res == 0.0)
  {
    pcl::io::savePCDFileASCII(filename, *map_ptr);
    std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; data points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
  }
  else
  {
    pcl::io::savePCDFileASCII(filename, *map_filtered);
    std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; &quot; data points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
  }
}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw += diff_imu_yaw;

  guess_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
  guess_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
  guess_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
  guess_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
  guess_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  guess_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;

  previous_time = current_time;
}

static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);

  offset_odom_roll += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw += diff_odom_yaw;

  guess_pose_odom.x = previous_pose.x + offset_odom_x;
  guess_pose_odom.y = previous_pose.y + offset_odom_y;
  guess_pose_odom.z = previous_pose.z + offset_odom_z;
  guess_pose_odom.roll = previous_pose.roll + offset_odom_roll;
  guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  guess_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;

  previous_time = current_time;
}

static void imu_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw += diff_imu_yaw;

  guess_pose_imu.x = previous_pose.x + offset_imu_x;
  guess_pose_imu.y = previous_pose.y + offset_imu_y;
  guess_pose_imu.z = previous_pose.z + offset_imu_z;
  guess_pose_imu.roll = previous_pose.roll + offset_imu_roll;
  guess_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  guess_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;

  previous_time = current_time;
}

static double wrapToPm(double a_num, const double a_max)
{
  if (a_num &gt;= a_max)
  {
    a_num -= 2.0 * a_max;
  }
  return a_num;
}

static double wrapToPmPi(double a_angle_rad)
{
  return wrapToPm(a_angle_rad, M_PI);
}

static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}

static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll *= -1;
  input_pitch *= -1;
  input_yaw *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}

static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if (_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time = (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll = imu_roll - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if (imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
    else
      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
  }
  else
    diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if (diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw = imu_yaw;
}

static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  double r;
  pcl::PointXYZI p;
  pcl::PointCloud&lt;pcl::PointXYZI&gt; tmp, scan;
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  tf::Quaternion q;

  Eigen::Matrix4f t_localizer(Eigen::Matrix4f::Identity());
  Eigen::Matrix4f t_base_link(Eigen::Matrix4f::Identity());
  tf::TransformBroadcaster br;
  tf::Transform transform;

  current_scan_time = input-&gt;header.stamp;

  pcl::fromROSMsg(*input, tmp);

  for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++)
  {
    p.x = (double)item-&gt;x;
    p.y = (double)item-&gt;y;
    p.z = (double)item-&gt;z;
    p.intensity = (double)item-&gt;intensity;

    r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
    if (r &gt; min_scan_range)
    {
      scan.push_back(p);
    }
  }

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));

  // Add initial point cloud to velodyne_map
  if (initial_scan_loaded == 0)
  {
    pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, tf_btol);
    map += *transformed_scan_ptr;
    initial_scan_loaded = 1;
  }

  // Apply voxelgrid filter
  pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
  voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
  voxel_grid_filter.setInputCloud(scan_ptr);
  voxel_grid_filter.filter(*filtered_scan_ptr);

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));

#ifdef CUDA_FOUND
  if (_use_gpu == true)
  {
    gpu_ndt.setTransformationEpsilon(trans_eps);
    gpu_ndt.setStepSize(step_size);
    gpu_ndt.setResolution(ndt_res);
    gpu_ndt.setMaximumIterations(max_iter);
    gpu_ndt.setInputSource(filtered_scan_ptr);
  }
  else
#endif
  {
    ndt.setTransformationEpsilon(trans_eps);
    ndt.setStepSize(step_size);
    ndt.setResolution(ndt_res);
    ndt.setMaximumIterations(max_iter);
    ndt.setInputSource(filtered_scan_ptr);
  }
  if (isMapUpdate == true)
  {
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setInputTarget(map_ptr);
    }
    else
    {
      ndt.setInputTarget(map_ptr);
    }
#else
    ndt.setInputTarget(map_ptr);
#endif

    isMapUpdate = false;
  }

  guess_pose.x = previous_pose.x + diff_x;
  guess_pose.y = previous_pose.y + diff_y;
  guess_pose.z = previous_pose.z + diff_z;
  guess_pose.roll = previous_pose.roll;
  guess_pose.pitch = previous_pose.pitch;
  guess_pose.yaw = previous_pose.yaw + diff_yaw;

  if (_use_imu == true &amp;&amp; _use_odom == true)
    imu_odom_calc(current_scan_time);
  if (_use_imu == true &amp;&amp; _use_odom == false)
    imu_calc(current_scan_time);
  if (_use_imu == false &amp;&amp; _use_odom == true)
    odom_calc(current_scan_time);

  pose guess_pose_for_ndt;
  if (_use_imu == true &amp;&amp; _use_odom == true)
    guess_pose_for_ndt = guess_pose_imu_odom;
  else if (_use_imu == true &amp;&amp; _use_odom == false)
    guess_pose_for_ndt = guess_pose_imu;
  else if (_use_imu == false &amp;&amp; _use_odom == true)
    guess_pose_for_ndt = guess_pose_odom;
  else
    guess_pose_for_ndt = guess_pose;

  Eigen::AngleAxisf init_rotation_x(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
  Eigen::AngleAxisf init_rotation_y(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf init_rotation_z(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());

  Eigen::Translation3f init_translation(guess_pose_for_ndt.x, guess_pose_for_ndt.y, guess_pose_for_ndt.z);

  Eigen::Matrix4f init_guess =
      (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;

  t3_end = ros::Time::now();
  d3 = t3_end - t3_start;

  t4_start = ros::Time::now();

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
  std::cout &lt;&lt; &quot;Start aligning&quot; &lt;&lt; std::endl;

#ifdef CUDA_FOUND
  if (_use_gpu == true)
  {
    gpu_ndt.align(init_guess);
    t_localizer = gpu_ndt.getFinalTransformation();
    has_converged = gpu_ndt.hasConverged();
    fitness_score = gpu_ndt.getFitnessScore();
    final_num_iteration = ndt.getFinalNumIteration();
  }
#ifdef USE_FAST_PCL
  else if (_use_openmp == true)
  {
    ndt.omp_align(*output_cloud, init_guess);
    t_localizer = ndt.getFinalTransformation();
    has_converged = ndt.hasConverged();
    fitness_score = ndt.omp_getFitnessScore();
    final_num_iteration = ndt.getFinalNumIteration();
  }
#endif
  else
  {
    ndt.align(*output_cloud, init_guess);
    t_localizer = ndt.getFinalTransformation();
    has_converged = ndt.hasConverged();
    fitness_score = ndt.getFitnessScore();
    final_num_iteration = ndt.getFinalNumIteration();
  }
#else
#ifdef USE_FAST_PCL
  if (_use_openmp == true)
  {
    ndt.omp_align(*output_cloud, init_guess);
    t_localizer = ndt.getFinalTransformation();
    has_converged = ndt.hasConverged;
    fitness_score = ndt.omp_getFitnessScore();
    final_num_iteration = ndt.getFinalNumIteration();
  }
  else
  {
#endif
    // Added for GPU ndt
    ndt.align(*output_cloud, init_guess);
    t_localizer = ndt.getFinalTransformation();
    has_converged = ndt.hasConverged();
    fitness_score = ndt.getFitnessScore();
    final_num_iteration = ndt.getFinalNumIteration();
// End of adding GPU ndt
#ifdef USE_FAST_PCL
  }
#endif
#endif

  t_base_link = t_localizer * tf_ltob;

  pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, t_localizer);

  tf::Matrix3x3 mat_l, mat_b;

  mat_l.setValue(static_cast&lt;double&gt;(t_localizer(0, 0)), static_cast&lt;double&gt;(t_localizer(0, 1)),
                 static_cast&lt;double&gt;(t_localizer(0, 2)), static_cast&lt;double&gt;(t_localizer(1, 0)),
                 static_cast&lt;double&gt;(t_localizer(1, 1)), static_cast&lt;double&gt;(t_localizer(1, 2)),
                 static_cast&lt;double&gt;(t_localizer(2, 0)), static_cast&lt;double&gt;(t_localizer(2, 1)),
                 static_cast&lt;double&gt;(t_localizer(2, 2)));

  mat_b.setValue(static_cast&lt;double&gt;(t_base_link(0, 0)), static_cast&lt;double&gt;(t_base_link(0, 1)),
                 static_cast&lt;double&gt;(t_base_link(0, 2)), static_cast&lt;double&gt;(t_base_link(1, 0)),
                 static_cast&lt;double&gt;(t_base_link(1, 1)), static_cast&lt;double&gt;(t_base_link(1, 2)),
                 static_cast&lt;double&gt;(t_base_link(2, 0)), static_cast&lt;double&gt;(t_base_link(2, 1)),
                 static_cast&lt;double&gt;(t_base_link(2, 2)));

  // Update localizer_pose.
  localizer_pose.x = t_localizer(0, 3);
  localizer_pose.y = t_localizer(1, 3);
  localizer_pose.z = t_localizer(2, 3);
  mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

  // Update ndt_pose.
  ndt_pose.x = t_base_link(0, 3);
  ndt_pose.y = t_base_link(1, 3);
  ndt_pose.z = t_base_link(2, 3);
  mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

  current_pose.x = ndt_pose.x;
  current_pose.y = ndt_pose.y;
  current_pose.z = ndt_pose.z;
  current_pose.roll = ndt_pose.roll;
  current_pose.pitch = ndt_pose.pitch;
  current_pose.yaw = ndt_pose.yaw;

  transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
  q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
  transform.setRotation(q);

  br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;map&quot;, &quot;base_link&quot;));

  scan_duration = current_scan_time - previous_scan_time;
  double secs = scan_duration.toSec();

  // Calculate the offset (curren_pos - previous_pos)
  diff_x = current_pose.x - previous_pose.x;
  diff_y = current_pose.y - previous_pose.y;
  diff_z = current_pose.z - previous_pose.z;
  diff_yaw = current_pose.yaw - previous_pose.yaw;
  diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

  current_velocity_x = diff_x / secs;
  current_velocity_y = diff_y / secs;
  current_velocity_z = diff_z / secs;

  current_pose_imu.x = current_pose.x;
  current_pose_imu.y = current_pose.y;
  current_pose_imu.z = current_pose.z;
  current_pose_imu.roll = current_pose.roll;
  current_pose_imu.pitch = current_pose.pitch;
  current_pose_imu.yaw = current_pose.yaw;

  current_pose_odom.x = current_pose.x;
  current_pose_odom.y = current_pose.y;
  current_pose_odom.z = current_pose.z;
  current_pose_odom.roll = current_pose.roll;
  current_pose_odom.pitch = current_pose.pitch;
  current_pose_odom.yaw = current_pose.yaw;

  current_pose_imu_odom.x = current_pose.x;
  current_pose_imu_odom.y = current_pose.y;
  current_pose_imu_odom.z = current_pose.z;
  current_pose_imu_odom.roll = current_pose.roll;
  current_pose_imu_odom.pitch = current_pose.pitch;
  current_pose_imu_odom.yaw = current_pose.yaw;

  current_velocity_imu_x = current_velocity_x;
  current_velocity_imu_y = current_velocity_y;
  current_velocity_imu_z = current_velocity_z;

  // Update position and posture. current_pos -&gt; previous_pos
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  previous_scan_time.sec = current_scan_time.sec;
  previous_scan_time.nsec = current_scan_time.nsec;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;

  // Calculate the shift between added_pos and current_pos
  double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
  if (shift &gt;= min_add_scan_shift)
  {
    map += *transformed_scan_ptr;
    added_pose.x = current_pose.x;
    added_pose.y = current_pose.y;
    added_pose.z = current_pose.z;
    added_pose.roll = current_pose.roll;
    added_pose.pitch = current_pose.pitch;
    added_pose.yaw = current_pose.yaw;
    isMapUpdate = true;
  }

  sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);
  pcl::toROSMsg(*map_ptr, *map_msg_ptr);
  ndt_map_pub.publish(*map_msg_ptr);

  q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
  current_pose_msg.header.frame_id = &quot;map&quot;;
  current_pose_msg.header.stamp = current_scan_time;
  current_pose_msg.pose.position.x = current_pose.x;
  current_pose_msg.pose.position.y = current_pose.y;
  current_pose_msg.pose.position.z = current_pose.z;
  current_pose_msg.pose.orientation.x = q.x();
  current_pose_msg.pose.orientation.y = q.y();
  current_pose_msg.pose.orientation.z = q.z();
  current_pose_msg.pose.orientation.w = q.w();

  current_pose_pub.publish(current_pose_msg);

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Sequence number: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of scan points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of filtered scan points: &quot; &lt;&lt; filtered_scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;transformed_scan_ptr: &quot; &lt;&lt; transformed_scan_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;map: &quot; &lt;&lt; map.points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; has_converged &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Fitness score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of iteration: &quot; &lt;&lt; final_num_iteration &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw):&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
            &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Transformation Matrix:&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; t_localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;shift: &quot; &lt;&lt; shift &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
}

int main(int argc, char** argv)
{
  previous_pose.x = 0.0;
  previous_pose.y = 0.0;
  previous_pose.z = 0.0;
  previous_pose.roll = 0.0;
  previous_pose.pitch = 0.0;
  previous_pose.yaw = 0.0;

  ndt_pose.x = 0.0;
  ndt_pose.y = 0.0;
  ndt_pose.z = 0.0;
  ndt_pose.roll = 0.0;
  ndt_pose.pitch = 0.0;
  ndt_pose.yaw = 0.0;

  current_pose.x = 0.0;
  current_pose.y = 0.0;
  current_pose.z = 0.0;
  current_pose.roll = 0.0;
  current_pose.pitch = 0.0;
  current_pose.yaw = 0.0;

  current_pose_imu.x = 0.0;
  current_pose_imu.y = 0.0;
  current_pose_imu.z = 0.0;
  current_pose_imu.roll = 0.0;
  current_pose_imu.pitch = 0.0;
  current_pose_imu.yaw = 0.0;

  guess_pose.x = 0.0;
  guess_pose.y = 0.0;
  guess_pose.z = 0.0;
  guess_pose.roll = 0.0;
  guess_pose.pitch = 0.0;
  guess_pose.yaw = 0.0;

  added_pose.x = 0.0;
  added_pose.y = 0.0;
  added_pose.z = 0.0;
  added_pose.roll = 0.0;
  added_pose.pitch = 0.0;
  added_pose.yaw = 0.0;

  diff_x = 0.0;
  diff_y = 0.0;
  diff_z = 0.0;
  diff_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;

  ros::init(argc, argv, &quot;ndt_mapping&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

// setting parameters
#ifdef CUDA_FOUND
  private_nh.getParam(&quot;use_gpu&quot;, _use_gpu);
  std::cout &lt;&lt; &quot;use_gpu: &quot; &lt;&lt; _use_gpu &lt;&lt; std::endl;
#endif
#ifdef USE_FAST_PCL
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
#endif
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;

  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
  if (_use_gpu == true &amp;&amp; _use_openmp == true)
  {
    std::cout &lt;&lt; &quot;use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false.&quot; &lt;&lt; std::endl;
    _use_openmp = false;
  }
#endif

  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
  Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
  tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();

  map.header.frame_id = &quot;map&quot;;

  ndt_map_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/ndt_map&quot;, 1000);
  current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);

  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt_mapping&quot;, 10, param_callback);
  ros::Subscriber output_sub = nh.subscribe(&quot;config/ndt_mapping_output&quot;, 10, output_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;points_raw&quot;, 100000, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, 100000, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic, 100000, imu_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp">
				<diff>@@ -63,13 +63,13 @@
 #include &lt;pcl/point_types.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 
-#if defined(USE_FAST_PCL) &amp;&amp; defined(CUDA_FOUND)
-#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
-#include &lt;fast_pcl/registration/ndt.h&gt;
+#ifdef USE_FAST_PCL
+  #include &lt;fast_pcl/registration/ndt.h&gt;
+#else
+  #include &lt;pcl/registration/ndt.h&gt;
 #endif
-
-#ifndef USE_FAST_PCL
-#include &lt;pcl/registration/ndt.h&gt;
+#ifdef CUDA_FOUND
+  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
 
 #include &lt;pcl_ros/point_cloud.h&gt;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;

#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;tf/transform_listener.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#if defined(USE_FAST_PCL) &amp;&amp; defined(CUDA_FOUND)
#include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
#include &lt;fast_pcl/registration/ndt.h&gt;
#endif

#ifndef USE_FAST_PCL
#include &lt;pcl/registration/ndt.h&gt;
#endif

#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_ros/transforms.h&gt;

#include &lt;autoware_msgs/ConfigNdt.h&gt;

#include &lt;autoware_msgs/ndt_stat.h&gt;

#define PREDICT_POSE_THRESHOLD 0.5

#define Wa 0.4
#define Wb 0.3
#define Wc 0.3

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose,
    ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose,
    previous_gnss_pose, current_gnss_pose;

static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
    offset_imu_odom_yaw;

// Can't load if typed &quot;pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;&quot;
static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;

// If the map is loaded, map_loaded will be 1.
static int map_loaded = 0;
static int _use_gnss = 1;
static int init_pos_set = 0;

#ifdef CUDA_FOUND
static gpu::GNormalDistributionsTransform gpu_ndt;
#endif
static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;

// Default values
static int max_iter = 30;        // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

static ros::Publisher predict_pose_pub;
static geometry_msgs::PoseStamped predict_pose_msg;

static ros::Publisher predict_pose_imu_pub;
static geometry_msgs::PoseStamped predict_pose_imu_msg;

static ros::Publisher predict_pose_odom_pub;
static geometry_msgs::PoseStamped predict_pose_odom_msg;

static ros::Publisher predict_pose_imu_odom_pub;
static geometry_msgs::PoseStamped predict_pose_imu_odom_msg;

static ros::Publisher ndt_pose_pub;
static geometry_msgs::PoseStamped ndt_pose_msg;

// current_pose is published by vel_pose_mux
/*
static ros::Publisher current_pose_pub;
static geometry_msgs::PoseStamped current_pose_msg;
*/

static ros::Publisher localizer_pose_pub;
static geometry_msgs::PoseStamped localizer_pose_msg;

static ros::Publisher estimate_twist_pub;
static geometry_msgs::TwistStamped estimate_twist_msg;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double exe_time = 0.0;
static bool has_converged;
static int iteration = 0;
static double fitness_score = 0.0;
static double trans_probability = 0.0;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;

static double current_velocity = 0.0, previous_velocity = 0.0, previous_previous_velocity = 0.0;  // [m/s]
static double current_velocity_x = 0.0, previous_velocity_x = 0.0;
static double current_velocity_y = 0.0, previous_velocity_y = 0.0;
static double current_velocity_z = 0.0, previous_velocity_z = 0.0;
// static double current_velocity_yaw = 0.0, previous_velocity_yaw = 0.0;
static double current_velocity_smooth = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static double current_accel = 0.0, previous_accel = 0.0;  // [m/s^2]
static double current_accel_x = 0.0;
static double current_accel_y = 0.0;
static double current_accel_z = 0.0;
// static double current_accel_yaw = 0.0;

static double angular_velocity = 0.0;

static int use_predict_pose = 0;

static ros::Publisher estimated_vel_mps_pub, estimated_vel_kmph_pub, estimated_vel_pub;
static std_msgs::Float32 estimated_vel_mps, estimated_vel_kmph, previous_estimated_vel_kmph;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; matching_start, matching_end;

static ros::Publisher time_ndt_matching_pub;
static std_msgs::Float32 time_ndt_matching;

static int _queue_size = 1000;

static ros::Publisher ndt_stat_pub;
static autoware_msgs::ndt_stat ndt_stat_msg;

static double predict_pose_error = 0.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol;

static std::string _localizer = &quot;velodyne&quot;;
static std::string _offset = &quot;linear&quot;;  // linear, zero, quadratic

static ros::Publisher ndt_reliability_pub;
static std_msgs::Float32 ndt_reliability;

#ifdef CUDA_FOUND
static bool _use_gpu = false;
#endif
#ifdef USE_FAST_PCL
static bool _use_openmp = false;
#endif

static bool _get_height = false;
static bool _use_local_transform = false;
static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;

static std::ofstream ofs;
static std::string filename;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;

// static tf::TransformListener local_transform_listener;
static tf::StampedTransform local_transform;

static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
{
  if (_use_gnss != input-&gt;init_pos_gnss)
  {
    init_pos_set = 0;
  }
  else if (_use_gnss == 0 &amp;&amp;
           (initial_pose.x != input-&gt;x || initial_pose.y != input-&gt;y || initial_pose.z != input-&gt;z ||
            initial_pose.roll != input-&gt;roll || initial_pose.pitch != input-&gt;pitch || initial_pose.yaw != input-&gt;yaw))
  {
    init_pos_set = 0;
  }

  _use_gnss = input-&gt;init_pos_gnss;

  // Setting parameters
  if (input-&gt;resolution != ndt_res)
  {
    ndt_res = input-&gt;resolution;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setResolution(ndt_res);
    }
    else
    {
#endif
      ndt.setResolution(ndt_res);
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;step_size != step_size)
  {
    step_size = input-&gt;step_size;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setStepSize(step_size);
    }
    else
    {
#endif
      ndt.setStepSize(step_size);
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;trans_epsilon != trans_eps)
  {
    trans_eps = input-&gt;trans_epsilon;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setTransformationEpsilon(trans_eps);
    }
    else
    {
#endif
      ndt.setTransformationEpsilon(trans_eps);
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;max_iterations != max_iter)
  {
    max_iter = input-&gt;max_iterations;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setMaximumIterations(max_iter);
    }
    else
    {
#endif
      ndt.setMaximumIterations(max_iter);
#ifdef CUDA_FOUND
    }
#endif
  }

  if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
  {
    initial_pose.x = input-&gt;x;
    initial_pose.y = input-&gt;y;
    initial_pose.z = input-&gt;z;
    initial_pose.roll = input-&gt;roll;
    initial_pose.pitch = input-&gt;pitch;
    initial_pose.yaw = input-&gt;yaw;

    if (_use_local_transform == true)
    {
      tf::Vector3 v(input-&gt;x, input-&gt;y, input-&gt;z);
      tf::Quaternion q;
      q.setRPY(input-&gt;roll, input-&gt;pitch, input-&gt;yaw);
      tf::Transform transform(q, v);
      initial_pose.x = (local_transform.inverse() * transform).getOrigin().getX();
      initial_pose.y = (local_transform.inverse() * transform).getOrigin().getY();
      initial_pose.z = (local_transform.inverse() * transform).getOrigin().getZ();

      tf::Matrix3x3 m(q);
      m.getRPY(initial_pose.roll, initial_pose.pitch, initial_pose.yaw);

      std::cout &lt;&lt; &quot;initial_pose.x: &quot; &lt;&lt; initial_pose.x &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.y: &quot; &lt;&lt; initial_pose.y &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.z: &quot; &lt;&lt; initial_pose.z &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.roll: &quot; &lt;&lt; initial_pose.roll &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.pitch: &quot; &lt;&lt; initial_pose.pitch &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.yaw: &quot; &lt;&lt; initial_pose.yaw &lt;&lt; std::endl;
    }

    // Setting position and posture for the first time.
    localizer_pose.x = initial_pose.x;
    localizer_pose.y = initial_pose.y;
    localizer_pose.z = initial_pose.z;
    localizer_pose.roll = initial_pose.roll;
    localizer_pose.pitch = initial_pose.pitch;
    localizer_pose.yaw = initial_pose.yaw;

    previous_pose.x = initial_pose.x;
    previous_pose.y = initial_pose.y;
    previous_pose.z = initial_pose.z;
    previous_pose.roll = initial_pose.roll;
    previous_pose.pitch = initial_pose.pitch;
    previous_pose.yaw = initial_pose.yaw;

    current_pose.x = initial_pose.x;
    current_pose.y = initial_pose.y;
    current_pose.z = initial_pose.z;
    current_pose.roll = initial_pose.roll;
    current_pose.pitch = initial_pose.pitch;
    current_pose.yaw = initial_pose.yaw;

    current_velocity = 0;
    current_velocity_x = 0;
    current_velocity_y = 0;
    current_velocity_z = 0;
    angular_velocity = 0;

    current_pose_imu.x = 0;
    current_pose_imu.y = 0;
    current_pose_imu.z = 0;
    current_pose_imu.roll = 0;
    current_pose_imu.pitch = 0;
    current_pose_imu.yaw = 0;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;
    init_pos_set = 1;
  }
}

static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 0)
  {
    // Convert the data type(from sensor_msgs to pcl).
    pcl::fromROSMsg(*input, map);

    if (_use_local_transform == true)
    {
      tf::TransformListener local_transform_listener;
      try
      {
        ros::Time now = ros::Time(0);
        local_transform_listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
        local_transform_listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, local_transform);
      }
      catch (tf::TransformException&amp; ex)
      {
        ROS_ERROR(&quot;%s&quot;, ex.what());
      }

      pcl_ros::transformPointCloud(map, map, local_transform.inverse());
    }

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));
// Setting point cloud to be aligned to.
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setInputTarget(map_ptr);
      gpu_ndt.setMaximumIterations(max_iter);
      gpu_ndt.setResolution(ndt_res);
      gpu_ndt.setStepSize(step_size);
      gpu_ndt.setTransformationEpsilon(trans_eps);
    }
    else
    {
#endif
      ndt.setInputTarget(map_ptr);
      ndt.setMaximumIterations(max_iter);
      ndt.setResolution(ndt_res);
      ndt.setStepSize(step_size);
      ndt.setTransformationEpsilon(trans_eps);
#ifdef CUDA_FOUND
    }
#endif
    map_loaded = 1;
  }
}

static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
{
  tf::Quaternion gnss_q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z,
                        input-&gt;pose.orientation.w);
  tf::Matrix3x3 gnss_m(gnss_q);
  current_gnss_pose.x = input-&gt;pose.position.x;
  current_gnss_pose.y = input-&gt;pose.position.y;
  current_gnss_pose.z = input-&gt;pose.position.z;
  gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);

  if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= 500.0)
  {
    previous_pose.x = previous_gnss_pose.x;
    previous_pose.y = previous_gnss_pose.y;
    previous_pose.z = previous_gnss_pose.z;
    previous_pose.roll = previous_gnss_pose.roll;
    previous_pose.pitch = previous_gnss_pose.pitch;
    previous_pose.yaw = previous_gnss_pose.yaw;

    current_pose.x = current_gnss_pose.x;
    current_pose.y = current_gnss_pose.y;
    current_pose.z = current_gnss_pose.z;
    current_pose.roll = current_gnss_pose.roll;
    current_pose.pitch = current_gnss_pose.pitch;
    current_pose.yaw = current_gnss_pose.yaw;

    current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;

    offset_x = current_pose.x - previous_pose.x;
    offset_y = current_pose.y - previous_pose.y;
    offset_z = current_pose.z - previous_pose.z;
    offset_yaw = current_pose.yaw - previous_pose.yaw;

    init_pos_set = 1;
  }

  previous_gnss_pose.x = current_gnss_pose.x;
  previous_gnss_pose.y = current_gnss_pose.y;
  previous_gnss_pose.z = current_gnss_pose.z;
  previous_gnss_pose.roll = current_gnss_pose.roll;
  previous_gnss_pose.pitch = current_gnss_pose.pitch;
  previous_gnss_pose.yaw = current_gnss_pose.yaw;
}

static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
{
  tf::TransformListener listener;
  tf::StampedTransform transform;
  try
  {
    ros::Time now = ros::Time(0);
    listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
    listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, transform);
  }
  catch (tf::TransformException&amp; ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
  }

  tf::Quaternion q(input-&gt;pose.pose.orientation.x, input-&gt;pose.pose.orientation.y, input-&gt;pose.pose.orientation.z,
                   input-&gt;pose.pose.orientation.w);
  tf::Matrix3x3 m(q);

  if (_use_local_transform == true)
  {
    current_pose.x = input-&gt;pose.pose.position.x;
    current_pose.y = input-&gt;pose.pose.position.y;
    current_pose.z = input-&gt;pose.pose.position.z;
  }
  else
  {
    current_pose.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
    current_pose.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
    current_pose.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
  }
  m.getRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);

  if (_get_height == true &amp;&amp; map_loaded == 1)
  {
    double min_distance = DBL_MAX;
    double nearest_z = current_pose.z;
    for (const auto&amp; p : map)
    {
      double distance = hypot(current_pose.x - p.x, current_pose.y - p.y);
      if (distance &lt; min_distance)
      {
        min_distance = distance;
        nearest_z = p.z;
      }
    }
    current_pose.z = nearest_z;
  }

  current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  offset_x = 0.0;
  offset_y = 0.0;
  offset_z = 0.0;
  offset_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;
}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw += diff_imu_yaw;

  predict_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
  predict_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
  predict_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
  predict_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
  predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  predict_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;

  previous_time = current_time;
}

static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);

  offset_odom_roll += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw += diff_odom_yaw;

  predict_pose_odom.x = previous_pose.x + offset_odom_x;
  predict_pose_odom.y = previous_pose.y + offset_odom_y;
  predict_pose_odom.z = previous_pose.z + offset_odom_z;
  predict_pose_odom.roll = previous_pose.roll + offset_odom_roll;
  predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  predict_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;

  previous_time = current_time;
}

static void imu_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw += diff_imu_yaw;

  predict_pose_imu.x = previous_pose.x + offset_imu_x;
  predict_pose_imu.y = previous_pose.y + offset_imu_y;
  predict_pose_imu.z = previous_pose.z + offset_imu_z;
  predict_pose_imu.roll = previous_pose.roll + offset_imu_roll;
  predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  predict_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;

  previous_time = current_time;
}

static const double wrapToPm(double a_num, const double a_max)
{
  if (a_num &gt;= a_max)
  {
    a_num -= 2.0 * a_max;
  }
  return a_num;
}

static const double wrapToPmPi(double a_angle_rad)
{
  return wrapToPm(a_angle_rad, M_PI);
}

static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}

static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll *= -1;
  input_pitch *= -1;
  input_yaw *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}

static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if (_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time = (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll = imu_roll - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if (imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
    else
      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
  }
  else
    diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if (diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw = imu_yaw;
}

static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
  {
    matching_start = std::chrono::system_clock::now();

    static tf::TransformBroadcaster br;
    tf::Transform transform;
    tf::Quaternion predict_q, ndt_q, current_q, localizer_q;

    pcl::PointXYZ p;
    pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;

    current_scan_time = input-&gt;header.stamp;

    pcl::fromROSMsg(*input, filtered_scan);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan));
    int scan_points_num = filtered_scan_ptr-&gt;size();

    Eigen::Matrix4f t(Eigen::Matrix4f::Identity());   // base_link
    Eigen::Matrix4f t2(Eigen::Matrix4f::Identity());  // localizer

    std::chrono::time_point&lt;std::chrono::system_clock&gt; align_start, align_end, getFitnessScore_start,
        getFitnessScore_end;
    static double align_time, getFitnessScore_time = 0.0;

#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setInputSource(filtered_scan_ptr);
    }
    else
    {
#endif
      ndt.setInputSource(filtered_scan_ptr);
#ifdef CUDA_FOUND
    }
#endif

    // Guess the initial gross estimation of the transformation
    predict_pose.x = previous_pose.x + offset_x;
    predict_pose.y = previous_pose.y + offset_y;
    predict_pose.z = previous_pose.z + offset_z;
    predict_pose.roll = previous_pose.roll;
    predict_pose.pitch = previous_pose.pitch;
    predict_pose.yaw = previous_pose.yaw + offset_yaw;

    if (_use_imu == true &amp;&amp; _use_odom == true)
      imu_odom_calc(current_scan_time);
    if (_use_imu == true &amp;&amp; _use_odom == false)
      imu_calc(current_scan_time);
    if (_use_imu == false &amp;&amp; _use_odom == true)
      odom_calc(current_scan_time);

    pose predict_pose_for_ndt;
    if (_use_imu == true &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_imu_odom;
    else if (_use_imu == true &amp;&amp; _use_odom == false)
      predict_pose_for_ndt = predict_pose_imu;
    else if (_use_imu == false &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_odom;
    else
      predict_pose_for_ndt = predict_pose;

    Eigen::Translation3f init_translation(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z);
    Eigen::AngleAxisf init_rotation_x(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
    Eigen::AngleAxisf init_rotation_y(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
    Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      align_start = std::chrono::system_clock::now();
      gpu_ndt.align(init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = gpu_ndt.hasConverged();

      t = gpu_ndt.getFinalTransformation();
      iteration = gpu_ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = gpu_ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = gpu_ndt.getTransformationProbability();
    }
#ifdef USE_FAST_PCL
    else if (_use_openmp == true)
    {
      align_start = std::chrono::system_clock::now();
      ndt.omp_align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.omp_getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
    }
#endif
    else
    {
      align_start = std::chrono::system_clock::now();
      ndt.align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
    }
#else
#ifdef USE_FAST_PCL
    if (_use_openmp == true)
    {
      align_start = std::chrono::system_clock::now();
      ndt.omp_align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.omp_getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
    }
    else
    {
#endif
      align_start = std::chrono::system_clock::now();
      ndt.align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
#ifdef USE_FAST_PCL
    }
#endif
#endif

    align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;

    t2 = t * tf_btol.inverse();

    getFitnessScore_time =
        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() /
        1000.0;

    tf::Matrix3x3 mat_l;  // localizer
    mat_l.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)),
                   static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)),
                   static_cast&lt;double&gt;(t(2, 0)), static_cast&lt;double&gt;(t(2, 1)), static_cast&lt;double&gt;(t(2, 2)));

    // Update localizer_pose
    localizer_pose.x = t(0, 3);
    localizer_pose.y = t(1, 3);
    localizer_pose.z = t(2, 3);
    mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

    tf::Matrix3x3 mat_b;  // base_link
    mat_b.setValue(static_cast&lt;double&gt;(t2(0, 0)), static_cast&lt;double&gt;(t2(0, 1)), static_cast&lt;double&gt;(t2(0, 2)),
                   static_cast&lt;double&gt;(t2(1, 0)), static_cast&lt;double&gt;(t2(1, 1)), static_cast&lt;double&gt;(t2(1, 2)),
                   static_cast&lt;double&gt;(t2(2, 0)), static_cast&lt;double&gt;(t2(2, 1)), static_cast&lt;double&gt;(t2(2, 2)));

    // Update ndt_pose
    ndt_pose.x = t2(0, 3);
    ndt_pose.y = t2(1, 3);
    ndt_pose.z = t2(2, 3);
    mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

    // Calculate the difference between ndt_pose and predict_pose
    predict_pose_error = sqrt((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) +
                              (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) +
                              (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));

    if (predict_pose_error &lt;= PREDICT_POSE_THRESHOLD)
    {
      use_predict_pose = 0;
    }
    else
    {
      use_predict_pose = 1;
    }
    use_predict_pose = 0;

    if (use_predict_pose == 0)
    {
      current_pose.x = ndt_pose.x;
      current_pose.y = ndt_pose.y;
      current_pose.z = ndt_pose.z;
      current_pose.roll = ndt_pose.roll;
      current_pose.pitch = ndt_pose.pitch;
      current_pose.yaw = ndt_pose.yaw;
    }
    else
    {
      current_pose.x = predict_pose_for_ndt.x;
      current_pose.y = predict_pose_for_ndt.y;
      current_pose.z = predict_pose_for_ndt.z;
      current_pose.roll = predict_pose_for_ndt.roll;
      current_pose.pitch = predict_pose_for_ndt.pitch;
      current_pose.yaw = predict_pose_for_ndt.yaw;
    }

    // Compute the velocity and acceleration
    scan_duration = current_scan_time - previous_scan_time;
    double secs = scan_duration.toSec();
    diff_x = current_pose.x - previous_pose.x;
    diff_y = current_pose.y - previous_pose.y;
    diff_z = current_pose.z - previous_pose.z;
    diff_yaw = current_pose.yaw - previous_pose.yaw;
    diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

    current_velocity = diff / secs;
    current_velocity_x = diff_x / secs;
    current_velocity_y = diff_y / secs;
    current_velocity_z = diff_z / secs;
    angular_velocity = diff_yaw / secs;

    current_pose_imu.x = current_pose.x;
    current_pose_imu.y = current_pose.y;
    current_pose_imu.z = current_pose.z;
    current_pose_imu.roll = current_pose.roll;
    current_pose_imu.pitch = current_pose.pitch;
    current_pose_imu.yaw = current_pose.yaw;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;

    current_pose_odom.x = current_pose.x;
    current_pose_odom.y = current_pose.y;
    current_pose_odom.z = current_pose.z;
    current_pose_odom.roll = current_pose.roll;
    current_pose_odom.pitch = current_pose.pitch;
    current_pose_odom.yaw = current_pose.yaw;

    current_pose_imu_odom.x = current_pose.x;
    current_pose_imu_odom.y = current_pose.y;
    current_pose_imu_odom.z = current_pose.z;
    current_pose_imu_odom.roll = current_pose.roll;
    current_pose_imu_odom.pitch = current_pose.pitch;
    current_pose_imu_odom.yaw = current_pose.yaw;

    current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
    if (current_velocity_smooth &lt; 0.2)
    {
      current_velocity_smooth = 0.0;
    }

    current_accel = (current_velocity - previous_velocity) / secs;
    current_accel_x = (current_velocity_x - previous_velocity_x) / secs;
    current_accel_y = (current_velocity_y - previous_velocity_y) / secs;
    current_accel_z = (current_velocity_z - previous_velocity_z) / secs;

    estimated_vel_mps.data = current_velocity;
    estimated_vel_kmph.data = current_velocity * 3.6;

    estimated_vel_mps_pub.publish(estimated_vel_mps);
    estimated_vel_kmph_pub.publish(estimated_vel_kmph);

    // Set values for publishing pose
    predict_q.setRPY(predict_pose.roll, predict_pose.pitch, predict_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(predict_pose.x, predict_pose.y, predict_pose.z);
      tf::Transform transform(predict_q, v);
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      predict_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      predict_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      predict_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      predict_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      predict_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      predict_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = predict_pose.x;
      predict_pose_msg.pose.position.y = predict_pose.y;
      predict_pose_msg.pose.position.z = predict_pose.z;
      predict_pose_msg.pose.orientation.x = predict_q.x();
      predict_pose_msg.pose.orientation.y = predict_q.y();
      predict_pose_msg.pose.orientation.z = predict_q.z();
      predict_pose_msg.pose.orientation.w = predict_q.w();
    }

    tf::Quaternion predict_q_imu;
    predict_q_imu.setRPY(predict_pose_imu.roll, predict_pose_imu.pitch, predict_pose_imu.yaw);
    predict_pose_imu_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_msg.pose.position.x = predict_pose_imu.x;
    predict_pose_imu_msg.pose.position.y = predict_pose_imu.y;
    predict_pose_imu_msg.pose.position.z = predict_pose_imu.z;
    predict_pose_imu_msg.pose.orientation.x = predict_q_imu.x();
    predict_pose_imu_msg.pose.orientation.y = predict_q_imu.y();
    predict_pose_imu_msg.pose.orientation.z = predict_q_imu.z();
    predict_pose_imu_msg.pose.orientation.w = predict_q_imu.w();
    predict_pose_imu_pub.publish(predict_pose_imu_msg);

    tf::Quaternion predict_q_odom;
    predict_q_odom.setRPY(predict_pose_odom.roll, predict_pose_odom.pitch, predict_pose_odom.yaw);
    predict_pose_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_odom_msg.pose.position.x = predict_pose_odom.x;
    predict_pose_odom_msg.pose.position.y = predict_pose_odom.y;
    predict_pose_odom_msg.pose.position.z = predict_pose_odom.z;
    predict_pose_odom_msg.pose.orientation.x = predict_q_odom.x();
    predict_pose_odom_msg.pose.orientation.y = predict_q_odom.y();
    predict_pose_odom_msg.pose.orientation.z = predict_q_odom.z();
    predict_pose_odom_msg.pose.orientation.w = predict_q_odom.w();
    predict_pose_odom_pub.publish(predict_pose_odom_msg);

    tf::Quaternion predict_q_imu_odom;
    predict_q_imu_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
    predict_pose_imu_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_odom_msg.pose.position.x = predict_pose_imu_odom.x;
    predict_pose_imu_odom_msg.pose.position.y = predict_pose_imu_odom.y;
    predict_pose_imu_odom_msg.pose.position.z = predict_pose_imu_odom.z;
    predict_pose_imu_odom_msg.pose.orientation.x = predict_q_imu_odom.x();
    predict_pose_imu_odom_msg.pose.orientation.y = predict_q_imu_odom.y();
    predict_pose_imu_odom_msg.pose.orientation.z = predict_q_imu_odom.z();
    predict_pose_imu_odom_msg.pose.orientation.w = predict_q_imu_odom.w();
    predict_pose_imu_odom_pub.publish(predict_pose_imu_odom_msg);

    ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(ndt_pose.x, ndt_pose.y, ndt_pose.z);
      tf::Transform transform(ndt_q, v);
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      ndt_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      ndt_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      ndt_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      ndt_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      ndt_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      ndt_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = ndt_pose.x;
      ndt_pose_msg.pose.position.y = ndt_pose.y;
      ndt_pose_msg.pose.position.z = ndt_pose.z;
      ndt_pose_msg.pose.orientation.x = ndt_q.x();
      ndt_pose_msg.pose.orientation.y = ndt_q.y();
      ndt_pose_msg.pose.orientation.z = ndt_q.z();
      ndt_pose_msg.pose.orientation.w = ndt_q.w();
    }

    current_q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
    // current_pose is published by vel_pose_mux
    /*
    current_pose_msg.header.frame_id = &quot;/map&quot;;
    current_pose_msg.header.stamp = current_scan_time;
    current_pose_msg.pose.position.x = current_pose.x;
    current_pose_msg.pose.position.y = current_pose.y;
    current_pose_msg.pose.position.z = current_pose.z;
    current_pose_msg.pose.orientation.x = current_q.x();
    current_pose_msg.pose.orientation.y = current_q.y();
    current_pose_msg.pose.orientation.z = current_q.z();
    current_pose_msg.pose.orientation.w = current_q.w();
    */

    localizer_q.setRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(localizer_pose.x, localizer_pose.y, localizer_pose.z);
      tf::Transform transform(localizer_q, v);
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      localizer_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      localizer_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      localizer_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      localizer_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      localizer_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      localizer_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = localizer_pose.x;
      localizer_pose_msg.pose.position.y = localizer_pose.y;
      localizer_pose_msg.pose.position.z = localizer_pose.z;
      localizer_pose_msg.pose.orientation.x = localizer_q.x();
      localizer_pose_msg.pose.orientation.y = localizer_q.y();
      localizer_pose_msg.pose.orientation.z = localizer_q.z();
      localizer_pose_msg.pose.orientation.w = localizer_q.w();
    }

    predict_pose_pub.publish(predict_pose_msg);
    ndt_pose_pub.publish(ndt_pose_msg);
    // current_pose is published by vel_pose_mux
    //    current_pose_pub.publish(current_pose_msg);
    localizer_pose_pub.publish(localizer_pose_msg);

    // Send TF &quot;/base_link&quot; to &quot;/map&quot;
    transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
    transform.setRotation(current_q);
    //    br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    if (_use_local_transform == true)
    {
      br.sendTransform(tf::StampedTransform(local_transform * transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }
    else
    {
      br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }

    matching_end = std::chrono::system_clock::now();
    exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
    time_ndt_matching.data = exe_time;
    time_ndt_matching_pub.publish(time_ndt_matching);

    // Set values for /estimate_twist
    estimate_twist_msg.header.stamp = current_scan_time;
    estimate_twist_msg.header.frame_id = &quot;/base_link&quot;;
    estimate_twist_msg.twist.linear.x = current_velocity;
    estimate_twist_msg.twist.linear.y = 0.0;
    estimate_twist_msg.twist.linear.z = 0.0;
    estimate_twist_msg.twist.angular.x = 0.0;
    estimate_twist_msg.twist.angular.y = 0.0;
    estimate_twist_msg.twist.angular.z = angular_velocity;

    estimate_twist_pub.publish(estimate_twist_msg);

    geometry_msgs::Vector3Stamped estimate_vel_msg;
    estimate_vel_msg.header.stamp = current_scan_time;
    estimate_vel_msg.vector.x = current_velocity;
    estimated_vel_pub.publish(estimate_vel_msg);

    // Set values for /ndt_stat
    ndt_stat_msg.header.stamp = current_scan_time;
    ndt_stat_msg.exe_time = time_ndt_matching.data;
    ndt_stat_msg.iteration = iteration;
    ndt_stat_msg.score = fitness_score;
    ndt_stat_msg.velocity = current_velocity;
    ndt_stat_msg.acceleration = current_accel;
    ndt_stat_msg.use_predict_pose = 0;

    ndt_stat_pub.publish(ndt_stat_msg);
    /* Compute NDT_Reliability */
    ndt_reliability.data = Wa * (exe_time / 100.0) * 100.0 + Wb * (iteration / 10.0) * 100.0 +
                           Wc * ((2.0 - trans_probability) / 2.0) * 100.0;
    ndt_reliability_pub.publish(ndt_reliability);

    // Write log
    if (!ofs)
    {
      std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      exit(1);
    }
    static ros::Time start_time = input-&gt;header.stamp;

    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; &quot;,&quot; &lt;&lt; scan_points_num &lt;&lt; &quot;,&quot; &lt;&lt; step_size &lt;&lt; &quot;,&quot; &lt;&lt; trans_eps &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed
        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.pitch
        &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.y &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.z &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose_error &lt;&lt; &quot;,&quot; &lt;&lt; iteration &lt;&lt; &quot;,&quot; &lt;&lt; fitness_score &lt;&lt; &quot;,&quot; &lt;&lt; trans_probability &lt;&lt; &quot;,&quot;
        &lt;&lt; ndt_reliability.data &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity_smooth &lt;&lt; &quot;,&quot; &lt;&lt; current_accel
        &lt;&lt; &quot;,&quot; &lt;&lt; angular_velocity &lt;&lt; &quot;,&quot; &lt;&lt; time_ndt_matching.data &lt;&lt; &quot;,&quot; &lt;&lt; align_time &lt;&lt; &quot;,&quot; &lt;&lt; getFitnessScore_time
        &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Sequence: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Timestamp: &quot; &lt;&lt; input-&gt;header.stamp &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Frame ID: &quot; &lt;&lt; input-&gt;header.frame_id &lt;&lt; std::endl;
    //		std::cout &lt;&lt; &quot;Number of Scan Points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Filtered Scan Points: &quot; &lt;&lt; scan_points_num &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; has_converged &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Fitness Score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Probability: &quot; &lt;&lt; trans_probability &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Execution Time: &quot; &lt;&lt; exe_time &lt;&lt; &quot; ms.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Iterations: &quot; &lt;&lt; iteration &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT Reliability: &quot; &lt;&lt; ndt_reliability.data &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw): &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
              &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Matrix: &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; t &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Align time: &quot; &lt;&lt; align_time &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Get fitness score time: &quot; &lt;&lt; getFitnessScore_time &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

    // Update offset
    if (_offset == &quot;linear&quot;)
    {
      offset_x = diff_x;
      offset_y = diff_y;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;quadratic&quot;)
    {
      offset_x = (current_velocity_x + current_accel_x * secs) * secs;
      offset_y = (current_velocity_y + current_accel_y * secs) * secs;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;zero&quot;)
    {
      offset_x = 0.0;
      offset_y = 0.0;
      offset_z = 0.0;
      offset_yaw = 0.0;
    }

    offset_imu_x = 0.0;
    offset_imu_y = 0.0;
    offset_imu_z = 0.0;
    offset_imu_roll = 0.0;
    offset_imu_pitch = 0.0;
    offset_imu_yaw = 0.0;

    offset_odom_x = 0.0;
    offset_odom_y = 0.0;
    offset_odom_z = 0.0;
    offset_odom_roll = 0.0;
    offset_odom_pitch = 0.0;
    offset_odom_yaw = 0.0;

    offset_imu_odom_x = 0.0;
    offset_imu_odom_y = 0.0;
    offset_imu_odom_z = 0.0;
    offset_imu_odom_roll = 0.0;
    offset_imu_odom_pitch = 0.0;
    offset_imu_odom_yaw = 0.0;

    // Update previous_***
    previous_pose.x = current_pose.x;
    previous_pose.y = current_pose.y;
    previous_pose.z = current_pose.z;
    previous_pose.roll = current_pose.roll;
    previous_pose.pitch = current_pose.pitch;
    previous_pose.yaw = current_pose.yaw;

    previous_scan_time.sec = current_scan_time.sec;
    previous_scan_time.nsec = current_scan_time.nsec;

    previous_previous_velocity = previous_velocity;
    previous_velocity = current_velocity;
    previous_velocity_x = current_velocity_x;
    previous_velocity_y = current_velocity_y;
    previous_velocity_z = current_velocity_z;
    previous_accel = current_accel;

    previous_estimated_vel_kmph.data = estimated_vel_kmph.data;
  }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;ndt_matching&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  // Set log file name.
  char buffer[80];
  std::time_t now = std::time(NULL);
  std::tm* pnow = std::localtime(&amp;now);
  std::strftime(buffer, 80, &quot;%Y%m%d_%H%M%S&quot;, pnow);
  filename = &quot;ndt_matching_&quot; + std::string(buffer) + &quot;.csv&quot;;
  ofs.open(filename.c_str(), std::ios::app);

  // Geting parameters
  private_nh.getParam(&quot;use_gnss&quot;, _use_gnss);
  private_nh.getParam(&quot;queue_size&quot;, _queue_size);
  private_nh.getParam(&quot;offset&quot;, _offset);
#ifdef USE_FAST_PCL
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
#endif
#ifdef CUDA_FOUND
  private_nh.getParam(&quot;use_gpu&quot;, _use_gpu);
#endif
  private_nh.getParam(&quot;get_height&quot;, _get_height);
  private_nh.getParam(&quot;use_local_transform&quot;, _use_local_transform);
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
  if (_use_gpu == true &amp;&amp; _use_openmp == true)
  {
    std::cout &lt;&lt; &quot;use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false.&quot; &lt;&lt; std::endl;
    _use_openmp = false;
  }
#endif

  if (nh.getParam(&quot;localizer&quot;, _localizer) == false)
  {
    std::cout &lt;&lt; &quot;localizer is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Log file: &quot; &lt;&lt; filename &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_gnss: &quot; &lt;&lt; _use_gnss &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;queue_size: &quot; &lt;&lt; _queue_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;offset: &quot; &lt;&lt; _offset &lt;&lt; std::endl;
#ifdef CUDA_FOUND
  std::cout &lt;&lt; &quot;use_gpu: &quot; &lt;&lt; _use_gpu &lt;&lt; std::endl;
#endif
#ifdef USE_FAST_PCL
  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
#endif
  std::cout &lt;&lt; &quot;get_height: &quot; &lt;&lt; _get_height &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_local_transform: &quot; &lt;&lt; _use_local_transform &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;localizer: &quot; &lt;&lt; _localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  // Updated in initialpose_callback or gnss_callback
  initial_pose.x = 0.0;
  initial_pose.y = 0.0;
  initial_pose.z = 0.0;
  initial_pose.roll = 0.0;
  initial_pose.pitch = 0.0;
  initial_pose.yaw = 0.0;

  // Publishers
  predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose&quot;, 1000);
  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu&quot;, 1000);
  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_odom&quot;, 1000);
  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu_odom&quot;, 1000);
  ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/ndt_pose&quot;, 1000);
  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);
  localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/localizer_pose&quot;, 1000);
  estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;/estimate_twist&quot;, 1000);
  estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_mps&quot;, 1000);
  estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_kmph&quot;, 1000);
  estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;(&quot;/estimated_vel&quot;, 1000);
  time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/time_ndt_matching&quot;, 1000);
  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;(&quot;/ndt_stat&quot;, 1000);
  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/ndt_reliability&quot;, 1000);

  // Subscribers
  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt&quot;, 10, param_callback);
  ros::Subscriber gnss_sub = nh.subscribe(&quot;gnss_pose&quot;, 10, gnss_callback);
  ros::Subscriber map_sub = nh.subscribe(&quot;points_map&quot;, 10, map_callback);
  ros::Subscriber initialpose_sub = nh.subscribe(&quot;initialpose&quot;, 1000, initialpose_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;filtered_points&quot;, _queue_size, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, _queue_size * 10, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size * 10, imu_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="b1d1d49e88f5044a4010f749b9cd5c193f80a4a0" fix_time="797,6359">
		<msg>fix pos_downloader WIP</msg>
		<modified_files>
			<file old_path="ros/src/data/packages/pos_db/nodes/pos_downloader/pos_downloader.cpp" new_path="ros/src/data/packages/pos_db/nodes/pos_downloader/pos_downloader.cpp">
				<diff>@@ -37,7 +37,7 @@ publish data as ractangular plane
 #include &quot;ros/ros.h&quot;
 #include &quot;std_msgs/String.h&quot;
 #include &lt;visualization_msgs/Marker.h&gt;
-#include &lt;jsk_rviz_plugins/PictogramArray&gt;
+#include &lt;jsk_rviz_plugins/Pictogram&gt;
 #include &lt;cstdio&gt;
 #include &lt;cstdlib&gt;
 #include &lt;vector&gt;
@@ -126,29 +126,29 @@ static std::vector&lt;std::string&gt; split(const string&amp; input, char delimiter)
     return result;
 }
 
-static void dbg_out_marker(visualization_msgs::Marker marker)
+static void dbg_out_marker(jsk_rviz_plugins::Pictogram pictogram)
 {
 #ifdef POS_DB_VERBOSE
   std::cout &lt;&lt; marker.id &lt;&lt; &quot; : &quot;
-	&lt;&lt; marker.pose.position.x &lt;&lt; &quot;,&quot;
-	&lt;&lt; marker.pose.position.y &lt;&lt; &quot;,&quot;
-	&lt;&lt; marker.pose.position.z &lt;&lt; &quot; : &quot;
-	&lt;&lt; marker.pose.orientation.x &lt;&lt; &quot;,&quot;
-	&lt;&lt; marker.pose.orientation.y &lt;&lt; &quot;,&quot;
-	&lt;&lt; marker.pose.orientation.z &lt;&lt; &quot;,&quot;
-	&lt;&lt; marker.pose.orientation.w &lt;&lt; std::endl;
+	&lt;&lt; pictogram.pose.position.x &lt;&lt; &quot;,&quot;
+	&lt;&lt; pictogram.pose.position.y &lt;&lt; &quot;,&quot;
+	&lt;&lt; pictogram.pose.position.z &lt;&lt; &quot; : &quot;
+	&lt;&lt; pictogram.pose.orientation.x &lt;&lt; &quot;,&quot;
+	&lt;&lt; pictogram.pose.orientation.y &lt;&lt; &quot;,&quot;
+	&lt;&lt; pictogram.pose.orientation.z &lt;&lt; &quot;,&quot;
+	&lt;&lt; pictogram.pose.orientation.w &lt;&lt; std::endl;
 #endif /* POS_DB_VERBOSE */
 }
 
 static void publish_car(int id, int is_current, ros::Time now,
 		       geometry_msgs::Pose&amp; pose, int diffmsec)
 {
-  visualization_msgs::Marker marker;
-  marker.header.frame_id = &quot;/map&quot;;
-  marker.header.stamp = now;
+  jsk_rviz_plugins::Pictogram pictogram;
+  pictogram.header.frame_id = &quot;/map&quot;;
+  pictogram.header.stamp = now;
   marker.ns = MARKERNAME;
-  marker.action = visualization_msgs::Marker::ADD;
-  marker.pose = pose;
+  pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
+  pictogram.pose = pose;
   if (is_current) {
 #ifdef CURRENT_CAR_DIRECTLY
     marker.id = id;
@@ -166,15 +166,15 @@ static void publish_car(int id, int is_current, ros::Time now,
 
     tf::Quaternion q1;
     q1.setRPY(M_PI/2, 0, M_PI);
-    tf::Quaternion q2(marker.pose.orientation.x, marker.pose.orientation.y, marker.pose.orientation.z, marker.pose.orientation.w);
+    tf::Quaternion q2(pictogram.pose.orientation.x, pictogram.pose.orientation.y, pictogram.pose.orientation.z, pictogram.pose.orientation.w);
     tf::Quaternion q3;
     q3 = q2 * q1;
 
-    marker.pose.position.z -= 2.0;
-    marker.pose.orientation.x = q3.x();
-    marker.pose.orientation.y = q3.y();
-    marker.pose.orientation.z = q3.z();
-    marker.pose.orientation.w = q3.w();
+    pictogram.pose.position.z -= 2.0;
+    pictogram.pose.orientation.x = q3.x();
+    pictogram.pose.orientation.y = q3.y();
+    pictogram.pose.orientation.z = q3.z();
+    pictogram.pose.orientation.w = q3.w();
 
     pub.publish(marker);
     dbg_out_marker(marker);
@@ -197,7 +197,7 @@ static void publish_car(int id, int is_current, ros::Time now,
     marker.scale.x = 2.0;
     marker.scale.y = 2.0;
     marker.scale.z = 2.0;
-    marker.pose.position.z += 0.5; // == #1/2
+    pictogram.pose.position.z += 0.5; // == #1/2
     pub.publish(marker);
     dbg_out_marker(marker);
   }
@@ -206,7 +206,7 @@ static void publish_car(int id, int is_current, ros::Time now,
 #ifndef CURRENT_CAR_DIRECTLY
 static void publish_car_summary(ros::Time now)
 {
-  visualization_msgs::Marker marker;
+  jsk_rviz_plugins::Pictogram pictogram;
   map&lt;int, geometry_msgs::Pose&gt;::iterator itr;
 
   for(itr = car_map.begin(); itr != car_map.end(); itr++) {
@@ -216,12 +216,12 @@ static void publish_car_summary(ros::Time now)
     if (prev_map.count(id) &gt; 0 &amp;&amp; cur &lt;= prev_map[id]) {
       continue;
     }
-    marker.header.frame_id = &quot;/map&quot;;
-    marker.header.stamp = cur;
+    pictogram.header.frame_id = &quot;/map&quot;;
+    pictogram.header.stamp = cur;
     marker.ns = MARKERNAME;
-    marker.action = visualization_msgs::Marker::ADD;
+    pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
     marker.id = id;
-    marker.pose = pose;
+    pictogram.pose = pose;
     marker.type = visualization_msgs::Marker::MESH_RESOURCE;
     marker.mesh_resource = &quot;package://pos_db/model/prius_model.dae&quot;;
     marker.mesh_use_embedded_materials = true;
@@ -236,15 +236,15 @@ static void publish_car_summary(ros::Time now)
 
     tf::Quaternion q1;
     q1.setRPY(M_PI/2, 0, M_PI);
-    tf::Quaternion q2(marker.pose.orientation.x, marker.pose.orientation.y, marker.pose.orientation.z, marker.pose.orientation.w);
+    tf::Quaternion q2(pictogram.pose.orientation.x, pictogram.pose.orientation.y, pictogram.pose.orientation.z, pictogram.pose.orientation.w);
     tf::Quaternion q3;
     q3 = q2 * q1;
 
-    marker.pose.position.z -= 2.0;
-    marker.pose.orientation.x = q3.x();
-    marker.pose.orientation.y = q3.y();
-    marker.pose.orientation.z = q3.z();
-    marker.pose.orientation.w = q3.w();
+    pictogram.pose.position.z -= 2.0;
+    pictogram.pose.orientation.x = q3.x();
+    pictogram.pose.orientation.y = q3.y();
+    pictogram.pose.orientation.z = q3.z();
+    pictogram.pose.orientation.w = q3.w();
 
     pub.publish(marker);
     dbg_out_marker(marker);
@@ -258,11 +258,11 @@ static void publish_car_summary(ros::Time now)
 static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
 			      geometry_msgs::Pose&amp; pose, int diffmsec)
 {
-  visualization_msgs::Marker marker;
-  marker.header.frame_id = &quot;/map&quot;;
-  marker.header.stamp = now;
+  jsk_rviz_plugins::Pictogram pictogram;
+  pictogram.header.frame_id = &quot;/map&quot;;
+  pictogram.header.stamp = now;
   marker.ns = MARKERNAME;
-  marker.action = visualization_msgs::Marker::ADD;
+  pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
   marker.type = visualization_msgs::Marker::CYLINDER;
   marker.lifetime = ros::Duration(life_time);
   marker.id = create_markerid(pose, 2);
@@ -281,8 +281,8 @@ static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
   marker.scale.x = 0.6;
   marker.scale.y = 0.6;
   marker.scale.z = 1.2; // #1
-  marker.pose = pose;
-  marker.pose.position.z += 0.6; // == #1/2
+  pictogram.pose = pose;
+  pictogram.pose.position.z += 0.6; // == #1/2
   pub.publish(marker);
   dbg_out_marker(marker);
 
@@ -291,8 +291,8 @@ static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
   marker.scale.x = 0.6; // #2
   marker.scale.y = 0.6;
   marker.scale.z = 0.6;
-  marker.pose = pose;
-  marker.pose.position.z += 1.2 + 0.3 + 0.1; // == #1 + #2/2 + alpha
+  pictogram.pose = pose;
+  pictogram.pose.position.z += 1.2 + 0.3 + 0.1; // == #1 + #2/2 + alpha
   pub.publish(marker);
   dbg_out_marker(marker);
 }
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
pos_downloader
This node get location data from db server and
publish data as ractangular plane
*/

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/String.h&quot;
#include &lt;visualization_msgs/Marker.h&gt;
#include &lt;jsk_rviz_plugins/PictogramArray&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;
#ifndef CURRENT_CAR_DIRECTLY
#include &lt;map&gt;
#endif /* ! CURRENT_CAR_DIRECTLY */
#include &lt;pthread.h&gt;

#include &lt;geo_pos_conv.hh&gt;
#include &lt;pos_db.h&gt;

#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;

#define MYNAME		&quot;pos_downloader&quot;
#define MARKERNAME	&quot;mo_marker&quot;
#define STARTTIME	(0)		// sec since 1970-01-01 (0==now)
#define DELAYSEC	(0)		// delay sec for pos_uploader
#define POSUP_DZ	(40)		// z offset of PosUp
#define PEDESTRIAN_DZ	(-2)		// z offset of pedestrian_pose
#define DOWNLOAD_PERIOD	(250)		// period (msec)
#define TOTAL_LIFETIME	(10.0)		// total lifetime (sec)

#define TYPE_OWN	(1)
#define TYPE_CAR	(2)
#define TYPE_PEDESTRIAN	(3)

#define ANON_MARKER_ID_MIN	(2)
#define ANON_MARKER_ID_MAX	(0x7f000000)

using namespace std;

static string db_host_name;
static int db_port;
static string sshpubkey;
static string sshprivatekey;
static int ssh_port;
static string sshtunnelhost;
static int sleep_msec = DOWNLOAD_PERIOD;	// period
static double life_time = 1.0;			// sec
static double posup_dz;
static double pedestrian_dz;

static ros::Publisher pub;

static SendData sd;

static char mac_addr[MAC_ADDRBUFSIZ];
static int ignore_my_pose = 1;

#ifndef CURRENT_CAR_DIRECTLY
static map&lt;int, geometry_msgs::Pose&gt; car_map;
static map&lt;int, ros::Time&gt; now_map;
static map&lt;int, ros::Time&gt; prev_map;
#endif /* ! CURRENT_CAR_DIRECTLY */

#ifdef NEVER
static double color_percent(int diffmsec)
{
  return (1.0 - diffmsec/TOTAL_LIFETIME/1000.0)*((256-48)/256.0) + (48/256.0);
}
#endif /* NEVER */
static double alpha_percent(int diffmsec)
{
  return (1.0 - diffmsec/TOTAL_LIFETIME/1000.0);
}

static int create_markerid(geometry_msgs::Pose&amp; pose, int type)
{
  return (int)(pose.position.x*11 + pose.position.y*13 + pose.position.z + type*5) % ANON_MARKER_ID_MAX;
}

static std::vector&lt;std::string&gt; split(const string&amp; input, char delimiter)
{
    std::istringstream stream(input);

    std::string field;
    std::vector&lt;std::string&gt; result;
    while (std::getline(stream, field, delimiter)) {
        result.push_back(field);
    }
    return result;
}

static void dbg_out_marker(visualization_msgs::Marker marker)
{
#ifdef POS_DB_VERBOSE
  std::cout &lt;&lt; marker.id &lt;&lt; &quot; : &quot;
	&lt;&lt; marker.pose.position.x &lt;&lt; &quot;,&quot;
	&lt;&lt; marker.pose.position.y &lt;&lt; &quot;,&quot;
	&lt;&lt; marker.pose.position.z &lt;&lt; &quot; : &quot;
	&lt;&lt; marker.pose.orientation.x &lt;&lt; &quot;,&quot;
	&lt;&lt; marker.pose.orientation.y &lt;&lt; &quot;,&quot;
	&lt;&lt; marker.pose.orientation.z &lt;&lt; &quot;,&quot;
	&lt;&lt; marker.pose.orientation.w &lt;&lt; std::endl;
#endif /* POS_DB_VERBOSE */
}

static void publish_car(int id, int is_current, ros::Time now,
		       geometry_msgs::Pose&amp; pose, int diffmsec)
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;/map&quot;;
  marker.header.stamp = now;
  marker.ns = MARKERNAME;
  marker.action = visualization_msgs::Marker::ADD;
  marker.pose = pose;
  if (is_current) {
#ifdef CURRENT_CAR_DIRECTLY
    marker.id = id;
    marker.type = visualization_msgs::Marker::MESH_RESOURCE;
    marker.mesh_resource = &quot;package://pos_db/model/prius_model.dae&quot;;
    marker.mesh_use_embedded_materials = true;
    marker.lifetime = ros::Duration();
    marker.color.r = 0.0;
    marker.color.g = 0.0;
    marker.color.b = 0.0;
    marker.color.a = 0.0;
    marker.scale.x = 1.0;
    marker.scale.y = 1.0;
    marker.scale.z = 1.0;

    tf::Quaternion q1;
    q1.setRPY(M_PI/2, 0, M_PI);
    tf::Quaternion q2(marker.pose.orientation.x, marker.pose.orientation.y, marker.pose.orientation.z, marker.pose.orientation.w);
    tf::Quaternion q3;
    q3 = q2 * q1;

    marker.pose.position.z -= 2.0;
    marker.pose.orientation.x = q3.x();
    marker.pose.orientation.y = q3.y();
    marker.pose.orientation.z = q3.z();
    marker.pose.orientation.w = q3.w();

    pub.publish(marker);
    dbg_out_marker(marker);
#else /* CURRENT_CAR_DIRECTLY */
    ros::Time newnow = now - ros::Duration(diffmsec/1000.0);
    if (now_map.count(id) == 0 || newnow &gt;= now_map[id]) {
      car_map[id] = pose;
      now_map[id] = newnow;
    }
#endif /* CURRENT_CAR_DIRECTLY */

  } else {
    marker.id = create_markerid(pose, 1);
    marker.type = visualization_msgs::Marker::SPHERE;
    marker.lifetime = ros::Duration(life_time);
    marker.color.r = 1.0;
    marker.color.g = 0.0;
    marker.color.b = 0.0;
    marker.color.a = alpha_percent(diffmsec);
    marker.scale.x = 2.0;
    marker.scale.y = 2.0;
    marker.scale.z = 2.0;
    marker.pose.position.z += 0.5; // == #1/2
    pub.publish(marker);
    dbg_out_marker(marker);
  }
}

#ifndef CURRENT_CAR_DIRECTLY
static void publish_car_summary(ros::Time now)
{
  visualization_msgs::Marker marker;
  map&lt;int, geometry_msgs::Pose&gt;::iterator itr;

  for(itr = car_map.begin(); itr != car_map.end(); itr++) {
    int id = itr-&gt;first;
    geometry_msgs::Pose pose = itr-&gt;second;
    ros::Time cur = now_map[id];
    if (prev_map.count(id) &gt; 0 &amp;&amp; cur &lt;= prev_map[id]) {
      continue;
    }
    marker.header.frame_id = &quot;/map&quot;;
    marker.header.stamp = cur;
    marker.ns = MARKERNAME;
    marker.action = visualization_msgs::Marker::ADD;
    marker.id = id;
    marker.pose = pose;
    marker.type = visualization_msgs::Marker::MESH_RESOURCE;
    marker.mesh_resource = &quot;package://pos_db/model/prius_model.dae&quot;;
    marker.mesh_use_embedded_materials = true;
    marker.lifetime = ros::Duration();
    marker.color.r = 0.0;
    marker.color.g = 0.0;
    marker.color.b = 0.0;
    marker.color.a = 0.0;
    marker.scale.x = 1.0;
    marker.scale.y = 1.0;
    marker.scale.z = 1.0;

    tf::Quaternion q1;
    q1.setRPY(M_PI/2, 0, M_PI);
    tf::Quaternion q2(marker.pose.orientation.x, marker.pose.orientation.y, marker.pose.orientation.z, marker.pose.orientation.w);
    tf::Quaternion q3;
    q3 = q2 * q1;

    marker.pose.position.z -= 2.0;
    marker.pose.orientation.x = q3.x();
    marker.pose.orientation.y = q3.y();
    marker.pose.orientation.z = q3.z();
    marker.pose.orientation.w = q3.w();

    pub.publish(marker);
    dbg_out_marker(marker);
    prev_map[id] = cur;
  }
  car_map.clear();
  now_map.clear();
}
#endif /* ! CURRENT_CAR_DIRECTLY */

static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
			      geometry_msgs::Pose&amp; pose, int diffmsec)
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;/map&quot;;
  marker.header.stamp = now;
  marker.ns = MARKERNAME;
  marker.action = visualization_msgs::Marker::ADD;
  marker.type = visualization_msgs::Marker::CYLINDER;
  marker.lifetime = ros::Duration(life_time);
  marker.id = create_markerid(pose, 2);
  if (is_pedestrian) {
    marker.color.r = 0.0;
    marker.color.g = 1.0;
    marker.color.b = 1.0;
    pose.position.z += pedestrian_dz;
  } else {
    marker.color.r = 1.0;
    marker.color.g = 1.0;
    marker.color.b = 1.0;
    pose.position.z += posup_dz;
  }
  marker.color.a = alpha_percent(diffmsec);
  marker.scale.x = 0.6;
  marker.scale.y = 0.6;
  marker.scale.z = 1.2; // #1
  marker.pose = pose;
  marker.pose.position.z += 0.6; // == #1/2
  pub.publish(marker);
  dbg_out_marker(marker);

  marker.id = 1 + create_markerid(pose, 2);
  marker.type = visualization_msgs::Marker::SPHERE;
  marker.scale.x = 0.6; // #2
  marker.scale.y = 0.6;
  marker.scale.z = 0.6;
  marker.pose = pose;
  marker.pose.position.z += 1.2 + 0.3 + 0.1; // == #1 + #2/2 + alpha
  pub.publish(marker);
  dbg_out_marker(marker);
}

static int result_to_marker(const string&amp; idstr, ros::Time now,
			    geometry_msgs::Pose&amp; pose, int type,
			    int diffmsec, int is_swap)
{
  int nid;

  switch (type) {
  case TYPE_OWN:
    /* use lower 6 bytes */
    nid = ANON_MARKER_ID_MAX |
      (std::strtol(idstr.substr(6, 6).c_str(), NULL, 16)) &lt;&lt; 1;
    publish_car(nid, 1, now, pose, diffmsec);
    break;
  case TYPE_CAR:
    publish_car(0, 0, now, pose, diffmsec);
    break;
  case TYPE_PEDESTRIAN:
    publish_pedestrian(0, 1, now, pose, diffmsec);
    break;

  /* backward compatibility */
  default:
    if (idstr.find(&quot;current_pose&quot;, 0) != string::npos) {
      /* current_pose:DEF012345678 */
      if (idstr.length() &gt;= 25) {
	/* use lower 6 bytes */
	nid = ANON_MARKER_ID_MAX |
	  (std::strtol((idstr.substr(19, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
        publish_car(nid, 1, now, pose, diffmsec);
      }
    } else if (idstr.find(&quot;ndt_pose&quot;, 0) != string::npos) {
      /* ndt_pose:9ABCDEF01234 */
      if (idstr.length() &gt;= 21) {
	/* use lower 6 bytes */
	nid = ANON_MARKER_ID_MAX |
	  (std::strtol((idstr.substr(15, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
        publish_car(nid, 1, now, pose, diffmsec);
      }
    } else if (idstr.find(&quot;car_pose&quot;, 0) != string::npos) {
      publish_car(0, 0, now, pose, diffmsec);
    } else if (idstr.find(&quot;pedestrian_pose&quot;, 0) != string::npos) {
      publish_pedestrian(0, 1, now, pose, diffmsec);
    } else {
      publish_pedestrian(0, 0, now, pose, diffmsec); // PosUp
    }
  }

  return 0;
}

static int get_timeval(const char *tstr, time_t *sp, int *np)
{
  struct tm tm;
  const char *p;

  if (sscanf(tstr, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;tm.tm_year, &amp;tm.tm_mon,
	&amp;tm.tm_mday, &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec) != 6) {
    std::cerr &lt;&lt; &quot;Cannot convert time \&quot;&quot; &lt;&lt; tstr &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
    return -1;
  }
  if ((p = strchr(tstr, '.')) != NULL) {
    sscanf(++p, &quot;%d&quot;, np);
    for (int i = strlen(p); i &lt; 9; i++, *np*=10);
  } else {
    *np = 0;
  }
  tm.tm_year -= 1900;
  tm.tm_mon -= 1;
  *sp = mktime(&amp;tm);
  return 0;
}

static void marker_publisher(const std_msgs::String&amp; msg, int is_swap)
{
  std::vector&lt;std::string&gt; db_data = split(msg.data, '\n');
  std::vector&lt;std::string&gt; cols;
  ros::Time now = ros::Time::now();
  geometry_msgs::Pose pose;
  int type;
  time_t now_sec, prv_sec = 0;
  int now_nsec, prv_nsec;

  for (const std::string&amp; row : db_data) {
    if(row.empty())
      continue;
    cols = split(row, '\t');
    // id,x,y,z,or_x,or_y,or_z,or_w,lon,lat,tm,type
    if(cols.size() != 12)
      continue;

    type = std::stoi(cols[11]);
    if(ignore_my_pose &amp;&amp;
       (type == TYPE_OWN ||
	cols[0].find(&quot;current_pose&quot;, 0) != string::npos ||
	cols[0].find(&quot;ndt_pose&quot;, 0) != string::npos) &amp;&amp;
       cols[0].find(mac_addr, 0) != string::npos) {
      continue;	// don't publish Marker of my pose
    }

    if (is_swap) {
      pose.position.x = std::stod(cols[2]);
      pose.position.y = std::stod(cols[1]);
      pose.orientation.x = std::stod(cols[5]);
      pose.orientation.y = std::stod(cols[4]);
    } else {
      pose.position.x = std::stod(cols[1]);
      pose.position.y = std::stod(cols[2]);
      pose.orientation.x = std::stod(cols[4]);
      pose.orientation.y = std::stod(cols[5]);
    }
    pose.position.z = std::stod(cols[3]);
    pose.orientation.z = std::stod(cols[6]);
    pose.orientation.w = std::stod(cols[7]);
    // VoltDB returns not NULL but -1.7976931348623157E308
    if (pose.position.x &lt; -1.79E308 ||
	pose.position.y &lt; -1.79E308 ||
	pose.position.z &lt; -1.79E308) {
      geo_pos_conv geo;
      double lon = std::stod(cols[8]);
      double lat = std::stod(cols[9]);
      geo.set_plane(7); // Aichi-ken
      geo.llh_to_xyz(lat, lon, 0/*h*/);
      if (is_swap) {
	pose.position.x = geo.y();
	pose.position.y = geo.x();
      } else {
	pose.position.x = geo.x();
	pose.position.y = geo.y();
      }
      pose.position.z = geo.z();
      pose.orientation.x = 0;
      pose.orientation.y = 0;
      pose.orientation.z = 0;
      pose.orientation.w = 1;
    }
    now_sec = now.toSec();
    now_nsec = now.toNSec()%(1000*1000*1000);
    get_timeval(cols[10].c_str(), &amp;prv_sec, &amp;prv_nsec);
    result_to_marker(cols[0], now, pose, type,
      (now_sec-prv_sec)*1000+(now_nsec-prv_nsec)/1000/1000, is_swap);
  }

#ifndef CURRENT_CAR_DIRECTLY
  publish_car_summary(now);
#endif /* ! CURRENT_CAR_DIRECTLY */
}

// create &quot;YYYY-mm-dd HH:MM:SS.sss&quot;
static int create_timestr(time_t sec, int nsec, char *str, size_t size)
{
  std::tm *nowtm;

  nowtm = std::gmtime(&amp;sec);
  return std::snprintf(str, size, &quot;%04d-%02d-%02d %02d:%02d:%02d.%03d&quot;,
	nowtm-&gt;tm_year + 1900, nowtm-&gt;tm_mon + 1, nowtm-&gt;tm_mday,
	nowtm-&gt;tm_hour, nowtm-&gt;tm_min, nowtm-&gt;tm_sec, nsec/1000/1000);
}

//wrap SendData class
static void send_sql(time_t diff_sec)
{
  std::string data;
  string db_response;
  std_msgs::String msg;
  ros::Time now = ros::Time::now();
  time_t now_sec = now.toSec() - diff_sec;
  int now_nsec = now.toNSec()%(1000*1000*1000);
  char timestr[64]; // &quot;YYYY-mm-dd HH:MM:SS.sss...&quot;
  char prevstr[64]; // &quot;YYYY-mm-dd HH:MM:SS.sss...&quot;

  create_timestr(now_sec-TOTAL_LIFETIME, now_nsec, prevstr, sizeof(prevstr));
  create_timestr(now_sec, now_nsec, timestr, sizeof(timestr));

  data = make_header(1, 1);
  // select pos data between previous latest timestamp and now
  data += &quot;SELECT id,x,y,z,or_x,or_y,or_z,or_w,lon,lat,tm,type FROM POS &quot;
	&quot;WHERE tm &gt; '&quot;;
  data += prevstr;
  data += &quot;' AND tm &lt; '&quot;;
  data += timestr;
  data += &quot;' ORDER BY tm;\r\n&quot;;

  int ret = sd.Sender(data, db_response, 0);
  if (ret &lt; 0) {
    std::cerr &lt;&lt; &quot;sd.Sender() failed&quot; &lt;&lt; std::endl;
  } else {
#ifdef POS_DB_VERBOSE
    std::cout &lt;&lt; &quot;return data: \&quot;&quot; &lt;&lt; db_response &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
#endif /* POS_DB_VERBOSE */
    msg.data = db_response.c_str();
    marker_publisher(msg, 1);
  }
}

static void* intervalCall(void *unused)
{
  double *args = (double *)unused;
  double diff_sec = args[1];

  if (args[0] != 0)
    diff_sec += ros::Time::now().toSec() - args[0];
#ifdef POS_DB_VERBOSE
  cout &lt;&lt; &quot;diff=&quot; &lt;&lt; diff_sec &lt;&lt; endl;
#endif /* POS_DB_VERBOSE */

  while (1) {
    send_sql((time_t)diff_sec);
    usleep(sleep_msec*1000);
  }

  return nullptr;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, MYNAME) ;
  ros::NodeHandle nh;
  pthread_t th;
  double args[2];

  cout &lt;&lt; MYNAME &lt;&lt; endl;

  if(argc &lt; 2) {
    std::cerr &lt;&lt; &quot;usage : \n\trosrun &quot; &lt;&lt; MYNAME &lt;&lt; &quot; &lt;user name&gt; [show_my_pose]&quot; &lt;&lt; std::endl;
    return -1;
  }
  if(argc &gt; 2) {
    if(strncmp(argv[2], &quot;show_my_pose&quot;, 12) == 0) ignore_my_pose = 0;
  }
  std::cerr &lt;&lt; &quot;ignore_my_pose=&quot; &lt;&lt; ignore_my_pose &lt;&lt; std::endl;

  probe_mac_addr(mac_addr);
  std::cerr &lt;&lt;  &quot;mac_addr=&quot; &lt;&lt; mac_addr &lt;&lt; std::endl;

  string home_dir = getenv(&quot;HOME&quot;);

  pub = nh.advertise&lt;visualization_msgs::Marker&gt;(MARKERNAME, 1);
  nh.param&lt;double&gt;(MYNAME &quot;/time&quot;, args[0], STARTTIME);
  cout &lt;&lt; &quot;time=&quot; &lt;&lt; args[0] &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/delay&quot;, args[1], DELAYSEC);
  cout &lt;&lt; &quot;delay=&quot; &lt;&lt; args[1] &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/posup_dz&quot;, posup_dz, POSUP_DZ);
  cout &lt;&lt; &quot;posup_dz=&quot; &lt;&lt; posup_dz &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/pedestrian_dz&quot;, pedestrian_dz, PEDESTRIAN_DZ);
  cout &lt;&lt; &quot;pedestrian_dz=&quot; &lt;&lt; pedestrian_dz &lt;&lt; endl;

  nh.param&lt;string&gt;(&quot;pos_db/db_host_name&quot;, db_host_name, DB_HOSTNAME);
  cout &lt;&lt; &quot;db_host_name=&quot; &lt;&lt; db_host_name &lt;&lt; endl;
  nh.param&lt;int&gt;(&quot;pos_db/db_port&quot;, db_port, DB_PORT);
  cout &lt;&lt; &quot;db_port=&quot; &lt;&lt; db_port &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshpubkey&quot;, sshpubkey, home_dir+SSHPUBKEY);
  cout &lt;&lt; &quot;sshpubkey=&quot; &lt;&lt; sshpubkey &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshprivatekey&quot;, sshprivatekey, home_dir+SSHPRIVATEKEY);
  cout &lt;&lt; &quot;sshprivatekey=&quot; &lt;&lt; sshprivatekey &lt;&lt; endl;
  nh.param&lt;int&gt;(&quot;pos_db/ssh_port&quot;, ssh_port, SSHPORT);
  cout &lt;&lt; &quot;ssh_port=&quot; &lt;&lt; ssh_port &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshtunnelhost&quot;, sshtunnelhost, SSHTUNNELHOST);
  cout &lt;&lt; &quot;sshtunnelhost=&quot; &lt;&lt; sshtunnelhost &lt;&lt; endl;

  sd = SendData(db_host_name, db_port, argv[1], sshpubkey, sshprivatekey, ssh_port, sshtunnelhost);

  if (pthread_create(&amp;th, nullptr, intervalCall, (void *)args) != 0) {
    std::perror(&quot;pthread_create&quot;);
    std::exit(1);
  }

  pthread_detach(th);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="6bbd0a4727968820791e6f925f16818ca03673df" fix_time="29,13628">
		<msg>Fix build error</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/motion/packages/waypoint_follower/nodes/twist_gate/twist_gate.cpp" new_path="ros/src/computing/planning/motion/packages/waypoint_follower/nodes/twist_gate/twist_gate.cpp">
				<diff>@@ -39,7 +39,7 @@
 #include &lt;geometry_msgs/TwistStamped.h&gt;
 
 #include &quot;autoware_msgs/RemoteCmd.h&quot;
-#include &quot;autoware_msgs/TwistGate.h&quot;
+#include &quot;autoware_msgs/VehicleCmd.h&quot;
 #include &quot;tablet_socket_msgs/mode_cmd.h&quot;
 #include &quot;tablet_socket_msgs/gear_cmd.h&quot;
 #include &quot;autoware_msgs/accel_cmd.h&quot;
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Tier IV, Inc.
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;chrono&gt;
#include &lt;map&gt;

#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;

#include &quot;autoware_msgs/RemoteCmd.h&quot;
#include &quot;autoware_msgs/TwistGate.h&quot;
#include &quot;tablet_socket_msgs/mode_cmd.h&quot;
#include &quot;tablet_socket_msgs/gear_cmd.h&quot;
#include &quot;autoware_msgs/accel_cmd.h&quot;
#include &quot;autoware_msgs/brake_cmd.h&quot;
#include &quot;autoware_msgs/steer_cmd.h&quot;
#include &quot;autoware_msgs/ControlCommandStamped.h&quot;

class TwistGate
{
  using remote_msgs_t = autoware_msgs::RemoteCmd;
  using vehicle_cmd_msg_t = autoware_msgs::VehicleCmd;

  public:
    TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh);
    ~TwistGate();
  private:
    void watchdog_timer();
    void remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg);
    void auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg);
    void mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg);
    void gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg);
    void accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg);
    void steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg);
    void brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg);
    void lamp_cmd_callback(const autoware_msgs::lamp_cmd::ConstPtr&amp; input_msg);
    void ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg);

    void reset_vehicle_cmd_msg();

    ros::NodeHandle nh_;
    ros::NodeHandle private_nh_;
    ros::Publisher emergency_stop_pub_;
    ros::Publisher control_command_pub_;
    ros::Publisher vehicle_cmd_pub_;
    ros::Subscriber remote_cmd_sub_;
    std::map&lt;std::string , ros::Subscriber&gt; auto_cmd_sub_stdmap_;

    vehicle_cmd_msg_t twist_gate_msg_;
    std_msgs::Bool emergency_stop_msg_;
    ros::Time remote_cmd_time_;
    ros::Duration timeout_period_;

    std::thread watchdog_timer_thread_;
    enum class CommandMode{AUTO=1, REMOTE=2} command_mode_, previous_command_mode_;
    std_msgs::String command_mode_topic_;
};

TwistGate::TwistGate(const ros::NodeHandle&amp; nh, const ros::NodeHandle&amp; private_nh) :
     nh_(nh)
    ,private_nh_(private_nh)
    ,timeout_period_(1.0)
    ,command_mode_(CommandMode::AUTO)
    ,previous_command_mode_(CommandMode::AUTO)
{
  emergency_stop_pub_ = nh_.advertise&lt;std_msgs::Bool&gt;(&quot;/emergency_stop&quot;, 1, true);
  control_command_pub_ = nh_.advertise&lt;std_msgs::String&gt;(&quot;/ctrl_mode&quot;, 1);
  vehicle_cmd_pub_ = nh_.advertise&lt;vehicle_cmd_msg_t&gt;(&quot;/vehicle_cmd&quot;, 1, true);

  remote_cmd_sub_ = nh_.subscribe(&quot;/remote_cmd&quot;, 1, &amp;TwistGate::remote_cmd_callback, this);

  auto_cmd_sub_stdmap_[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;/twist_cmd&quot;, 1, &amp;TwistGate::auto_cmd_twist_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;mode_cmd&quot;] = nh_.subscribe(&quot;/mode_cmd&quot;, 1, &amp;TwistGate::mode_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;gear_cmd&quot;] = nh_.subscribe(&quot;/gear_cmd&quot;, 1, &amp;TwistGate::gear_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;accel_cmd&quot;] = nh_.subscribe(&quot;/accel_cmd&quot;, 1, &amp;TwistGate::accel_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;steer_cmd&quot;] = nh_.subscribe(&quot;/steer_cmd&quot;, 1, &amp;TwistGate::steer_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;brake_cmd&quot;] = nh_.subscribe(&quot;/brake_cmd&quot;, 1, &amp;TwistGate::brake_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;lamp_cmd&quot;] = nh_.subscribe(&quot;/lamp_cmd&quot;, 1, &amp;TwistGate::lamp_cmd_callback, this);
  auto_cmd_sub_stdmap_[&quot;ctrl_cmd&quot;] = nh_.subscribe(&quot;/ctrl_cmd&quot;, 1, &amp;TwistGate::ctrl_cmd_callback, this);

  twist_gate_msg_.header.seq = 0;

  emergency_stop_msg_.data = false;

  remote_cmd_time_ = ros::Time::now();
  watchdog_timer_thread_ = std::thread(&amp;TwistGate::watchdog_timer, this);
  watchdog_timer_thread_.detach();
}

TwistGate::~TwistGate()
{
}

void TwistGate::reset_vehicle_cmd_msg()
{
  twist_gate_msg_.twist_cmd.twist.linear.x  = 0;
  twist_gate_msg_.twist_cmd.twist.angular.z = 0;
  twist_gate_msg_.mode                      = 0;
  twist_gate_msg_.gear                      = 0;
  twist_gate_msg_.lamp_cmd.l                = 0;
  twist_gate_msg_.lamp_cmd.r                = 0;
  twist_gate_msg_.accel_cmd.accel           = 0;
  twist_gate_msg_.brake_cmd.brake           = 0;
  twist_gate_msg_.steer_cmd.steer           = 0;
  twist_gate_msg_.ctrl_cmd.linear_velocity  = -1;
  twist_gate_msg_.ctrl_cmd.steering_angle   = 0;
}

void TwistGate::watchdog_timer()
{
  while(1)
  {
    ros::Time now_time = ros::Time::now();
    bool emergency_flag = false;

    // check command mode
    if(previous_command_mode_ != command_mode_) {
      if(command_mode_ == CommandMode::AUTO) {
        command_mode_topic_.data = &quot;AUTO&quot;;
      }
      else if(command_mode_ == CommandMode::REMOTE) {
        command_mode_topic_.data = &quot;REMOTE&quot;;
      }
      else{
        command_mode_topic_.data = &quot;UNDEFINED&quot;;
      }

      control_command_pub_.publish(command_mode_topic_);
      previous_command_mode_ = command_mode_;
    }

    // if lost Communication
    if(command_mode_ == CommandMode::REMOTE &amp;&amp; now_time - remote_cmd_time_ &gt;  timeout_period_) {
      emergency_flag = true;
      ROS_WARN(&quot;Lost Communication!&quot;);
    }

    // if push emergency stop button
    if(emergency_stop_msg_.data == true)
    {
      emergency_flag = true;
      ROS_WARN(&quot;Emergency Mode!&quot;);
    }

    // Emergency
    if(emergency_flag) {
      command_mode_ = CommandMode::AUTO;
      emergency_stop_msg_.data = true;
      emergency_stop_pub_.publish(emergency_stop_msg_);
      ROS_WARN(&quot;Emergency Stop!&quot;);
    }

    std::this_thread::sleep_for(std::chrono::milliseconds(10));
  }
}

void TwistGate::remote_cmd_callback(const remote_msgs_t::ConstPtr&amp; input_msg)
{
  command_mode_ = static_cast&lt;CommandMode&gt;(input_msg-&gt;control_mode);
  emergency_stop_msg_.data = static_cast&lt;bool&gt;(input_msg-&gt;vehicle_cmd.emergency);
  remote_cmd_time_ = ros::Time::now();

  if(command_mode_ == CommandMode::REMOTE)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;vehicle_cmd.header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;vehicle_cmd.header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.twist_cmd.twist = input_msg-&gt;vehicle_cmd.twist_cmd.twist;
    twist_gate_msg_.ctrl_cmd  = input_msg-&gt;vehicle_cmd.ctrl_cmd;
    twist_gate_msg_.accel_cmd = input_msg-&gt;vehicle_cmd.accel_cmd;
    twist_gate_msg_.brake_cmd = input_msg-&gt;vehicle_cmd.brake_cmd;
    twist_gate_msg_.steer_cmd = input_msg-&gt;vehicle_cmd.steer_cmd;
    twist_gate_msg_.gear = input_msg-&gt;vehicle_cmd.gear;
    twist_gate_msg_.lamp_cmd = input_msg-&gt;vehicle_cmd.lamp_cmd;
    twist_gate_msg_.mode = input_msg-&gt;vehicle_cmd.mode;
    twist_gate_msg_.emergency = input_msg-&gt;vehicle_cmd.emergency;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::auto_cmd_twist_cmd_callback(const geometry_msgs::TwistStamped::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.twist_cmd.twist = input_msg-&gt;twist;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::mode_cmd_callback(const tablet_socket_msgs::mode_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    //TODO:check this if statement
    if(input_msg-&gt;mode == -1 || input_msg-&gt;mode == 0){
      reset_vehicle_cmd_msg();
    }
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.mode = input_msg-&gt;mode;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::gear_cmd_callback(const tablet_socket_msgs::gear_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.gear = input_msg-&gt;gear;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::accel_cmd_callback(const autoware_msgs::accel_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.accel_cmd.accel = input_msg-&gt;accel;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::steer_cmd_callback(const autoware_msgs::steer_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.steer_cmd.steer = input_msg-&gt;steer;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::brake_cmd_callback(const autoware_msgs::brake_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.brake_cmd.brake = input_msg-&gt;brake;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::lamp_cmd_callback(const autoware_msgs::lamp_cmd::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.lamp_cmd.l = input_msg-&gt;l;
    twist_gate_msg_.lamp_cmd.r = input_msg-&gt;r;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}

void TwistGate::ctrl_cmd_callback(const autoware_msgs::ControlCommandStamped::ConstPtr&amp; input_msg)
{
  if(command_mode_ == CommandMode::AUTO)
  {
    twist_gate_msg_.header.frame_id = input_msg-&gt;header.frame_id;
    twist_gate_msg_.header.stamp = input_msg-&gt;header.stamp;
    twist_gate_msg_.header.seq++;
    twist_gate_msg_.ctrl_cmd = input_msg-&gt;cmd;
    vehicle_cmd_pub_.publish(twist_gate_msg_);
  }
}


int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;twist_gate&quot;);
  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  TwistGate twist_gate(nh, private_nh);

  ros::spin();
  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/socket/packages/vehicle_socket/nodes/vehicle_sender/vehicle_sender.cpp" new_path="ros/src/socket/packages/vehicle_socket/nodes/vehicle_sender/vehicle_sender.cpp">
				<diff>@@ -29,7 +29,7 @@
 */
 
 #include &lt;ros/ros.h&gt;
-#include &quot;autoware_msgs/TwistGate.h&quot;
+#include &quot;autoware_msgs/VehicleCmd.h&quot;
 
 #include &lt;iostream&gt;
 #include &lt;string&gt;
@@ -72,7 +72,7 @@ void CommandData::reset()
 
 static CommandData command_data;
 
-static void twistGateCallback(const autoware_msgs::TwistGate&amp; msg)
+static void vehicleCmdCallback(const autoware_msgs::VehicleCmd&amp; msg)
 {
   command_data.linear_x = msg.twist_cmd.twist.linear.x;
   command_data.angular_z = msg.twist_cmd.twist.angular.z;
@@ -197,7 +197,7 @@ int main(int argc, char **argv)
   ros::NodeHandle nh;
 
   std::cout &lt;&lt; &quot;vehicle sender&quot; &lt;&lt; std::endl;
-  ros::Subscriber sub = nh.subscribe(&quot;/vehicle_cmd&quot;, 1, twistGateCallback);
+  ros::Subscriber sub = nh.subscribe(&quot;/vehicle_cmd&quot;, 1, vehicleCmdCallback);
 
   command_data.reset();
 
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;ros/ros.h&gt;
#include &quot;autoware_msgs/TwistGate.h&quot;

#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdio&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

struct CommandData {
  double linear_x;
  double angular_z;
  int modeValue;
  int gearValue;
  int lampValue;
  int accellValue;
  int brakeValue;
  int steerValue;
  double linear_velocity;
  double steering_angle;

  void reset();
};

void CommandData::reset()
{
  linear_x      = 0;
  angular_z     = 0;
  modeValue     = 0;
  gearValue     = 0;
  lampValue     = 0;
  accellValue   = 0;
  brakeValue    = 0;
  steerValue    = 0;
  linear_velocity = -1;
  steering_angle = 0;
}

static CommandData command_data;

static void twistGateCallback(const autoware_msgs::TwistGate&amp; msg)
{
  command_data.linear_x = msg.twist_cmd.twist.linear.x;
  command_data.angular_z = msg.twist_cmd.twist.angular.z;
  command_data.modeValue = msg.mode;
  command_data.gearValue = msg.gear;
  if(msg.lamp_cmd.l == 0 &amp;&amp; msg.lamp_cmd.r == 0) {
    command_data.lampValue = 0;
  }
  else if (msg.lamp_cmd.l == 1 &amp;&amp; msg.lamp_cmd.r == 0) {
    command_data.lampValue = 1;
  }
  else if (msg.lamp_cmd.l == 0 &amp;&amp; msg.lamp_cmd.r == 1) {
    command_data.lampValue = 2;
  }
  else if (msg.lamp_cmd.l == 1 &amp;&amp; msg.lamp_cmd.r == 1) {
    command_data.lampValue = 3;
  }
  command_data.accellValue = msg.accel_cmd.accel;
  command_data.steerValue = msg.steer_cmd.steer;
  command_data.brakeValue = msg.brake_cmd.brake;
  command_data.linear_velocity = msg.ctrl_cmd.linear_velocity;
  command_data.steering_angle = msg.ctrl_cmd.steering_angle;
}

static void *sendCommand(void *arg)
{
  int *client_sockp = static_cast&lt;int*&gt;(arg);
  int client_sock = *client_sockp;
  delete client_sockp;

  std::ostringstream oss;
  oss &lt;&lt; command_data.linear_x &lt;&lt; &quot;,&quot;;
  oss &lt;&lt; command_data.angular_z &lt;&lt; &quot;,&quot;;
  oss &lt;&lt; command_data.modeValue &lt;&lt; &quot;,&quot;;
  oss &lt;&lt; command_data.gearValue &lt;&lt; &quot;,&quot;;
  oss &lt;&lt; command_data.accellValue &lt;&lt; &quot;,&quot;;
  oss &lt;&lt; command_data.brakeValue &lt;&lt; &quot;,&quot;;
  oss &lt;&lt; command_data.steerValue &lt;&lt; &quot;,&quot;;
  oss &lt;&lt; command_data.linear_velocity &lt;&lt; &quot;,&quot;;
  oss &lt;&lt; command_data.steering_angle;

  std::string cmd(oss.str());
  ssize_t n = write(client_sock, cmd.c_str(), cmd.size());
  if(n &lt; 0){
    std::perror(&quot;write&quot;);
    return nullptr;
  }

  if(close(client_sock) == -1){
    std::perror(&quot;close&quot;);
    return nullptr;
  }

  std::cout &lt;&lt; &quot;cmd: &quot; &lt;&lt; cmd &lt;&lt; &quot;, size: &quot; &lt;&lt; cmd.size() &lt;&lt; std::endl;
  return nullptr;
}

static void* receiverCaller(void *unused)
{
  constexpr int listen_port = 10001;

  int sock = socket(AF_INET, SOCK_STREAM, 0);
  if(sock == -1){
    std::perror(&quot;socket&quot;);
    return nullptr;
  }

  sockaddr_in addr;
  sockaddr_in client;
  socklen_t len = sizeof(client);

  std::memset(&amp;addr, 0, sizeof(sockaddr_in));
  addr.sin_family = PF_INET;
  addr.sin_port = htons(listen_port);
  addr.sin_addr.s_addr = INADDR_ANY;

  int ret = bind(sock, (struct sockaddr *)&amp;addr, sizeof(addr));
  if(ret == -1){
    std::perror(&quot;bind&quot;);
    goto error;
  }

  ret = listen(sock, 20);
  if(ret == -1){
    std::perror(&quot;listen&quot;);
    goto error;
  }

  while(true){
    //get connect to android
    std::cout &lt;&lt; &quot;Waiting access...&quot; &lt;&lt; std::endl;

    int *client_sock = new int();
    *client_sock = accept(sock, reinterpret_cast&lt;sockaddr*&gt;(&amp;client), &amp;len);
    if(*client_sock == -1){
      std::perror(&quot;accept&quot;);
      break;
    }

    std::cout &lt;&lt; &quot;get connect.&quot; &lt;&lt; std::endl;

    pthread_t th;
    if(pthread_create(&amp;th, nullptr, sendCommand, static_cast&lt;void*&gt;(client_sock)) != 0){
      std::perror(&quot;pthread_create&quot;);
      break;
    }

    if(pthread_detach(th) != 0){
      std::perror(&quot;pthread_detach&quot;);
      break;
    }
  }

error:
  close(sock);
  return nullptr;
}

int main(int argc, char **argv)
{
  ros::init(argc ,argv, &quot;vehicle_sender&quot;) ;
  ros::NodeHandle nh;

  std::cout &lt;&lt; &quot;vehicle sender&quot; &lt;&lt; std::endl;
  ros::Subscriber sub = nh.subscribe(&quot;/vehicle_cmd&quot;, 1, twistGateCallback);

  command_data.reset();

  pthread_t th;
  if(pthread_create(&amp;th, nullptr, receiverCaller, nullptr) != 0){
    std::perror(&quot;pthread_create&quot;);
    std::exit(1);
  }

  if (pthread_detach(th) != 0){
    std::perror(&quot;pthread_detach&quot;);
    std::exit(1);
  }

  ros::spin();
  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="f42a35efcadc41b015e7525b4cb4b031c5b2b220" fix_time="160,16972">
		<msg>- Update OpenPlanner libraries (plannerh, simuh, utilityh) with the latest modifications
- Fix inconsistency after library update, make sure old (way_planner, dp_planner) are working fine
- Create new package (op_local_planner)
- Create common launch file for local planning params
- Create new node (op_trajectory_generator)
- Create launch file for trajectory generation only
- Test generating trajectories (rollouts) in simulation with way_planner
- Test generating trajectories with real rosbag data with way_planner
- Test generating trajectories with real rosbag data and waypoints_loader</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/GridMap.h" new_path="">
				<diff>@@ -1,230 +0,0 @@
-/*
- * GridMap.h
- *
- *  Created on: May 14, 2016
- *      Author: hatem
- */
-
-#ifndef GRIDMAPSA_H_
-#define GRIDMAPSA_H_
-
-#include &quot;RoadNetwork.h&quot;
-
-namespace PlannerHNS
-{
-
-#define get2dIndex(r,c,w) r*w + c
-#define checkGridLimit(r,c,h,w) r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; h &amp;&amp; c &lt; w
-#define checkGridIndex(i, nCells) i &gt;= 0 &amp;&amp; i &lt; nCells
-#define SUBCELL_L 10 //subcell lenth in centimeter
-
-
-class CELL_Info
-{
-public:
-  int r,c,index;
-  GPSPoint center;
-  int nCells;
-  double heuristic;
-  double forwardHeuristic;
-  double backwardHeuristic;
-  double heuristicValue;
-  double forward_heuristicValue;
-  double backward_heuristicValue;
-  int expanded; // used in path planning
-  bool closed;
-  double value;
-  int action;
-  double localize_val;
-  double localize_prob;
-  std::vector&lt;double&gt; localize_features;
-  GPSPoint forwardCenter;
-  GPSPoint backwardCenter;
-  DIRECTION_TYPE bDir;
-  POINT2D bottom_left;
-  POINT2D top_right;
-  POINT2D bottom_right;
-  POINT2D top_left;
-  int nStaticPoints;
-  int nMovingPoints;
-
-  CELL_Info* pInnerMap;
-
-  std::vector&lt;POINT2D&gt; innerStaticPointsList;
-  std::vector&lt;POINT2D&gt; innerMovingPointsList;
-
-  std::vector&lt;GPSPoint&gt; path;
-
-
-public:
-  void InitSubCells(double cell_l, double sub_cell_l);
-/**
- * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
- * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
- */
-  void Clear(int bMovingOnly);
-  void ClearSubCells(bool bMovingOnly);
-
-  CELL_Info();
-
-  virtual ~CELL_Info();
-
-  /*
-   * Cell initialization
-   */
-  void Initialize(POINT2D bottom_left, double cell_l, int row, int col, bool bDefaultEmpty);
-
-  /*
-   * assignment operator
-   */
-  bool operator==(const CELL_Info&amp; cell);
-
-  bool operator!=(const CELL_Info&amp; cell);
-
-  inline bool PointInRect(const POINT2D&amp; p)
-   {
-     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-   }
-
-  bool TestWithRectangle(RECTANGLE&amp; rec);
-  bool TestWithCircle(POINT2D _center,double  width);
-   inline bool HitTest(const POINT2D&amp; p);
-
-   void UpdateSubCellCostValue(const std::vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l);
-   void UpdateCostValue(const std::vector&lt;POINT2D&gt;&amp; ps);
-
-   void SaveCell(std::ostream&amp; f);
-   void LoadCell(std::ifstream&amp; f);
-
-};
-
-class GridMap
-{
-  public:
-
-	  pthread_mutex_t update_map_mutex;
-
-    double w, inner_w; // current world width
-    double h, inner_h; // current world height
-    double cell_l; // cell or block length, if this is an inner cell measurements will be in meter
-    double sub_cell_l;
-    double origin_x , origin_y;
-
-
-
-    int inner_start_row;
-    int inner_start_col;
-    int inner_end_row;
-    int inner_end_col;
-
-    bool m_bEnableInnerMap;
-    bool m_bUpdatedMap;
-
-
-
-    int wCells, nInnerWCells; // width, number of cells per row
-    int hCells, nInnerHCells; // height, number of cells per column
-	//POINT2D center;
-	int m_MaxHeuristics;
-
-	int m_DisplayResolution;
-
-	POINT2D* delta;
-
-
-    // This method map obstacles from real world space to Grid space , marking each cell or internal cells as obstacle
-	void UpdateMapObstacleValue(const Obstacle&amp; ob);
-	void UpdateMapDrivablesValue(const DrivableArea&amp; dr);
-	void UpdateMapDrivablesValuePlygon(const std::vector&lt;std::vector&lt;POINT2D&gt; &gt;&amp; points);
-	void UpdateMapObstaclesValuePlygon(const std::vector&lt;POINT2D&gt;&amp; poly, std::vector&lt;CELL_Info*&gt;&amp; modifiedCell);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update cell to indicate that there is an obstacle @ absolute point p , and make the map thiner according to a giving threshold
-	 * @param p absolute x,y point
-	 * @param thiningTHreshold distance to search for old obstacles
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold);
-
-	/**
-	 * @brief update cell to indicate that there is an moving obstacle @ absolute point p
-	 * @param p absolute x,y point
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapMovingObstaclePoint(const POINT2D&amp; p);
-
-	/**
-	 * @brief update subcells cost values to reflect the effect of obstacle @ absolute pint p
-	 * @param p obstacle point (x,y)
-	 * @param currPos current car location to apply the effect of obstacle on p
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateMapCostValueRange(const std::vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const std::vector&lt;double&gt;&amp; features);
-	/**
-	 * @brief find the cell @ p then update its localization cost and probability which were read from a map file
-	 * @param p absolute position of the cell center
-	 * @param localize_val cost value
-	 * @param localize_prob probability value (should be zero in case of updating from map file
-	 * @return pointer to the updated cell
-	 */
-	CELL_Info* UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);
-
-	CELL_Info* GetCellFromPointInnerMap(const POINT2D&amp; p);
-	CELL_Info* GetCellFromPoint(const POINT2D&amp; p, bool bExpand = false); // return cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromPoint(const POINT2D&amp; p); // return sub cell information from (x,y) coordinates
-	CELL_Info* GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p); // return sub cell information from parent cell
-
-	bool CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold, std::vector&lt;CELL_Info*&gt;&amp; pSubCellsList);
-
-	/**
-	 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
-	 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
-	 */
-	void ClearMap(int bMovingOnly);
-	void OpenClosedCells();
-	void BackupMap();
-
-	GridMap();
-    GridMap(double start_x, double start_y, double  map_w, double map_h, double cell_length, bool bDefaultEmpty); // initialize and construct the 2D array of the Grid cells
-    void InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center); // initialize and construct map from another map (cells will point to cells from the other map , width and hight will be maximum available limited by the parameters
-    virtual ~GridMap();
-
-    CELL_Info* pCells;
-    int nCells;
-
-    void SaveMap(const std::string&amp; mapFilePath, const std::string&amp; mapName);
-    void LoadMap(const std::string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation);
-
-    int GetSurroundingMainCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingNonObstacleCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
-    int GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-    int GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, double radius);
-    int GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
-
-    bool IsUpdated()
-    {
-    	return m_bUpdatedMap;
-    }
-
-    void ObservedMap()
-    {
-    	m_bUpdatedMap = false;
-    }
-
-  private:
-    int InsidePolygon(const std::vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p);
-
-    //vector&lt;CELL_Info*&gt; pDrivableCells;
-  };
-
-}
-#endif /* GRIDMAP_H_ */
</diff>
				<old_file>/*
 * GridMap.h
 *
 *  Created on: May 14, 2016
 *      Author: hatem
 */

#ifndef GRIDMAPSA_H_
#define GRIDMAPSA_H_

#include &quot;RoadNetwork.h&quot;

namespace PlannerHNS
{

#define get2dIndex(r,c,w) r*w + c
#define checkGridLimit(r,c,h,w) r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; h &amp;&amp; c &lt; w
#define checkGridIndex(i, nCells) i &gt;= 0 &amp;&amp; i &lt; nCells
#define SUBCELL_L 10 //subcell lenth in centimeter


class CELL_Info
{
public:
  int r,c,index;
  GPSPoint center;
  int nCells;
  double heuristic;
  double forwardHeuristic;
  double backwardHeuristic;
  double heuristicValue;
  double forward_heuristicValue;
  double backward_heuristicValue;
  int expanded; // used in path planning
  bool closed;
  double value;
  int action;
  double localize_val;
  double localize_prob;
  std::vector&lt;double&gt; localize_features;
  GPSPoint forwardCenter;
  GPSPoint backwardCenter;
  DIRECTION_TYPE bDir;
  POINT2D bottom_left;
  POINT2D top_right;
  POINT2D bottom_right;
  POINT2D top_left;
  int nStaticPoints;
  int nMovingPoints;

  CELL_Info* pInnerMap;

  std::vector&lt;POINT2D&gt; innerStaticPointsList;
  std::vector&lt;POINT2D&gt; innerMovingPointsList;

  std::vector&lt;GPSPoint&gt; path;


public:
  void InitSubCells(double cell_l, double sub_cell_l);
/**
 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
 */
  void Clear(int bMovingOnly);
  void ClearSubCells(bool bMovingOnly);

  CELL_Info();

  virtual ~CELL_Info();

  /*
   * Cell initialization
   */
  void Initialize(POINT2D bottom_left, double cell_l, int row, int col, bool bDefaultEmpty);

  /*
   * assignment operator
   */
  bool operator==(const CELL_Info&amp; cell);

  bool operator!=(const CELL_Info&amp; cell);

  inline bool PointInRect(const POINT2D&amp; p)
   {
     return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
   }

  bool TestWithRectangle(RECTANGLE&amp; rec);
  bool TestWithCircle(POINT2D _center,double  width);
   inline bool HitTest(const POINT2D&amp; p);

   void UpdateSubCellCostValue(const std::vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l);
   void UpdateCostValue(const std::vector&lt;POINT2D&gt;&amp; ps);

   void SaveCell(std::ostream&amp; f);
   void LoadCell(std::ifstream&amp; f);

};

class GridMap
{
  public:

	  pthread_mutex_t update_map_mutex;

    double w, inner_w; // current world width
    double h, inner_h; // current world height
    double cell_l; // cell or block length, if this is an inner cell measurements will be in meter
    double sub_cell_l;
    double origin_x , origin_y;



    int inner_start_row;
    int inner_start_col;
    int inner_end_row;
    int inner_end_col;

    bool m_bEnableInnerMap;
    bool m_bUpdatedMap;



    int wCells, nInnerWCells; // width, number of cells per row
    int hCells, nInnerHCells; // height, number of cells per column
	//POINT2D center;
	int m_MaxHeuristics;

	int m_DisplayResolution;

	POINT2D* delta;


    // This method map obstacles from real world space to Grid space , marking each cell or internal cells as obstacle
	void UpdateMapObstacleValue(const Obstacle&amp; ob);
	void UpdateMapDrivablesValue(const DrivableArea&amp; dr);
	void UpdateMapDrivablesValuePlygon(const std::vector&lt;std::vector&lt;POINT2D&gt; &gt;&amp; points);
	void UpdateMapObstaclesValuePlygon(const std::vector&lt;POINT2D&gt;&amp; poly, std::vector&lt;CELL_Info*&gt;&amp; modifiedCell);

	/**
	 * @brief update cell to indicate that there is an obstacle @ absolute point p
	 * @param p absolute x,y point
	 * @return pointer to the updated cell
	 */
	CELL_Info* UpdateMapObstaclePoint(const POINT2D&amp; p);

	/**
	 * @brief update cell to indicate that there is an obstacle @ absolute point p , and make the map thiner according to a giving threshold
	 * @param p absolute x,y point
	 * @param thiningTHreshold distance to search for old obstacles
	 * @return pointer to the updated cell
	 */
	CELL_Info* UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold);

	/**
	 * @brief update cell to indicate that there is an moving obstacle @ absolute point p
	 * @param p absolute x,y point
	 * @return pointer to the updated cell
	 */
	CELL_Info* UpdateMapMovingObstaclePoint(const POINT2D&amp; p);

	/**
	 * @brief update subcells cost values to reflect the effect of obstacle @ absolute pint p
	 * @param p obstacle point (x,y)
	 * @param currPos current car location to apply the effect of obstacle on p
	 * @return pointer to the updated cell
	 */
	CELL_Info* UpdateMapCostValueRange(const std::vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const std::vector&lt;double&gt;&amp; features);
	/**
	 * @brief find the cell @ p then update its localization cost and probability which were read from a map file
	 * @param p absolute position of the cell center
	 * @param localize_val cost value
	 * @param localize_prob probability value (should be zero in case of updating from map file
	 * @return pointer to the updated cell
	 */
	CELL_Info* UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);

	CELL_Info* UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob);

	CELL_Info* GetCellFromPointInnerMap(const POINT2D&amp; p);
	CELL_Info* GetCellFromPoint(const POINT2D&amp; p, bool bExpand = false); // return cell information from (x,y) coordinates
	CELL_Info* GetSubCellFromPoint(const POINT2D&amp; p); // return sub cell information from (x,y) coordinates
	CELL_Info* GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p); // return sub cell information from parent cell

	bool CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningTHreshold, std::vector&lt;CELL_Info*&gt;&amp; pSubCellsList);

	/**
	 * @brief Clear the map contents including obstacle data if bMovingOnly parameter = -1
	 * @param bMovingOnly , 1 : clear cell data and moving only points, 0 clear all data including moving and static points, -1 clear data only.
	 */
	void ClearMap(int bMovingOnly);
	void OpenClosedCells();
	void BackupMap();

	GridMap();
    GridMap(double start_x, double start_y, double  map_w, double map_h, double cell_length, bool bDefaultEmpty); // initialize and construct the 2D array of the Grid cells
    void InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center); // initialize and construct map from another map (cells will point to cells from the other map , width and hight will be maximum available limited by the parameters
    virtual ~GridMap();

    CELL_Info* pCells;
    int nCells;

    void SaveMap(const std::string&amp; mapFilePath, const std::string&amp; mapName);
    void LoadMap(const std::string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation);

    int GetSurroundingMainCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
    int GetSurroundingNonObstacleCells(const POINT2D&amp; pos, std::vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range=5);
    int GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);
    int GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, double radius);
    int GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	std::vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect);

    bool IsUpdated()
    {
    	return m_bUpdatedMap;
    }

    void ObservedMap()
    {
    	m_bUpdatedMap = false;
    }

  private:
    int InsidePolygon(const std::vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p);

    //vector&lt;CELL_Info*&gt; pDrivableCells;
  };

}
#endif /* GRIDMAP_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/HMIStateMachine.h" new_path="">
				<diff>@@ -1,99 +0,0 @@
-/*
- * HMIStateMachine.h
- *
- *  Created on: February 14, 2017
- *      Author: Hatem Darweesh
- */
-
-#ifndef HMIStateMachine_H_
-#define HMIStateMachine_H_
-
-#include &quot;RoadNetwork.h&quot;
-#include &lt;sstream&gt;
-
-namespace PlannerHNS
-{
-
-class HMIStateMachine
-{
-public:
-	virtual HMIStateMachine* GetNextState() = 0;
-	virtual void Init();
-	virtual void ResetTimer();
-	virtual void InsertNextState(HMIStateMachine* nextState);
-	HMIStateMachine(HMIStateMachine* nextState);
-	virtual ~HMIStateMachine() ;
-
-	GLOBAL_STATE_TYPE m_Behavior;
-	double decisionMakingTime;
-
-	HMIPreCalculatedConditions* GetCalcParams()
-	{
-		if(!m_pCalculatedValues)
-				m_pCalculatedValues = new HMIPreCalculatedConditions();
-
-		return m_pCalculatedValues;
-	}
-
-	void SetBehaviorsParams(const PlanningParams&amp; params)
-	{
-		m_PlanningParams = params;
-	}
-
-	static HMIPreCalculatedConditions* m_pCalculatedValues;
-	timespec m_StateTimer;
-	std::vector&lt;HMIStateMachine*&gt; pNextStates;
-	static PlanningParams m_PlanningParams;
-
-	HMIStateMachine* FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior);
-};
-
-class GWaitingState : public HMIStateMachine
-{
-public:
-	GWaitingState(GWaitingState* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_WAITING_STATE;}
-	virtual ~GWaitingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GPlanningState : public HMIStateMachine
-{
-public:
-	GPlanningState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_PLANING_STATE;}
-	virtual ~GPlanningState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GForwardState : public HMIStateMachine
-{
-public:
-	GForwardState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FORWARD_STATE;}
-	virtual ~GForwardState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GBranchingState : public HMIStateMachine
-{
-public:
-	GBranchingState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_BRANCHING_STATE;}
-	virtual ~GBranchingState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-class GEndState : public HMIStateMachine
-{
-public:
-	GEndState(HMIStateMachine* pNextState)
-	: HMIStateMachine(pNextState){m_Behavior = G_FINISH_STATE;}
-	virtual ~GEndState(){}
-	virtual HMIStateMachine* GetNextState();
-};
-
-
-} /* namespace PlannerHNS */
-
-#endif /* HMIStateMachine_H_ */
</diff>
				<old_file>/*
 * HMIStateMachine.h
 *
 *  Created on: February 14, 2017
 *      Author: Hatem Darweesh
 */

#ifndef HMIStateMachine_H_
#define HMIStateMachine_H_

#include &quot;RoadNetwork.h&quot;
#include &lt;sstream&gt;

namespace PlannerHNS
{

class HMIStateMachine
{
public:
	virtual HMIStateMachine* GetNextState() = 0;
	virtual void Init();
	virtual void ResetTimer();
	virtual void InsertNextState(HMIStateMachine* nextState);
	HMIStateMachine(HMIStateMachine* nextState);
	virtual ~HMIStateMachine() ;

	GLOBAL_STATE_TYPE m_Behavior;
	double decisionMakingTime;

	HMIPreCalculatedConditions* GetCalcParams()
	{
		if(!m_pCalculatedValues)
				m_pCalculatedValues = new HMIPreCalculatedConditions();

		return m_pCalculatedValues;
	}

	void SetBehaviorsParams(const PlanningParams&amp; params)
	{
		m_PlanningParams = params;
	}

	static HMIPreCalculatedConditions* m_pCalculatedValues;
	timespec m_StateTimer;
	std::vector&lt;HMIStateMachine*&gt; pNextStates;
	static PlanningParams m_PlanningParams;

	HMIStateMachine* FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior);
};

class GWaitingState : public HMIStateMachine
{
public:
	GWaitingState(GWaitingState* pNextState)
	: HMIStateMachine(pNextState){m_Behavior = G_WAITING_STATE;}
	virtual ~GWaitingState(){}
	virtual HMIStateMachine* GetNextState();
};

class GPlanningState : public HMIStateMachine
{
public:
	GPlanningState(HMIStateMachine* pNextState)
	: HMIStateMachine(pNextState){m_Behavior = G_PLANING_STATE;}
	virtual ~GPlanningState(){}
	virtual HMIStateMachine* GetNextState();
};

class GForwardState : public HMIStateMachine
{
public:
	GForwardState(HMIStateMachine* pNextState)
	: HMIStateMachine(pNextState){m_Behavior = G_FORWARD_STATE;}
	virtual ~GForwardState(){}
	virtual HMIStateMachine* GetNextState();
};

class GBranchingState : public HMIStateMachine
{
public:
	GBranchingState(HMIStateMachine* pNextState)
	: HMIStateMachine(pNextState){m_Behavior = G_BRANCHING_STATE;}
	virtual ~GBranchingState(){}
	virtual HMIStateMachine* GetNextState();
};

class GEndState : public HMIStateMachine
{
public:
	GEndState(HMIStateMachine* pNextState)
	: HMIStateMachine(pNextState){m_Behavior = G_FINISH_STATE;}
	virtual ~GEndState(){}
	virtual HMIStateMachine* GetNextState();
};


} /* namespace PlannerHNS */

#endif /* HMIStateMachine_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/LocalPlannerH.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/LocalPlannerH.h">
				<diff>@@ -12,7 +12,9 @@
 #include &quot;PlannerCommonDef.h&quot;
 #include &quot;RoadNetwork.h&quot;
 #include &quot;TrajectoryCosts.h&quot;
+#include &quot;TrajectoryPrediction.h&quot;
 
+#define AVOIDANCE_SPEED_FACTOR 0.75
 namespace PlannerHNS
 {
 
@@ -24,11 +26,15 @@ public:
 	ControllerParams m_ControlParams;
 	std::vector&lt;GPSPoint&gt; m_CarShapePolygon;
 	std::vector&lt;WayPoint&gt; m_Path;
+	std::vector&lt;WayPoint&gt; m_OriginalLocalPath;
 	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalPath;
+	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalOriginalPath;
+	std::vector&lt;DetectedObject&gt; m_PredictedTrajectoryObstacles;
 	int m_iCurrentTotalPathId;
 	int m_iSafeTrajectory;
+	double m_InitialFollowingDistance;
 //	int m_iGlobalPathPrevID;
-	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
+//	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
 	std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt; m_RollOuts;
 	std::string carId;
 	Lane* pLane;
@@ -38,6 +44,7 @@ public:
 	double m_CostCalculationTime;
 	double m_BehaviorGenTime;
 	double m_RollOutsGenerationTime;
+	int m_PrevBrakingWayPoint;
 
 	BehaviorStateMachine* 		m_pCurrentBehaviorState;
 	ForwardState * 				m_pGoToGoalState;
@@ -54,15 +61,16 @@ public:
 	StopSignWaitState* 			m_pStopSignWaitState;
 
 	TrajectoryCosts m_TrajectoryCostsCalculatotor;
-
-
+	TrajectoryPrediction m_TrajectoryPredictionForMovingObstacles;
 
 	//for debugging
-	std::vector&lt;WayPoint&gt; m_PathSection;
+
 	std::vector&lt;WayPoint&gt; m_SampledPoints;
 
 	void InitBehaviorStates();
 
+	void ReInitializePlanner(const WayPoint&amp; start_pose);
+
 	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const SHIFT_POS&amp; shift_d)
 	{
 		m_CurrentVelocityD = velocity_d;
@@ -96,6 +104,9 @@ public:
 	double m_CurrentAccVelocity; // kilometer/hour
 	//std::vector&lt;TrafficLight&gt; m_TrafficLights;
 
+	UtilityHNS::PIDController 	m_pidVelocity;
+	UtilityHNS::PIDController 	m_pidStopping;
+
 public:
 
 	LocalPlannerH();
@@ -106,7 +117,7 @@ public:
 	void LocalizeMe(const double&amp; dt); // in seconds
 	void UpdateState(const VehicleState&amp; state, const bool&amp; bUseDelay = false);
 	void CalculateImportantParameterForDecisionMaking(const VehicleState&amp; car_state,
-			const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
+			const int&amp; goalID, const bool&amp; bEmergencyStop, const vector&lt;TrafficLight&gt;&amp; detectedLights,
 			const TrajectoryCost&amp; bestTrajectory);
 
 	BehaviorState DoOneStep(
@@ -116,7 +127,7 @@ public:
 			const int&amp; goalID,
 			RoadNetwork&amp; map,
 			const bool&amp; bEmergencyStop,
-			const bool&amp; bGreenTrafficLight,
+			const std::vector&lt;TrafficLight&gt;&amp; trafficLight,
 			const bool&amp; bLive = false);
 
 	void SimulateOdoPosition(const double&amp; dt, const VehicleState&amp; vehicleState);
@@ -124,20 +135,20 @@ public:
 private:
 
 	//Obstacle avoidance functionalities
-	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
-
-	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
-			const VehicleState&amp; vstatus,
-			const WayPoint&amp; currState);
-
-	void PredictObstacleTrajectory(RoadNetwork&amp; map,
-			const WayPoint&amp; pos,
-			const double&amp; predTime,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
-
-	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
-			const DetectedObject&amp; obj);
+//	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);
+//
+//	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
+//			const VehicleState&amp; vstatus,
+//			const WayPoint&amp; currState);
+//
+//	void PredictObstacleTrajectory(RoadNetwork&amp; map,
+//			const WayPoint&amp; pos,
+//			const double&amp; predTime,
+//			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
+//
+//	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
+//			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
+//			const DetectedObject&amp; obj);
 
 	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;TrafficLight&gt;&amp; trafficLights, TrafficLight&amp; trafficL);
 	void UpdateCurrentLane(RoadNetwork&amp; map, const double&amp; search_distance);
@@ -145,7 +156,9 @@ private:
 	BehaviorState GenerateBehaviorState(const VehicleState&amp; vehicleState);
 	void TransformPoint(const WayPoint&amp; refPose, GPSPoint&amp; p);
 	void AddAndTransformContourPoints(const DetectedObject&amp; obj, std::vector&lt;WayPoint&gt;&amp; contourPoints);
-	void UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
+	double UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);
+
+	void ExtractHorizonAndCalculateRecommendedSpeed();
 
 	bool NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex);
 
</diff>
				<old_file>/*
 * CarState.h
 *
 *  Created on: Dec 14, 2016
 *      Author: hatem
 */

#ifndef LOCALPLANNERH_H_
#define LOCALPLANNERH_H_

#include &quot;BehaviorStateMachine.h&quot;
#include &quot;PlannerCommonDef.h&quot;
#include &quot;RoadNetwork.h&quot;
#include &quot;TrajectoryCosts.h&quot;

namespace PlannerHNS
{

class LocalPlannerH
{
public:
	WayPoint state;
	CAR_BASIC_INFO m_CarInfo;
	ControllerParams m_ControlParams;
	std::vector&lt;GPSPoint&gt; m_CarShapePolygon;
	std::vector&lt;WayPoint&gt; m_Path;
	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_TotalPath;
	int m_iCurrentTotalPathId;
	int m_iSafeTrajectory;
//	int m_iGlobalPathPrevID;
	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; m_PredictedPath;
	std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt; m_RollOuts;
	std::string carId;
	Lane* pLane;
	double m_SimulationSteeringDelayFactor; //second , time that every degree change in the steering wheel takes
	timespec m_SteerDelayTimer;
	double m_PredictionTime;
	double m_CostCalculationTime;
	double m_BehaviorGenTime;
	double m_RollOutsGenerationTime;

	BehaviorStateMachine* 		m_pCurrentBehaviorState;
	ForwardState * 				m_pGoToGoalState;
	StopState* 					m_pStopState;
	WaitState* 					m_pWaitState;
	InitState* 					m_pInitState;
	MissionAccomplishedState*	m_pMissionCompleteState;
	GoalState*					m_pGoalState;
	FollowState*				m_pFollowState;
	SwerveState*				m_pAvoidObstacleState;
	TrafficLightStopState*		m_pTrafficLightStopState;
	TrafficLightWaitState*		m_pTrafficLightWaitState;
	StopSignStopState* 			m_pStopSignStopState;
	StopSignWaitState* 			m_pStopSignWaitState;

	TrajectoryCosts m_TrajectoryCostsCalculatotor;



	//for debugging
	std::vector&lt;WayPoint&gt; m_PathSection;
	std::vector&lt;WayPoint&gt; m_SampledPoints;

	void InitBehaviorStates();

	void SetSimulatedTargetOdometryReadings(const double&amp; velocity_d, const double&amp; steering_d, const SHIFT_POS&amp; shift_d)
	{
		m_CurrentVelocityD = velocity_d;
		m_CurrentSteeringD = steering_d;
		m_CurrentShiftD = shift_d;
	}

	double GetSimulatedVelocity()
	{
		return m_CurrentVelocity;
	}

	double GetSimulatedSteering()
	{
		return m_CurrentSteering;
	}

	double GetSimulatedShift()
	{
		return m_CurrentShift;
	}


	//For Simulation
	WayPoint m_OdometryState;
	double m_CurrentVelocity, m_CurrentVelocityD; //meter/second
	double m_CurrentSteering, m_CurrentSteeringD; //radians
	SHIFT_POS m_CurrentShift , m_CurrentShiftD;

	double m_CurrentAccSteerAngle; //degrees steer wheel range
	double m_CurrentAccVelocity; // kilometer/hour
	//std::vector&lt;TrafficLight&gt; m_TrafficLights;

public:

	LocalPlannerH();
	virtual ~LocalPlannerH();
	void Init(const ControllerParams&amp; ctrlParams, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo);
	void InitPolygons();
	void FirstLocalizeMe(const WayPoint&amp; initCarPos);
	void LocalizeMe(const double&amp; dt); // in seconds
	void UpdateState(const VehicleState&amp; state, const bool&amp; bUseDelay = false);
	void CalculateImportantParameterForDecisionMaking(const VehicleState&amp; car_state,
			const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
			const TrajectoryCost&amp; bestTrajectory);

	BehaviorState DoOneStep(
			const double&amp; dt,
			const VehicleState&amp; state,
			const std::vector&lt;DetectedObject&gt;&amp; obj_list,
			const int&amp; goalID,
			RoadNetwork&amp; map,
			const bool&amp; bEmergencyStop,
			const bool&amp; bGreenTrafficLight,
			const bool&amp; bLive = false);

	void SimulateOdoPosition(const double&amp; dt, const VehicleState&amp; vehicleState);

private:

	//Obstacle avoidance functionalities
	bool CalculateObstacleCosts(RoadNetwork&amp; map, const VehicleState&amp; vstatus, const std::vector&lt;DetectedObject&gt;&amp; obj_list);

	double PredictTimeCostForTrajectory(std::vector&lt;WayPoint&gt;&amp; path,
			const VehicleState&amp; vstatus,
			const WayPoint&amp; currState);

	void PredictObstacleTrajectory(RoadNetwork&amp; map,
			const WayPoint&amp; pos,
			const double&amp; predTime,
			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);

	bool CalculateIntersectionVelocities(std::vector&lt;WayPoint&gt;&amp; path,
			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; predctedPath,
			const DetectedObject&amp; obj);

	bool GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;TrafficLight&gt;&amp; trafficLights, TrafficLight&amp; trafficL);
	void UpdateCurrentLane(RoadNetwork&amp; map, const double&amp; search_distance);
	bool SelectSafeTrajectoryAndSpeedProfile(const VehicleState&amp; vehicleState);
	BehaviorState GenerateBehaviorState(const VehicleState&amp; vehicleState);
	void TransformPoint(const WayPoint&amp; refPose, GPSPoint&amp; p);
	void AddAndTransformContourPoints(const DetectedObject&amp; obj, std::vector&lt;WayPoint&gt;&amp; contourPoints);
	void UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt);

	bool NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex);

	PlannerHNS::PlanningParams m_params;
};

} /* namespace PlannerHNS */

#endif /* LOCALPLANNERH_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/MappingHelpers.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/MappingHelpers.h">
				<diff>@@ -32,12 +32,14 @@ public:
 			const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
 			const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
 			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+			const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+			const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
 			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
 			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);
 
 	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);
 
-	static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
+	//static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);
 
 	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
 	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
@@ -45,32 +47,45 @@ public:
 			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
 			const GPSPoint&amp; origin, WayPoint&amp; way_point);
 
-	static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
+	//static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
 	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);
 
-	static void SetRoadLinksList(TiXmlElement* pElem, std::vector&lt;RoadSegment&gt;&amp; roadSegments);
-	static void SetLaneLinksList(TiXmlElement* pElem, std::vector&lt;Lane&gt;&amp; lanes);
-	static void SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines);
-	static void SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights);
-	static void SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes);
-
 	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
 	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);
 
 
-	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
+	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0, const bool bDirectionBased = true);
+	static std::vector&lt;Lane*&gt; GetClosestLanesListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 2.0, const bool bDirectionBased = true);
 	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
 	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
-	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
+	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const bool bDirectionBased = true);
+
+	static std::vector&lt;WayPoint*&gt; GetClosestWaypointsListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 2.0, const bool bDirectionBased = true);
+
 	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
 	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
 	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);
+	static void FindAdjacentLanes(RoadNetwork&amp; map);
+	static void ExtractSignalData(const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map);
+
+	static void ExtractStopLinesData(const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map);
+
+	static void ExtractCurbData(const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+				const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+				const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+				const GPSPoint&amp; origin, RoadNetwork&amp; map);
 
+	static void LinkMissingBranchingWayPoints(RoadNetwork&amp; map);
+	static void LinkTrafficLightsAndStopLinesConData(const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
+			const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; id_replace_list, RoadNetwork&amp; map);
 
-	static void llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin);
-	static void llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
-	static void xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin);
-	static void xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
+	static void LinkTrafficLightsAndStopLines(RoadNetwork&amp; map);
 
 	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);
 
@@ -95,7 +110,7 @@ public:
 	static std::vector&lt;GPSPoint&gt; GetPointsData(TiXmlElement* pElem);
 	static std::vector&lt;std::string&gt; SplitString(const std::string&amp; str, const std::string&amp; token);
 
-	static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
+	//static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);
 
 	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);
 
</diff>
				<old_file>/*
 * MappingHelpers.h
 *
 *  Created on: Jul 2, 2016
 *      Author: Hatem
 */

#ifndef MAPPINGHELPERS_H_
#define MAPPINGHELPERS_H_

#include &lt;math.h&gt;
#include &quot;RoadNetwork.h&quot;
#include &quot;UtilityH.h&quot;
#include &quot;DataRW.h&quot;
#include &quot;tinyxml.h&quot;


namespace PlannerHNS {


class MappingHelpers {
public:
	MappingHelpers();
	virtual ~MappingHelpers();

	static void ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
			const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
			const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
			const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
			const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
			const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
			const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag = false);

	static void ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin = false);

	static void SaveTrajectoryLonLatToKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectory);

	static void GetWayPoint(const int&amp; pid, const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path);
	static bool GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
			const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
			const GPSPoint&amp; origin, WayPoint&amp; way_point);

	static void WriteKML(const std::string&amp; kmlFile, const std::string&amp; kmlTemplat, RoadNetwork&amp; ap);
	static void LoadKML(const std::string&amp; kmlMap, RoadNetwork&amp; map);

	static void SetRoadLinksList(TiXmlElement* pElem, std::vector&lt;RoadSegment&gt;&amp; roadSegments);
	static void SetLaneLinksList(TiXmlElement* pElem, std::vector&lt;Lane&gt;&amp; lanes);
	static void SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines);
	static void SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights);
	static void SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes);

	static TiXmlElement* GetHeadElement(TiXmlElement* pMainElem);
	static TiXmlElement* GetDataFolder(const std::string&amp; folderName, TiXmlElement* pMainElem);


	static Lane* GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
	static Lane* GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
	static std::vector&lt;Lane*&gt; GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance = 5.0);
	static WayPoint* GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
	static WayPoint* GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map);
	static WayPoint GetFirstWaypoint(RoadNetwork&amp; map);
	static WayPoint* GetLastWaypoint(RoadNetwork&amp; map);


	static void llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin);
	static void llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);
	static void xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin);
	static void xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset);

	static void GetUniqueNextLanes(const Lane* l,  const std::vector&lt;Lane*&gt;&amp; traversed_lanes, std::vector&lt;Lane*&gt;&amp; lanes_list);

	static GPSPoint GetTransformationOrigin(const int&amp; bToyotaCityMap = 0);

	static Lane* GetLaneFromPath(const WayPoint&amp; currPos, const std::vector&lt;WayPoint&gt;&amp; currPath);
	static Lane* GetLaneById(const int&amp; id,RoadNetwork&amp; map);
	static int GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes);

	static WayPoint* FindWaypoint(const int&amp; id, RoadNetwork&amp; map);


	static std::vector&lt;TrafficLight&gt; GetTrafficLightsList(TiXmlElement* pElem);
	static std::vector&lt;StopLine&gt; GetStopLinesList(TiXmlElement* pElem);
	static std::vector&lt;Lane&gt; GetLanesList(TiXmlElement* pElem);
	static std::vector&lt;RoadSegment&gt; GetRoadSegmentsList(TiXmlElement* pElem);
	static std::vector&lt;int&gt; GetIDsFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
	static std::vector&lt;double&gt; GetDoubleFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
	static std::pair&lt;ACTION_TYPE, double&gt; GetActionPairFromPrefix(const std::string&amp; str, const std::string&amp; prefix, const std::string&amp; postfix);
	static std::vector&lt;WayPoint&gt; GetCenterLaneData(TiXmlElement* pElem, const int&amp; currLaneID);
	static std::vector&lt;WayPoint&gt; GetCenterLaneDataVer0(TiXmlElement* pElem, const int&amp; currLaneID);
	static std::vector&lt;GPSPoint&gt; GetPointsData(TiXmlElement* pElem);
	static std::vector&lt;std::string&gt; SplitString(const std::string&amp; str, const std::string&amp; token);

	static void CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,const double&amp; maxLaneDistance, const double&amp; density,const std::vector&lt;TrafficLight&gt;&amp; trafficLights, const std::vector&lt;GPSPoint&gt;&amp; stopLines);

	static int ReplaceMyID(int&amp; id, const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list);

	static double m_USING_VER_ZERO;

};

} /* namespace PlannerHNS */

#endif /* MAPPINGHELPERS_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/MatrixOperations.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/MatrixOperations.h">
				<diff>@@ -17,39 +17,21 @@ namespace PlannerHNS {
 
 class Mat3
 {
-	double m11, m12, m13;
-	double m21, m22, m23;
-	double m31, m32, m33;
-
 	double m[3][3];
 
 public:
 	Mat3()
 	{
 		//initialize Identity by default
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
-	}
+		for(int i=0;i&lt;3;i++)
+			for(int j=0;j&lt;3;j++)
+				m[i][j] = 0;
 
-	Mat3(double angle, POINT2D trans)
-	{
-		//Initialize Rotation Matrix
-		double c = cos(angle);
-		double s = sin(angle);
-		m11 = c;
-		m12 = s;
-		m21 = -s;
-		m22 = c;
-		m31 = trans.x;
-		m32 = trans.y;
-		m13 = m23= 0;
-		m33 = 1;
+		m[0][0] = m[1][1] = m[2][2] = 1;
 	}
 
 	Mat3(double transX, double transY, bool mirrorX, bool mirrorY )
 	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
 		m[0][0] = (mirrorX == true ) ? -1 : 1; m[0][1] =  0; m[0][2] =  transX;
 		m[1][0] = 0; m[1][1] =  (mirrorY==true) ? -1 : 1; m[1][2] =  transY;
 		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
@@ -57,8 +39,6 @@ public:
 
 	Mat3(double transX, double transY)
 	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
 		m[0][0] = 1; m[0][1] =  0; m[0][2] =  transX;
 		m[1][0] = 0; m[1][1] =  1; m[1][2] =  transY;
 		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
@@ -66,8 +46,6 @@ public:
 
 	Mat3(double rotation_angle)
 	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
 		double c = cos(rotation_angle);
 		double s = sin(rotation_angle);
 		m[0][0] = c; m[0][1] = -s; m[0][2] =  0;
@@ -77,8 +55,6 @@ public:
 
 	Mat3(GPSPoint rotationCenter)
 	{
-		m11 = m22 = m33 = 1;
-		m12 = m13 = m21 = m23 = m31 = m32 = 0;
 		double c = cos(rotationCenter.a);
 		double s = sin(rotationCenter.a);
 		double u = rotationCenter.x;
@@ -96,34 +72,6 @@ public:
 		v.y = m[1][0]*_v.x + m[1][1]*_v.y + m[1][2]*1;
 		return v;
 	}
-
-	POINT2D operator * (POINT2D v)
-	{
-		Mat3 m = *this;
-		POINT2D r;
-		r.x = m.m11 * v.x + m.m21 * v.y + m.m31 * 1;
-		r.y = m.m12 * v.x + m.m22 * v.y + m.m32 * 1;
-		return r;
-	}
-
-	Mat3 operator *(Mat3 m2)
-	{
-		Mat3 m1 = *this;
-		Mat3 r;
-		r.m11 = m1.m11 * m2.m11 + m1.m12 * m2.m21 + m1.m13 * m2.m31;
-		r.m12 = m1.m11 * m2.m12 + m1.m12 * m2.m22 + m1.m13 * m2.m32;
-		r.m13 = m1.m11 * m2.m13 + m1.m12 * m2.m23 + m1.m13 * m2.m33;
-
-		r.m21 = m1.m21 * m2.m11 + m1.m22 * m2.m21 + m1.m23 * m2.m31;
-		r.m22 = m1.m21 * m2.m12 + m1.m22 * m2.m22 + m1.m23 * m2.m32;
-		r.m23 = m1.m21 * m2.m13 + m1.m22 * m2.m23 + m1.m23 * m2.m33;
-
-		r.m31 = m1.m31 * m2.m11 + m1.m32 * m2.m21 + m1.m33 * m2.m31;
-		r.m32 = m1.m31 * m2.m12 + m1.m32 * m2.m22 + m1.m33 * m2.m32;
-		r.m33 = m1.m31 * m2.m13 + m1.m32 * m2.m23 + m1.m33 * m2.m33;
-
-		return r;
-	}
 };
 
 } /* namespace PlannerHNS */
</diff>
				<old_file>/*
 * MatrixOperations.h
 *
 *  Created on: Jun 19, 2016
 *      Author: hatem
 */

#ifndef MATRIXOPERATIONS_H_
#define MATRIXOPERATIONS_H_

#include &quot;RoadNetwork.h&quot;
#include &lt;math.h&gt;


namespace PlannerHNS {


class Mat3
{
	double m11, m12, m13;
	double m21, m22, m23;
	double m31, m32, m33;

	double m[3][3];

public:
	Mat3()
	{
		//initialize Identity by default
		m11 = m22 = m33 = 1;
		m12 = m13 = m21 = m23 = m31 = m32 = 0;
	}

	Mat3(double angle, POINT2D trans)
	{
		//Initialize Rotation Matrix
		double c = cos(angle);
		double s = sin(angle);
		m11 = c;
		m12 = s;
		m21 = -s;
		m22 = c;
		m31 = trans.x;
		m32 = trans.y;
		m13 = m23= 0;
		m33 = 1;
	}

	Mat3(double transX, double transY, bool mirrorX, bool mirrorY )
	{
		m11 = m22 = m33 = 1;
		m12 = m13 = m21 = m23 = m31 = m32 = 0;
		m[0][0] = (mirrorX == true ) ? -1 : 1; m[0][1] =  0; m[0][2] =  transX;
		m[1][0] = 0; m[1][1] =  (mirrorY==true) ? -1 : 1; m[1][2] =  transY;
		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
	}

	Mat3(double transX, double transY)
	{
		m11 = m22 = m33 = 1;
		m12 = m13 = m21 = m23 = m31 = m32 = 0;
		m[0][0] = 1; m[0][1] =  0; m[0][2] =  transX;
		m[1][0] = 0; m[1][1] =  1; m[1][2] =  transY;
		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
	}

	Mat3(double rotation_angle)
	{
		m11 = m22 = m33 = 1;
		m12 = m13 = m21 = m23 = m31 = m32 = 0;
		double c = cos(rotation_angle);
		double s = sin(rotation_angle);
		m[0][0] = c; m[0][1] = -s; m[0][2] =  0;
		m[1][0] = s; m[1][1] =  c; m[1][2] =  0;
		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
	}

	Mat3(GPSPoint rotationCenter)
	{
		m11 = m22 = m33 = 1;
		m12 = m13 = m21 = m23 = m31 = m32 = 0;
		double c = cos(rotationCenter.a);
		double s = sin(rotationCenter.a);
		double u = rotationCenter.x;
		double v = rotationCenter.y;
		m[0][0] = c; m[0][1] = -s; m[0][2] = -u*c + v*s + u;
		m[1][0] = s; m[1][1] =  c; m[1][2] = -u*s - v*c + v;
		m[2][0] = 0; m[2][1] =  0; m[2][2] =  1;
	}


	GPSPoint operator * (GPSPoint v)
	{
		GPSPoint _v = v;
		v.x = m[0][0]*_v.x + m[0][1]*_v.y + m[0][2]*1;
		v.y = m[1][0]*_v.x + m[1][1]*_v.y + m[1][2]*1;
		return v;
	}

	POINT2D operator * (POINT2D v)
	{
		Mat3 m = *this;
		POINT2D r;
		r.x = m.m11 * v.x + m.m21 * v.y + m.m31 * 1;
		r.y = m.m12 * v.x + m.m22 * v.y + m.m32 * 1;
		return r;
	}

	Mat3 operator *(Mat3 m2)
	{
		Mat3 m1 = *this;
		Mat3 r;
		r.m11 = m1.m11 * m2.m11 + m1.m12 * m2.m21 + m1.m13 * m2.m31;
		r.m12 = m1.m11 * m2.m12 + m1.m12 * m2.m22 + m1.m13 * m2.m32;
		r.m13 = m1.m11 * m2.m13 + m1.m12 * m2.m23 + m1.m13 * m2.m33;

		r.m21 = m1.m21 * m2.m11 + m1.m22 * m2.m21 + m1.m23 * m2.m31;
		r.m22 = m1.m21 * m2.m12 + m1.m22 * m2.m22 + m1.m23 * m2.m32;
		r.m23 = m1.m21 * m2.m13 + m1.m22 * m2.m23 + m1.m23 * m2.m33;

		r.m31 = m1.m31 * m2.m11 + m1.m32 * m2.m21 + m1.m33 * m2.m31;
		r.m32 = m1.m31 * m2.m12 + m1.m32 * m2.m22 + m1.m33 * m2.m32;
		r.m33 = m1.m31 * m2.m13 + m1.m32 * m2.m23 + m1.m33 * m2.m33;

		return r;
	}
};

} /* namespace PlannerHNS */

#endif /* MATRIXOPERATIONS_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/PlannerCommonDef.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/PlannerCommonDef.h">
				<diff>@@ -14,6 +14,13 @@
 namespace PlannerHNS
 {
 
+enum MAP_SOURCE_TYPE
+{
+	MAP_AUTOWARE,
+	MAP_FOLDER,
+	MAP_KML_FILE
+};
+
 enum CAR_TYPE
 {
   Mv2Car, //!&lt; Mv2Car
</diff>
				<old_file>/*
 * PlannerCommonDef.h
 *
 *  Created on: Dec 14, 2016
 *      Author: hatem
 */

#ifndef PLANNERCOMMONDEF_H_
#define PLANNERCOMMONDEF_H_

#include &lt;math.h&gt;
#include &lt;string&gt;

namespace PlannerHNS
{

enum CAR_TYPE
{
  Mv2Car, //!&lt; Mv2Car
  PHVCar, //!&lt; PHVCar
  HVCar,  //!&lt; HVCar
  RoboCar,//!&lt; RoboCar
  SimulationCar
};

class PID_CONST
{
public:
	double kP;
	double kI;
	double kD;

	PID_CONST()
	{
		kP = kI = kD = 0;
	}

	PID_CONST(const double&amp; p, const double&amp; i, const double&amp; d)
	{
		kP = p;
		kI = i;
		kD = d;
	}
};

class ControllerParams
{
public:
	double SimulationSteeringDelay;
	double SteeringDelay;
	double minPursuiteDistance;
	PID_CONST Steering_Gain;
	PID_CONST Velocity_Gain;
	double Acceleration;
	double Deceleration;
	double FollowDistance;
	double LowpassSteerCutoff;
	double maxAccel;
	double maxDecel;


	ControllerParams()
	{
		SimulationSteeringDelay = 0.0;
		SteeringDelay 		= 0.8;
		Acceleration		= 0.5;
		Deceleration		= -0.8;
		FollowDistance		= 8.0;
		LowpassSteerCutoff	= 5.0;
		maxAccel			= 0.9;
		minPursuiteDistance = 2.0;
		maxDecel 			= -1.5;
	}
};

class CAR_BASIC_INFO
{
public:
  CAR_TYPE model;

  double turning_radius;
  double wheel_base;
  double max_speed_forward;
  double min_speed_forward;
  double max_speed_backword;
  double max_steer_value;
  double min_steer_value;
  double max_brake_value;
  double min_brake_value;
  double max_steer_angle;
  double min_steer_angle;
  double length;
  double width;
  double max_acceleration;
  double max_deceleration;

  CAR_BASIC_INFO()
  {
	  model 				= SimulationCar;
	  turning_radius 		= 5.2;
	  wheel_base			= 2.7;
	  max_speed_forward		= 3.0;
	  min_speed_forward		= 0.0;
	  max_speed_backword	= 1.0;
	  max_steer_value		= 660;
	  min_steer_value		= -660;
	  max_brake_value		= 0;
	  min_brake_value		= 0;
	  max_steer_angle		= 0.42;
	  min_steer_angle		= 0.42;
	  length				= 4.3;
	  width					= 1.82;
	  max_acceleration		= 1.5; // m/s2
	  max_deceleration		= -1.5; // 1/3 G
  }

  double CalcMaxSteeringAngle()
  {
    return  max_steer_angle;//asin(wheel_base/turning_radius);
  }

  double BoundSpeed(double s)
  {
	if(s &gt; 0 &amp;&amp; s &gt; max_speed_forward)
		return max_speed_forward;
	if(s &lt; 0 &amp;&amp; s &lt; max_speed_backword)
		return max_speed_backword;
	return s;
  }

  double BoundSteerAngle(double a)
  {
	if(a &gt; max_steer_angle)
		return max_steer_angle;
	if(a &lt; min_steer_angle)
		return min_steer_angle;

	return a;
  }

  double BoundSteerValue(double v)
  {
	  if(v &gt;= max_steer_value)
		return max_steer_value;
	if(v &lt;= min_steer_value)
		return min_steer_value;

	return v;
  }

};


} /* namespace PlannerHNS */

#endif /* PLANNERCOMMONDEF_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/PlannerH.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/PlannerH.h">
				<diff>@@ -6,7 +6,6 @@
  */
 
 #include &quot;RSPlanner.h&quot;
-#include &quot;GridMap.h&quot;
 
 #define START_POINT_MAX_DISTANCE 8 // meters
 #define GOAL_POINT_MAX_DISTANCE 8 // meters
@@ -24,18 +23,6 @@ public:
 	PlannerH();
 	virtual ~PlannerH(); 
 
-
-	/**
-	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles
-	 * @param start: Start position for the trajectory (x,y,theta)
-	 * @param goal:  Goal position (Destination point) (x,y,theta)
-	 * @param map:  2d grid map, ( cost map or occupancy grid.
-	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
-	 * @return path length
-	 */
-	double PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal, GridMap&amp; map, std::vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-			const double pathDensity = 0.25, const double smoothFactor = 12.0);
-
 	/**
 	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
 	 * @param start: Start position for the trajectory (x,y,theta)
@@ -75,7 +62,7 @@ public:
 				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
 				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
 				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
-				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints);
+				std::vector&lt;WayPoint&gt;&amp; sampledPoints);
 
 	/**
 	 * @brief Path planning for structured environment using dynamic programming
@@ -109,6 +96,10 @@ public:
 	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
 			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);
 
+	double PredictPlanUsingDP(const WayPoint&amp; startPose, WayPoint* closestWP, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches = true);
+
+	double PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vector&lt;WayPoint*&gt; closestWPs, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches = true, const bool bDirectionBased = false);
+
 	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);
 
 	//PlanningInternalParams m_Params;
</diff>
				<old_file>/*
 * PlannerH.h
 *
 *  Created on: May 14, 2016
 *      Author: hatem
 */

#include &quot;RSPlanner.h&quot;
#include &quot;GridMap.h&quot;

#define START_POINT_MAX_DISTANCE 8 // meters
#define GOAL_POINT_MAX_DISTANCE 8 // meters
#define LANE_CHANGE_SMOOTH_FACTOR_DISTANCE 8 // meters

namespace PlannerHNS
{

enum PLANDIRECTION {MOVE_FORWARD_ONLY, MOVE_BACKWARD_ONLY, 	MOVE_FREE};
enum HeuristicConstrains {EUCLIDEAN, NEIGBORHOOD,DIRECTION };

class PlannerH
{
public:
	PlannerH();
	virtual ~PlannerH(); 


	/**
	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles
	 * @param start: Start position for the trajectory (x,y,theta)
	 * @param goal:  Goal position (Destination point) (x,y,theta)
	 * @param map:  2d grid map, ( cost map or occupancy grid.
	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
	 * @return path length
	 */
	double PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal, GridMap&amp; map, std::vector&lt;WayPoint&gt;&amp; genSmoothedPath,
			const double pathDensity = 0.25, const double smoothFactor = 12.0);

	/**
	 * @brief Generates Trajectory using Reeds Shepp, this method will not try to avoid obstacles , but if there an obstacle on the trajectory function will fail. , also this function does not guaranteed to generate trajectories
	 * @param start: Start position for the trajectory (x,y,theta)
	 * @param goal:  Goal position (Destination point) (x,y,theta)
	 * @param generatedPath: pointer to return the smooth trajectory. - Better Not to use this
	 * @return path length
	 */
	double PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, std::vector&lt;WayPoint&gt;&amp; generatedPath,
			const double pathDensity = 0.25, const double smoothFactor = 12.0);


	/**
	 * @brief Generate Roll outs for global generated path
	 * @param referencePath center lint reference path
	 * @param carPos current car position
	 * @param bEnableLaneChange is lane change is available
	 * @param speed current car speed
	 * @param microPlanDistance distance limit for roll outs
	 * @param maxSpeed maximum forward speed
	 * @param minSpeed minimum forward speed
	 * @param carTipMargin 1st roll out smoothing parameter
	 * @param rollInMargin 2nd roll out smoothing parameter
	 * @param rollInSpeedFactor roll out 3rd smoothing parameter
	 * @param pathDensity distance between every two waypoints in the generated trajectory
	 * @param rollOutDensity distance between the center line and adjacent trajectories
	 * @param rollOutNumber number of sampled trajectories
	 * @param SmoothDataWeight general smoothing parameter , how smoother keep close to original data 0 - 0.5
	 * @param SmoothWeight general smoothing parameter, how smoother is trying to pull away to form the shortest and strait line possible
	 * @param SmoothTolerance performance measure , conjugate gradient conversion factor should be 0.1 - 0.01
	 * @param speedProfileFactor how car should slow for corners
	 * @param bHeadingSmooth follow car heading direction or center line path heading for sampling direction
	 */
	void GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths, const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints);

	/**
	 * @brief Path planning for structured environment using dynamic programming
	 * @param lane
	 * @param carPos
	 * @param goalPos
	 * @param prevWayPoint
	 * @param maxPlanningDistance
	 * @param globalPath
	 * @param path
	 * @return generated path length
	 */
	double PlanUsingDP(const WayPoint&amp; carPos,const WayPoint&amp; goalPos,
			const double&amp; maxPlanningDistance, const bool bEnableLaneChange, const std::vector&lt;int&gt;&amp; globalPath,
			RoadNetwork&amp; map, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, std::vector&lt;WayPoint*&gt;* all_cell_to_delete = 0);

	 double PlanUsingDPRandom(const WayPoint&amp; start,
	 		 const double&amp; maxPlanningDistance,
	 		 RoadNetwork&amp; map,
	 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);


	/**
	 * @brief Return all possible trajectories from current position to max planning distance in all directions
	 * @param lane
	 * @param carPos
	 * @param maxPlanningDistance
	 * @param paths
	 * @return
	 */
	double PredictPlanUsingDP(Lane* lane, const WayPoint&amp; carPos, const double&amp; maxPlanningDistance,
			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths);

	void DeleteWaypoints(std::vector&lt;WayPoint*&gt;&amp; wps);

	//PlanningInternalParams m_Params;
};

}


</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/PlanningHelpers.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/PlanningHelpers.h">
				<diff>@@ -25,7 +25,12 @@ namespace PlannerHNS {
 #define LANE_CHANGE_COST 3.0 // meters
 #define BACKUP_STRAIGHT_PLAN_DISTANCE 75 //meters
 
-class PlanningHelpers {
+class PlanningHelpers
+{
+
+public:
+	static std::vector&lt;std::pair&lt;GPSPoint, GPSPoint&gt; &gt; m_TestingClosestPoint;
+
 public:
 	PlanningHelpers();
 	virtual ~PlanningHelpers();
@@ -40,6 +45,7 @@ public:
 	 */
 	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);
 
+
 	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);
 
 	/**
@@ -67,10 +73,15 @@ public:
 	 * @param prevIndex initial search index
 	 * @return index of the closest next point from trajectory
 	 */
-	static int GetClosestNextPointIndex(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+	static int GetClosestNextPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+
+	static int GetClosestNextPointIndexFast(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+
+	static int GetClosestNextPointIndexFastV2(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
 
-	static int GetClosestNextPointIndexDirection(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
+	static int GetClosestNextPointIndexDirectionFast(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
 
+	static int GetClosestNextPointIndexDirectionFastV2(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
 
 	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
 	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
@@ -80,6 +91,9 @@ public:
 	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);
 
 
+	static void CreateManualBranch(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; degree, const DIRECTION_TYPE&amp; direction);
+	static void CreateManualBranchFromTwoPoints(WayPoint&amp; p1,WayPoint&amp; p2 , const double&amp; distance, const DIRECTION_TYPE&amp; direction, std::vector&lt;WayPoint&gt;&amp; path);
+
 	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
 	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
 	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
@@ -92,6 +106,9 @@ public:
 	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
 			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
 
+	static void ExtractPartFromPointToDistanceFast(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
+				const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);
+
 	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
 			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
 			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
@@ -101,11 +118,12 @@ public:
 			const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
 			std::vector&lt;WayPoint&gt;&amp; sampledPoints);
 
-
 	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
 	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
 	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
 
+	static void SmoothGlobalPathSpeed(std::vector&lt;WayPoint&gt;&amp; path);
+
 	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
 //	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
 //			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
@@ -126,6 +144,9 @@ public:
 	static int PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
 			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints);
 
+	static int PredictiveIgnorIdsDP(WayPoint* pStart, const double&amp; DistanceLimit,
+				std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints, std::vector&lt;int&gt;&amp; lanes_ids);
+
 	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
 	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
 	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);
@@ -151,11 +172,13 @@ public:
 
 	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);
 
-	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance);
+	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const RelativeInfo&amp; info,int&amp; prev_index, const double&amp; reasonable_brake_distance);
 	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);
 
 	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);
 
+	static bool GetThreePointsInfo(const WayPoint&amp; p0, const WayPoint&amp; p1, const WayPoint&amp; p2, WayPoint&amp; perp_p, double&amp; long_d, double lat_d);
+
 	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);
 
 	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
</diff>
				<old_file>/*
 * PlanningHelpers.h
 *
 *  Created on: Jun 16, 2016
 *      Author: hatem
 */

#ifndef PLANNINGHELPERS_H_
#define PLANNINGHELPERS_H_

#include &lt;math.h&gt;
#include &quot;RoadNetwork.h&quot;
#include &quot;UtilityH.h&quot;
#include &quot;DataRW.h&quot;
#include &quot;tinyxml.h&quot;


namespace PlannerHNS {

#define distance2points(from , to) sqrt(pow(to.x - from.x, 2) + pow(to.y - from.y, 2))
#define distance2pointsSqr(from , to) pow(to.x - from.x, 2) + pow(to.y - from.y, 2)
#define pointNorm(v) sqrt(v.x*v.x + v.y*v.y)
#define angle2points(from , to) atan2(to.y - from.y, to.x - from.x )
#define LANE_CHANGE_SPEED_FACTOR 0.5
#define LANE_CHANGE_COST 3.0 // meters
#define BACKUP_STRAIGHT_PLAN_DISTANCE 75 //meters

class PlanningHelpers {
public:
	PlanningHelpers();
	virtual ~PlanningHelpers();

	/**
	 * @brief Find all relative information from the point p to the trajectory such as (perpendicular distance , closest next point , closest back point, distance from perpendicular intersection point to next point, distance from perpendicular intersection point to previous point)
	 * @param trajectory list of waypoints
	 * @param p query point
	 * @param info collection of calculated information
	 * @param prevIndex initial search index
	 * @return true if success without errors, false otherwise
	 */
	static bool GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex = 0);

	static bool GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p, const double&amp; searchDistance, RelativeInfo&amp; info);

	/**
	 * @brief Find point on the trajectory after initial relative point with specific distance
	 * @param trajectory list of waypoints
	 * @param init_p initial relative point on trajectory
	 * @param distance distance from initial relative point to follow point
	 * @return point on trajectory
	 */
	static WayPoint GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index);

	/**
	 * @brief Calculate the precise distance from projection of point p2 (relative) to projection of point 1 (relative)
	 * @param trajectory list of waypoints
	 * @param p1 first relative point
	 * @param p2 second relative point
	 * @return distance on trajectory
	 */
	static double GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2);

	/**
	 * @brief Find the closest next point on the trajectory index
	 * @param trajectory list of waypoints
	 * @param p query point
	 * @param prevIndex initial search index
	 * @return index of the closest next point from trajectory
	 */
	static int GetClosestNextPointIndex(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);

	static int GetClosestNextPointIndexDirection(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);


	static int GetClosestPointIndex_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex = 0 );
	static WayPoint GetPerpendicularOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex = 0);
	static double GetPerpDistanceToTrajectorySimple_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, const int&amp; prevIndex = 0);
	static double GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; p1, const WayPoint&amp; p2, const WayPoint&amp; pose);
	static WayPoint GetNextPointOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex = 0);
	static double GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);


	static void FixPathDensity(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity);
	static void SmoothPath(std::vector&lt;WayPoint&gt;&amp; path, double weight_data =0.25,double weight_smooth = 0.25,double tolerance = 0.01);
	static double CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center);
	static double CalcAngleAndCost(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0, const bool&amp; bSmooth = true );
	//static double CalcAngleAndCostSimple(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);
	static double CalcAngleAndCostAndCurvatureAnd2D(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost = 0);

	static double GetAccurateDistanceOnTrajectory(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p);

	static void ExtractPartFromPointToDistance(const std::vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
			const double&amp; pathDensity, std::vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance);

	static void CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const std::vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
			int&amp; end_index, std::vector&lt;double&gt;&amp; end_laterals ,
			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
			const double&amp; maxSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
			const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
			const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
			const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
			std::vector&lt;WayPoint&gt;&amp; sampledPoints);


	static void SmoothSpeedProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);
	static void SmoothCurvatureProfiles(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance = 0.1);
	static void SmoothWayPointsDirections(std::vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	= 0.1);

	static void GenerateRecommendedSpeed(std::vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor);
//	static WayPoint* BuildPlanningSearchTree(Lane* l, const WayPoint&amp; prevWayPointIndex,
//			const WayPoint&amp; startPos, const WayPoint&amp; goalPos,
//			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
//			int&amp; nMaxLeftBranches, int&amp; nMaxRightBranches,
//			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );

	static WayPoint* BuildPlanningSearchTreeV2(WayPoint* pStart,
			const WayPoint&amp; goalPos,
			const std::vector&lt;int&gt;&amp; globalPath, const double&amp; DistanceLimit,
			const bool&amp; bEnableLaneChange,
			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );

	static WayPoint* BuildPlanningSearchTreeStraight(WayPoint* pStart,
			const double&amp; DistanceLimit,
			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete );

	static int PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
			std::vector&lt;WayPoint*&gt;&amp; all_cells_to_delete, std::vector&lt;WayPoint*&gt;&amp; end_waypoints);

	static bool CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL);
	static WayPoint* CheckLaneExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL);
	static WayPoint* CheckNodeExits(const std::vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL);

	static WayPoint* CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
			WayPoint* pBack);
	static double GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
			const double&amp; minDistance , const double&amp; prevCost, std::vector&lt;WayPoint&gt;&amp; points);

	static WayPoint* GetMinCostCell(const std::vector&lt;WayPoint*&gt;&amp; cells, const std::vector&lt;int&gt;&amp; globalPathIds);

	static void TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP, const std::vector&lt;int&gt;&amp; globalPathIds,
			std::vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths);

	static void ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths);

	static std::vector&lt;int&gt; GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path);

	static bool FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x);
	static void RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x);

	static ACTION_TYPE GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP);

	static void CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, std::vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance = 100);

	static double GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance);
	static bool CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2);

	static double GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID,int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex = 0);

	static void WritePathToFile(const std::string&amp; fileName, const std::vector&lt;WayPoint&gt;&amp; path);

	static void TestQuadraticSpline(const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path);
	static double frunge ( double x );
	static double fprunge ( double x );
	static double fpprunge ( double x );

};

} /* namespace PlannerHNS */

#endif /* PLANNINGHELPERS_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/RoadNetwork.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/RoadNetwork.h">
				<diff>@@ -29,7 +29,7 @@ enum DRIVABLE_TYPE {DIRT, TARMAC, PARKINGAREA, INDOOR, GENERAL_AREA};
 enum GLOBAL_STATE_TYPE {G_WAITING_STATE, G_PLANING_STATE, G_FORWARD_STATE, G_BRANCHING_STATE, G_FINISH_STATE};
 
 enum STATE_TYPE {INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
-	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE};
+	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE, YIELDING_STATE, BRANCH_LEFT_STATE, BRANCH_RIGHT_STATE};
 
 enum LIGHT_INDICATOR {INDICATOR_LEFT, INDICATOR_RIGHT, INDICATOR_BOTH , INDICATOR_NONE};
 
@@ -37,8 +37,9 @@ enum SHIFT_POS {SHIFT_POS_PP = 0x60, SHIFT_POS_RR = 0x40, SHIFT_POS_NN = 0x20,
 	SHIFT_POS_DD = 0x10, SHIFT_POS_BB = 0xA0, SHIFT_POS_SS = 0x0f, SHIFT_POS_UU = 0xff };
 
 enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION,
-	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION};
+	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION, START_ACTION, SLOWDOWN_ACTION, CHANGE_DESTINATION, WAITING_ACTION, DESTINATION_REACHED,  UNKOWN_ACTION};
 
+enum BEH_STATE_TYPE {BEH_FORWARD_STATE=0,BEH_STOPPING_STATE=1, BEH_BRANCH_LEFT_STATE=2, BEH_BRANCH_RIGHT_STATE=3, BEH_YIELDING_STATE=4, BEH_ACCELERATING_STATE=5, BEH_SLOWDOWN_STATE=6};
 
 class Lane;
 class TrafficLight;
@@ -55,56 +56,23 @@ public:
 	}
 };
 
-class POINT2D
-{
-public:
-    double x;
-    double y;
-    double z;
-    POINT2D()
-    {
-      x=0;y=0;z=0;
-    }
-    POINT2D(double px, double py, double pz = 0)
-    {
-      x = px;
-      y = py;
-      z = pz;
-    }
-};
-
-
-
-class RECTANGLE
-
-{
-public:
-  POINT2D bottom_left;
-  POINT2D top_right;
-  double width;
-  double length;
-  bool bObstacle;
-
-
-  inline bool PointInRect(POINT2D p)
-  {
-    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
-  }
-
-  inline bool HitTest(POINT2D p)
-  {
-    return PointInRect(p) &amp;&amp; bObstacle;
-  }
-
-  RECTANGLE()
-  {
-	  width=0;
-	  length = 0;
-    bObstacle = true;
-  }
-
-  virtual ~RECTANGLE(){}
-};
+//class POINT2D
+//{
+//public:
+//    double x;
+//    double y;
+//    double z;
+//    POINT2D()
+//    {
+//      x=0;y=0;z=0;
+//    }
+//    POINT2D(double px, double py, double pz = 0)
+//    {
+//      x = px;
+//      y = py;
+//      z = pz;
+//    }
+//};
 
 class GPSPoint
 {
@@ -145,6 +113,37 @@ public:
 	}
 };
 
+class RECTANGLE
+
+{
+public:
+  GPSPoint bottom_left;
+  GPSPoint top_right;
+  double width;
+  double length;
+  bool bObstacle;
+
+
+  inline bool PointInRect(GPSPoint p)
+  {
+    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
+  }
+
+  inline bool HitTest(GPSPoint p)
+  {
+    return PointInRect(p) &amp;&amp; bObstacle;
+  }
+
+  RECTANGLE()
+  {
+	  width=0;
+	  length = 0;
+    bObstacle = true;
+  }
+
+  virtual ~RECTANGLE(){}
+};
+
 class PolygonShape
 {
 public:
@@ -193,17 +192,17 @@ class MapItem
 {
 public:
   int id;
-  POINT2D sp; //start point
-  POINT2D ep; // end point
+  GPSPoint sp; //start point
+  GPSPoint ep; // end point
   GPSPoint center;
   double c; //curvature
   double w; //width
   double l; //length
   std::string fileName; //
-  std::vector&lt;POINT2D&gt; polygon;
+  std::vector&lt;GPSPoint&gt; polygon;
 
 
-  MapItem(int ID, POINT2D start, POINT2D end, double curvature, double width, double length, std::string objName)
+  MapItem(int ID, GPSPoint start, GPSPoint end, double curvature, double width, double length, std::string objName)
   {
     id = ID;
     sp = start;
@@ -255,7 +254,7 @@ class Obstacle : public MapItem
   public:
     OBSTACLE_TYPE t;
 
-    Obstacle(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
+    Obstacle(int ID, GPSPoint start, GPSPoint end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
   {
       t = type;
   }
@@ -297,7 +296,7 @@ class DrivableArea : public MapItem
 public:
   DRIVABLE_TYPE t; // drivable area type
 
-  DrivableArea(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
+  DrivableArea(int ID, GPSPoint start, GPSPoint end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
   {
     t = type;
   }
@@ -373,6 +372,9 @@ public:
 	int 		RightLaneId;
 	int 		stopLineID;
 	DIRECTION_TYPE bDir;
+	STATE_TYPE	state;
+	BEH_STATE_TYPE beh_state;
+	int 		iOriginalIndex;
 
 	Lane* pLane;
 	WayPoint* pLeft;
@@ -400,6 +402,9 @@ public:
 		collisionCost = 0;
 		laneChangeCost = 0;
 		stopLineID = -1;
+		state = INITIAL_STATE;
+		beh_state = BEH_STOPPING_STATE;
+		iOriginalIndex = 0;
 	}
 
 	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
@@ -424,6 +429,9 @@ public:
 		collisionCost = 0;
 		laneChangeCost = 0;
 		stopLineID = -1;
+		iOriginalIndex = 0;
+		state = INITIAL_STATE;
+		beh_state = BEH_STOPPING_STATE;
 	}
 };
 
@@ -451,6 +459,24 @@ public:
 	}
 };
 
+class Curb
+{
+public:
+	int id;
+	int laneId;
+	int roadId;
+	std::vector&lt;GPSPoint&gt; points;
+	Lane* pLane;
+
+	Curb()
+	{
+		id    = 0;
+		laneId =0;
+		roadId =0;
+		pLane = 0;
+	}
+};
+
 class StopLine
 {
 public:
@@ -461,6 +487,7 @@ public:
 	int stopSignID;
 	std::vector&lt;GPSPoint&gt; points;
 	Lane* pLane;
+	int linkID;
 
 	StopLine()
 	{
@@ -470,6 +497,7 @@ public:
 		pLane = 0;
 		trafficLightID = -1;
 		stopSignID = -1;
+		linkID = 0;
 	}
 };
 
@@ -528,7 +556,7 @@ public:
 	}
 };
 
-enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLAH_RED};
+enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLASH_RED};
 
 class TrafficLight
 {
@@ -539,12 +567,14 @@ public:
 	double stoppingDistance;
 	std::vector&lt;int&gt; laneIds;
 	std::vector&lt;Lane*&gt; pLanes;
+	int linkID;
 
 	TrafficLight()
 	{
 		stoppingDistance = 2;
 		id 			= 0;
 		lightState	= GREEN_LIGHT;
+		linkID 		= 0;
 	}
 
 	bool CheckLane(const int&amp; laneId)
@@ -637,6 +667,7 @@ public:
 	std::vector&lt;RoadSegment&gt; roadSegments;
 	std::vector&lt;TrafficLight&gt; trafficLights;
 	std::vector&lt;StopLine&gt; stopLines;
+	std::vector&lt;Curb&gt; curbs;
 
 };
 
@@ -691,19 +722,36 @@ public:
 	OBSTACLE_TYPE t;
 	WayPoint center;
 	WayPoint predicted_center;
+	WayPoint noisy_center;
+	STATE_TYPE predicted_behavior;
 	std::vector&lt;GPSPoint&gt; contour;
+	std::vector&lt;std::vector&lt;WayPoint&gt; &gt; predTrajectories;
+	std::vector&lt;WayPoint*&gt; pClosestWaypoints;
 	double w;
 	double l;
 	double h;
 	double distance_to_center;
+
+	double actual_speed;
+	double actual_yaw;
+
+	bool bDirection;
+	bool bVelocity;
+	int acceleration;
 	DetectedObject()
 	{
+		bDirection = false;
+		bVelocity = false;
+		acceleration = 0;
 		id = 0;
 		w = 0;
 		l = 0;
 		h = 0;
 		t = GENERAL_OBSTACLE;
 		distance_to_center = 0;
+		predicted_behavior = INITIAL_STATE;
+		actual_speed = 0;
+		actual_yaw = 0;
 	}
 
 };
@@ -730,6 +778,8 @@ public:
 	double 	smoothingSmoothWeight;
 	double 	smoothingToleranceError;
 
+
+	double additionalBrakingDistance;
 	double verticalSafetyDistance;
 	double horizontalSafetyDistancel;
 
@@ -739,8 +789,6 @@ public:
 	bool 	enableHeadingSmoothing;
 	bool 	enableTrafficLightBehavior;
 	bool 	enableStopSignBehavior;
-	
-	bool	enableDynamicPlannerSwitch;
 
 	bool 	enabTrajectoryVelocities;
 
@@ -761,10 +809,11 @@ public:
 		minDistanceToAvoid				= 15;
 		maxDistanceToAvoid				= 5;
 		speedProfileFactor				= 1.0;
-		smoothingDataWeight				= 0.45;
-		smoothingSmoothWeight			= 0.3;
+		smoothingDataWeight				= 0.47;
+		smoothingSmoothWeight			= 0.2;
 		smoothingToleranceError			= 0.05;
 
+		additionalBrakingDistance		= 10.0;
 		verticalSafetyDistance 			= 0.0;
 		horizontalSafetyDistancel		= 0.0;
 
@@ -774,10 +823,7 @@ public:
 		enableTrafficLightBehavior		= false;
 		enableLaneChange 				= false;
 		enableStopSignBehavior			= false;
-		enabTrajectoryVelocities		= false;
-
-		enableDynamicPlannerSwitch 		= false;
-
+		enabTrajectoryVelocities 		= false;
 	}
 };
 
</diff>
				<old_file>/*
 * RoadNetwork.h
 *
 *  Created on: May 19, 2016
 *      Author: hatem
 */

#ifndef ROADNETWORK_H_
#define ROADNETWORK_H_

#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;sstream&gt;
#include &quot;UtilityH.h&quot;

#define OPENPLANNER_ENABLE_LOGS

namespace PlannerHNS
{


enum DIRECTION_TYPE {	FORWARD_DIR, FORWARD_LEFT_DIR, FORWARD_RIGHT_DIR,
	BACKWARD_DIR, BACKWARD_LEFT_DIR, BACKWARD_RIGHT_DIR, STANDSTILL_DIR};

enum OBSTACLE_TYPE {SIDEWALK, TREE, CAR, TRUCK, HOUSE, PEDESTRIAN, CYCLIST, GENERAL_OBSTACLE};

enum DRIVABLE_TYPE {DIRT, TARMAC, PARKINGAREA, INDOOR, GENERAL_AREA};

enum GLOBAL_STATE_TYPE {G_WAITING_STATE, G_PLANING_STATE, G_FORWARD_STATE, G_BRANCHING_STATE, G_FINISH_STATE};

enum STATE_TYPE {INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
	TRAFFIC_LIGHT_STOP_STATE,TRAFFIC_LIGHT_WAIT_STATE, STOP_SIGN_STOP_STATE, STOP_SIGN_WAIT_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, GOAL_STATE, FINISH_STATE};

enum LIGHT_INDICATOR {INDICATOR_LEFT, INDICATOR_RIGHT, INDICATOR_BOTH , INDICATOR_NONE};

enum SHIFT_POS {SHIFT_POS_PP = 0x60, SHIFT_POS_RR = 0x40, SHIFT_POS_NN = 0x20,
	SHIFT_POS_DD = 0x10, SHIFT_POS_BB = 0xA0, SHIFT_POS_SS = 0x0f, SHIFT_POS_UU = 0xff };

enum ACTION_TYPE {FORWARD_ACTION, BACKWARD_ACTION, STOP_ACTION, LEFT_TURN_ACTION,
	RIGHT_TURN_ACTION, U_TURN_ACTION, SWERVE_ACTION, OVERTACK_ACTION};


class Lane;
class TrafficLight;

class ObjTimeStamp
{
public:
	timespec tStamp;

	ObjTimeStamp()
	{
		tStamp.tv_nsec = 0;
		tStamp.tv_sec = 0;
	}
};

class POINT2D
{
public:
    double x;
    double y;
    double z;
    POINT2D()
    {
      x=0;y=0;z=0;
    }
    POINT2D(double px, double py, double pz = 0)
    {
      x = px;
      y = py;
      z = pz;
    }
};



class RECTANGLE

{
public:
  POINT2D bottom_left;
  POINT2D top_right;
  double width;
  double length;
  bool bObstacle;


  inline bool PointInRect(POINT2D p)
  {
    return p.x &gt;= bottom_left.x &amp;&amp; p.x &lt;= top_right.x &amp;&amp; p.y &gt;= bottom_left.y &amp;&amp; p.y &lt;= top_right.y;
  }

  inline bool HitTest(POINT2D p)
  {
    return PointInRect(p) &amp;&amp; bObstacle;
  }

  RECTANGLE()
  {
	  width=0;
	  length = 0;
    bObstacle = true;
  }

  virtual ~RECTANGLE(){}
};

class GPSPoint
{
public:
	double lat, x;
	double lon, y;
	double alt, z;
	double dir, a;

	GPSPoint()
	{
		lat = x = 0;
		lon = y = 0;
		alt = z = 0;
		dir = a = 0;
	}

	GPSPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
	{
		this-&gt;x = x;
		this-&gt;y = y;
		this-&gt;z = z;
		this-&gt;a = a;

		lat = 0;
		lon = 0;
		alt = 0;
		dir = 0;
	}

	std::string ToString()
	{
		std::stringstream str;
		str.precision(12);
		str &lt;&lt; &quot;X:&quot; &lt;&lt; x &lt;&lt; &quot;, Y:&quot; &lt;&lt; y &lt;&lt; &quot;, Z:&quot; &lt;&lt; z &lt;&lt; &quot;, A:&quot; &lt;&lt; a &lt;&lt; std::endl;
		str &lt;&lt; &quot;Lon:&quot; &lt;&lt; lon &lt;&lt; &quot;, Lat:&quot; &lt;&lt; lat &lt;&lt; &quot;, Alt:&quot; &lt;&lt; alt &lt;&lt; &quot;, Dir:&quot; &lt;&lt; dir &lt;&lt; std::endl;
		return str.str();
	}
};

class PolygonShape
{
public:
	std::vector&lt;GPSPoint&gt; points;

	inline int PointInsidePolygon(const PolygonShape&amp; polygon,const GPSPoint&amp; p)
	{
		int counter = 0;
		  int i;
		  double xinters;
		  GPSPoint p1,p2;
		  int N = polygon.points.size();
		  if(N &lt;=0 ) return -1;

		  p1 = polygon.points.at(0);
		  for (i=1;i&lt;=N;i++)
		  {
		    p2 = polygon.points.at(i % N);

		    if (p.y &gt; MIN(p1.y,p2.y))
		    {
		      if (p.y &lt;= MAX(p1.y,p2.y))
		      {
		        if (p.x &lt;= MAX(p1.x,p2.x))
		        {
		          if (p1.y != p2.y)
		          {
		            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
		            if (p1.x == p2.x || p.x &lt;= xinters)
		              counter++;
		          }
		        }
		      }
		    }
		    p1 = p2;
		  }

		  if (counter % 2 == 0)
		    return 0;
		  else
		    return 1;
	}
};

class MapItem
{
public:
  int id;
  POINT2D sp; //start point
  POINT2D ep; // end point
  GPSPoint center;
  double c; //curvature
  double w; //width
  double l; //length
  std::string fileName; //
  std::vector&lt;POINT2D&gt; polygon;


  MapItem(int ID, POINT2D start, POINT2D end, double curvature, double width, double length, std::string objName)
  {
    id = ID;
    sp = start;
    ep = end;
    c = curvature;
    w = width;
    l = length;
    fileName = objName;

  }

  MapItem()
  {
    id = 0; c = 0; w = 0; l = 0;
  }

  virtual ~MapItem(){}

  MapItem(const MapItem &amp; cmi)
  {
        id = cmi.id;
        sp = cmi.sp;
        ep = cmi.ep;
        c = cmi.c;
        w = cmi.w;
        l = cmi.l;
        fileName = cmi.fileName;
  }
  MapItem &amp;operator=(const MapItem &amp;cmi)
  {
    this-&gt;id = cmi.id;
      this-&gt;sp = cmi.sp;
      this-&gt;ep = cmi.ep;
      this-&gt;c = cmi.c;
      this-&gt;w = cmi.w;
      this-&gt;l = cmi.l;
      this-&gt;fileName = cmi.fileName;
      return *this;
  }

  virtual int operator==(const MapItem &amp;mi) const
    {
      return this-&gt;id == mi.id;
    }
};

class Obstacle : public MapItem
{
  public:
    OBSTACLE_TYPE t;

    Obstacle(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,OBSTACLE_TYPE type, std::string fileName ) : MapItem(ID, start, end, curvature, width, length, fileName)
  {
      t = type;
  }
    virtual ~Obstacle()
    {
    }

    Obstacle() : MapItem()
       {
      t = SIDEWALK;
       }

    Obstacle(const Obstacle&amp; ob) : MapItem(ob)
      {
        t = ob.t;
      }

    Obstacle&amp; operator=(const Obstacle&amp; ob)
      {
      this-&gt;id = ob.id;
      this-&gt;sp = ob.sp;
      this-&gt;ep = ob.ep;
      this-&gt;c = ob.c;
      this-&gt;w = ob.w;
      this-&gt;l = ob.l;
      this-&gt;t = ob.t;
      this-&gt;fileName = ob.fileName;
      return *this;
      }

      virtual int operator==(const Obstacle &amp;ob) const
          {
            return this-&gt;id == ob.id &amp;&amp; this-&gt;t == ob.t;
          }
};

class DrivableArea : public MapItem
{
public:
  DRIVABLE_TYPE t; // drivable area type

  DrivableArea(int ID, POINT2D start, POINT2D end, double curvature, double width, double length,DRIVABLE_TYPE type, std::string fileName ) : MapItem( ID, start, end, curvature, width, length, fileName)
  {
    t = type;
  }

  virtual ~DrivableArea()
  {

  }

  DrivableArea() : MapItem()
    {
      t = PARKINGAREA;
    }

  DrivableArea(const DrivableArea&amp; da) : MapItem(da)
  {
    t = da.t;
  }

  DrivableArea&amp; operator=(const DrivableArea&amp; da)
  {
    this-&gt;id = da.id;
    this-&gt;sp = da.sp;
    this-&gt;ep = da.ep;
    this-&gt;c = da.c;
    this-&gt;w = da.w;
    this-&gt;l = da.l;
    this-&gt;t = da.t;
    this-&gt;fileName = da.fileName;
    return *this;
  }

  virtual int operator==(const DrivableArea &amp;da) const
      {
        return this-&gt;id == da.id &amp;&amp; this-&gt;t == da.t;
      }

};



class Rotation
{
public:
	double x;
	double y;
	double z;
	double w;

	Rotation()
	{
		x = 0;
		y = 0;
		z = 0;
		w = 0;
	}
};

class WayPoint
{
public:
	GPSPoint	pos;
	Rotation 	rot;
	double  	v;
	double  	cost;
	double  	timeCost;
	double  	totalReward;
	double  	collisionCost;
	double 		laneChangeCost;
	int 		laneId;
	int 		id;
	int 		LeftLaneId;
	int 		RightLaneId;
	int 		stopLineID;
	DIRECTION_TYPE bDir;

	Lane* pLane;
	WayPoint* pLeft;
	WayPoint* pRight;
	std::vector&lt;int&gt; 	toIds;
	std::vector&lt;int&gt; 	fromIds;
	std::vector&lt;WayPoint*&gt; pFronts;
	std::vector&lt;WayPoint*&gt; pBacks;
	std::vector&lt;std::pair&lt;ACTION_TYPE, double&gt; &gt; actionCost;

	WayPoint()
	{
		id = 0;
		v = 0;
		cost = 0;
		laneId = -1;
		pLane  = 0;
		pLeft = 0;
		pRight = 0;
		bDir = FORWARD_DIR;
		LeftLaneId = 0;
		RightLaneId = 0;
		timeCost = 0;
		totalReward = 0;
		collisionCost = 0;
		laneChangeCost = 0;
		stopLineID = -1;
	}

	WayPoint(const double&amp; x, const double&amp; y, const double&amp; z, const double&amp; a)
	{
		pos.x = x;
		pos.y = y;
		pos.z = z;
		pos.a = a;

		id = 0;
		v = 0;
		cost = 0;
		laneId = -1;
		pLane  = 0;
		pLeft = 0;
		pRight = 0;
		bDir = FORWARD_DIR;
		LeftLaneId = 0;
		RightLaneId = 0;
		timeCost = 0;
		totalReward = 0;
		collisionCost = 0;
		laneChangeCost = 0;
		stopLineID = -1;
	}
};

class RelativeInfo
{
public:
	double perp_distance;
	double to_front_distance; //negative
	double from_back_distance;
	int iFront;
	int iBack;
	int iGlobalPath;
	WayPoint perp_point;
	double angle_diff; // degrees

	RelativeInfo()
	{
		perp_distance = 0;
		to_front_distance = 0;
		from_back_distance = 0;
		iFront = 0;
		iBack = 0;
		iGlobalPath = 0;
		angle_diff = 0;
	}
};

class StopLine
{
public:
	int id;
	int laneId;
	int roadId;
	int trafficLightID;
	int stopSignID;
	std::vector&lt;GPSPoint&gt; points;
	Lane* pLane;

	StopLine()
	{
		id    = 0;
		laneId =0;
		roadId =0;
		pLane = 0;
		trafficLightID = -1;
		stopSignID = -1;
	}
};

class WaitingLine
{
public:
	int id;
	int laneId;
	int roadId;
	std::vector&lt;GPSPoint&gt; points;
	Lane* pLane;

	WaitingLine()
	{
		id    = 0;
		laneId =0;
		roadId =0;
		pLane = 0;
	}
};

enum TrafficSignTypes {UNKNOWN_SIGN, STOP_SIGN, MAX_SPEED_SIGN, MIN_SPEED_SIGN};

class TrafficSign
{
public:
	int id;
	int laneId;
	int roadId;

	GPSPoint pos;
	TrafficSignTypes signType;
	double value;
	double fromValue;
	double toValue;
	std::string strValue;
	timespec timeValue;
	timespec fromTimeValue;
	timespec toTimeValue;

	Lane* pLane;

	TrafficSign()
	{
		id    		= 0;
		laneId 		= 0;
		roadId		= 0;
		signType  	= UNKNOWN_SIGN;
		value		= 0;
		fromValue	= 0;
		toValue		= 0;
//		timeValue	= 0;
//		fromTimeValue = 0;
//		toTimeValue	= 0;
		pLane 		= 0;
	}
};

enum TrafficLightState {UNKNOWN_LIGHT, RED_LIGHT, GREEN_LIGHT, YELLOW_LIGHT, LEFT_GREEN, FORWARD_GREEN, RIGHT_GREEN, FLASH_YELLOW, FLAH_RED};

class TrafficLight
{
public:
	int id;
	GPSPoint pos;
	TrafficLightState lightState;
	double stoppingDistance;
	std::vector&lt;int&gt; laneIds;
	std::vector&lt;Lane*&gt; pLanes;

	TrafficLight()
	{
		stoppingDistance = 2;
		id 			= 0;
		lightState	= GREEN_LIGHT;
	}

	bool CheckLane(const int&amp; laneId)
	{
		for(unsigned int i=0; i &lt; laneIds.size(); i++)
		{
			if(laneId == laneIds.at(i))
				return true;
		}
		return false;
	}
};

enum RoadSegmentType {NORMAL_ROAD, INTERSECTION_ROAD, UTURN_ROAD, EXIT_ROAD, MERGE_ROAD, HIGHWAY_ROAD};

class RoadSegment
{
public:
	int id;
	RoadSegmentType roadType;
	std::vector&lt;int&gt; fromIds;
	std::vector&lt;int&gt; toIds;
	std::vector&lt;Lane&gt; Lanes;


	std::vector&lt;RoadSegment*&gt; fromLanes;
	std::vector&lt;RoadSegment*&gt; toLanes;

	RoadSegment()
	{
		id = 0;
		roadType = NORMAL_ROAD;
	}


};

enum LaneType{NORMAL_LANE, MERGE_LANE, EXIT_LANE, BUS_LANE, BUS_STOP_LANE, EMERGENCY_LANE};

class Lane
{
public:
	int id;
	int roadId;
	int areaId;
	int fromAreaId;
	int toAreaId;
	std::vector&lt;int&gt; fromIds;
	std::vector&lt;int&gt; toIds;
	int num; //lane number in the road segment from left to right
	double speed;
	double length;
	double dir;
	LaneType type;
	std::vector&lt;TrafficSign&gt; signs;
	std::vector&lt;WayPoint&gt; points;
	std::vector&lt;TrafficLight&gt; trafficlights;
	std::vector&lt;StopLine&gt; stopLines;
	WaitingLine waitingLine;

	std::vector&lt;Lane*&gt; fromLanes;
	std::vector&lt;Lane*&gt; toLanes;
	Lane* pLeftLane;
	Lane* pRightLane;

	RoadSegment * pRoad;

	Lane()
	{
		id 		= 0;
		num		= 0;
		speed 	= 0;
		length 	= 0;
		dir		= 0;
		type 	= NORMAL_LANE;
		pLeftLane = 0;
		pRightLane = 0;
		pRoad	= 0;
		roadId = 0;
		areaId = 0;
		fromAreaId = 0;
		toAreaId = 0;
	}

};

class RoadNetwork
{
public:
	std::vector&lt;RoadSegment&gt; roadSegments;
	std::vector&lt;TrafficLight&gt; trafficLights;
	std::vector&lt;StopLine&gt; stopLines;

};

class VehicleState : public ObjTimeStamp
{
public:
	double speed;
	double steer;
	SHIFT_POS shift;

	VehicleState()
	{
		speed = 0;
		steer = 0;
		shift = SHIFT_POS_NN;
	}

};

class BehaviorState
{
public:
	STATE_TYPE state;
	double maxVelocity;
	double minVelocity;
	double stopDistance;
	double followVelocity;
	double followDistance;
	LIGHT_INDICATOR indicator;
	bool bNewPlan;


	BehaviorState()
	{
		state = INITIAL_STATE;
		maxVelocity = 0;
		minVelocity = 0;
		stopDistance = 0;
		followVelocity = 0;
		followDistance = 0;
		indicator  = INDICATOR_NONE;
		bNewPlan = false;

	}

};

class DetectedObject
{
public:
	int id;
	OBSTACLE_TYPE t;
	WayPoint center;
	WayPoint predicted_center;
	std::vector&lt;GPSPoint&gt; contour;
	double w;
	double l;
	double h;
	double distance_to_center;
	DetectedObject()
	{
		id = 0;
		w = 0;
		l = 0;
		h = 0;
		t = GENERAL_OBSTACLE;
		distance_to_center = 0;
	}

};

class PlanningParams
{
public:
	double 	maxSpeed;
	double 	minSpeed;
	double 	planningDistance;
	double 	microPlanDistance;
	double 	carTipMargin;
	double 	rollInMargin;
	double 	rollInSpeedFactor;
	double 	pathDensity;
	double 	rollOutDensity;
	int 	rollOutNumber;
	double 	horizonDistance;
	double 	minFollowingDistance; //should be bigger than Distance to follow
	double 	minDistanceToAvoid; // should be smaller than minFollowingDistance and larger than maxDistanceToAvoid
	double	maxDistanceToAvoid; // should be smaller than minDistanceToAvoid
	double 	speedProfileFactor;
	double 	smoothingDataWeight;
	double 	smoothingSmoothWeight;
	double 	smoothingToleranceError;

	double verticalSafetyDistance;
	double horizontalSafetyDistancel;

	bool 	enableLaneChange;
	bool 	enableSwerving;
	bool 	enableFollowing;
	bool 	enableHeadingSmoothing;
	bool 	enableTrafficLightBehavior;
	bool 	enableStopSignBehavior;
	
	bool	enableDynamicPlannerSwitch;

	bool 	enabTrajectoryVelocities;

	PlanningParams()
	{
		maxSpeed 						= 3;
		minSpeed 						= 0;
		planningDistance 				= 10000;
		microPlanDistance 				= 30;
		carTipMargin					= 4.0;
		rollInMargin					= 12.0;
		rollInSpeedFactor				= 0.25;
		pathDensity						= 0.25;
		rollOutDensity					= 0.5;
		rollOutNumber					= 4;
		horizonDistance					= 120;
		minFollowingDistance			= 35;
		minDistanceToAvoid				= 15;
		maxDistanceToAvoid				= 5;
		speedProfileFactor				= 1.0;
		smoothingDataWeight				= 0.45;
		smoothingSmoothWeight			= 0.3;
		smoothingToleranceError			= 0.05;

		verticalSafetyDistance 			= 0.0;
		horizontalSafetyDistancel		= 0.0;

		enableHeadingSmoothing			= false;
		enableSwerving 					= false;
		enableFollowing					= false;
		enableTrafficLightBehavior		= false;
		enableLaneChange 				= false;
		enableStopSignBehavior			= false;
		enabTrajectoryVelocities		= false;

		enableDynamicPlannerSwitch 		= false;

	}
};

class HMIPreCalculatedConditions
{
public:

	HMIPreCalculatedConditions()
	{

	}
};

class PreCalculatedConditions
{
public:
	//-------------------------------------------//
	//Global Goals
	int 				currentGoalID;
	int 				prevGoalID;
	//-------------------------------------------//
	//Following
	double 				distanceToNext;
	double				velocityOfNext;
	//-------------------------------------------//
	//For Lane Change
	int 				iPrevSafeLane;
	int 				iCurrSafeLane;
	double				distanceToGoBack;
	double 				timeToGoBack;
	double 				distanceToChangeLane;
	double				timeToChangeLane;
	int 				currentLaneID;
	int 				originalLaneID;
	int 				targetLaneID;
	bool 				bUpcomingLeft;
	bool 				bUpcomingRight;
	bool				bCanChangeLane;
	bool				bTargetLaneSafe;
	//-------------------------------------------//
	//Traffic Lights &amp; Stop Sign
	int 				currentStopSignID;
	int 				prevStopSignID;
	int 				currentTrafficLightID;
	int 				prevTrafficLightID;
	bool 				bTrafficIsRed; //On , off status
	//-------------------------------------------//
	//Swerving
	int 				iPrevSafeTrajectory;
	int 				iCurrSafeTrajectory;
	int 				iCentralTrajectory;
	bool				bFullyBlock;
	LIGHT_INDICATOR 	indicator;

	//-------------------------------------------//
	//General
	bool 				bNewGlobalPath;
	bool 				bRePlan;
	double 				currentVelocity;
	double				minStoppingDistance; //comfortably
	int 				bOutsideControl; // 0 waiting, 1 start, 2 Green Traffic Light, 3 Red Traffic Light, 5 Emergency Stop
	bool				bGreenOutsideControl;
	std::vector&lt;double&gt; stoppingDistances;


	double distanceToStop()
	{
		if(stoppingDistances.size()==0) return 0;
		double minS = stoppingDistances.at(0);
		for(unsigned int i=0; i&lt; stoppingDistances.size(); i++)
		{
			if(stoppingDistances.at(i) &lt; minS)
				minS = stoppingDistances.at(i);
		}
		return minS;
	}

	PreCalculatedConditions()
	{
		currentGoalID 			= 0;
		prevGoalID				= -1;
		currentVelocity 		= 0;
		minStoppingDistance		= 1;
		bOutsideControl			= 0;
		bGreenOutsideControl	= false;
		//distance to stop
		distanceToNext			= -1;
		velocityOfNext			= 0;
		currentStopSignID		= -1;
		prevStopSignID			= -1;
		currentTrafficLightID	= -1;
		prevTrafficLightID		= -1;
		bTrafficIsRed			= false;
		iCurrSafeTrajectory		= -1;
		bFullyBlock				= false;

		iPrevSafeTrajectory		= -1;
		iCentralTrajectory		= -1;
		bRePlan					= false;
		bNewGlobalPath			= false;

		bCanChangeLane			= false;
		distanceToGoBack		= 0;
		timeToGoBack			= 0;
		distanceToChangeLane	= 0;
		timeToChangeLane		= 0;
		bTargetLaneSafe			= true;
		bUpcomingLeft			= false;
		bUpcomingRight			= false;
		targetLaneID			= -1;
		currentLaneID			= -1;
		originalLaneID			= -1;
		iCurrSafeLane 			= -1;
		iPrevSafeLane			= -1;

		indicator 				= INDICATOR_NONE;
	}

	virtual ~PreCalculatedConditions(){}

	std::string ToStringHeader()
	{
		return &quot;Time:General&gt;&gt;:currentVelocity:distanceToStop:minStoppingDistance:bStartBehaviorGenerator:bGoalReached:&quot;
				&quot;Following&gt;&gt;:velocityOfNext:distanceToNext:&quot;
				&quot;TrafficLight&gt;&gt;:currentTrafficLightID:bTrafficIsRed:&quot;
				&quot;Swerving&gt;&gt;:iSafeTrajectory:bFullyBlock:&quot;;
	}

	std::string ToString(STATE_TYPE beh)
	{
		std::string str = &quot;Unknown&quot;;
		switch(beh)
		{
		case PlannerHNS::INITIAL_STATE:
			str = &quot;Init&quot;;
			break;
		case PlannerHNS::WAITING_STATE:
			str = &quot;Waiting&quot;;
			break;
		case PlannerHNS::FORWARD_STATE:
			str = &quot;Forward&quot;;
			break;
		case PlannerHNS::STOPPING_STATE:
			str = &quot;Stop&quot;;
			break;
		case PlannerHNS::FINISH_STATE:
			str = &quot;End&quot;;
			break;
		case PlannerHNS::FOLLOW_STATE:
			str = &quot;Follow&quot;;
			break;
		case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
			str = &quot;Swerving&quot;;
			break;
		case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
			str = &quot;Light Stop&quot;;
			break;
		case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
			str = &quot;Light Wait&quot;;
			break;
		case PlannerHNS::STOP_SIGN_STOP_STATE:
			str = &quot;Sign Stop&quot;;
			break;
		case PlannerHNS::STOP_SIGN_WAIT_STATE:
			str = &quot;Sign Wait&quot;;
			break;
		default:
			str = &quot;Unknown&quot;;
			break;
		}

		return str;
	}
};

class TrajectoryCost
{
public:
	int index;
	int relative_index;
	double closest_obj_velocity;
	double distance_from_center;
	double priority_cost; //0 to 1
	double transition_cost; // 0 to 1
	double closest_obj_cost; // 0 to 1
	double cost;
	double closest_obj_distance;

	int lane_index;
	double lane_change_cost;
	double lateral_cost;
	double longitudinal_cost;
	bool bBlocked;
	std::vector&lt;std::pair&lt;int, double&gt; &gt; lateral_costs;


	TrajectoryCost()
	{
		lane_index = -1;
		index = -1;
		relative_index = -100;
		closest_obj_velocity = 0;
		priority_cost = 0;
		transition_cost = 0;
		closest_obj_cost = 0;
		distance_from_center = 0;
		cost = 0;
		closest_obj_distance = -1;
		lane_change_cost = 0;
		lateral_cost = 0;
		longitudinal_cost = 0;
		bBlocked = false;
	}

	std::string ToString()
	{
		std::ostringstream str;
		str.precision(4);
		str &lt;&lt; &quot;LaneIndex    : &quot; &lt;&lt; lane_index;
		str &lt;&lt; &quot;, Index      : &quot; &lt;&lt; relative_index;
		str &lt;&lt; &quot;, TotalCost  : &quot; &lt;&lt; cost;
		str &lt;&lt; &quot;, Priority   : &quot; &lt;&lt; priority_cost;
		str &lt;&lt; &quot;, Transition : &quot; &lt;&lt; transition_cost;
		str &lt;&lt; &quot;, Lateral    : &quot; &lt;&lt; lateral_cost;
		str &lt;&lt; &quot;, Longitu    : &quot; &lt;&lt; longitudinal_cost;
		str &lt;&lt; &quot;, LaneChange : &quot; &lt;&lt; lane_change_cost;
		str &lt;&lt; &quot;, Blocked    : &quot; &lt;&lt; bBlocked;
		str &lt;&lt; &quot;\n&quot;;
		for (unsigned int i=0; i&lt;lateral_costs.size(); i++ )
		{
			str &lt;&lt; &quot; - (&quot; &lt;&lt; lateral_costs.at(i).first &lt;&lt; &quot;, &quot; &lt;&lt; lateral_costs.at(i).second &lt;&lt; &quot;)&quot;;
		}

		return str.str();

	}
};

}


#endif /* ROADNETWORK_H_ */

</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/TrajectoryCosts.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/TrajectoryCosts.h">
				<diff>@@ -32,7 +32,14 @@ public:
 	vector&lt;TrajectoryCost&gt; m_TrajectoryCosts;
 	PlanningParams m_Params;
 	PolygonShape m_SafetyBorder;
-	//vector&lt;GPSPoint&gt; m_SafetyBox;
+	vector&lt;WayPoint&gt; m_AllContourPoints;
+	vector&lt;WayPoint&gt; m_CollisionPoints;
+	double m_WeightPriority;
+	double m_WeightTransition;
+	double m_WeightLong;
+	double m_WeightLat;
+	double m_WeightLaneChange;
+	double m_LateralSkipDistance;
 
 
 
@@ -42,6 +49,7 @@ private:
 	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
 	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
 	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);
+	bool CalculateIntersectionVelocities(const std::vector&lt;WayPoint&gt;&amp; path, const DetectedObject&amp; obj, const WayPoint&amp; currState,const CAR_BASIC_INFO&amp; carInfo, WayPoint&amp; collisionPoint);
 
 };
 
</diff>
				<old_file>/*
 * TrajectoryCosts.h
 *
 *  Created on: Dec 14, 2016
 *      Author: user
 */

#ifndef TRAJECTORYCOSTS_H_
#define TRAJECTORYCOSTS_H_

#include &quot;RoadNetwork.h&quot;
#include &quot;PlannerCommonDef.h&quot;
#include &quot;PlanningHelpers.h&quot;

using namespace std;

namespace PlannerHNS
{

class TrajectoryCosts
{
public:
	TrajectoryCosts();
	virtual ~TrajectoryCosts();

	TrajectoryCost DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths,
			const WayPoint&amp; currState, const int&amp; currTrajectoryIndex, const int&amp; currLaneIndex, const PlanningParams&amp; params,
			const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);

public:
	int m_PrevCostIndex;
	vector&lt;TrajectoryCost&gt; m_TrajectoryCosts;
	PlanningParams m_Params;
	PolygonShape m_SafetyBorder;
	//vector&lt;GPSPoint&gt; m_SafetyBox;



private:
	bool ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts);
	vector&lt;TrajectoryCost&gt; CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts, const int&amp; lane_index, const PlanningParams&amp; params);
	void NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts);
	void CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState);
	void CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params);

};

}

#endif /* TRAJECTORYCOSTS_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/include/geo_pos_conv.hh" new_path="">
				<diff>@@ -1,40 +0,0 @@
-#ifndef __GEO_POS_CONV__
-#define __GEO_POS_CONV__
-
-#include &lt;math.h&gt;
-
-class geo_pos_conv {
-private:
-	double m_x;  //m
-	double m_y;  //m
-	double m_z;  //m
-
-	double m_lat;  //latitude
-	double m_lon; //longitude
-	double m_h;
-  
-	double m_PLato;        //plane lat
-	double m_PLo;          //plane lon
-
-public:
-	double x() const;
-	double y() const;
-	double z() const;
-  
-	void set_plane(double lat,   double lon);
-	void set_plane(int num);
-	void set_xyz(double cx,   double cy,   double cz);
-
-	//set llh in radians
-	void set_llh(double lat, double lon, double h);
-
-	//set llh in nmea degrees
-	void set_llh_nmea_degrees(double latd,double lond, double h);
-
-        void llh_to_xyz(double lat, double lon, double ele);
-
-	void conv_llh2xyz(void);
-	void conv_xyz2llh(void);
-};
-
-#endif
</diff>
				<old_file>#ifndef __GEO_POS_CONV__
#define __GEO_POS_CONV__

#include &lt;math.h&gt;

class geo_pos_conv {
private:
	double m_x;  //m
	double m_y;  //m
	double m_z;  //m

	double m_lat;  //latitude
	double m_lon; //longitude
	double m_h;
  
	double m_PLato;        //plane lat
	double m_PLo;          //plane lon

public:
	double x() const;
	double y() const;
	double z() const;
  
	void set_plane(double lat,   double lon);
	void set_plane(int num);
	void set_xyz(double cx,   double cy,   double cz);

	//set llh in radians
	void set_llh(double lat, double lon, double h);

	//set llh in nmea degrees
	void set_llh_nmea_degrees(double latd,double lond, double h);

        void llh_to_xyz(double lat, double lon, double ele);

	void conv_llh2xyz(void);
	void conv_xyz2llh(void);
};

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/BehaviorStateMachine.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/BehaviorStateMachine.cpp">
				<diff>@@ -218,7 +218,7 @@ BehaviorStateMachine* WaitState::GetNextState()
 	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
 		return this;
 
-	PreCalculatedConditions* pCParams = GetCalcParams();
+	//PreCalculatedConditions* pCParams = GetCalcParams();
 
 	return FindBehaviorState(FORWARD_STATE);
 }
@@ -249,7 +249,18 @@ BehaviorStateMachine* FollowState::GetNextState()
 
 	//std::cout &lt;&lt; &quot;Following State &gt;&gt; followDistance: &quot; &lt;&lt; pCParams-&gt;distanceToNext &lt;&lt; &quot;, followSpeed: &quot; &lt;&lt; pCParams-&gt;velocityOfNext &lt;&lt; std::endl;
 
-	if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID
+	if(m_pParams-&gt;enableTrafficLightBehavior
+				&amp;&amp; pCParams-&gt;currentTrafficLightID &gt; 0
+				&amp;&amp; pCParams-&gt;bTrafficIsRed
+				&amp;&amp; pCParams-&gt;currentTrafficLightID != pCParams-&gt;prevTrafficLightID)
+			return FindBehaviorState(TRAFFIC_LIGHT_STOP_STATE);
+
+	else if(m_pParams-&gt;enableStopSignBehavior
+			&amp;&amp; pCParams-&gt;currentStopSignID &gt; 0
+			&amp;&amp; pCParams-&gt;currentStopSignID != pCParams-&gt;prevStopSignID)
+			return FindBehaviorState(STOP_SIGN_STOP_STATE);
+
+	else if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID
 			|| !pCParams-&gt;bFullyBlock)
 		return FindBehaviorState(FORWARD_STATE);
 
</diff>
				<old_file>/*
 * BehaviorStateMachine.cpp
 *
 *  Created on: Jun 19, 2016
 *      Author: hatem
 */

#include &quot;BehaviorStateMachine.h&quot;
#include &quot;UtilityH.h&quot;
#include &lt;iostream&gt;

using namespace UtilityHNS;


namespace PlannerHNS {

//PreCalculatedConditions* BehaviorStateMachine::m_pCalculatedValues = 0;
//PlanningParams BehaviorStateMachine::m_PlanningParams;

BehaviorStateMachine::BehaviorStateMachine(PlanningParams* pParams, PreCalculatedConditions* pPreCalcVal, BehaviorStateMachine* nextState)
{
	m_Behavior = INITIAL_STATE;

	m_currentStopSignID		= -1;
	m_currentTrafficLightID	= -1;
	decisionMakingTime		= 0.0;
	m_zero_velocity 		= 0.2;

	if(!pPreCalcVal)
		m_pCalculatedValues = new PreCalculatedConditions();
	else
		m_pCalculatedValues = pPreCalcVal;

	if(!pParams)
		m_pParams = new PlanningParams;
	else
		m_pParams = pParams;

	if(nextState)
		pNextStates.push_back(nextState);

	pNextStates.push_back(this);

	Init();
}

void BehaviorStateMachine::InsertNextState(BehaviorStateMachine* nextState)
{
	if(nextState)
		pNextStates.push_back(nextState);
}

BehaviorStateMachine* BehaviorStateMachine::FindBehaviorState(const STATE_TYPE&amp; behavior)
{
	for(unsigned int i = 0 ; i &lt; pNextStates.size(); i++)
	{
		BehaviorStateMachine* pState = pNextStates.at(i);
		if(pState &amp;&amp; behavior == pState-&gt;m_Behavior )
		{
			pState-&gt;ResetTimer();
			return pState;
		}
	}

	return 0;
}

void BehaviorStateMachine::Init()
{
	UtilityH::GetTickCount(m_StateTimer);
}

void BehaviorStateMachine::ResetTimer()
{
	UtilityH::GetTickCount(m_StateTimer);
}

BehaviorStateMachine::~BehaviorStateMachine()
{
}

BehaviorStateMachine* ForwardState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this; //return this behavior only , without reset

	PreCalculatedConditions* pCParams = GetCalcParams();

	if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID)
		return FindBehaviorState(GOAL_STATE);

	else if(m_pParams-&gt;enableSwerving
			&amp;&amp; pCParams-&gt;distanceToNext &lt;= m_pParams-&gt;minDistanceToAvoid
			&amp;&amp; !pCParams-&gt;bFullyBlock
			&amp;&amp; (pCParams-&gt;iCurrSafeTrajectory != pCParams-&gt;iPrevSafeTrajectory || pCParams-&gt;iCurrSafeLane != pCParams-&gt;iPrevSafeLane)
			)
		return FindBehaviorState(OBSTACLE_AVOIDANCE_STATE);

	else if(m_pParams-&gt;enableTrafficLightBehavior
			&amp;&amp; pCParams-&gt;currentTrafficLightID &gt; 0
			&amp;&amp; pCParams-&gt;bTrafficIsRed
			&amp;&amp; pCParams-&gt;currentTrafficLightID != pCParams-&gt;prevTrafficLightID)
		return FindBehaviorState(TRAFFIC_LIGHT_STOP_STATE);

	else if(m_pParams-&gt;enableStopSignBehavior
			&amp;&amp; pCParams-&gt;currentStopSignID &gt; 0
			&amp;&amp; pCParams-&gt;currentStopSignID != pCParams-&gt;prevStopSignID)
			return FindBehaviorState(STOP_SIGN_STOP_STATE);

	else if(m_pParams-&gt;enableFollowing
			&amp;&amp; pCParams-&gt;bFullyBlock)
			return FindBehaviorState(FOLLOW_STATE);

//	else if(pCParams-&gt;distanceToNext &lt;= m_pParams-&gt;maxDistanceToAvoid)
//		return FindBehaviorState(STOPPING_STATE);

	else
	{
		if(pCParams-&gt;iCurrSafeTrajectory == pCParams-&gt;iCentralTrajectory
				&amp;&amp; pCParams-&gt;iPrevSafeTrajectory != pCParams-&gt;iCurrSafeTrajectory)
			pCParams-&gt;bRePlan = true;

		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
	}
}

BehaviorStateMachine* MissionAccomplishedState::GetNextState()
{
	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

BehaviorStateMachine* StopState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	if(pCParams-&gt;distanceToNext &gt; m_pParams-&gt;maxDistanceToAvoid)
		return FindBehaviorState(FORWARD_STATE);

	else
		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

BehaviorStateMachine* TrafficLightStopState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	if(!pCParams-&gt;bTrafficIsRed)
	{
		pCParams-&gt;prevTrafficLightID = pCParams-&gt;currentTrafficLightID;
		return FindBehaviorState(FORWARD_STATE);
	}

	else if(pCParams-&gt;bTrafficIsRed &amp;&amp; pCParams-&gt;currentVelocity &lt;= m_zero_velocity)
			return FindBehaviorState(TRAFFIC_LIGHT_WAIT_STATE);
	else
		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

BehaviorStateMachine* TrafficLightWaitState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	if(!pCParams-&gt;bTrafficIsRed)
	{
		pCParams-&gt;prevTrafficLightID = pCParams-&gt;currentTrafficLightID;
		return FindBehaviorState(FORWARD_STATE);
	}

	else if(pCParams-&gt;currentVelocity &gt; m_zero_velocity)
		return FindBehaviorState(TRAFFIC_LIGHT_STOP_STATE);

	else
		return FindBehaviorState(this-&gt;m_Behavior); // return and reset

}

BehaviorStateMachine* StopSignStopState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	//std::cout &lt;&lt; &quot;From Stop Beh D: &quot; &lt;&lt; pCParams-&gt;distanceToStop() &lt;&lt; &quot;, Prev LineID: &quot; &lt;&lt; pCParams-&gt;prevStopSignID &lt;&lt; &quot;, Curr SignID: &quot; &lt;&lt; pCParams-&gt;currentStopSignID &lt;&lt; std::endl;

	if(pCParams-&gt;currentVelocity &lt; m_zero_velocity)
		return FindBehaviorState(STOP_SIGN_WAIT_STATE);

	else
		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

BehaviorStateMachine* StopSignWaitState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	//std::cout &lt;&lt; &quot;From Wait Beh D: &quot; &lt;&lt; pCParams-&gt;distanceToStop() &lt;&lt; &quot;, Prev LineID: &quot; &lt;&lt; pCParams-&gt;prevStopSignID &lt;&lt; &quot;, Curr SignID: &quot; &lt;&lt; pCParams-&gt;currentStopSignID &lt;&lt; std::endl;

	pCParams-&gt;prevStopSignID = pCParams-&gt;currentStopSignID;

	return FindBehaviorState(FORWARD_STATE);
}

BehaviorStateMachine* WaitState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	return FindBehaviorState(FORWARD_STATE);
}

BehaviorStateMachine* InitState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	if(pCParams-&gt;bOutsideControl == 1)
	{
		pCParams-&gt;prevGoalID = pCParams-&gt;currentGoalID;
		return FindBehaviorState(FORWARD_STATE);
	}

	else
		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

BehaviorStateMachine* FollowState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
			return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	//std::cout &lt;&lt; &quot;Following State &gt;&gt; followDistance: &quot; &lt;&lt; pCParams-&gt;distanceToNext &lt;&lt; &quot;, followSpeed: &quot; &lt;&lt; pCParams-&gt;velocityOfNext &lt;&lt; std::endl;

	if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID
			|| !pCParams-&gt;bFullyBlock)
		return FindBehaviorState(FORWARD_STATE);

	else
		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

BehaviorStateMachine* SwerveState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	if(pCParams-&gt;distanceToNext &gt; 0
				&amp;&amp; pCParams-&gt;distanceToNext &lt; m_pParams-&gt;minDistanceToAvoid
				&amp;&amp; !pCParams-&gt;bFullyBlock
				&amp;&amp; pCParams-&gt;iCurrSafeTrajectory != pCParams-&gt;iPrevSafeTrajectory)
		return FindBehaviorState(this-&gt;m_Behavior);

	else
		return FindBehaviorState(FORWARD_STATE);
}

BehaviorStateMachine* GoalState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this;

	PreCalculatedConditions* pCParams = GetCalcParams();

	if(pCParams-&gt;currentGoalID == -1)
		return FindBehaviorState(FINISH_STATE);

	else if(pCParams-&gt;currentGoalID != pCParams-&gt;prevGoalID)
	{
		pCParams-&gt;prevGoalID = pCParams-&gt;currentGoalID;
		return FindBehaviorState(FORWARD_STATE);
	}

	else
		return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

} /* namespace PlannerHNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/GridMap.cpp" new_path="">
				<diff>@@ -1,1674 +0,0 @@
-/*
- * GridMap.cpp
- *
- *  Created on: Oct 22, 2013
- *      Author: hatem
- */
-
-#include &quot;GridMap.h&quot;
-#include &quot;PlanningHelpers.h&quot;
-#include &lt;fstream&gt;
-
-using namespace std;
-
-namespace PlannerHNS
-{
-
-GridMap::GridMap(double start_x, double start_y, double map_w, double map_h, double cell_length, bool bDefaultEmpty)
- {
-	assert(cell_length &gt; 0);
-    assert(map_w&gt;0);
-    assert(map_h&gt;0);
-
-    m_bUpdatedMap = false;
-    origin_x = start_x ;
-    origin_y = start_y;
-    m_DisplayResolution = 1;
-    sub_cell_l = 0;
-	nInnerWCells = nInnerHCells = 0;
-	m_bEnableInnerMap = false;
-	inner_end_col = inner_end_row = inner_h = inner_start_col = inner_start_row = inner_w = 0;
-
-	w = map_w;
-    h = map_h;
-
-    cell_l = cell_length;
-    sub_cell_l = cell_l/(double)SUBCELL_L;
-
-    wCells =  w/cell_l;
-    hCells =  h/cell_l;
-
-    nCells = wCells*hCells;
-	m_MaxHeuristics = w*h*cell_l;
-
-    pCells =  new CELL_Info[nCells];
-    POINT2D p;
-    int index = 0;
-
-    for(int r=0; r&lt;hCells; r++)
-    {
-       for(int c=0; c&lt;wCells; c++)
-	   {
-		 index = get2dIndex(r,c,wCells);
-		 p.x = ((double)c * cell_l) + origin_x;
-		 p.y = ((double)r * cell_l) + origin_y;
-		 pCells[index].Initialize(p, cell_l, r, c,bDefaultEmpty);
-		 pCells[index].index = index;
-
-	   }
-    }
-
-    double temp[8][3] = { { -1, 0, 1 }, { 0, -1, 1 }, { 1, 0, 1 }, { 0, 1, 1 }, { -1, -1, 1.5 }, { 1, -1, 1.5 }, { 1, 1, 1.5 }, { -1, 1, 1.5 } }; // left, down, right, top, left down, right down, top right, left top
-    delta = new POINT2D[8];
-    for (int i = 0; i &lt; 8; i++)
-    	delta[i] = POINT2D(temp[i][0], temp[i][1]);
- }
-
-int GridMap::InsidePolygon(const vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p)
-{
-  int counter = 0;
-  int i;
-  double xinters;
-  POINT2D p1,p2;
-  int N = polygon.size();
-  if(N &lt;=0 ) return -1;
-
-  p1 = polygon.at(0);
-  for (i=1;i&lt;=N;i++)
-  {
-    p2 = polygon.at(i % N);
-
-    if (p.y &gt; MIN(p1.y,p2.y))
-    {
-      if (p.y &lt;= MAX(p1.y,p2.y))
-      {
-        if (p.x &lt;= MAX(p1.x,p2.x))
-        {
-          if (p1.y != p2.y)
-          {
-            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
-            if (p1.x == p2.x || p.x &lt;= xinters)
-              counter++;
-          }
-        }
-      }
-    }
-    p1 = p2;
-  }
-
-  if (counter % 2 == 0)
-    return 0;
-  else
-    return 1;
-}
-
-
-  void GridMap::OpenClosedCells()
-  {
-	int loop_size =  nCells;
-	int index = 0;
-	while(index != loop_size)
-	{
-			pCells[index].closed = false;
-			pCells[index].expanded = -1;
-			index++;
-	}
-  }
-
-  void GridMap::ClearMap(int bMovingOnly)
-  {
-  	int loop_size =  nCells;
-  	int index = 0;
-	  while(index != loop_size)
-		{
-		  pCells[index].Clear(bMovingOnly);
-		index++;
-	  }
-	  m_bUpdatedMap = true;
-  }
-
-  void GridMap::UpdateMapObstacleValue(const Obstacle&amp; ob)
-  {
-	  POINT2D p1, p2, p3, p4;
-		p1 = ob.sp;
-		p2 = ob.ep;
-
-		if(ob.polygon.size() == 0)
-		{
-			int loop_size =  nCells;
-			int index = 0;
-			while(index != loop_size)
-			{
-					p3 = pCells[index].bottom_left;
-					p4 = pCells[index].top_right;
-
-					if(! ( p2.y &lt; p3.y || p1.y &gt; p4.y || p2.x &lt; p3.x || p1.x &gt; p4.x ))
-					{
-						pCells[index].nStaticPoints++;
-						m_bUpdatedMap = true;
-					}
-
-					index++;
-			}
-		}
-		else
-		{
-			vector&lt;CELL_Info*&gt; modList;
-			UpdateMapObstaclesValuePlygon(ob.polygon, modList);
-		}
-  }
-
-  void GridMap::UpdateMapObstaclesValuePlygon(const vector&lt;POINT2D&gt;&amp; poly, vector&lt;CELL_Info*&gt;&amp; modifiedCell)
-  {
-
-	  POINT2D minP, maxP;
-	  CELL_Info* minC, *maxC;
-	  int index = 0;
-
-	  minP = poly[0];
-	  maxP = poly[0];
-
-		for(unsigned int j=1; j&lt; poly.size(); j++)
-		{
-			if(poly[j].x &lt; minP.x) minP.x = poly[j].x;
-			if(poly[j].y &lt; minP.y) minP.y = poly[j].y;
-
-			if(poly[j].x &gt; maxP.x) maxP.x = poly[j].x;
-			if(poly[j].y &gt; maxP.y) maxP.y = poly[j].y;
-		}
-
-
-		minC = GetCellFromPoint(minP,false);
-		maxC = GetCellFromPoint(maxP, false);
-
-		if(!maxC || ! minC)
-		{
-			printf(&quot;Obstacle Polygon is outside the Map !!&quot;);
-			return;
-		}
-
-		for(int r=minC-&gt;r; r&lt;=maxC-&gt;r; r++)
-		{
-			for(int c=minC-&gt;c; c&lt;=maxC-&gt;c; c++)
-			{
-				index = get2dIndex(r,c,wCells);
-				//CELL_Info* pSub = &amp;pCells[index];
-
-//					if(pSub-&gt;pInnerMap == 0)
-//					{
-//						pSub-&gt;InitSubCells(cell_l, sub_cell_l);
-//					}
-//						int index_sub = 0;
-//						bool bUpdatedSubCell = false;
-//						while(index_sub &lt; pSub-&gt;nCells)
-//						{
-//							if(InsidePolygon(&amp;poly, poly.size(), pSub-&gt;pInnerMap[index_sub].bottom_left)==1 || InsidePolygon(&amp;poly, poly.size(), pSub-&gt;pInnerMap[index_sub].top_right)==1)
-//							{
-//								pSub-&gt;pInnerMap[index_sub].nStaticPoints = 1;
-//								m_bUpdatedMap = true;
-//								bUpdatedSubCell = true;
-//							}
-//							index_sub++;
-//						}
-
-
-				//if(bUpdatedSubCell)
-				{
-					POINT2D bl= pCells[index].bottom_left;
-					bl.x += 0.01;
-					bl.y += 0.01;
-					POINT2D tr= pCells[index].top_right;
-					tr.x -= 0.01;
-					tr.y -= 0.01;
-					if(InsidePolygon(poly, bl)==1 || InsidePolygon(poly, tr)==1)
-					{
-
-							pCells[index].nMovingPoints = 1;
-							pCells[index].nStaticPoints = 1;
-//							pCells[index].forwardHeuristic = nCells;
-//							pCells[index].backwardHeuristic = nCells;
-//							pCells[index].heuristic = nCells;
-							modifiedCell.push_back(&amp;pCells[index]);
-							m_bUpdatedMap = true;
-							//pDrivableCells.push_back(&amp;pCells[r][c]);
-					}
-				}
-			}
-		}
-  }
-
-  void GridMap::UpdateMapDrivablesValuePlygon(const vector&lt;vector&lt;POINT2D&gt; &gt;&amp; points)
-  {
-//		for(int r=0; r&lt;nColCells; r++)
-//		{
-//			for(int c=0; c&lt;nRowCells; c++)
-//			{
-//				if(pCells[r][c].cell.bObstacle)
-//				{
-//					for(unsigned int i=0; i&lt; points-&gt;size(); i++)
-//					{
-//						vector&lt;POINT2D&gt;* poly = &amp;((*points)[i]);
-//						if(InsidePolygon(poly, poly-&gt;size(), pCells[r][c].cell.bottom_left)==1 || InsidePolygon(poly, poly-&gt;size(), pCells[r][c].cell.top_right)==1)
-//								pCells[r][c].cell.bObstacle = false;
-//					}
-//				}
-//
-//			}
-//		}
-
-	  POINT2D minP, maxP;
-	  CELL_Info* minC, *maxC;
-	  int index = 0;
-
-	  for(unsigned int i=0; i&lt; points.size(); i++)
-		{
-			vector&lt;POINT2D&gt; poly = points.at(i);
-			maxP = minP = poly[0];
-
-			for(unsigned int j=1; j&lt; poly.size(); j++)
-			{
-				if(poly[j].x &lt; minP.x) minP.x = poly[j].x;
-				if(poly[j].y &lt; minP.y) minP.y = poly[j].y;
-
-				if(poly[j].x &gt; maxP.x) maxP.x = poly[j].x;
-				if(poly[j].y &gt; maxP.y) maxP.y = poly[j].y;
-			}
-
-
-			minC = GetCellFromPoint(minP,false);
-			maxC = GetCellFromPoint(maxP, false);
-
-			for(int r=minC-&gt;r; r&lt;maxC-&gt;r; r++)
-			{
-				for(int c=minC-&gt;c; c&lt;maxC-&gt;c; c++)
-				{
-					index = get2dIndex(r,c,wCells);
-
-					CELL_Info* pSub = &amp;pCells[index];
-
-					if(pSub-&gt;pInnerMap != 0)
-					{
-						pSub-&gt;InitSubCells(cell_l, sub_cell_l);
-					}
-						int index_sub = 0;
-						//bool bUpdatedSubCell = false;
-						while(index_sub &lt; pSub-&gt;nCells)
-						{
-							if(InsidePolygon(poly, pSub-&gt;pInnerMap[index_sub].bottom_left)==1 || InsidePolygon(poly, pSub-&gt;pInnerMap[index_sub].top_right)==1)
-							{
-								pSub-&gt;pInnerMap[index_sub].nStaticPoints = 0;
-								m_bUpdatedMap = true;
-								//bUpdatedSubCell = true;
-							}
-							index_sub++;
-						}
-
-
-					//if(bUpdatedSubCell)
-					{
-						if(InsidePolygon(poly, pCells[index].bottom_left)==1 || InsidePolygon(poly, pCells[index].top_right)==1)
-						{
-
-								pCells[index].nStaticPoints = 0;
-								m_bUpdatedMap = true;
-								//pDrivableCells.push_back(&amp;pCells[r][c]);
-						}
-					}
-				}
-			}
-		}
-  }
-
-  void GridMap::UpdateMapDrivablesValue(const DrivableArea&amp; dr)
-    {
-  	  POINT2D p1, p2, p3, p4;
-  	  p1 = dr.sp;
-  	  p2 = dr.ep;
-
-  		int loop_size =  nCells;
-  	int index = 0;
-	  while(index != loop_size)
-		{
-				p3 = pCells[index].bottom_left;
-				p4 = pCells[index].top_right;
-
-				if(! ( p2.y &lt; p3.y || p1.y &gt; p4.y || p2.x &lt; p3.x || p1.x &gt; p4.x ))
-				{
-					pCells[index].nStaticPoints = 0;
-					m_bUpdatedMap = true;
-				}
-
-				index++;
-		}
-    }
-
-  void GridMap::InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center)
-  {
-	  int min_row, min_col, max_row, max_col;
-	  CELL_Info* scell = GetCellFromPoint(center);
-		if(!scell) return;
-
-		//Get First Left Cell
-		double max_left = scell-&gt;c * pParentMap-&gt;cell_l;
-		if(max_left &lt; map_l)
-		{
-			min_row = 0;
-		}
-		else
-		{
-			POINT2D p(center.x-map_l, center.y);
-			min_row = GetCellFromPoint(p)-&gt;r;
-		}
-
-		double max_right = (pParentMap-&gt;hCells - scell-&gt;c) * pParentMap-&gt;cell_l;
-		if(max_right &lt; map_l)
-		{
-			max_row = pParentMap-&gt;hCells;
-		}
-		else
-		{
-			POINT2D p(center.x+map_l, center.y);
-			max_row = GetCellFromPoint(p)-&gt;r;
-		}
-
-		double max_bottom = scell-&gt;r * pParentMap-&gt;cell_l;
-		if(max_bottom &lt; map_l)
-		{
-			min_col = 0;
-		}
-		else
-		{
-			POINT2D p(center.x, center.y-map_l);
-			min_col = GetCellFromPoint(p)-&gt;c;
-		}
-
-		double max_top = (pParentMap-&gt;wCells- scell-&gt;r) * pParentMap-&gt;cell_l;
-		if(max_top &lt; map_l)
-		{
-			max_col = pParentMap-&gt;wCells;
-		}
-		else
-		{
-			POINT2D p(center.x, center.y+map_l);
-			max_col = GetCellFromPoint(p)-&gt;c;
-		}
-
-		inner_start_row = min_row;
-		inner_start_col = min_col;
-		inner_end_row = max_row;
-		inner_end_col = max_col;
-		nInnerWCells =max_col-min_col;
-		nInnerHCells = max_row-min_row;
-		inner_w =  nInnerWCells* pParentMap-&gt;cell_l;
-		inner_h =  nInnerHCells* pParentMap-&gt;cell_l;
-		cell_l = pParentMap-&gt;cell_l;
-		sub_cell_l = pParentMap-&gt;sub_cell_l;
-
-
-  }
-
- CELL_Info* GridMap::UpdateMapCostValueRange(const vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const vector&lt;double&gt;&amp; features)
-  {
-	 POINT2D pos(currPos.x, currPos.y);
-	CELL_Info* pC = GetCellFromPoint(pos);
-
-
-
-	if(pC)
-	{
-		//Update Affected cells value from this new point
-		vector&lt;CELL_Info*&gt; cells;
-		GetSurroundingMainCells(pos, cells, 1);
-		for(unsigned int i=0; i&lt; cells.size(); i++)
-		{
-			cells[i]-&gt;UpdateSubCellCostValue(ps, cell_l, sub_cell_l);
-			cells[i]-&gt;UpdateCostValue(ps);
-			m_bUpdatedMap = true;
-		}
-		//only one level
-//			pC-&gt;UpdateSubCellCostValue(p, cell_l, sub_cell_l);
-
-	}
-
-	return pC;
-  }
-
- bool GridMap::CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningThreshold, vector&lt;CELL_Info*&gt;&amp; pSubCellsList)
- {
-	 POINT2D v(p.x - carPos.x, p.y - carPos.y);
-	 double v_norm = pointNorm(v);
-
-
-	 //Number of search iteration will be a ratio between the thining threshold   and the sub cell length
-	 double step_d = sub_cell_l;
-	 double start_d = -thiningThreshold/ 2.0;
-	 pSubCellsList.clear();
-	 CELL_Info* pSubCell = 0;
-	 while(start_d &lt; thiningThreshold)
-	 {
-		 POINT2D p_obstacle = p;
-		 p_obstacle.x += v.x/v_norm * start_d;
-		 p_obstacle.y += v.y/v_norm * start_d;
-		 pSubCell = GetSubCellFromPoint(p_obstacle);
-		 if(pSubCell &amp;&amp; pSubCell-&gt;nStaticPoints&gt;0)
-			 return true;
-
-		pSubCellsList.push_back(pSubCell);
-		 start_d += step_d;
-	 }
-
-	 return false;
- }
-
- CELL_Info* GridMap::UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos,const double&amp; thiningTHreshold)
- {
-	 CELL_Info* pC = GetCellFromPoint(p);
-	if(pC)
-	{
-		vector&lt;CELL_Info*&gt; subcells_list;
-
-		if(!CheckSubCellsInTheWay(p, carPos, thiningTHreshold, subcells_list))
-		{
-			pC-&gt;nStaticPoints++;
-			CELL_Info* pSubc = GetSubCellFromCell(pC, p);
-			if(pSubc)
-			{
-				if(pSubc-&gt;nStaticPoints&lt;1)
-				{
-					pSubc-&gt;innerStaticPointsList.push_back(p);
-					m_bUpdatedMap = true;
-				}
-
-				pSubc-&gt;nStaticPoints++;
-			}
-		}
-	}
-	return pC;
- }
-
- CELL_Info* GridMap::UpdateMapObstaclePoint(const POINT2D&amp; p)
-{
-	CELL_Info* pC = GetCellFromPoint(p);
-	if(pC)
-	{
-		if(pC-&gt;nStaticPoints &lt; 5)
-			pC-&gt;nStaticPoints++;
-		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
-		if(pSubc)
-		{
-			if(pSubc-&gt;nStaticPoints&lt;1)
-			{
-				//pthread_mutex_lock(&amp;update_map_mutex);
-				pSubc-&gt;innerStaticPointsList.push_back(p);
-				m_bUpdatedMap = true;
-				//pthread_mutex_unlock(&amp;update_map_mutex);
-			}
-
-			if(pSubc-&gt;nStaticPoints &lt; 5)
-				pSubc-&gt;nStaticPoints++;
-		}
-	}
-	return pC;
-}
-
-CELL_Info* GridMap::UpdateMapMovingObstaclePoint(const POINT2D&amp; p)
-{
-	CELL_Info* pC = GetCellFromPoint(p);
-	if(pC)
-	{
-		if(pC-&gt;nMovingPoints &lt; 5)
-			pC-&gt;nMovingPoints++;
-		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
-		if(pSubc)
-		{
-			if(pSubc-&gt;nMovingPoints&lt;1)
-			{
-				//pthread_mutex_lock(&amp;update_map_mutex);
-				pSubc-&gt;innerMovingPointsList.push_back(p);
-				m_bUpdatedMap = true;
-				//pthread_mutex_unlock(&amp;update_map_mutex);
-			}
-
-			if(pSubc-&gt;nMovingPoints&lt;5)
-				pSubc-&gt;nMovingPoints++;
-		}
-	}
-	return pC;
-}
-
- CELL_Info* GridMap::UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob)
- {
- 	CELL_Info* pC = GetCellFromPoint(p);
- 	if(pC)
- 	{
- 		pC-&gt;localize_val = localize_val;
- 		pC-&gt;localize_prob = localize_prob;
- 		m_bUpdatedMap = true;
- 	}
-
- 	return pC;
- }
-
- CELL_Info* GridMap::UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob)
- {
- 	CELL_Info* pC = GetCellFromPoint(p);
- 	if(pC)
- 	{
-
- 		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
- 		if(pSubc)
- 		{
- 			pSubc-&gt;localize_val = localize_val;
- 			pSubc-&gt;localize_prob = localize_prob;
- 			m_bUpdatedMap = true;
- 		}
- 	}
-
- 	return pC;
- }
-
-CELL_Info* GridMap::GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p)
-{
-	if(!parent) return 0;
-
-	if(!parent-&gt;pInnerMap)
-		parent-&gt;InitSubCells(cell_l, sub_cell_l);
-
-	int row = floor((p.y - parent-&gt;bottom_left.y)/sub_cell_l);
-	int col = floor((p.x - parent-&gt;bottom_left.x)/sub_cell_l);
-
-	if(row&gt;=0 &amp;&amp; row&lt;SUBCELL_L &amp;&amp; col &gt;=0 &amp;&amp; col &lt; SUBCELL_L)
-		return &amp;parent-&gt;pInnerMap[get2dIndex(row,col,SUBCELL_L)];
-	else
-		return 0;
-}
-
-CELL_Info* GridMap::GetSubCellFromPoint(const POINT2D&amp; p)
-{
-	CELL_Info* pMainCell = GetCellFromPoint(p);
-	if(pMainCell)
-	{
-		if(!pMainCell-&gt;pInnerMap)
-			pMainCell-&gt;InitSubCells(cell_l, sub_cell_l);
-
-		int row = floor((p.y - pMainCell-&gt;bottom_left.y)/sub_cell_l);
-		int col = floor((p.x - pMainCell-&gt;bottom_left.x)/sub_cell_l);
-
-		return &amp;pMainCell-&gt;pInnerMap[get2dIndex(row,col,SUBCELL_L)];
-	}
-	else
-		return 0;
-}
-
-CELL_Info* GridMap::GetCellFromPoint(const POINT2D&amp; p, bool bExpand)
-{
-
-	  int row = floor((p.y-origin_y) /cell_l);
-	  int col = floor((p.x-origin_x) /cell_l);
-
-	  if(row&gt;=0 &amp;&amp; row &lt; hCells &amp;&amp; col &gt;=0 &amp;&amp; col &lt; wCells)
-	  {
-//		  POINT2D _p(p.x , p.y );
-//		bool exist = pCells[get2dIndex(row,col,nColCells)].PointInRect(p);
-//
-//		if(!exist)
-//			return 0;
-
-		  //retCell = pCells[row][col];
-		  //retCell.center.a = p.a;
-		  int index = get2dIndex(row,col,wCells);
-		  if(index &gt;= 0 &amp;&amp; index &lt; nCells)
-			  return &amp;pCells[index];
-		  else
-			  printf(&quot;Error Getting Cell with Info: P(%f,%f) , C(%d,%d), index = %d&quot;, p.x, p.y, row, col, index);
-	  }
-	  else if(bExpand)
-	  {
-		  //first get extend direction and factor
-		  double lf=0, rf=0,tf=0,bf=0;
-		  int nRC=0,nCC=0;
-		  if(fabsf(p.x) &gt;= 0)
-			nRC= (fabsf(p.x) - 0)/cell_l + 1;
-
-		  if(fabsf(p.y) &gt;= 0)
-			nCC= (fabsf(p.y) - 0)/cell_l + 1;
-
-		  if(p.x &gt; 0)
-			  rf = nRC*4.0;
-		  else
-			  lf = nRC*4.0;
-
-		  if(p.y &gt; 0)
-			  tf = nCC*4.0;
-		  else
-			  bf = nCC*4.0;
-
-	  }
-
-    return 0;
-  }
-
-
-CELL_Info* GridMap::GetCellFromPointInnerMap(const POINT2D&amp; p)
-{
-  int row = floor((p.y - origin_y) /cell_l);
-  int col = floor((p.x - origin_x)/cell_l);
-
-  if(row&gt;=inner_start_row &amp;&amp; row &lt; inner_end_row &amp;&amp; col &gt;=inner_start_col &amp;&amp; col &lt; inner_end_col)
-  {
-
-	  POINT2D _p(p.x , p.y );
-
-	bool exist = pCells[get2dIndex(row,col,wCells)].PointInRect(p);
-
-	if(!exist)
-		return 0;
-
-	  //retCell = pCells[row][col];
-	  //retCell.center.a = p.a;
-	  return &amp;pCells[get2dIndex(row,col,wCells)];
-  }
-
-  return 0;
-
-}
-
-  void GridMap::BackupMap()
-  {
-  }
-
-  GridMap::GridMap()
-	{
-	  //update_map_mutex = PTHREAD_MUTEX_INITIALIZER;
-		sub_cell_l = 0;
-		nCells = 0;
-		nInnerWCells = nInnerHCells = 0;
-		m_bEnableInnerMap = false;
-		inner_end_col = inner_end_row = inner_h = inner_start_col = inner_start_row = inner_w = 0;
-		w = h = cell_l  = wCells = hCells = m_MaxHeuristics = 0;
-		pCells = 0;
-		m_DisplayResolution = 1;
-		delta = 0;
-		origin_y = 0;
-		origin_x =0;
-		m_bUpdatedMap  = false;
-	}
-
-  GridMap::~GridMap()
-  {
-    if(pCells)
-    {
-      delete [] pCells;
-      pCells = 0;
-    }
-    if(delta)
-    {
-    	delete [] delta;
-    	delta = 0;
-    }
-  }
-
-  int GridMap::GetSurroundingNonObstacleCells(const POINT2D&amp; pos, vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range)
-  {
-	  int nMaxLevels = max_range/cell_l;
-
-	int r, c;
-	vector&lt;CELL_Info*&gt; nextLevel;
-	vector&lt;CELL_Info*&gt; currentLevel;
-	vector&lt;CELL_Info*&gt; tempLevel;
-
-	CELL_Info* originalGoal = GetCellFromPoint(pos);
-	if(!originalGoal) return 0;
-
-	CELL_Info* tempCell;
-
-
-	currentLevel.push_back(originalGoal);
-	cells_list.push_back(originalGoal);
-	int counter = 0;
-	int index = 0;
-
-	while (currentLevel.size() &gt; 0 &amp;&amp; nMaxLevels&gt;0)
-	{
-		tempCell = currentLevel.back();
-		currentLevel.pop_back();
-
-		for (int i = 0; i &lt; 8; i++)
-		{
-			counter++;
-			r = tempCell-&gt;r + delta[i].x;
-			c = tempCell-&gt;c + delta[i].y;
-			index = get2dIndex(r,c,wCells);
-
-			if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; hCells &amp;&amp; c &lt; wCells)
-			{
-				if(pCells[index].nMovingPoints&gt;0 || pCells[index].nStaticPoints &gt; 0 || pCells[index].heuristic == m_MaxHeuristics)
-					continue;
-				//insert unique
-				bool bFound = false;
-				for(unsigned int j=0; j&lt; cells_list.size();j++)
-				{
-					if(cells_list[j] == &amp;pCells[index])
-					{
-						bFound = true;
-						break;
-					}
-				}
-				if(!bFound)
-				{
-					cells_list.push_back(&amp;pCells[index]);
-					nextLevel.push_back(&amp;pCells[index]);
-				}
-			}
-		}
-
-		if (currentLevel.size() == 0 &amp;&amp; nextLevel.size() &gt; 0)
-		{
-			tempLevel = currentLevel;
-			currentLevel = nextLevel;
-			nextLevel = tempLevel;
-			nMaxLevels--;
-		}
-	}
-
-	return counter;
-  }
-
-  int GridMap::GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect)
-    {
-
-    	//calculate the number of levels that satisfy the max range criteria
-    	int nMaxLevels = hypot(rect.width, rect.length) / cell_l;
-
-    	CELL_Info* originalGoal = GetCellFromPoint(pos);
-
-    	if (!originalGoal)
-    		return 0;
-
-    	cells_list.push_back(originalGoal);
-
-    	if (nMaxLevels &lt;= 1)
-    		return 1;
-
-    	nMaxLevels--;
-
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
-    	int r, c;
-    	CELL_Info* tempCell = 0;
-    	int counter = 1;
-    	int index = 0;
-
-    	POINT2D mask;
-    	//first level , // left, down, right, top, left down, right down, top right, left top
-    	//strait degree
-    	for (unsigned int i = 0; i &lt; 4; i++)
-    	{
-    		mask.x = delta[i].x;
-    		mask.y = delta[i].y;
-    		r = originalGoal-&gt;r + mask.x;
-    		c = originalGoal-&gt;c + mask.y;
-    		index = get2dIndex(r, c, wCells);
-
-    		if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-  		{
-  			straitCells.push_back(make_pair(&amp;pCells[index], mask));
-  			if (!pCells[index].TestWithRectangle(rect))
-  				cells_list.push_back(&amp;pCells[index]);
-  		}
-    	}
-
-    	//diagonal degree
-    	for (unsigned int i = 4; i &lt; 8; i++)
-    	{
-    		mask.x = delta[i].x;
-    		mask.y = delta[i].y;
-    		r = originalGoal-&gt;r + mask.x;
-    		c = originalGoal-&gt;c + mask.y;
-    		index = get2dIndex(r, c, wCells);
-    		if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    		{
-    			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
-  			if (!pCells[index].TestWithRectangle(rect))
-  				cells_list.push_back(&amp;pCells[index]);
-    		}
-    	}
-
-    	nMaxLevels--;
-    	counter++;
-
-    	while (nMaxLevels &gt; 0)
-    	{
-    		straitCellsL2.clear();
-    		diagonalCellsL2.clear();
-    		while (straitCells.size() &gt; 0)
-    		{
-    			mask = straitCells.back().second;
-    			tempCell = straitCells.back().first;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    			{
-  				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-  				if (!pCells[index].TestWithRectangle(rect))
-  					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			//diagonal 1
-    			if (straitCells.back().second.x == 0)
-    				mask.x += 1;
-    			else
-    				mask.y += 1;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    			{
-  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-  				if (!pCells[index].TestWithRectangle(rect))
-  					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			//diagonal 2
-    			if (straitCells.back().second.x == 0)
-    				mask.x += -2;
-    			else
-    				mask.y += -2;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    			{
-  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-  				if (!pCells[index].TestWithRectangle(rect))
-  					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			straitCells.pop_back();
-    		}
-
-    		//Diagonal
-    		while (diagonalCells.size() &gt; 0)
-    		{
-    			mask = diagonalCells.back().second;
-    			tempCell = diagonalCells.back().first;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
-    			{
-  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-  				if (!pCells[index].TestWithRectangle(rect))
-  					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			diagonalCells.pop_back();
-    		}
-
-    		nMaxLevels--;
-    		counter++;
-    		if (nMaxLevels &lt;= 0)
-    			break;
-
-    		straitCells = straitCellsL2;
-    		diagonalCells = diagonalCellsL2;
-
-    	}
-
-    	return counter;
-
-    }
-
-  int GridMap::GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect)
-  {
-
-  	//calculate the number of levels that satisfy the max range criteria
-  	int nMaxLevels = hypot(rect.width, rect.length) / cell_l;
-
-  	CELL_Info* originalGoal = GetCellFromPoint(pos);
-
-  	if (!originalGoal)
-  		return 0;
-
-  	cells_list.push_back(originalGoal);
-
-  	if (nMaxLevels &lt;= 1)
-  		return 1;
-
-  	nMaxLevels--;
-
-  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
-  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
-  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
-  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
-  	int r, c;
-  	CELL_Info* tempCell = 0;
-  	int counter = 1;
-  	int index = 0;
-
-  	POINT2D mask;
-  	//first level , // left, down, right, top, left down, right down, top right, left top
-  	//strait degree
-  	for (unsigned int i = 0; i &lt; 4; i++)
-  	{
-  		mask.x = delta[i].x;
-  		mask.y = delta[i].y;
-  		r = originalGoal-&gt;r + mask.x;
-  		c = originalGoal-&gt;c + mask.y;
-  		index = get2dIndex(r, c, wCells);
-  		if(checkGridIndex(index, nCells))
-		{
-			straitCells.push_back(make_pair(&amp;pCells[index], mask));
-			if (!pCells[index].TestWithRectangle(rect))
-				cells_list.push_back(&amp;pCells[index]);
-		}
-  	}
-
-  	//diagonal degree
-  	for (unsigned int i = 4; i &lt; 8; i++)
-  	{
-  		mask.x = delta[i].x;
-  		mask.y = delta[i].y;
-  		r = originalGoal-&gt;r + mask.x;
-  		c = originalGoal-&gt;c + mask.y;
-  		index = get2dIndex(r, c, wCells);
-  		if(checkGridIndex(index, nCells))
-  		{
-  			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
-			if (!pCells[index].TestWithRectangle(rect))
-				cells_list.push_back(&amp;pCells[index]);
-  		}
-  	}
-
-  	nMaxLevels--;
-  	counter++;
-
-  	while (nMaxLevels &gt; 0)
-  	{
-  		straitCellsL2.clear();
-  		diagonalCellsL2.clear();
-  		while (straitCells.size() &gt; 0)
-  		{
-  			mask = straitCells.back().second;
-  			tempCell = straitCells.back().first;
-  			r = tempCell-&gt;r + mask.x;
-  			c = tempCell-&gt;c + mask.y;
-  			index = get2dIndex(r, c, wCells);
-  			if(checkGridIndex(index, nCells))
-  			{
-				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-				if (!pCells[index].TestWithRectangle(rect))
-					cells_list.push_back(&amp;pCells[index]);
-  			}
-
-  			//diagonal 1
-  			if (straitCells.back().second.x == 0)
-  				mask.x += 1;
-  			else
-  				mask.y += 1;
-  			r = tempCell-&gt;r + mask.x;
-  			c = tempCell-&gt;c + mask.y;
-  			index = get2dIndex(r, c, wCells);
-  			if(checkGridIndex(index, nCells))
-  			{
-				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-				if (!pCells[index].TestWithRectangle(rect))
-					cells_list.push_back(&amp;pCells[index]);
-  			}
-
-  			//diagonal 2
-  			if (straitCells.back().second.x == 0)
-  				mask.x += -2;
-  			else
-  				mask.y += -2;
-  			r = tempCell-&gt;r + mask.x;
-  			c = tempCell-&gt;c + mask.y;
-  			index = get2dIndex(r, c, wCells);
-  			if(checkGridIndex(index, nCells))
-  			{
-				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-				if (!pCells[index].TestWithRectangle(rect))
-					cells_list.push_back(&amp;pCells[index]);
-  			}
-
-  			straitCells.pop_back();
-  		}
-
-  		//Diagonal
-  		while (diagonalCells.size() &gt; 0)
-  		{
-  			mask = diagonalCells.back().second;
-  			tempCell = diagonalCells.back().first;
-  			r = tempCell-&gt;r + mask.x;
-  			c = tempCell-&gt;c + mask.y;
-  			index = get2dIndex(r, c, wCells);
-  			if(checkGridIndex(index, nCells))
-  			{
-				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-				if (!pCells[index].TestWithRectangle(rect))
-					cells_list.push_back(&amp;pCells[index]);
-  			}
-
-  			diagonalCells.pop_back();
-  		}
-
-  		nMaxLevels--;
-  		counter++;
-  		if (nMaxLevels &lt;= 0)
-  			break;
-
-  		straitCells = straitCellsL2;
-  		diagonalCells = diagonalCellsL2;
-
-  	}
-
-  	return counter;
-
-  }
-
-  int GridMap::GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, double radius)
-    {
-
-    	//calculate the number of levels that satisfy the max range criteria
-    	int nMaxLevels = radius * 2.0 / cell_l;
-
-    	CELL_Info* originalGoal = GetCellFromPoint(pos);
-
-    	if (!originalGoal)
-    		return 0;
-
-    	cells_list.push_back(originalGoal);
-
-    	if (nMaxLevels &lt;= 1)
-    		return 1;
-
-    	nMaxLevels--;
-
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
-    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
-    	int r, c;
-    	CELL_Info* tempCell = 0;
-    	int counter = 1;
-    	int index = 0;
-
-    	POINT2D mask;
-    	//first level , // left, down, right, top, left down, right down, top right, left top
-    	//strait degree
-    	for (unsigned int i = 0; i &lt; 4; i++)
-    	{
-    		mask.x = delta[i].x;
-    		mask.y = delta[i].y;
-    		r = originalGoal-&gt;r + mask.x;
-    		c = originalGoal-&gt;c + mask.y;
-    		index = get2dIndex(r, c, wCells);
-    		if(checkGridIndex(index, nCells))
-  		{
-  			straitCells.push_back(make_pair(&amp;pCells[index], mask));
-  			if (pCells[index].TestWithCircle(pos, radius))
-  				cells_list.push_back(&amp;pCells[index]);
-  		}
-    	}
-
-    	//diagonal degree
-    	for (unsigned int i = 4; i &lt; 8; i++)
-    	{
-    		mask.x = delta[i].x;
-    		mask.y = delta[i].y;
-    		r = originalGoal-&gt;r + mask.x;
-    		c = originalGoal-&gt;c + mask.y;
-    		index = get2dIndex(r, c, wCells);
-    		if(checkGridIndex(index, nCells))
-    		{
-    			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
-    			if (pCells[index].TestWithCircle(pos, radius))
-    				cells_list.push_back(&amp;pCells[index]);
-    		}
-    	}
-
-    	nMaxLevels--;
-    	counter++;
-
-    	while (nMaxLevels &gt; 0)
-    	{
-    		straitCellsL2.clear();
-    		diagonalCellsL2.clear();
-    		while (straitCells.size() &gt; 0)
-    		{
-    			mask = straitCells.back().second;
-    			tempCell = straitCells.back().first;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells))
-    			{
-    				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-    				if (pCells[index].TestWithCircle(pos, radius))
-    					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			//diagonal 1
-    			if (straitCells.back().second.x == 0)
-    				mask.x += 1;
-    			else
-    				mask.y += 1;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells))
-    			{
-					diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-					if (pCells[index].TestWithCircle(pos, radius))
-						cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			//diagonal 2
-    			if (straitCells.back().second.x == 0)
-    				mask.x += -2;
-    			else
-    				mask.y += -2;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells))
-    			{
-    				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-    				if (pCells[index].TestWithCircle(pos, radius))
-    					cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			straitCells.pop_back();
-    		}
-
-    		//Diagonal
-    		while (diagonalCells.size() &gt; 0)
-    		{
-    			mask = diagonalCells.back().second;
-    			tempCell = diagonalCells.back().first;
-    			r = tempCell-&gt;r + mask.x;
-    			c = tempCell-&gt;c + mask.y;
-    			index = get2dIndex(r, c, wCells);
-    			if(checkGridIndex(index, nCells))
-    			{
-					diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
-					if (pCells[index].TestWithCircle(pos, radius))
-						cells_list.push_back(&amp;pCells[index]);
-    			}
-
-    			diagonalCells.pop_back();
-    		}
-
-    		nMaxLevels--;
-    		counter++;
-    		if (nMaxLevels &lt;= 0)
-    			break;
-
-    		straitCells = straitCellsL2;
-    		diagonalCells = diagonalCellsL2;
-
-    	}
-
-    	return counter;
-
-    }
-
-  int GridMap::GetSurroundingMainCells(const POINT2D&amp; pos, vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range)
-  {
-
-	  //calculate the number of levels that satisfy the max range criteria
-	int nMaxLevels = max_range/cell_l;
-
-  	int r, c;
-  	vector&lt;CELL_Info*&gt; nextLevel;
-  	vector&lt;CELL_Info*&gt; currentLevel;
-  	vector&lt;CELL_Info*&gt; tempLevel;
-
-  	CELL_Info* originalGoal = GetCellFromPoint(pos);
-  	if(!originalGoal) return 0;
-
-  	CELL_Info* tempCell;
-
-
-  	currentLevel.push_back(originalGoal);
-  	cells_list.push_back(originalGoal);
-  	int counter = 0;
-  	int index = 0;
-
-  	while (currentLevel.size() &gt; 0 &amp;&amp; nMaxLevels&gt;0)
-  	{
-  		tempCell = currentLevel.back();
-  		currentLevel.pop_back();
-
-  		for (int i = 0; i &lt; 8; i++)
-  		{
-  			counter++;
-  			r = tempCell-&gt;r + delta[i].x;
-  			c = tempCell-&gt;c + delta[i].y;
-  			index = get2dIndex(r,c,wCells);
-
-  			if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; hCells &amp;&amp; c &lt; wCells)
-  			{
-  				//insert unique
-  				bool bFound = false;
-  				for(unsigned int j=0; j&lt; cells_list.size();j++)
-  				{
-  					if(cells_list[j] == &amp;pCells[index])
-  					{
-  						bFound = true;
-  						break;
-  					}
-  				}
-  				if(!bFound)
-  				{
-  					cells_list.push_back(&amp;pCells[index]);
-  					nextLevel.push_back(&amp;pCells[index]);
-  				}
-  			}
-  		}
-
-  		if (currentLevel.size() == 0 &amp;&amp; nextLevel.size() &gt; 0)
-  		{
-  			tempLevel = currentLevel;
-  			currentLevel = nextLevel;
-  			nextLevel = tempLevel;
-  			nMaxLevels--;
-  		}
-  	}
-
-  	return counter;
-
-  }
-
-  void GridMap::SaveMap(const string&amp; mapFilePath, const string&amp; mapName)
-  {
-	  ofstream f(mapFilePath.c_str(),ios::out);
-	  if(!f.is_open())
-	  {
-		  printf(&quot;\n Can't Open Map File to Save!, %s&quot;, mapFilePath.c_str());
-		  return;
-	  }
-	  f.precision(8);
-
-	  if(nCells&gt;0)
-	  {
-		  int loop_size =  nCells;
-		  int index = 0;
-			while(index != loop_size)
-			{
-				if(pCells[index].nStaticPoints &gt; 0 )
-				{
-					int subindex = 0;
-					int sub_loop_size = pCells[index].nCells;
-					while(subindex != sub_loop_size)
-					{
-						if(pCells[index].pInnerMap[subindex].nStaticPoints &gt; 0)
-						{
-							for(unsigned int p=0; p&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList.size(); p++)
-							{
-								f&lt;&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList[p].x&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList[p].y&lt;&lt;&quot; &quot;;
-							}
-							f&lt;&lt;endl;
-						}
-
-						subindex++;
-					}
-				}
-
-			index++;
-			}
-	  }
-
-	  f.close();
-
-	  //save Values Map
-//	  string cost_file = mapFilePath + &quot;_cost.grd&quot;;
-//	  ofstream f2(cost_file.c_str(),ios::out);
-//  	  f2.precision(8);
-//  	if(nCells&gt;0)
-//	  {
-//		  int loop_size =  nCells;
-//		  int index = 0;
-//			while(index != loop_size)
-//			{
-//				if(pCells[index].nCells&gt;0)
-//				{
-//					if(pCells[index].localize_val&gt;0)
-//					{
-//						f2&lt;&lt;&quot;C,&quot;&lt;&lt;pCells[index].center.p.x&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].center.p.y&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].localize_val &lt;&lt; &quot; &quot;;
-//						f2&lt;&lt;endl;
-//					}
-//
-//					int subIndex = 0;
-//					while(subIndex != pCells[index].nCells)
-//					{
-//						f2&lt;&lt;&quot;S,&quot;&lt;&lt;pCells[index].pInnerMap[subIndex].center.p.x&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].pInnerMap[subIndex].center.p.y&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].pInnerMap[subIndex].localize_val &lt;&lt; &quot; &quot;;
-//						subIndex++;
-//					}
-//					f2&lt;&lt;endl;
-//				}
-//
-//				index++;
-//			}
-//	  }
-//
-//  	f2.close();
-
-  }
-
-  void GridMap::LoadMap(const string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation)
-  {
-
-//	  GPSPoint point;
-//	  ifstream f(mapFilePath.c_str(), ios::in);
-//	  if(!f.is_open())
-//	  {
-//		  printf(&quot;\n Can't Open Map File !, %s&quot;, mapFilePath.c_str());
-//		  return;
-//	  }
-//
-//	  f.precision(8);
-//	  string token, temp, innerToken;
-//	  string strLine;
-//
-//	while(!f.eof())
-//	{
-//		getline(f, strLine);
-//		istringstream str_stream(strLine);
-//		while(getline(str_stream, innerToken, ' '))
-//		{
-//
-//			string str_x, str_y;
-//
-//			istringstream ss(innerToken);
-//
-//			getline(ss, str_x, ',');
-//			getline(ss, str_y, ',');
-//
-//			point.p.x = atof(str_x.c_str());
-//			point.p.y = atof(str_y.c_str());
-//
-//			MathUtil::CoordinateTransform(point, mapTransformation);
-//
-//			UpdateMapObstaclePoint(point);
-//		}
-//	}
-//
-//	  f.close();
-
-//	  string cost_file = mapFilePath + &quot;_cost.grd&quot;;
-//	  ifstream f2(cost_file.c_str(),ios::in);
-//	  f2.precision(8);
-//	  double cost_val = 0;
-//	  while(!f2.eof())
-//	  	{
-//	  		getline(f2, strLine);
-//	  		istringstream str_stream(strLine);
-//
-//	  		while(getline(str_stream, innerToken, ' '))
-//			{
-//				string str_key, str_x, str_y, str_val;
-//				istringstream ss(innerToken);
-//				getline(ss, str_key, ',');
-//				getline(ss, str_x, ',');
-//				getline(ss, str_y, ',');
-//				getline(ss, str_val, ',');
-//
-//				point.x = atof(str_x.c_str());
-//				point.y = atof(str_y.c_str());
-//				cost_val = atof(str_val.c_str());
-//
-//				if(str_key.compare(&quot;S&quot;)==0)
-//					UpdateSubMapCostValue(point, cost_val, 0);
-//				else
-//					UpdateMapCostValue(point, cost_val, 0);
-//			}
-//
-//	  	}
-//
-//	  f2.close();
-  }
-
-  CELL_Info::CELL_Info()
-    {
-		index = 0;
-		r=0;
-		c=0;
-
-		nCells = 0;
-		pInnerMap = 0;
-		heuristicValue = 0;
-		forwardHeuristic = 0;
-		backwardHeuristic = 0;
-		heuristic = 0;
-		expanded = -1;
-		value = 0;
-		action = -1;
-		forward_heuristicValue = 0;
-		backward_heuristicValue = 0;
-		bDir = STANDSTILL_DIR;
-		closed = false;
-		nMovingPoints = 0;
-		nStaticPoints = 0;
-		localize_val = 0;
-		localize_prob = 0;
-    }
-
-  CELL_Info::~CELL_Info()
-     {
-  //     if(pInnerCells)
-  //       delete [] pInnerCells;
-  	if(pInnerMap)
-  		delete [] pInnerMap;
-     }
-
-  void CELL_Info::ClearSubCells(bool bMovingOnly)
-  {
-  	for(int i=0; i&lt;nCells; i++)
-  	{
-  		if(!bMovingOnly)
-  		{
-  			pInnerMap[i].nStaticPoints = 0;
-  			pInnerMap[i].innerStaticPointsList.clear();
-  		}
-  		pInnerMap[i].nMovingPoints = 0;
-  		pInnerMap[i].innerMovingPointsList.clear();
-  	}
-  }
-
-  void CELL_Info::Clear(int bMovingOnly)
-  {
-  	//forwardCenter = center;
-  	//backwardCenter = center;
-
-  	heuristicValue = 0;
-  	heuristic = 0;
-  	forwardHeuristic  = 0;
-  	backwardHeuristic  = 0;
-  	forward_heuristicValue = 0;
-  	backward_heuristicValue = 0;
-  	expanded = -1;
-  	value = 0;
-  	closed = false;
-  	action = -1;
-  	bDir = STANDSTILL_DIR;
-  	if(bMovingOnly == 1)
-  	{
-  		if(nMovingPoints&gt;0)
-  		{
-  			nMovingPoints = 0;
-  			ClearSubCells(true);
-  		}
-  	}
-  	else if(bMovingOnly == 0)
-  	{
-  		if(nMovingPoints&gt;0 || nStaticPoints&gt;0)
-  		{
-  			nMovingPoints = 0;
-  			nStaticPoints = 0;
-  			ClearSubCells(false);
-  		}
-  	}
-
-  }
-
-  void CELL_Info::InitSubCells(double cell_l, double sub_cell_l)
-  {
-  	nCells = SUBCELL_L*SUBCELL_L;
-  	pInnerMap =  new CELL_Info[nCells];
-  	 POINT2D p;
-  	 int index = 0;
-
-  	 for(int rr=0; rr&lt;SUBCELL_L; rr++)
-  	 {
-  		 for(int cc=0; cc&lt;SUBCELL_L; cc++)
-  		   {
-  			 index = get2dIndex(rr,cc,SUBCELL_L);
-  			 p.x = this-&gt;bottom_left.x +  ((double)cc * sub_cell_l );
-  			 p.y = this-&gt;bottom_left.y + ((double)rr * sub_cell_l );
-  			 pInnerMap[index].Initialize(p, sub_cell_l, rr, cc,true);
-  			 pInnerMap[index].index = index;
-  		   }
-  	 }
-  }
-
-  void CELL_Info::UpdateCostValue(const vector&lt;POINT2D&gt;&amp; ps)
-  {
-  	index = 0;
-  	double cost = 0;
-  	for(unsigned int i=0; i&lt;ps.size() ; i++)
-  	{
-  		cost += sqrt(distance2points(center, ps[i]));
-  	}
-  	if(localize_val==0)
-  		localize_val = cost;
-  	else
-  		localize_val = (localize_val + cost) / 2.0;
-  }
-
-  void CELL_Info::UpdateSubCellCostValue(const vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l)
-  {
-  	if(!pInnerMap)
-  		InitSubCells(cell_l, sub_cell_l);
-
-  	index = 0;
-  	double cost = 0;
-  	while(index &lt; nCells)
-  	{
-  		//if(pInnerMap[index].localize_val == 0)
-  		{
-  			cost = 0;
-  			for(unsigned int i=0; i&lt;ps.size() ; i++)
-  			{
-  				//cost += abs(ps[i].x - pInnerMap[index].center.p.x) + abs(ps[i].y - pInnerMap[index].center.p.y);//sqrt(MathUtil::Distance(pInnerMap[index].center.p, ps[i]));
-  				cost += sqrt(distance2points(pInnerMap[index].center, ps[i]));
-  			}
-  			if(pInnerMap[index].localize_val == 0)
-  				pInnerMap[index].localize_val = cost;
-  			else
-  				pInnerMap[index].localize_val = (pInnerMap[index].localize_val+cost)/2.0;
-  		}
-  		 index++;
-  	 }
-
-  }
-
-  void CELL_Info::Initialize(POINT2D bottom_l, double cell_l, int row, int col, bool bDefaultEmpty)
-    {
-		double half = cell_l / 2.0;
-		center.x = bottom_l.x + half;
-		center.y = bottom_l.y + half;
-		bottom_left = bottom_l;
-		top_right.x = bottom_left.x + cell_l;
-		top_right.y = bottom_left.y + cell_l;
-		bottom_right.x = top_right.x;
-		bottom_right.y = bottom_left.y;
-		top_left.x = bottom_left.x;
-		top_left.y = top_right.y;
-		nMovingPoints = !bDefaultEmpty;
-		nStaticPoints = !bDefaultEmpty;
-		r = row;
-		c = col;
-    }
-
-bool CELL_Info::operator==(const CELL_Info&amp; cell)
-  {
-	if((this-&gt;r == cell.r &amp;&amp; this-&gt;c == cell.c) || this-&gt;index == cell.index)
-	  return true;
-	else
-	  return false;
-  }
-
-bool CELL_Info::operator!=(const CELL_Info&amp; cell)
-  {
-	if((this-&gt;r != cell.r || this-&gt;c != cell.c) || this-&gt;index != cell.index)
-	  return true;
-	else
-	  return false;
-  }
-
-
-    /*
-     * Check for point to lie in the cell and cell this is an obstacle
-     */
-   inline bool CELL_Info::HitTest(const POINT2D&amp; p)
-    {
-
-  	 bool bHit = PointInRect(p);
-
-  	     if(pInnerMap &amp;&amp; bHit)
-  	       {
-  	         for(int i=0; i&lt;nCells; i++)
-  	           {
-  	             if(pInnerMap[i].PointInRect(p) == true) return true;
-  	           }
-  	       }
-
-  	     return bHit;
-    }
-
-   bool CELL_Info::TestWithRectangle(RECTANGLE&amp; rec)
-   {
-  	 if(!rec.PointInRect(bottom_left))
-  		 return true;
-  	 if(!rec.PointInRect(bottom_right))
-  		 return true;
-  	 if(!rec.PointInRect(top_right))
-  		 return true;
-  	 if(!rec.PointInRect(top_left))
-  		 return true;
-
-  	 return false;
-   }
-
-   bool CELL_Info::TestWithCircle(POINT2D _center, double width)
-   {
-  	 if(distance2points(center, _center) &lt;= width)
-  		 return true;
-  	 else
-  		 return false;
-   }
-   void CELL_Info::SaveCell(ostream&amp; f)
-   {
-  //	 f&lt;&lt;&quot;#CELL_Info:&quot;&lt;&lt;r&lt;&lt;c&lt;&lt;index&lt;nPoints&lt;&lt;bottom_left.x&lt;&lt;bottom_left.y&lt;&lt;top_right.x&lt;&lt;top_right.y;
-  //	 f&lt;&lt;endl;
-  //	 if(pInnerMap)
-  //	 {
-  //		 f&lt;&lt;&quot;#InnerMap:&quot;;
-  //		 for(int i=0; i&lt;nCells; i++)
-  //		   {
-  //			 pInnerMap[i].SaveCell(f);
-  //		   }
-  //	 }
-
-   }
-
-   void CELL_Info::LoadCell(ifstream&amp; f)
-   {
-
-   }
-
-}
</diff>
				<old_file>/*
 * GridMap.cpp
 *
 *  Created on: Oct 22, 2013
 *      Author: hatem
 */

#include &quot;GridMap.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &lt;fstream&gt;

using namespace std;

namespace PlannerHNS
{

GridMap::GridMap(double start_x, double start_y, double map_w, double map_h, double cell_length, bool bDefaultEmpty)
 {
	assert(cell_length &gt; 0);
    assert(map_w&gt;0);
    assert(map_h&gt;0);

    m_bUpdatedMap = false;
    origin_x = start_x ;
    origin_y = start_y;
    m_DisplayResolution = 1;
    sub_cell_l = 0;
	nInnerWCells = nInnerHCells = 0;
	m_bEnableInnerMap = false;
	inner_end_col = inner_end_row = inner_h = inner_start_col = inner_start_row = inner_w = 0;

	w = map_w;
    h = map_h;

    cell_l = cell_length;
    sub_cell_l = cell_l/(double)SUBCELL_L;

    wCells =  w/cell_l;
    hCells =  h/cell_l;

    nCells = wCells*hCells;
	m_MaxHeuristics = w*h*cell_l;

    pCells =  new CELL_Info[nCells];
    POINT2D p;
    int index = 0;

    for(int r=0; r&lt;hCells; r++)
    {
       for(int c=0; c&lt;wCells; c++)
	   {
		 index = get2dIndex(r,c,wCells);
		 p.x = ((double)c * cell_l) + origin_x;
		 p.y = ((double)r * cell_l) + origin_y;
		 pCells[index].Initialize(p, cell_l, r, c,bDefaultEmpty);
		 pCells[index].index = index;

	   }
    }

    double temp[8][3] = { { -1, 0, 1 }, { 0, -1, 1 }, { 1, 0, 1 }, { 0, 1, 1 }, { -1, -1, 1.5 }, { 1, -1, 1.5 }, { 1, 1, 1.5 }, { -1, 1, 1.5 } }; // left, down, right, top, left down, right down, top right, left top
    delta = new POINT2D[8];
    for (int i = 0; i &lt; 8; i++)
    	delta[i] = POINT2D(temp[i][0], temp[i][1]);
 }

int GridMap::InsidePolygon(const vector&lt;POINT2D&gt;&amp; polygon,const POINT2D&amp; p)
{
  int counter = 0;
  int i;
  double xinters;
  POINT2D p1,p2;
  int N = polygon.size();
  if(N &lt;=0 ) return -1;

  p1 = polygon.at(0);
  for (i=1;i&lt;=N;i++)
  {
    p2 = polygon.at(i % N);

    if (p.y &gt; MIN(p1.y,p2.y))
    {
      if (p.y &lt;= MAX(p1.y,p2.y))
      {
        if (p.x &lt;= MAX(p1.x,p2.x))
        {
          if (p1.y != p2.y)
          {
            xinters = (p.y-p1.y)*(p2.x-p1.x)/(p2.y-p1.y)+p1.x;
            if (p1.x == p2.x || p.x &lt;= xinters)
              counter++;
          }
        }
      }
    }
    p1 = p2;
  }

  if (counter % 2 == 0)
    return 0;
  else
    return 1;
}


  void GridMap::OpenClosedCells()
  {
	int loop_size =  nCells;
	int index = 0;
	while(index != loop_size)
	{
			pCells[index].closed = false;
			pCells[index].expanded = -1;
			index++;
	}
  }

  void GridMap::ClearMap(int bMovingOnly)
  {
  	int loop_size =  nCells;
  	int index = 0;
	  while(index != loop_size)
		{
		  pCells[index].Clear(bMovingOnly);
		index++;
	  }
	  m_bUpdatedMap = true;
  }

  void GridMap::UpdateMapObstacleValue(const Obstacle&amp; ob)
  {
	  POINT2D p1, p2, p3, p4;
		p1 = ob.sp;
		p2 = ob.ep;

		if(ob.polygon.size() == 0)
		{
			int loop_size =  nCells;
			int index = 0;
			while(index != loop_size)
			{
					p3 = pCells[index].bottom_left;
					p4 = pCells[index].top_right;

					if(! ( p2.y &lt; p3.y || p1.y &gt; p4.y || p2.x &lt; p3.x || p1.x &gt; p4.x ))
					{
						pCells[index].nStaticPoints++;
						m_bUpdatedMap = true;
					}

					index++;
			}
		}
		else
		{
			vector&lt;CELL_Info*&gt; modList;
			UpdateMapObstaclesValuePlygon(ob.polygon, modList);
		}
  }

  void GridMap::UpdateMapObstaclesValuePlygon(const vector&lt;POINT2D&gt;&amp; poly, vector&lt;CELL_Info*&gt;&amp; modifiedCell)
  {

	  POINT2D minP, maxP;
	  CELL_Info* minC, *maxC;
	  int index = 0;

	  minP = poly[0];
	  maxP = poly[0];

		for(unsigned int j=1; j&lt; poly.size(); j++)
		{
			if(poly[j].x &lt; minP.x) minP.x = poly[j].x;
			if(poly[j].y &lt; minP.y) minP.y = poly[j].y;

			if(poly[j].x &gt; maxP.x) maxP.x = poly[j].x;
			if(poly[j].y &gt; maxP.y) maxP.y = poly[j].y;
		}


		minC = GetCellFromPoint(minP,false);
		maxC = GetCellFromPoint(maxP, false);

		if(!maxC || ! minC)
		{
			printf(&quot;Obstacle Polygon is outside the Map !!&quot;);
			return;
		}

		for(int r=minC-&gt;r; r&lt;=maxC-&gt;r; r++)
		{
			for(int c=minC-&gt;c; c&lt;=maxC-&gt;c; c++)
			{
				index = get2dIndex(r,c,wCells);
				//CELL_Info* pSub = &amp;pCells[index];

//					if(pSub-&gt;pInnerMap == 0)
//					{
//						pSub-&gt;InitSubCells(cell_l, sub_cell_l);
//					}
//						int index_sub = 0;
//						bool bUpdatedSubCell = false;
//						while(index_sub &lt; pSub-&gt;nCells)
//						{
//							if(InsidePolygon(&amp;poly, poly.size(), pSub-&gt;pInnerMap[index_sub].bottom_left)==1 || InsidePolygon(&amp;poly, poly.size(), pSub-&gt;pInnerMap[index_sub].top_right)==1)
//							{
//								pSub-&gt;pInnerMap[index_sub].nStaticPoints = 1;
//								m_bUpdatedMap = true;
//								bUpdatedSubCell = true;
//							}
//							index_sub++;
//						}


				//if(bUpdatedSubCell)
				{
					POINT2D bl= pCells[index].bottom_left;
					bl.x += 0.01;
					bl.y += 0.01;
					POINT2D tr= pCells[index].top_right;
					tr.x -= 0.01;
					tr.y -= 0.01;
					if(InsidePolygon(poly, bl)==1 || InsidePolygon(poly, tr)==1)
					{

							pCells[index].nMovingPoints = 1;
							pCells[index].nStaticPoints = 1;
//							pCells[index].forwardHeuristic = nCells;
//							pCells[index].backwardHeuristic = nCells;
//							pCells[index].heuristic = nCells;
							modifiedCell.push_back(&amp;pCells[index]);
							m_bUpdatedMap = true;
							//pDrivableCells.push_back(&amp;pCells[r][c]);
					}
				}
			}
		}
  }

  void GridMap::UpdateMapDrivablesValuePlygon(const vector&lt;vector&lt;POINT2D&gt; &gt;&amp; points)
  {
//		for(int r=0; r&lt;nColCells; r++)
//		{
//			for(int c=0; c&lt;nRowCells; c++)
//			{
//				if(pCells[r][c].cell.bObstacle)
//				{
//					for(unsigned int i=0; i&lt; points-&gt;size(); i++)
//					{
//						vector&lt;POINT2D&gt;* poly = &amp;((*points)[i]);
//						if(InsidePolygon(poly, poly-&gt;size(), pCells[r][c].cell.bottom_left)==1 || InsidePolygon(poly, poly-&gt;size(), pCells[r][c].cell.top_right)==1)
//								pCells[r][c].cell.bObstacle = false;
//					}
//				}
//
//			}
//		}

	  POINT2D minP, maxP;
	  CELL_Info* minC, *maxC;
	  int index = 0;

	  for(unsigned int i=0; i&lt; points.size(); i++)
		{
			vector&lt;POINT2D&gt; poly = points.at(i);
			maxP = minP = poly[0];

			for(unsigned int j=1; j&lt; poly.size(); j++)
			{
				if(poly[j].x &lt; minP.x) minP.x = poly[j].x;
				if(poly[j].y &lt; minP.y) minP.y = poly[j].y;

				if(poly[j].x &gt; maxP.x) maxP.x = poly[j].x;
				if(poly[j].y &gt; maxP.y) maxP.y = poly[j].y;
			}


			minC = GetCellFromPoint(minP,false);
			maxC = GetCellFromPoint(maxP, false);

			for(int r=minC-&gt;r; r&lt;maxC-&gt;r; r++)
			{
				for(int c=minC-&gt;c; c&lt;maxC-&gt;c; c++)
				{
					index = get2dIndex(r,c,wCells);

					CELL_Info* pSub = &amp;pCells[index];

					if(pSub-&gt;pInnerMap != 0)
					{
						pSub-&gt;InitSubCells(cell_l, sub_cell_l);
					}
						int index_sub = 0;
						//bool bUpdatedSubCell = false;
						while(index_sub &lt; pSub-&gt;nCells)
						{
							if(InsidePolygon(poly, pSub-&gt;pInnerMap[index_sub].bottom_left)==1 || InsidePolygon(poly, pSub-&gt;pInnerMap[index_sub].top_right)==1)
							{
								pSub-&gt;pInnerMap[index_sub].nStaticPoints = 0;
								m_bUpdatedMap = true;
								//bUpdatedSubCell = true;
							}
							index_sub++;
						}


					//if(bUpdatedSubCell)
					{
						if(InsidePolygon(poly, pCells[index].bottom_left)==1 || InsidePolygon(poly, pCells[index].top_right)==1)
						{

								pCells[index].nStaticPoints = 0;
								m_bUpdatedMap = true;
								//pDrivableCells.push_back(&amp;pCells[r][c]);
						}
					}
				}
			}
		}
  }

  void GridMap::UpdateMapDrivablesValue(const DrivableArea&amp; dr)
    {
  	  POINT2D p1, p2, p3, p4;
  	  p1 = dr.sp;
  	  p2 = dr.ep;

  		int loop_size =  nCells;
  	int index = 0;
	  while(index != loop_size)
		{
				p3 = pCells[index].bottom_left;
				p4 = pCells[index].top_right;

				if(! ( p2.y &lt; p3.y || p1.y &gt; p4.y || p2.x &lt; p3.x || p1.x &gt; p4.x ))
				{
					pCells[index].nStaticPoints = 0;
					m_bUpdatedMap = true;
				}

				index++;
		}
    }

  void GridMap::InitInnerMap(double  map_l, GridMap* const pParentMap, const POINT2D&amp; center)
  {
	  int min_row, min_col, max_row, max_col;
	  CELL_Info* scell = GetCellFromPoint(center);
		if(!scell) return;

		//Get First Left Cell
		double max_left = scell-&gt;c * pParentMap-&gt;cell_l;
		if(max_left &lt; map_l)
		{
			min_row = 0;
		}
		else
		{
			POINT2D p(center.x-map_l, center.y);
			min_row = GetCellFromPoint(p)-&gt;r;
		}

		double max_right = (pParentMap-&gt;hCells - scell-&gt;c) * pParentMap-&gt;cell_l;
		if(max_right &lt; map_l)
		{
			max_row = pParentMap-&gt;hCells;
		}
		else
		{
			POINT2D p(center.x+map_l, center.y);
			max_row = GetCellFromPoint(p)-&gt;r;
		}

		double max_bottom = scell-&gt;r * pParentMap-&gt;cell_l;
		if(max_bottom &lt; map_l)
		{
			min_col = 0;
		}
		else
		{
			POINT2D p(center.x, center.y-map_l);
			min_col = GetCellFromPoint(p)-&gt;c;
		}

		double max_top = (pParentMap-&gt;wCells- scell-&gt;r) * pParentMap-&gt;cell_l;
		if(max_top &lt; map_l)
		{
			max_col = pParentMap-&gt;wCells;
		}
		else
		{
			POINT2D p(center.x, center.y+map_l);
			max_col = GetCellFromPoint(p)-&gt;c;
		}

		inner_start_row = min_row;
		inner_start_col = min_col;
		inner_end_row = max_row;
		inner_end_col = max_col;
		nInnerWCells =max_col-min_col;
		nInnerHCells = max_row-min_row;
		inner_w =  nInnerWCells* pParentMap-&gt;cell_l;
		inner_h =  nInnerHCells* pParentMap-&gt;cell_l;
		cell_l = pParentMap-&gt;cell_l;
		sub_cell_l = pParentMap-&gt;sub_cell_l;


  }

 CELL_Info* GridMap::UpdateMapCostValueRange(const vector&lt;POINT2D&gt;&amp; ps, const GPSPoint&amp; currPos, const vector&lt;double&gt;&amp; features)
  {
	 POINT2D pos(currPos.x, currPos.y);
	CELL_Info* pC = GetCellFromPoint(pos);



	if(pC)
	{
		//Update Affected cells value from this new point
		vector&lt;CELL_Info*&gt; cells;
		GetSurroundingMainCells(pos, cells, 1);
		for(unsigned int i=0; i&lt; cells.size(); i++)
		{
			cells[i]-&gt;UpdateSubCellCostValue(ps, cell_l, sub_cell_l);
			cells[i]-&gt;UpdateCostValue(ps);
			m_bUpdatedMap = true;
		}
		//only one level
//			pC-&gt;UpdateSubCellCostValue(p, cell_l, sub_cell_l);

	}

	return pC;
  }

 bool GridMap::CheckSubCellsInTheWay(const POINT2D&amp; p, const GPSPoint&amp; carPos, const double&amp; thiningThreshold, vector&lt;CELL_Info*&gt;&amp; pSubCellsList)
 {
	 POINT2D v(p.x - carPos.x, p.y - carPos.y);
	 double v_norm = pointNorm(v);


	 //Number of search iteration will be a ratio between the thining threshold   and the sub cell length
	 double step_d = sub_cell_l;
	 double start_d = -thiningThreshold/ 2.0;
	 pSubCellsList.clear();
	 CELL_Info* pSubCell = 0;
	 while(start_d &lt; thiningThreshold)
	 {
		 POINT2D p_obstacle = p;
		 p_obstacle.x += v.x/v_norm * start_d;
		 p_obstacle.y += v.y/v_norm * start_d;
		 pSubCell = GetSubCellFromPoint(p_obstacle);
		 if(pSubCell &amp;&amp; pSubCell-&gt;nStaticPoints&gt;0)
			 return true;

		pSubCellsList.push_back(pSubCell);
		 start_d += step_d;
	 }

	 return false;
 }

 CELL_Info* GridMap::UpdateThinMapObstaclePoint(const POINT2D&amp; p, const GPSPoint&amp; carPos,const double&amp; thiningTHreshold)
 {
	 CELL_Info* pC = GetCellFromPoint(p);
	if(pC)
	{
		vector&lt;CELL_Info*&gt; subcells_list;

		if(!CheckSubCellsInTheWay(p, carPos, thiningTHreshold, subcells_list))
		{
			pC-&gt;nStaticPoints++;
			CELL_Info* pSubc = GetSubCellFromCell(pC, p);
			if(pSubc)
			{
				if(pSubc-&gt;nStaticPoints&lt;1)
				{
					pSubc-&gt;innerStaticPointsList.push_back(p);
					m_bUpdatedMap = true;
				}

				pSubc-&gt;nStaticPoints++;
			}
		}
	}
	return pC;
 }

 CELL_Info* GridMap::UpdateMapObstaclePoint(const POINT2D&amp; p)
{
	CELL_Info* pC = GetCellFromPoint(p);
	if(pC)
	{
		if(pC-&gt;nStaticPoints &lt; 5)
			pC-&gt;nStaticPoints++;
		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
		if(pSubc)
		{
			if(pSubc-&gt;nStaticPoints&lt;1)
			{
				//pthread_mutex_lock(&amp;update_map_mutex);
				pSubc-&gt;innerStaticPointsList.push_back(p);
				m_bUpdatedMap = true;
				//pthread_mutex_unlock(&amp;update_map_mutex);
			}

			if(pSubc-&gt;nStaticPoints &lt; 5)
				pSubc-&gt;nStaticPoints++;
		}
	}
	return pC;
}

CELL_Info* GridMap::UpdateMapMovingObstaclePoint(const POINT2D&amp; p)
{
	CELL_Info* pC = GetCellFromPoint(p);
	if(pC)
	{
		if(pC-&gt;nMovingPoints &lt; 5)
			pC-&gt;nMovingPoints++;
		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
		if(pSubc)
		{
			if(pSubc-&gt;nMovingPoints&lt;1)
			{
				//pthread_mutex_lock(&amp;update_map_mutex);
				pSubc-&gt;innerMovingPointsList.push_back(p);
				m_bUpdatedMap = true;
				//pthread_mutex_unlock(&amp;update_map_mutex);
			}

			if(pSubc-&gt;nMovingPoints&lt;5)
				pSubc-&gt;nMovingPoints++;
		}
	}
	return pC;
}

 CELL_Info* GridMap::UpdateMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob)
 {
 	CELL_Info* pC = GetCellFromPoint(p);
 	if(pC)
 	{
 		pC-&gt;localize_val = localize_val;
 		pC-&gt;localize_prob = localize_prob;
 		m_bUpdatedMap = true;
 	}

 	return pC;
 }

 CELL_Info* GridMap::UpdateSubMapCostValue(const POINT2D&amp; p, const double&amp; localize_val, const double&amp; localize_prob)
 {
 	CELL_Info* pC = GetCellFromPoint(p);
 	if(pC)
 	{

 		CELL_Info* pSubc = GetSubCellFromCell(pC, p);
 		if(pSubc)
 		{
 			pSubc-&gt;localize_val = localize_val;
 			pSubc-&gt;localize_prob = localize_prob;
 			m_bUpdatedMap = true;
 		}
 	}

 	return pC;
 }

CELL_Info* GridMap::GetSubCellFromCell(CELL_Info* const parent, const POINT2D&amp; p)
{
	if(!parent) return 0;

	if(!parent-&gt;pInnerMap)
		parent-&gt;InitSubCells(cell_l, sub_cell_l);

	int row = floor((p.y - parent-&gt;bottom_left.y)/sub_cell_l);
	int col = floor((p.x - parent-&gt;bottom_left.x)/sub_cell_l);

	if(row&gt;=0 &amp;&amp; row&lt;SUBCELL_L &amp;&amp; col &gt;=0 &amp;&amp; col &lt; SUBCELL_L)
		return &amp;parent-&gt;pInnerMap[get2dIndex(row,col,SUBCELL_L)];
	else
		return 0;
}

CELL_Info* GridMap::GetSubCellFromPoint(const POINT2D&amp; p)
{
	CELL_Info* pMainCell = GetCellFromPoint(p);
	if(pMainCell)
	{
		if(!pMainCell-&gt;pInnerMap)
			pMainCell-&gt;InitSubCells(cell_l, sub_cell_l);

		int row = floor((p.y - pMainCell-&gt;bottom_left.y)/sub_cell_l);
		int col = floor((p.x - pMainCell-&gt;bottom_left.x)/sub_cell_l);

		return &amp;pMainCell-&gt;pInnerMap[get2dIndex(row,col,SUBCELL_L)];
	}
	else
		return 0;
}

CELL_Info* GridMap::GetCellFromPoint(const POINT2D&amp; p, bool bExpand)
{

	  int row = floor((p.y-origin_y) /cell_l);
	  int col = floor((p.x-origin_x) /cell_l);

	  if(row&gt;=0 &amp;&amp; row &lt; hCells &amp;&amp; col &gt;=0 &amp;&amp; col &lt; wCells)
	  {
//		  POINT2D _p(p.x , p.y );
//		bool exist = pCells[get2dIndex(row,col,nColCells)].PointInRect(p);
//
//		if(!exist)
//			return 0;

		  //retCell = pCells[row][col];
		  //retCell.center.a = p.a;
		  int index = get2dIndex(row,col,wCells);
		  if(index &gt;= 0 &amp;&amp; index &lt; nCells)
			  return &amp;pCells[index];
		  else
			  printf(&quot;Error Getting Cell with Info: P(%f,%f) , C(%d,%d), index = %d&quot;, p.x, p.y, row, col, index);
	  }
	  else if(bExpand)
	  {
		  //first get extend direction and factor
		  double lf=0, rf=0,tf=0,bf=0;
		  int nRC=0,nCC=0;
		  if(fabsf(p.x) &gt;= 0)
			nRC= (fabsf(p.x) - 0)/cell_l + 1;

		  if(fabsf(p.y) &gt;= 0)
			nCC= (fabsf(p.y) - 0)/cell_l + 1;

		  if(p.x &gt; 0)
			  rf = nRC*4.0;
		  else
			  lf = nRC*4.0;

		  if(p.y &gt; 0)
			  tf = nCC*4.0;
		  else
			  bf = nCC*4.0;

	  }

    return 0;
  }


CELL_Info* GridMap::GetCellFromPointInnerMap(const POINT2D&amp; p)
{
  int row = floor((p.y - origin_y) /cell_l);
  int col = floor((p.x - origin_x)/cell_l);

  if(row&gt;=inner_start_row &amp;&amp; row &lt; inner_end_row &amp;&amp; col &gt;=inner_start_col &amp;&amp; col &lt; inner_end_col)
  {

	  POINT2D _p(p.x , p.y );

	bool exist = pCells[get2dIndex(row,col,wCells)].PointInRect(p);

	if(!exist)
		return 0;

	  //retCell = pCells[row][col];
	  //retCell.center.a = p.a;
	  return &amp;pCells[get2dIndex(row,col,wCells)];
  }

  return 0;

}

  void GridMap::BackupMap()
  {
  }

  GridMap::GridMap()
	{
	  //update_map_mutex = PTHREAD_MUTEX_INITIALIZER;
		sub_cell_l = 0;
		nCells = 0;
		nInnerWCells = nInnerHCells = 0;
		m_bEnableInnerMap = false;
		inner_end_col = inner_end_row = inner_h = inner_start_col = inner_start_row = inner_w = 0;
		w = h = cell_l  = wCells = hCells = m_MaxHeuristics = 0;
		pCells = 0;
		m_DisplayResolution = 1;
		delta = 0;
		origin_y = 0;
		origin_x =0;
		m_bUpdatedMap  = false;
	}

  GridMap::~GridMap()
  {
    if(pCells)
    {
      delete [] pCells;
      pCells = 0;
    }
    if(delta)
    {
    	delete [] delta;
    	delta = 0;
    }
  }

  int GridMap::GetSurroundingNonObstacleCells(const POINT2D&amp; pos, vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range)
  {
	  int nMaxLevels = max_range/cell_l;

	int r, c;
	vector&lt;CELL_Info*&gt; nextLevel;
	vector&lt;CELL_Info*&gt; currentLevel;
	vector&lt;CELL_Info*&gt; tempLevel;

	CELL_Info* originalGoal = GetCellFromPoint(pos);
	if(!originalGoal) return 0;

	CELL_Info* tempCell;


	currentLevel.push_back(originalGoal);
	cells_list.push_back(originalGoal);
	int counter = 0;
	int index = 0;

	while (currentLevel.size() &gt; 0 &amp;&amp; nMaxLevels&gt;0)
	{
		tempCell = currentLevel.back();
		currentLevel.pop_back();

		for (int i = 0; i &lt; 8; i++)
		{
			counter++;
			r = tempCell-&gt;r + delta[i].x;
			c = tempCell-&gt;c + delta[i].y;
			index = get2dIndex(r,c,wCells);

			if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; hCells &amp;&amp; c &lt; wCells)
			{
				if(pCells[index].nMovingPoints&gt;0 || pCells[index].nStaticPoints &gt; 0 || pCells[index].heuristic == m_MaxHeuristics)
					continue;
				//insert unique
				bool bFound = false;
				for(unsigned int j=0; j&lt; cells_list.size();j++)
				{
					if(cells_list[j] == &amp;pCells[index])
					{
						bFound = true;
						break;
					}
				}
				if(!bFound)
				{
					cells_list.push_back(&amp;pCells[index]);
					nextLevel.push_back(&amp;pCells[index]);
				}
			}
		}

		if (currentLevel.size() == 0 &amp;&amp; nextLevel.size() &gt; 0)
		{
			tempLevel = currentLevel;
			currentLevel = nextLevel;
			nextLevel = tempLevel;
			nMaxLevels--;
		}
	}

	return counter;
  }

  int GridMap::GetSurroundingMainCellsRectangleNoObstacle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect)
    {

    	//calculate the number of levels that satisfy the max range criteria
    	int nMaxLevels = hypot(rect.width, rect.length) / cell_l;

    	CELL_Info* originalGoal = GetCellFromPoint(pos);

    	if (!originalGoal)
    		return 0;

    	cells_list.push_back(originalGoal);

    	if (nMaxLevels &lt;= 1)
    		return 1;

    	nMaxLevels--;

    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
    	int r, c;
    	CELL_Info* tempCell = 0;
    	int counter = 1;
    	int index = 0;

    	POINT2D mask;
    	//first level , // left, down, right, top, left down, right down, top right, left top
    	//strait degree
    	for (unsigned int i = 0; i &lt; 4; i++)
    	{
    		mask.x = delta[i].x;
    		mask.y = delta[i].y;
    		r = originalGoal-&gt;r + mask.x;
    		c = originalGoal-&gt;c + mask.y;
    		index = get2dIndex(r, c, wCells);

    		if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
  		{
  			straitCells.push_back(make_pair(&amp;pCells[index], mask));
  			if (!pCells[index].TestWithRectangle(rect))
  				cells_list.push_back(&amp;pCells[index]);
  		}
    	}

    	//diagonal degree
    	for (unsigned int i = 4; i &lt; 8; i++)
    	{
    		mask.x = delta[i].x;
    		mask.y = delta[i].y;
    		r = originalGoal-&gt;r + mask.x;
    		c = originalGoal-&gt;c + mask.y;
    		index = get2dIndex(r, c, wCells);
    		if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
    		{
    			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
  			if (!pCells[index].TestWithRectangle(rect))
  				cells_list.push_back(&amp;pCells[index]);
    		}
    	}

    	nMaxLevels--;
    	counter++;

    	while (nMaxLevels &gt; 0)
    	{
    		straitCellsL2.clear();
    		diagonalCellsL2.clear();
    		while (straitCells.size() &gt; 0)
    		{
    			mask = straitCells.back().second;
    			tempCell = straitCells.back().first;
    			r = tempCell-&gt;r + mask.x;
    			c = tempCell-&gt;c + mask.y;
    			index = get2dIndex(r, c, wCells);
    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
    			{
  				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
  				if (!pCells[index].TestWithRectangle(rect))
  					cells_list.push_back(&amp;pCells[index]);
    			}

    			//diagonal 1
    			if (straitCells.back().second.x == 0)
    				mask.x += 1;
    			else
    				mask.y += 1;
    			r = tempCell-&gt;r + mask.x;
    			c = tempCell-&gt;c + mask.y;
    			index = get2dIndex(r, c, wCells);
    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
    			{
  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
  				if (!pCells[index].TestWithRectangle(rect))
  					cells_list.push_back(&amp;pCells[index]);
    			}

    			//diagonal 2
    			if (straitCells.back().second.x == 0)
    				mask.x += -2;
    			else
    				mask.y += -2;
    			r = tempCell-&gt;r + mask.x;
    			c = tempCell-&gt;c + mask.y;
    			index = get2dIndex(r, c, wCells);
    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
    			{
  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
  				if (!pCells[index].TestWithRectangle(rect))
  					cells_list.push_back(&amp;pCells[index]);
    			}

    			straitCells.pop_back();
    		}

    		//Diagonal
    		while (diagonalCells.size() &gt; 0)
    		{
    			mask = diagonalCells.back().second;
    			tempCell = diagonalCells.back().first;
    			r = tempCell-&gt;r + mask.x;
    			c = tempCell-&gt;c + mask.y;
    			index = get2dIndex(r, c, wCells);
    			if(checkGridIndex(index, nCells) &amp;&amp; pCells[index].nMovingPoints == 0 &amp;&amp; pCells[index].nStaticPoints == 0 &amp;&amp; pCells[index].heuristic != m_MaxHeuristics)
    			{
  				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
  				if (!pCells[index].TestWithRectangle(rect))
  					cells_list.push_back(&amp;pCells[index]);
    			}

    			diagonalCells.pop_back();
    		}

    		nMaxLevels--;
    		counter++;
    		if (nMaxLevels &lt;= 0)
    			break;

    		straitCells = straitCellsL2;
    		diagonalCells = diagonalCellsL2;

    	}

    	return counter;

    }

  int GridMap::GetSurroundingMainCellsRectangle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, RECTANGLE&amp; rect)
  {

  	//calculate the number of levels that satisfy the max range criteria
  	int nMaxLevels = hypot(rect.width, rect.length) / cell_l;

  	CELL_Info* originalGoal = GetCellFromPoint(pos);

  	if (!originalGoal)
  		return 0;

  	cells_list.push_back(originalGoal);

  	if (nMaxLevels &lt;= 1)
  		return 1;

  	nMaxLevels--;

  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
  	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
  	int r, c;
  	CELL_Info* tempCell = 0;
  	int counter = 1;
  	int index = 0;

  	POINT2D mask;
  	//first level , // left, down, right, top, left down, right down, top right, left top
  	//strait degree
  	for (unsigned int i = 0; i &lt; 4; i++)
  	{
  		mask.x = delta[i].x;
  		mask.y = delta[i].y;
  		r = originalGoal-&gt;r + mask.x;
  		c = originalGoal-&gt;c + mask.y;
  		index = get2dIndex(r, c, wCells);
  		if(checkGridIndex(index, nCells))
		{
			straitCells.push_back(make_pair(&amp;pCells[index], mask));
			if (!pCells[index].TestWithRectangle(rect))
				cells_list.push_back(&amp;pCells[index]);
		}
  	}

  	//diagonal degree
  	for (unsigned int i = 4; i &lt; 8; i++)
  	{
  		mask.x = delta[i].x;
  		mask.y = delta[i].y;
  		r = originalGoal-&gt;r + mask.x;
  		c = originalGoal-&gt;c + mask.y;
  		index = get2dIndex(r, c, wCells);
  		if(checkGridIndex(index, nCells))
  		{
  			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
			if (!pCells[index].TestWithRectangle(rect))
				cells_list.push_back(&amp;pCells[index]);
  		}
  	}

  	nMaxLevels--;
  	counter++;

  	while (nMaxLevels &gt; 0)
  	{
  		straitCellsL2.clear();
  		diagonalCellsL2.clear();
  		while (straitCells.size() &gt; 0)
  		{
  			mask = straitCells.back().second;
  			tempCell = straitCells.back().first;
  			r = tempCell-&gt;r + mask.x;
  			c = tempCell-&gt;c + mask.y;
  			index = get2dIndex(r, c, wCells);
  			if(checkGridIndex(index, nCells))
  			{
				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
				if (!pCells[index].TestWithRectangle(rect))
					cells_list.push_back(&amp;pCells[index]);
  			}

  			//diagonal 1
  			if (straitCells.back().second.x == 0)
  				mask.x += 1;
  			else
  				mask.y += 1;
  			r = tempCell-&gt;r + mask.x;
  			c = tempCell-&gt;c + mask.y;
  			index = get2dIndex(r, c, wCells);
  			if(checkGridIndex(index, nCells))
  			{
				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
				if (!pCells[index].TestWithRectangle(rect))
					cells_list.push_back(&amp;pCells[index]);
  			}

  			//diagonal 2
  			if (straitCells.back().second.x == 0)
  				mask.x += -2;
  			else
  				mask.y += -2;
  			r = tempCell-&gt;r + mask.x;
  			c = tempCell-&gt;c + mask.y;
  			index = get2dIndex(r, c, wCells);
  			if(checkGridIndex(index, nCells))
  			{
				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
				if (!pCells[index].TestWithRectangle(rect))
					cells_list.push_back(&amp;pCells[index]);
  			}

  			straitCells.pop_back();
  		}

  		//Diagonal
  		while (diagonalCells.size() &gt; 0)
  		{
  			mask = diagonalCells.back().second;
  			tempCell = diagonalCells.back().first;
  			r = tempCell-&gt;r + mask.x;
  			c = tempCell-&gt;c + mask.y;
  			index = get2dIndex(r, c, wCells);
  			if(checkGridIndex(index, nCells))
  			{
				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
				if (!pCells[index].TestWithRectangle(rect))
					cells_list.push_back(&amp;pCells[index]);
  			}

  			diagonalCells.pop_back();
  		}

  		nMaxLevels--;
  		counter++;
  		if (nMaxLevels &lt;= 0)
  			break;

  		straitCells = straitCellsL2;
  		diagonalCells = diagonalCellsL2;

  	}

  	return counter;

  }

  int GridMap::GetSurroundingMainCellsCircle(const POINT2D&amp; pos,	vector&lt;CELL_Info*&gt;&amp; cells_list, double radius)
    {

    	//calculate the number of levels that satisfy the max range criteria
    	int nMaxLevels = radius * 2.0 / cell_l;

    	CELL_Info* originalGoal = GetCellFromPoint(pos);

    	if (!originalGoal)
    		return 0;

    	cells_list.push_back(originalGoal);

    	if (nMaxLevels &lt;= 1)
    		return 1;

    	nMaxLevels--;

    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCells;
    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCells;
    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; straitCellsL2;
    	vector&lt;pair&lt;CELL_Info*, POINT2D&gt; &gt; diagonalCellsL2;
    	int r, c;
    	CELL_Info* tempCell = 0;
    	int counter = 1;
    	int index = 0;

    	POINT2D mask;
    	//first level , // left, down, right, top, left down, right down, top right, left top
    	//strait degree
    	for (unsigned int i = 0; i &lt; 4; i++)
    	{
    		mask.x = delta[i].x;
    		mask.y = delta[i].y;
    		r = originalGoal-&gt;r + mask.x;
    		c = originalGoal-&gt;c + mask.y;
    		index = get2dIndex(r, c, wCells);
    		if(checkGridIndex(index, nCells))
  		{
  			straitCells.push_back(make_pair(&amp;pCells[index], mask));
  			if (pCells[index].TestWithCircle(pos, radius))
  				cells_list.push_back(&amp;pCells[index]);
  		}
    	}

    	//diagonal degree
    	for (unsigned int i = 4; i &lt; 8; i++)
    	{
    		mask.x = delta[i].x;
    		mask.y = delta[i].y;
    		r = originalGoal-&gt;r + mask.x;
    		c = originalGoal-&gt;c + mask.y;
    		index = get2dIndex(r, c, wCells);
    		if(checkGridIndex(index, nCells))
    		{
    			diagonalCells.push_back(make_pair(&amp;pCells[index], mask));
    			if (pCells[index].TestWithCircle(pos, radius))
    				cells_list.push_back(&amp;pCells[index]);
    		}
    	}

    	nMaxLevels--;
    	counter++;

    	while (nMaxLevels &gt; 0)
    	{
    		straitCellsL2.clear();
    		diagonalCellsL2.clear();
    		while (straitCells.size() &gt; 0)
    		{
    			mask = straitCells.back().second;
    			tempCell = straitCells.back().first;
    			r = tempCell-&gt;r + mask.x;
    			c = tempCell-&gt;c + mask.y;
    			index = get2dIndex(r, c, wCells);
    			if(checkGridIndex(index, nCells))
    			{
    				straitCellsL2.push_back(make_pair(&amp;pCells[index], mask));
    				if (pCells[index].TestWithCircle(pos, radius))
    					cells_list.push_back(&amp;pCells[index]);
    			}

    			//diagonal 1
    			if (straitCells.back().second.x == 0)
    				mask.x += 1;
    			else
    				mask.y += 1;
    			r = tempCell-&gt;r + mask.x;
    			c = tempCell-&gt;c + mask.y;
    			index = get2dIndex(r, c, wCells);
    			if(checkGridIndex(index, nCells))
    			{
					diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
					if (pCells[index].TestWithCircle(pos, radius))
						cells_list.push_back(&amp;pCells[index]);
    			}

    			//diagonal 2
    			if (straitCells.back().second.x == 0)
    				mask.x += -2;
    			else
    				mask.y += -2;
    			r = tempCell-&gt;r + mask.x;
    			c = tempCell-&gt;c + mask.y;
    			index = get2dIndex(r, c, wCells);
    			if(checkGridIndex(index, nCells))
    			{
    				diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
    				if (pCells[index].TestWithCircle(pos, radius))
    					cells_list.push_back(&amp;pCells[index]);
    			}

    			straitCells.pop_back();
    		}

    		//Diagonal
    		while (diagonalCells.size() &gt; 0)
    		{
    			mask = diagonalCells.back().second;
    			tempCell = diagonalCells.back().first;
    			r = tempCell-&gt;r + mask.x;
    			c = tempCell-&gt;c + mask.y;
    			index = get2dIndex(r, c, wCells);
    			if(checkGridIndex(index, nCells))
    			{
					diagonalCellsL2.push_back(make_pair(&amp;pCells[index], mask));
					if (pCells[index].TestWithCircle(pos, radius))
						cells_list.push_back(&amp;pCells[index]);
    			}

    			diagonalCells.pop_back();
    		}

    		nMaxLevels--;
    		counter++;
    		if (nMaxLevels &lt;= 0)
    			break;

    		straitCells = straitCellsL2;
    		diagonalCells = diagonalCellsL2;

    	}

    	return counter;

    }

  int GridMap::GetSurroundingMainCells(const POINT2D&amp; pos, vector&lt;CELL_Info*&gt;&amp; cells_list, double max_range)
  {

	  //calculate the number of levels that satisfy the max range criteria
	int nMaxLevels = max_range/cell_l;

  	int r, c;
  	vector&lt;CELL_Info*&gt; nextLevel;
  	vector&lt;CELL_Info*&gt; currentLevel;
  	vector&lt;CELL_Info*&gt; tempLevel;

  	CELL_Info* originalGoal = GetCellFromPoint(pos);
  	if(!originalGoal) return 0;

  	CELL_Info* tempCell;


  	currentLevel.push_back(originalGoal);
  	cells_list.push_back(originalGoal);
  	int counter = 0;
  	int index = 0;

  	while (currentLevel.size() &gt; 0 &amp;&amp; nMaxLevels&gt;0)
  	{
  		tempCell = currentLevel.back();
  		currentLevel.pop_back();

  		for (int i = 0; i &lt; 8; i++)
  		{
  			counter++;
  			r = tempCell-&gt;r + delta[i].x;
  			c = tempCell-&gt;c + delta[i].y;
  			index = get2dIndex(r,c,wCells);

  			if (r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; hCells &amp;&amp; c &lt; wCells)
  			{
  				//insert unique
  				bool bFound = false;
  				for(unsigned int j=0; j&lt; cells_list.size();j++)
  				{
  					if(cells_list[j] == &amp;pCells[index])
  					{
  						bFound = true;
  						break;
  					}
  				}
  				if(!bFound)
  				{
  					cells_list.push_back(&amp;pCells[index]);
  					nextLevel.push_back(&amp;pCells[index]);
  				}
  			}
  		}

  		if (currentLevel.size() == 0 &amp;&amp; nextLevel.size() &gt; 0)
  		{
  			tempLevel = currentLevel;
  			currentLevel = nextLevel;
  			nextLevel = tempLevel;
  			nMaxLevels--;
  		}
  	}

  	return counter;

  }

  void GridMap::SaveMap(const string&amp; mapFilePath, const string&amp; mapName)
  {
	  ofstream f(mapFilePath.c_str(),ios::out);
	  if(!f.is_open())
	  {
		  printf(&quot;\n Can't Open Map File to Save!, %s&quot;, mapFilePath.c_str());
		  return;
	  }
	  f.precision(8);

	  if(nCells&gt;0)
	  {
		  int loop_size =  nCells;
		  int index = 0;
			while(index != loop_size)
			{
				if(pCells[index].nStaticPoints &gt; 0 )
				{
					int subindex = 0;
					int sub_loop_size = pCells[index].nCells;
					while(subindex != sub_loop_size)
					{
						if(pCells[index].pInnerMap[subindex].nStaticPoints &gt; 0)
						{
							for(unsigned int p=0; p&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList.size(); p++)
							{
								f&lt;&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList[p].x&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].pInnerMap[subindex].innerStaticPointsList[p].y&lt;&lt;&quot; &quot;;
							}
							f&lt;&lt;endl;
						}

						subindex++;
					}
				}

			index++;
			}
	  }

	  f.close();

	  //save Values Map
//	  string cost_file = mapFilePath + &quot;_cost.grd&quot;;
//	  ofstream f2(cost_file.c_str(),ios::out);
//  	  f2.precision(8);
//  	if(nCells&gt;0)
//	  {
//		  int loop_size =  nCells;
//		  int index = 0;
//			while(index != loop_size)
//			{
//				if(pCells[index].nCells&gt;0)
//				{
//					if(pCells[index].localize_val&gt;0)
//					{
//						f2&lt;&lt;&quot;C,&quot;&lt;&lt;pCells[index].center.p.x&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].center.p.y&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].localize_val &lt;&lt; &quot; &quot;;
//						f2&lt;&lt;endl;
//					}
//
//					int subIndex = 0;
//					while(subIndex != pCells[index].nCells)
//					{
//						f2&lt;&lt;&quot;S,&quot;&lt;&lt;pCells[index].pInnerMap[subIndex].center.p.x&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].pInnerMap[subIndex].center.p.y&lt;&lt;&quot;,&quot;&lt;&lt;pCells[index].pInnerMap[subIndex].localize_val &lt;&lt; &quot; &quot;;
//						subIndex++;
//					}
//					f2&lt;&lt;endl;
//				}
//
//				index++;
//			}
//	  }
//
//  	f2.close();

  }

  void GridMap::LoadMap(const string&amp; mapFilePath, const POINT2D&amp; pos, const double&amp; loadingRadius, const GPSPoint&amp; mapTransformation)
  {

//	  GPSPoint point;
//	  ifstream f(mapFilePath.c_str(), ios::in);
//	  if(!f.is_open())
//	  {
//		  printf(&quot;\n Can't Open Map File !, %s&quot;, mapFilePath.c_str());
//		  return;
//	  }
//
//	  f.precision(8);
//	  string token, temp, innerToken;
//	  string strLine;
//
//	while(!f.eof())
//	{
//		getline(f, strLine);
//		istringstream str_stream(strLine);
//		while(getline(str_stream, innerToken, ' '))
//		{
//
//			string str_x, str_y;
//
//			istringstream ss(innerToken);
//
//			getline(ss, str_x, ',');
//			getline(ss, str_y, ',');
//
//			point.p.x = atof(str_x.c_str());
//			point.p.y = atof(str_y.c_str());
//
//			MathUtil::CoordinateTransform(point, mapTransformation);
//
//			UpdateMapObstaclePoint(point);
//		}
//	}
//
//	  f.close();

//	  string cost_file = mapFilePath + &quot;_cost.grd&quot;;
//	  ifstream f2(cost_file.c_str(),ios::in);
//	  f2.precision(8);
//	  double cost_val = 0;
//	  while(!f2.eof())
//	  	{
//	  		getline(f2, strLine);
//	  		istringstream str_stream(strLine);
//
//	  		while(getline(str_stream, innerToken, ' '))
//			{
//				string str_key, str_x, str_y, str_val;
//				istringstream ss(innerToken);
//				getline(ss, str_key, ',');
//				getline(ss, str_x, ',');
//				getline(ss, str_y, ',');
//				getline(ss, str_val, ',');
//
//				point.x = atof(str_x.c_str());
//				point.y = atof(str_y.c_str());
//				cost_val = atof(str_val.c_str());
//
//				if(str_key.compare(&quot;S&quot;)==0)
//					UpdateSubMapCostValue(point, cost_val, 0);
//				else
//					UpdateMapCostValue(point, cost_val, 0);
//			}
//
//	  	}
//
//	  f2.close();
  }

  CELL_Info::CELL_Info()
    {
		index = 0;
		r=0;
		c=0;

		nCells = 0;
		pInnerMap = 0;
		heuristicValue = 0;
		forwardHeuristic = 0;
		backwardHeuristic = 0;
		heuristic = 0;
		expanded = -1;
		value = 0;
		action = -1;
		forward_heuristicValue = 0;
		backward_heuristicValue = 0;
		bDir = STANDSTILL_DIR;
		closed = false;
		nMovingPoints = 0;
		nStaticPoints = 0;
		localize_val = 0;
		localize_prob = 0;
    }

  CELL_Info::~CELL_Info()
     {
  //     if(pInnerCells)
  //       delete [] pInnerCells;
  	if(pInnerMap)
  		delete [] pInnerMap;
     }

  void CELL_Info::ClearSubCells(bool bMovingOnly)
  {
  	for(int i=0; i&lt;nCells; i++)
  	{
  		if(!bMovingOnly)
  		{
  			pInnerMap[i].nStaticPoints = 0;
  			pInnerMap[i].innerStaticPointsList.clear();
  		}
  		pInnerMap[i].nMovingPoints = 0;
  		pInnerMap[i].innerMovingPointsList.clear();
  	}
  }

  void CELL_Info::Clear(int bMovingOnly)
  {
  	//forwardCenter = center;
  	//backwardCenter = center;

  	heuristicValue = 0;
  	heuristic = 0;
  	forwardHeuristic  = 0;
  	backwardHeuristic  = 0;
  	forward_heuristicValue = 0;
  	backward_heuristicValue = 0;
  	expanded = -1;
  	value = 0;
  	closed = false;
  	action = -1;
  	bDir = STANDSTILL_DIR;
  	if(bMovingOnly == 1)
  	{
  		if(nMovingPoints&gt;0)
  		{
  			nMovingPoints = 0;
  			ClearSubCells(true);
  		}
  	}
  	else if(bMovingOnly == 0)
  	{
  		if(nMovingPoints&gt;0 || nStaticPoints&gt;0)
  		{
  			nMovingPoints = 0;
  			nStaticPoints = 0;
  			ClearSubCells(false);
  		}
  	}

  }

  void CELL_Info::InitSubCells(double cell_l, double sub_cell_l)
  {
  	nCells = SUBCELL_L*SUBCELL_L;
  	pInnerMap =  new CELL_Info[nCells];
  	 POINT2D p;
  	 int index = 0;

  	 for(int rr=0; rr&lt;SUBCELL_L; rr++)
  	 {
  		 for(int cc=0; cc&lt;SUBCELL_L; cc++)
  		   {
  			 index = get2dIndex(rr,cc,SUBCELL_L);
  			 p.x = this-&gt;bottom_left.x +  ((double)cc * sub_cell_l );
  			 p.y = this-&gt;bottom_left.y + ((double)rr * sub_cell_l );
  			 pInnerMap[index].Initialize(p, sub_cell_l, rr, cc,true);
  			 pInnerMap[index].index = index;
  		   }
  	 }
  }

  void CELL_Info::UpdateCostValue(const vector&lt;POINT2D&gt;&amp; ps)
  {
  	index = 0;
  	double cost = 0;
  	for(unsigned int i=0; i&lt;ps.size() ; i++)
  	{
  		cost += sqrt(distance2points(center, ps[i]));
  	}
  	if(localize_val==0)
  		localize_val = cost;
  	else
  		localize_val = (localize_val + cost) / 2.0;
  }

  void CELL_Info::UpdateSubCellCostValue(const vector&lt;POINT2D&gt;&amp; ps, const double&amp; cell_l, const double&amp; sub_cell_l)
  {
  	if(!pInnerMap)
  		InitSubCells(cell_l, sub_cell_l);

  	index = 0;
  	double cost = 0;
  	while(index &lt; nCells)
  	{
  		//if(pInnerMap[index].localize_val == 0)
  		{
  			cost = 0;
  			for(unsigned int i=0; i&lt;ps.size() ; i++)
  			{
  				//cost += abs(ps[i].x - pInnerMap[index].center.p.x) + abs(ps[i].y - pInnerMap[index].center.p.y);//sqrt(MathUtil::Distance(pInnerMap[index].center.p, ps[i]));
  				cost += sqrt(distance2points(pInnerMap[index].center, ps[i]));
  			}
  			if(pInnerMap[index].localize_val == 0)
  				pInnerMap[index].localize_val = cost;
  			else
  				pInnerMap[index].localize_val = (pInnerMap[index].localize_val+cost)/2.0;
  		}
  		 index++;
  	 }

  }

  void CELL_Info::Initialize(POINT2D bottom_l, double cell_l, int row, int col, bool bDefaultEmpty)
    {
		double half = cell_l / 2.0;
		center.x = bottom_l.x + half;
		center.y = bottom_l.y + half;
		bottom_left = bottom_l;
		top_right.x = bottom_left.x + cell_l;
		top_right.y = bottom_left.y + cell_l;
		bottom_right.x = top_right.x;
		bottom_right.y = bottom_left.y;
		top_left.x = bottom_left.x;
		top_left.y = top_right.y;
		nMovingPoints = !bDefaultEmpty;
		nStaticPoints = !bDefaultEmpty;
		r = row;
		c = col;
    }

bool CELL_Info::operator==(const CELL_Info&amp; cell)
  {
	if((this-&gt;r == cell.r &amp;&amp; this-&gt;c == cell.c) || this-&gt;index == cell.index)
	  return true;
	else
	  return false;
  }

bool CELL_Info::operator!=(const CELL_Info&amp; cell)
  {
	if((this-&gt;r != cell.r || this-&gt;c != cell.c) || this-&gt;index != cell.index)
	  return true;
	else
	  return false;
  }


    /*
     * Check for point to lie in the cell and cell this is an obstacle
     */
   inline bool CELL_Info::HitTest(const POINT2D&amp; p)
    {

  	 bool bHit = PointInRect(p);

  	     if(pInnerMap &amp;&amp; bHit)
  	       {
  	         for(int i=0; i&lt;nCells; i++)
  	           {
  	             if(pInnerMap[i].PointInRect(p) == true) return true;
  	           }
  	       }

  	     return bHit;
    }

   bool CELL_Info::TestWithRectangle(RECTANGLE&amp; rec)
   {
  	 if(!rec.PointInRect(bottom_left))
  		 return true;
  	 if(!rec.PointInRect(bottom_right))
  		 return true;
  	 if(!rec.PointInRect(top_right))
  		 return true;
  	 if(!rec.PointInRect(top_left))
  		 return true;

  	 return false;
   }

   bool CELL_Info::TestWithCircle(POINT2D _center, double width)
   {
  	 if(distance2points(center, _center) &lt;= width)
  		 return true;
  	 else
  		 return false;
   }
   void CELL_Info::SaveCell(ostream&amp; f)
   {
  //	 f&lt;&lt;&quot;#CELL_Info:&quot;&lt;&lt;r&lt;&lt;c&lt;&lt;index&lt;nPoints&lt;&lt;bottom_left.x&lt;&lt;bottom_left.y&lt;&lt;top_right.x&lt;&lt;top_right.y;
  //	 f&lt;&lt;endl;
  //	 if(pInnerMap)
  //	 {
  //		 f&lt;&lt;&quot;#InnerMap:&quot;;
  //		 for(int i=0; i&lt;nCells; i++)
  //		   {
  //			 pInnerMap[i].SaveCell(f);
  //		   }
  //	 }

   }

   void CELL_Info::LoadCell(ifstream&amp; f)
   {

   }

}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/HMIStateMachine.cpp" new_path="">
				<diff>@@ -1,109 +0,0 @@
-/*
- * BehaviorStateMachine.cpp
- *
- *  Created on: Jun 19, 2016
- *      Author: hatem
- */
-
-#include &quot;HMIStateMachine.h&quot;
-#include &quot;UtilityH.h&quot;
-
-using namespace UtilityHNS;
-
-namespace PlannerHNS {
-
-HMIPreCalculatedConditions* HMIStateMachine::m_pCalculatedValues = 0;
-PlanningParams HMIStateMachine::m_PlanningParams;
-
-HMIStateMachine::HMIStateMachine(HMIStateMachine* nextState)
-{
-	m_Behavior = G_WAITING_STATE;
-
-	decisionMakingTime		= 0.0;
-
-	if(nextState)
-		pNextStates.push_back(nextState);
-
-	pNextStates.push_back(this);
-
-	Init();
-}
-
-void HMIStateMachine::InsertNextState(HMIStateMachine* nextState)
-{
-	if(nextState)
-		pNextStates.push_back(nextState);
-}
-
-HMIStateMachine* HMIStateMachine::FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior)
-{
-	for(unsigned int i = 0 ; i &lt; pNextStates.size(); i++)
-	{
-		HMIStateMachine* pState = pNextStates.at(i);
-		if(pState &amp;&amp; behavior == pState-&gt;m_Behavior )
-		{
-			pState-&gt;ResetTimer();
-			return pState;
-		}
-	}
-
-	return 0;
-}
-
-void HMIStateMachine::Init()
-{
-	UtilityH::GetTickCount(m_StateTimer);
-}
-
-void HMIStateMachine::ResetTimer()
-{
-	UtilityH::GetTickCount(m_StateTimer);
-}
-
-HMIStateMachine::~HMIStateMachine()
-{
-}
-
-HMIStateMachine* GPlanningState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	HMIPreCalculatedConditions* pCParams = GetCalcParams();
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-HMIStateMachine* GWaitingState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-HMIStateMachine* GForwardState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-HMIStateMachine* GBranchingState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-HMIStateMachine* GEndState::GetNextState()
-{
-	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
-		return this; //return this behavior only , without reset
-
-	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
-}
-
-} /* namespace PlannerHNS */
</diff>
				<old_file>/*
 * BehaviorStateMachine.cpp
 *
 *  Created on: Jun 19, 2016
 *      Author: hatem
 */

#include &quot;HMIStateMachine.h&quot;
#include &quot;UtilityH.h&quot;

using namespace UtilityHNS;

namespace PlannerHNS {

HMIPreCalculatedConditions* HMIStateMachine::m_pCalculatedValues = 0;
PlanningParams HMIStateMachine::m_PlanningParams;

HMIStateMachine::HMIStateMachine(HMIStateMachine* nextState)
{
	m_Behavior = G_WAITING_STATE;

	decisionMakingTime		= 0.0;

	if(nextState)
		pNextStates.push_back(nextState);

	pNextStates.push_back(this);

	Init();
}

void HMIStateMachine::InsertNextState(HMIStateMachine* nextState)
{
	if(nextState)
		pNextStates.push_back(nextState);
}

HMIStateMachine* HMIStateMachine::FindBehaviorState(const GLOBAL_STATE_TYPE&amp; behavior)
{
	for(unsigned int i = 0 ; i &lt; pNextStates.size(); i++)
	{
		HMIStateMachine* pState = pNextStates.at(i);
		if(pState &amp;&amp; behavior == pState-&gt;m_Behavior )
		{
			pState-&gt;ResetTimer();
			return pState;
		}
	}

	return 0;
}

void HMIStateMachine::Init()
{
	UtilityH::GetTickCount(m_StateTimer);
}

void HMIStateMachine::ResetTimer()
{
	UtilityH::GetTickCount(m_StateTimer);
}

HMIStateMachine::~HMIStateMachine()
{
}

HMIStateMachine* GPlanningState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this; //return this behavior only , without reset

	HMIPreCalculatedConditions* pCParams = GetCalcParams();

	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

HMIStateMachine* GWaitingState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this; //return this behavior only , without reset

	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

HMIStateMachine* GForwardState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this; //return this behavior only , without reset

	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

HMIStateMachine* GBranchingState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this; //return this behavior only , without reset

	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

HMIStateMachine* GEndState::GetNextState()
{
	if(UtilityH::GetTimeDiffNow(m_StateTimer) &lt; decisionMakingTime)
		return this; //return this behavior only , without reset

	return FindBehaviorState(this-&gt;m_Behavior); // return and reset
}

} /* namespace PlannerHNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/LocalPlannerH.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/LocalPlannerH.cpp">
				<diff>@@ -19,6 +19,8 @@ namespace PlannerHNS
 
 LocalPlannerH::LocalPlannerH()
 {
+
+	m_PrevBrakingWayPoint = 0;
 	m_iSafeTrajectory = 0;
 	m_iCurrentTotalPathId = 0;
 	pLane = 0;
@@ -40,6 +42,7 @@ LocalPlannerH::LocalPlannerH()
 	m_SimulationSteeringDelayFactor = 0.1;
 	UtilityH::GetTickCount(m_SteerDelayTimer);
 	m_PredictionTime = 0;
+
 	InitBehaviorStates();
 }
 
@@ -61,6 +64,7 @@ LocalPlannerH::~LocalPlannerH()
 
 void LocalPlannerH::Init(const ControllerParams&amp; ctrlParams, const PlannerHNS::PlanningParams&amp; params,const CAR_BASIC_INFO&amp; carInfo)
  	{
+
  		m_CarInfo = carInfo;
  		m_ControlParams = ctrlParams;
  		m_CurrentVelocity =  m_CurrentVelocityD =0;
@@ -68,9 +72,17 @@ void LocalPlannerH::Init(const ControllerParams&amp; ctrlParams, const PlannerHNS::P
  		m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
  		m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
  		m_params = params;
+ 		m_InitialFollowingDistance = m_params.minFollowingDistance;
+
+ 		m_pidVelocity.Init(0.005, 0.005, 0.05);
+		m_pidVelocity.Setlimit(m_params.maxSpeed, 0);
+
+		m_pidStopping.Init(0.1, 0.05, 0.1);
+		m_pidStopping.Setlimit(m_params.horizonDistance, 0);
+
+		if(m_pCurrentBehaviorState)
+			m_pCurrentBehaviorState-&gt;SetBehaviorsParams(&amp;m_params);
 
- 		if(m_pCurrentBehaviorState)
- 			m_pCurrentBehaviorState-&gt;SetBehaviorsParams(&amp;m_params);
  	}
 
 void LocalPlannerH::InitBehaviorStates()
@@ -104,6 +116,12 @@ void LocalPlannerH::InitBehaviorStates()
 	m_pStopSignWaitState-&gt;decisionMakingTime = 5.0;
 	m_pStopSignWaitState-&gt;InsertNextState(m_pStopSignStopState);
 
+	m_pFollowState-&gt;InsertNextState(m_pStopState);
+	m_pFollowState-&gt;InsertNextState(m_pTrafficLightStopState);
+	m_pFollowState-&gt;InsertNextState(m_pStopSignStopState);
+
+	m_pAvoidObstacleState-&gt;decisionMakingTime = 0.1;
+
 	m_pCurrentBehaviorState = m_pInitState;
 }
 
@@ -118,6 +136,35 @@ void LocalPlannerH::InitPolygons()
 	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 0,0));
 }
 
+void LocalPlannerH::ReInitializePlanner(const WayPoint&amp; start_pose)
+{
+
+	m_pidVelocity.Init(0.005, 0.005, 0.05);
+	m_pidVelocity.Setlimit(m_params.maxSpeed, 0);
+
+	m_pidStopping.Init(0.1, 0.05, 0.1);
+	m_pidStopping.Setlimit(m_params.horizonDistance, 0);
+
+	m_PrevBrakingWayPoint = 0;
+	m_iSafeTrajectory = 0;
+	m_iCurrentTotalPathId = 0;
+	m_CurrentVelocity =  m_CurrentVelocityD =0;
+	m_CurrentSteering = m_CurrentSteeringD =0;
+	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
+	m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
+
+	m_pCurrentBehaviorState = m_pFollowState;
+	m_TotalPath.clear();
+	m_OriginalLocalPath.clear();
+	m_TotalOriginalPath.clear();
+	m_Path.clear();
+	m_RollOuts.clear();
+	m_pCurrentBehaviorState-&gt;m_Behavior = PlannerHNS::FORWARD_STATE;
+	m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
+	FirstLocalizeMe(start_pose);
+	LocalizeMe(0);
+}
+
  void LocalPlannerH::FirstLocalizeMe(const WayPoint&amp; initCarPos)
  {
 	pLane = initCarPos.pLane;
@@ -236,7 +283,7 @@ void LocalPlannerH::InitPolygons()
  }
 
  void LocalPlannerH::CalculateImportantParameterForDecisionMaking(const PlannerHNS::VehicleState&amp; car_state,
-		 const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
+		 const int&amp; goalID, const bool&amp; bEmergencyStop, const vector&lt;TrafficLight&gt;&amp; detectedLights,
 		 const TrajectoryCost&amp; bestTrajectory)
  {
  	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();
@@ -244,7 +291,7 @@ void LocalPlannerH::InitPolygons()
  	double critical_long_front_distance =  m_CarInfo.wheel_base/2.0 + m_CarInfo.length/2.0 + m_params.verticalSafetyDistance;
 	//double critical_long_back_distance =  m_CarInfo.length/2.0 + m_params.verticalSafetyDistance - m_CarInfo.wheel_base/2.0;
 
- 	pValues-&gt;minStoppingDistance = -pow(car_state.speed, 2)/m_CarInfo.max_deceleration;
+ 	pValues-&gt;minStoppingDistance = -pow(car_state.speed, 2)/(m_CarInfo.max_deceleration);
 
  	pValues-&gt;iCentralTrajectory		= m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber/2;
 
@@ -301,6 +348,7 @@ void LocalPlannerH::InitPolygons()
  	int stopSignID = -1;
  	int trafficLightID = -1;
  	double distanceToClosestStopLine = 0;
+ 	bool bGreenTrafficLight = true;
 
  	if(m_TotalPath.size()&gt;0)
  		distanceToClosestStopLine = PlanningHelpers::GetDistanceToClosestStopLineAndCheck(m_TotalPath.at(pValues-&gt;iCurrSafeLane), state, stopLineID, stopSignID, trafficLightID) - critical_long_front_distance;
@@ -308,13 +356,21 @@ void LocalPlannerH::InitPolygons()
  	if(distanceToClosestStopLine &gt; 0 &amp;&amp; distanceToClosestStopLine &lt; pValues-&gt;minStoppingDistance)
  	{
  		if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableTrafficLightBehavior)
+ 		{
  			pValues-&gt;currentTrafficLightID = trafficLightID;
+ 			//cout &lt;&lt; &quot;Detected Traffic Light: &quot; &lt;&lt; trafficLightID &lt;&lt; endl;
+ 			for(unsigned int i=0; i&lt; detectedLights.size(); i++)
+ 			{
+ 				if(detectedLights.at(i).id == trafficLightID)
+ 					bGreenTrafficLight = (detectedLights.at(i).lightState == GREEN_LIGHT);
+ 			}
+ 		}
 
  		if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableStopSignBehavior)
  			pValues-&gt;currentStopSignID = stopSignID;
 
 		pValues-&gt;stoppingDistances.push_back(distanceToClosestStopLine);
-		//std::cout &lt;&lt; &quot;From Local Planner =&gt; D: &quot; &lt;&lt; pValues-&gt;distanceToStop() &lt;&lt; &quot;, Prev SignID: &quot; &lt;&lt; pValues-&gt;prevStopSignID &lt;&lt; &quot;, Curr SignID: &quot; &lt;&lt; pValues-&gt;currentStopSignID &lt;&lt; endl;
+		//std::cout &lt;&lt; &quot;LP =&gt; D: &quot; &lt;&lt; pValues-&gt;distanceToStop() &lt;&lt; &quot;, PrevSignID: &quot; &lt;&lt; pValues-&gt;prevTrafficLightID &lt;&lt; &quot;, CurrSignID: &quot; &lt;&lt; pValues-&gt;currentTrafficLightID &lt;&lt; &quot;, Green: &quot; &lt;&lt; bGreenTrafficLight &lt;&lt; endl;
  	}
 
 
@@ -331,250 +387,18 @@ void LocalPlannerH::InitPolygons()
  	//cout &lt;&lt; &quot;Distances: &quot; &lt;&lt; pValues-&gt;stoppingDistances.size() &lt;&lt; &quot;, Distance To Stop : &quot; &lt;&lt; pValues-&gt;distanceToStop &lt;&lt; endl;
  }
 
-double LocalPlannerH::PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState)
-{
-	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;
-
-		//1- Calculate time prediction for each trajectory
-	if(path.size() == 0) return 0;
-
-//	SimulatedTrajectoryFollower predControl;
-//	ControllerParams params;
-//	params.Steering_Gain = PID_CONST(1.5, 0.0, 0.0);
-//	params.Velocity_Gain = PID_CONST(0.2, 0.01, 0.1);
-//	params.minPursuiteDistance = 3.0;
-//
-//	predControl.Init(params, m_CarInfo);
-//	//double totalDistance = 0;
-//	VehicleState CurrentState = vstatus;
-//	VehicleState CurrentSteeringD;
-//	bool bNewPath = true;
-//	WayPoint localState = currState;
-//	WayPoint prevState = currState;
-//	int iPrevIndex = 0;
-	double accum_time = 0;
-//	double pred_max_time = 10.0;
-//	double endDistance = pParams-&gt;microPlanDistance/2.0;
-//
-//	for(unsigned int i = 0 ; i &lt; path.size(); i++)
-//	{
-//		path.at(i).collisionCost = 0;
-//		path.at(i).timeCost = -1;
-//	}
-//
-//	int startIndex = PlanningHelpers::GetClosestPointIndex(path, state);
-//	double total_distance = 0;
-//	path.at(startIndex).timeCost = 0;
-//	for(unsigned int i=startIndex+1; i&lt;path.size(); i++)
-//	{
-//		total_distance += hypot(path.at(i).pos.x- path.at(i-1).pos.x,path.at(i).pos.y- path.at(i-1).pos.y);
-//		if(m_CurrentVelocity &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
-//			accum_time = total_distance/m_CurrentVelocity;
-//		path.at(i).timeCost = accum_time;
-//		if(total_distance &gt; endDistance)
-//			break;
-//	}
-
-//	while(totalDistance &lt; pParams-&gt;microPlanDistance/2.0 &amp;&amp; accum_time &lt; pred_max_time)
-//	{
-//		double dt = 0.05;
-//		PlannerHNS::BehaviorState currMessage;
-//		currMessage.state = FORWARD_STATE;
-//		currMessage.maxVelocity = PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*CurrentState.speed*3.6);
-//
-//		ControllerParams c_params = m_ControlParams;
-//		c_params.SteeringDelay = m_ControlParams.SteeringDelay / (1.0-UtilityH::GetMomentumScaleFactor(CurrentState.speed));
-//		predControl.Init(c_params, m_CarInfo);
-//		CurrentSteeringD = predControl.DoOneStep(dt, currMessage, path, localState, CurrentState, bNewPath);
-//
-//		if(bNewPath) // first call
-//		{
-//			if(predControl.m_iCalculatedIndex &gt; 0)
-//			{
-//				for(unsigned int j=0; j &lt; predControl.m_iCalculatedIndex; j++)
-//					path.at(j).timeCost = -1;
-//			}
-//		}
-//		else
-//		{
-//			if(predControl.m_iCalculatedIndex != iPrevIndex)
-//				path.at(iPrevIndex).timeCost = accum_time;
-//		}
-//
-//		accum_time+=dt;
-//		bNewPath = false;
-//
-//		//Update State
-//		CurrentState = CurrentSteeringD;
-//
-//		//Localize Me
-//		localState.pos.x	 +=  CurrentState.speed * dt * cos(localState.pos.a);
-//		localState.pos.y	 +=  CurrentState.speed * dt * sin(localState.pos.a);
-//		localState.pos.a	 +=  CurrentState.speed * dt * tan(CurrentState.steer)  / m_CarInfo.wheel_base;
-//
-//		totalDistance += distance2points(prevState.pos, localState.pos);
-//
-//		prevState = localState;
-//		iPrevIndex = predControl.m_iCalculatedIndex;
-//	}
-
-	return accum_time;
-}
-
-void LocalPlannerH::PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::WayPoint&amp; pos, const double&amp; predTime, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths)
-{
-	PlannerHNS::PlanningParams planningDefaultParams;
-	planningDefaultParams.rollOutNumber = 0;
-	planningDefaultParams.microPlanDistance = predTime*pos.v;
-
-	planningDefaultParams.pathDensity = 0.5;
-	//PlannerHNS::Lane* pMapLane  = MappingHelpers::GetClosestLaneFromMapDirectionBased(pos, map, 3.0);
-	std::vector&lt;PlannerHNS::Lane*&gt; pMapLanes = MappingHelpers::GetClosestMultipleLanesFromMap(pos, map, 1.5);
-
-	PlannerHNS::PlannerH planner;
-	std::vector&lt;int&gt; LanesIds;
-	std::vector&lt; std::vector&lt;PlannerHNS::WayPoint&gt; &gt;  rollOuts;
-	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedPath;
-
-	if(planningDefaultParams.microPlanDistance &gt; 0)
-	{
-		for(unsigned int i = 0; i &lt; pMapLanes.size(); i++)
-		{
-			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; loca_generatedPath;
-			planner.PredictPlanUsingDP(pMapLanes.at(i), pos, planningDefaultParams.microPlanDistance, loca_generatedPath);
-			if(loca_generatedPath.size() &gt; 0)
-				generatedPath.insert(generatedPath.begin(),loca_generatedPath.begin(), loca_generatedPath.end());
-		}
-	}
-
-//	planner.GenerateRunoffTrajectory(generatedPath, pos,
-//			planningDefaultParams.enableLaneChange,
-//			pos.v,
-//			planningDefaultParams.microPlanDistance,
-//			m_CarInfo.max_speed_forward,
-//			planningDefaultParams.minSpeed,
-//			planningDefaultParams.carTipMargin,
-//			planningDefaultParams.rollInMargin,
-//			planningDefaultParams.rollInSpeedFactor,
-//			planningDefaultParams.pathDensity,
-//			planningDefaultParams.rollOutDensity,
-//			planningDefaultParams.rollOutNumber,
-//			planningDefaultParams.smoothingDataWeight,
-//			planningDefaultParams.smoothingSmoothWeight,
-//			planningDefaultParams.smoothingToleranceError,
-//			planningDefaultParams.speedProfileFactor,
-//			planningDefaultParams.enableHeadingSmoothing,
-//			rollOuts);
-
-	if(generatedPath.size() &gt; 0)
-	{
-		//path = rollOuts.at(0);
-		paths = generatedPath;
-
-//		PlanningHelpers::GenerateRecommendedSpeed(path,
-//				m_CarInfo.max_speed_forward,
-//				planningDefaultParams.speedProfileFactor);
-//		PlanningHelpers::SmoothSpeedProfiles(path, 0.15,0.35, 0.1);
-	}
-
-	if(pMapLanes.size() ==0 || paths.size() == 0)
-	{
-		paths.clear();
-		generatedPath.clear();
-	}
-	else
-	{
-		//std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
-		//std::cout &lt;&lt; &quot;Predicted Trajectories for Distance : &quot; &lt;&lt;  planningDefaultParams.microPlanDistance &lt;&lt; std::endl;
-		for(unsigned int j=0; j &lt; paths.size(); j++)
-		{
-			if(paths.at(j).size()==0)
-				continue;
-
-			double timeDelay = 0;
-			double total_distance = 0;
-			paths.at(j).at(0).timeCost = 0;
-			paths.at(j).at(0).v = pos.v;
-			for(unsigned int i=1; i&lt;paths.at(j).size(); i++)
-			{
-				paths.at(j).at(i).v = pos.v;
-				paths.at(j).at(i).pos.a = atan2(paths.at(j).at(i).pos.y - paths.at(j).at(i-1).pos.y, paths.at(j).at(i).pos.x - paths.at(j).at(i-1).pos.x);
-				total_distance += distance2points(paths.at(j).at(i).pos, paths.at(j).at(i-1).pos);
-				if(pos.v &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
-					timeDelay = total_distance/pos.v;
-				paths.at(j).at(i).timeCost = timeDelay;
-			}
-
-			//std::cout &lt;&lt; &quot;ID : &quot; &lt;&lt;  j &lt;&lt; &quot;, timeDelay : &quot; &lt;&lt; timeDelay &lt;&lt; &quot;, Distance : &quot; &lt;&lt; total_distance &lt;&lt; std::endl;
-		}
-
-		//std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
-	}
-}
-
-bool LocalPlannerH::CalculateIntersectionVelocities(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; ego_path, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; predctedPath, const PlannerHNS::DetectedObject&amp; obj)
-{
-	bool bCollisionDetected = false;
-	for(unsigned int k = 0; k &lt; predctedPath.size(); k++)
-	{
-		for(unsigned int j = 0; j &lt; predctedPath.at(k).size(); j++)
-		{
-			bool bCollisionFound =false;
-			for(unsigned int i = 0; i &lt; ego_path.size(); i++)
-			{
-				if(ego_path.at(i).timeCost &gt; 0.0)
-				{
-					double collision_distance = hypot(ego_path.at(i).pos.x-predctedPath.at(k).at(j).pos.x, ego_path.at(i).pos.y-predctedPath.at(k).at(j).pos.y);
-					double contact_distance = hypot(state.pos.x - ego_path.at(i).pos.x,state.pos.y - ego_path.at(i).pos.y);
-					if(collision_distance &lt;= m_CarInfo.width  &amp;&amp; fabs(ego_path.at(i).timeCost - predctedPath.at(k).at(j).timeCost)&lt;4.0)
-					{
-						ego_path.at(i).collisionCost = 1;
-						double a = UtilityH::AngleBetweenTwoAnglesPositive(ego_path.at(i).pos.a, predctedPath.at(k).at(j).pos.a);
-						if(a &lt; M_PI_4/2.0)
-							ego_path.at(i).v = obj.center.v;
-						else
-							ego_path.at(i).v = 0;
-						predctedPath.at(k).at(j).collisionCost = 1;
-						bCollisionFound = true;
-						bCollisionDetected = true;
-						break;
-					}
-				}
-			}
-
-			if(bCollisionFound)
-				break;
-		}
-	}
-
-	return bCollisionDetected;
-}
-
-bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
-{
-	double predTime = PredictTimeCostForTrajectory(m_Path, vstatus, state);
-	m_PredictedPath.clear();
-	bool bObstacleDetected = false;
-	for(unsigned int i = 0; i &lt; obj_list.size(); i++)
-	{
-		//std::vector&lt;WayPoint&gt; predPath;
-		PredictObstacleTrajectory(map, obj_list.at(i).center, 10.0, m_PredictedPath);
-		bool bObstacle = CalculateIntersectionVelocities(m_Path, m_PredictedPath, obj_list.at(i));
-		if(bObstacle)
-			bObstacleDetected = true;
-	}
-
-	return bObstacleDetected;
-}
-
  void LocalPlannerH::UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance)
  {
 	 PlannerHNS::Lane* pMapLane = 0;
 	PlannerHNS::Lane* pPathLane = 0;
 	pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
 	if(!pPathLane)
+	{
+		cout &lt;&lt; &quot;Performance Alert: Can't Find Lane Information in Global Path, Searching the Map :( &quot; &lt;&lt; endl;
 		pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, search_distance);
 
+	}
+
 	if(pPathLane)
 		pLane = pPathLane;
 	else if(pMapLane)
@@ -586,7 +410,7 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
  void LocalPlannerH::SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState)
  {
 	SetSimulatedTargetOdometryReadings(vehicleState.speed, vehicleState.steer, vehicleState.shift);
-	UpdateState(vehicleState, true);
+	UpdateState(vehicleState, false);
 	LocalizeMe(dt);
  }
 
@@ -616,7 +440,7 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 
 	if(m_TotalPath.size()&gt;0)
 	{
-		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
+		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(m_Path, state);
 		int index_limit = 0;//m_Path.size() - 20;
 		if(index_limit&lt;=0)
 			index_limit =  m_Path.size()/2.0;
@@ -645,13 +469,11 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 					m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor,
 					m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableHeadingSmoothing,
 					preCalcPrams-&gt;iCurrSafeLane , preCalcPrams-&gt;iCurrSafeTrajectory,
-					m_RollOuts, m_PathSection, m_SampledPoints);
+					m_RollOuts, m_SampledPoints);
 
 			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = false;
 			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = false;
 
-			//cout &lt;&lt; &quot;Generating New Trajectories ! iPrev: &quot; &lt;&lt; preCalcPrams-&gt;iPrevSafeTrajectory &lt;&lt; &quot; , iSafe: &quot; &lt;&lt; preCalcPrams-&gt;iCurrSafeTrajectory &lt;&lt; endl;
-
 			if(m_pCurrentBehaviorState-&gt;m_Behavior == OBSTACLE_AVOIDANCE_STATE)
 				preCalcPrams-&gt;iPrevSafeTrajectory = preCalcPrams-&gt;iCurrSafeTrajectory;
 			else
@@ -660,16 +482,12 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 			preCalcPrams-&gt;iPrevSafeLane = preCalcPrams-&gt;iCurrSafeLane;
 
 			if(preCalcPrams-&gt;iPrevSafeLane &gt;= 0
-					&amp;&amp; preCalcPrams-&gt;iPrevSafeLane &lt; m_RollOuts.size()
+					&amp;&amp; preCalcPrams-&gt;iPrevSafeLane &lt; (int)m_RollOuts.size()
 					&amp;&amp; preCalcPrams-&gt;iPrevSafeTrajectory &gt;= 0
-					&amp;&amp; preCalcPrams-&gt;iPrevSafeTrajectory &lt; m_RollOuts.at(preCalcPrams-&gt;iPrevSafeLane).size())
+					&amp;&amp; preCalcPrams-&gt;iPrevSafeTrajectory &lt; (int)m_RollOuts.at(preCalcPrams-&gt;iPrevSafeLane).size())
 			{
-				//cout &lt;&lt; &quot;Select New Trajectories ! iPrev: &quot; &lt;&lt; preCalcPrams-&gt;iPrevSafeTrajectory &lt;&lt; &quot; , iSafe: &quot; &lt;&lt; preCalcPrams-&gt;iCurrSafeTrajectory &lt;&lt; endl;
-
 				m_Path = m_RollOuts.at(preCalcPrams-&gt;iPrevSafeLane).at(preCalcPrams-&gt;iPrevSafeTrajectory);
-//				PlanningHelpers::GenerateRecommendedSpeed(m_Path,
-//						m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed,
-//						m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
+				m_OriginalLocalPath = m_TotalPath.at(m_iCurrentTotalPathId);
 				bNewTrajectory = true;
 			}
 		}
@@ -686,10 +504,7 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 	PlannerHNS::BehaviorState currentBehavior;
 
 	currentBehavior.state = m_pCurrentBehaviorState-&gt;m_Behavior;
-	//if(currentBehavior.state == PlannerHNS::FOLLOW_STATE)
-		currentBehavior.followDistance = preCalcPrams-&gt;distanceToNext;
-	//else
-	//	currentBehavior.followDistance = 0;
+	currentBehavior.followDistance = preCalcPrams-&gt;distanceToNext;
 
 	if(preCalcPrams-&gt;bUpcomingRight)
 		currentBehavior.indicator = PlannerHNS::INDICATOR_RIGHT;
@@ -697,7 +512,7 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
 	else
 		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
-	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
+
 	currentBehavior.minVelocity		= 0;
 	currentBehavior.stopDistance 	= preCalcPrams-&gt;distanceToStop();
 	currentBehavior.followVelocity 	= preCalcPrams-&gt;velocityOfNext;
@@ -705,145 +520,237 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 	return currentBehavior;
  }
 
- void LocalPlannerH::UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt)
+// double LocalPlannerH::UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt)
+// {
+//	RelativeInfo info, total_info;
+//	PlanningHelpers::GetRelativeInfo(m_TotalPath.at(m_iCurrentTotalPathId), state, total_info);
+//	PlanningHelpers::GetRelativeInfo(m_Path, state, info);
+//	double average_braking_distance = -pow(CurrStatus.speed, 2)/(m_CarInfo.max_deceleration);
+//	double max_velocity	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_TotalPath.at(m_iCurrentTotalPathId), total_info, average_braking_distance);
+//
+//	unsigned int point_index = 0;
+//	double critical_long_front_distance = 2.0;
+//
+//	if(m_Path.size() &lt;= 5)
+//	{
+//		double target_velocity = 0;
+//		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+//			m_Path.at(i).v = target_velocity;
+//	}
+//	else if(beh.state == TRAFFIC_LIGHT_STOP_STATE || beh.state == STOP_SIGN_STOP_STATE || beh.state == STOP_SIGN_WAIT_STATE || beh.state == TRAFFIC_LIGHT_WAIT_STATE)
+//	{
+//		PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.stopDistance - critical_long_front_distance, point_index);
+//
+//		double inc = CurrStatus.speed;
+//		int iRange = point_index - info.iBack;
+//		if(iRange &gt; 0)
+//			inc = inc / (double)iRange;
+//		else
+//			inc = 0;
+//
+//		double target_velocity = CurrStatus.speed - inc;
+//		for(unsigned int i =  info.iBack; i &lt; point_index; i++)
+//		{
+//			 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
+//				 m_Path.at(i).v = target_velocity;
+//			 target_velocity -= inc;
+//		}
+//	}
+//	else if(beh.state == FOLLOW_STATE)
+//	{
+//		double targe_acceleration = -pow(CurrStatus.speed, 2)/(2.0*(beh.followDistance - critical_long_front_distance));
+//		if(targe_acceleration &lt;= 0 &amp;&amp;  targe_acceleration &gt; m_CarInfo.max_deceleration/2.0)
+//		{
+//			double target_velocity = (targe_acceleration * dt) + CurrStatus.speed;
+//			for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+//			{
+//				if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
+//					m_Path.at(i).v = target_velocity;
+//				else
+//					m_Path.at(i).v = target_velocity*AVOIDANCE_SPEED_FACTOR;
+//			}
+//
+//			//cout &lt;&lt; &quot;Accelerate -&gt; Target V: &quot; &lt;&lt; target_velocity &lt;&lt; &quot;, Brake D: &quot; &lt;&lt;  average_braking_distance &lt;&lt; &quot;, Acceleration: &quot; &lt;&lt; targe_acceleration &lt;&lt; endl;
+//		}
+//		else
+//		{
+//			WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.followDistance - critical_long_front_distance, point_index);
+//			double inc = CurrStatus.speed;
+//			int iRange = point_index - info.iBack;
+//
+//			if(iRange &gt; 0)
+//				inc = inc / (double)iRange;
+//			else
+//				inc = 0;
+//
+//			double target_velocity = CurrStatus.speed - inc;
+//			for(unsigned int i =  info.iBack; i &lt; point_index; i++)
+//			{
+//				 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
+//				 {
+//					 target_velocity = target_velocity &lt; 0 ? 0 : target_velocity;
+//					 if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
+//						 m_Path.at(i).v = target_velocity;
+//					 else
+//						 m_Path.at(i).v = target_velocity*AVOIDANCE_SPEED_FACTOR;
+//				 }
+//
+//				 target_velocity -= inc;
+//			}
+//
+//			//cout &lt;&lt; &quot;Decelerate -&gt; Target V: &quot; &lt;&lt; target_velocity &lt;&lt; &quot;, Brake D: &quot; &lt;&lt;  average_braking_distance &lt;&lt; &quot;, Start I&quot; &lt;&lt; info.iBack &lt;&lt; endl;
+//		}
+//
+//	}
+//	else if(beh.state == FORWARD_STATE || beh.state == OBSTACLE_AVOIDANCE_STATE )
+//	{
+//		double target_velocity = max_velocity;
+//
+//		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+//		{
+//			if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
+//				m_Path.at(i).v = target_velocity;
+//			else
+//				m_Path.at(i).v = target_velocity*AVOIDANCE_SPEED_FACTOR;
+//		}
+//	}
+//	else
+//	{
+//		double target_velocity = 0;
+//		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+//			m_Path.at(i).v = target_velocity;
+//	}
+//
+//	return max_velocity;
+// }
+
+ double LocalPlannerH::UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt)
  {
+	if(m_TotalOriginalPath.size() ==0 ) return 0;
 
-	 RelativeInfo info;
+	RelativeInfo info, total_info;
+	PlanningHelpers::GetRelativeInfo(m_TotalOriginalPath.at(m_iCurrentTotalPathId), state, total_info);
 	PlanningHelpers::GetRelativeInfo(m_Path, state, info);
+	double average_braking_distance = -pow(CurrStatus.speed, 2)/(m_CarInfo.max_deceleration) + m_params.additionalBrakingDistance;
+	double max_velocity	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_TotalOriginalPath.at(m_iCurrentTotalPathId), total_info, m_PrevBrakingWayPoint, average_braking_distance);
+
 	unsigned int point_index = 0;
 	double critical_long_front_distance = 2.0;
-	for(unsigned int i = 0; i &lt; m_Path.size(); i++)
-		m_Path.at(i).v = m_CarInfo.min_speed_forward;
 
-	if(beh.state == TRAFFIC_LIGHT_STOP_STATE || beh.state == STOP_SIGN_STOP_STATE)
+	if(m_Path.size() &lt;= 5)
+	{
+		double target_velocity = 0;
+		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+			m_Path.at(i).v = target_velocity;
+	}
+	else if(beh.state == TRAFFIC_LIGHT_STOP_STATE || beh.state == STOP_SIGN_STOP_STATE || beh.state == STOP_SIGN_WAIT_STATE || beh.state == TRAFFIC_LIGHT_WAIT_STATE)
 	{
 		PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.stopDistance - critical_long_front_distance, point_index);
 
-		double inc = CurrStatus.speed;
-		int iRange = point_index - info.iBack;
-		//cout &lt;&lt; &quot;Range : &quot; &lt;&lt; iRange;
-		if(iRange &gt; 0)
-			inc = inc / (double)iRange;
-		else
-			inc = 0;
+		double e = -beh.stopDistance;
+		double desiredVelocity = m_pidStopping.getPID(e);
 
-	//	cout &lt;&lt; &quot;Target Stopping Velocity: &quot;  &lt;&lt;  endl ;
-		double target_velocity = CurrStatus.speed - inc;
 		for(unsigned int i =  info.iBack; i &lt; point_index; i++)
 		{
-			if(target_velocity &gt; m_CarInfo.max_speed_forward)
-				target_velocity = m_CarInfo.max_speed_forward;
-
-			if(target_velocity &lt; m_CarInfo.min_speed_forward)
-				target_velocity = m_CarInfo.min_speed_forward;
-
 			 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
-			 {
-			//	 cout &lt;&lt; target_velocity &lt;&lt; &quot;, &quot; ;
-				 m_Path.at(i).v = target_velocity;
-			 }
-
-			 target_velocity -= inc;
+				 m_Path.at(i).v = desiredVelocity;
 		}
 
-		//cout &lt;&lt; endl &lt;&lt; endl;
+		return desiredVelocity;
 	}
 	else if(beh.state == FOLLOW_STATE)
 	{
 		double targe_acceleration = -pow(CurrStatus.speed, 2)/(2.0*(beh.followDistance - critical_long_front_distance));
 		if(targe_acceleration &lt;= 0 &amp;&amp;  targe_acceleration &gt; m_CarInfo.max_deceleration/2.0)
 		{
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-
-			double follow_distance = fabs(CurrStatus.speed) * (m_ControlParams.SteeringDelay+1);
-			if(follow_distance &lt; m_ControlParams.minPursuiteDistance)
-				follow_distance = m_ControlParams.minPursuiteDistance;
+			double target_velocity = (targe_acceleration * dt) + CurrStatus.speed;
 
-			RelativeInfo info;
-			PlanningHelpers::GetRelativeInfo(m_Path, state, info);
-			unsigned int point_index = 0;
-			WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, follow_distance, point_index);
-			double target_velocity = pursuite_point.v;
-			if(target_velocity &gt; m_CarInfo.max_speed_forward)
-				target_velocity = m_CarInfo.max_speed_forward;
+			double e = target_velocity - CurrStatus.speed;
+			double desiredVelocity = m_pidVelocity.getPID(e);
 
-
-			for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+			for(unsigned int i = info.iBack; i &lt; m_Path.size(); i++)
 			{
-				if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
-					m_Path.at(i).v = target_velocity;
-				else
-					m_Path.at(i).v = target_velocity*0.75;
+				if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
+					m_Path.at(i).v = desiredVelocity;
 			}
+
+			return desiredVelocity;
+			//cout &lt;&lt; &quot;Accelerate -&gt; Target V: &quot; &lt;&lt; target_velocity &lt;&lt; &quot;, Brake D: &quot; &lt;&lt;  average_braking_distance &lt;&lt; &quot;, Acceleration: &quot; &lt;&lt; targe_acceleration &lt;&lt; endl;
 		}
 		else
 		{
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-
 			WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.followDistance - critical_long_front_distance, point_index);
 
-			double inc = CurrStatus.speed;
-			int iRange = point_index - info.iBack;
-			//cout &lt;&lt; &quot;Range : &quot; &lt;&lt; iRange;
-			if(iRange &gt; 0)
-				inc = inc / (double)iRange;
-			else
-				inc = 0;
+			double e = beh.followDistance - m_params.minFollowingDistance;
+			double desiredVelocity = m_pidStopping.getPID(e);
 
-			//cout &lt;&lt; &quot;Target Follow Velocity: &quot; &lt;&lt;  endl ;
-			double target_velocity = CurrStatus.speed - inc;
 			for(unsigned int i =  info.iBack; i &lt; point_index; i++)
 			{
-				if(target_velocity &gt; m_CarInfo.max_speed_forward)
-					target_velocity = m_CarInfo.max_speed_forward;
-
-				if(target_velocity &lt; m_CarInfo.min_speed_forward)
-					target_velocity = m_CarInfo.min_speed_forward;
-
-				 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
-				 {
-				//	 cout &lt;&lt; target_velocity &lt;&lt; &quot;, &quot; ;
-					 if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
-						 m_Path.at(i).v = target_velocity;
-					 else
-						 m_Path.at(i).v = target_velocity*0.75;
-				 }
-
-				 target_velocity -= inc;
+				if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
+					m_Path.at(i).v = desiredVelocity;
 			}
+
+			return desiredVelocity;
+			//cout &lt;&lt; &quot;Decelerate -&gt; Target V: &quot; &lt;&lt; target_velocity &lt;&lt; &quot;, Brake D: &quot; &lt;&lt;  average_braking_distance &lt;&lt; &quot;, Start I&quot; &lt;&lt; info.iBack &lt;&lt; endl;
 		}
+
 	}
 	else if(beh.state == FORWARD_STATE || beh.state == OBSTACLE_AVOIDANCE_STATE )
 	{
-		PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
+		double target_velocity = max_velocity;
+		if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory != m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
+			target_velocity*=AVOIDANCE_SPEED_FACTOR;
 
-		double follow_distance = fabs(CurrStatus.speed) * (m_ControlParams.SteeringDelay+1);
-		if(follow_distance &lt; m_ControlParams.minPursuiteDistance)
-			follow_distance = m_ControlParams.minPursuiteDistance;
+		double e = target_velocity - CurrStatus.speed;
+		double desiredVelocity = m_pidVelocity.getPID(e);
 
-		RelativeInfo info;
-		PlanningHelpers::GetRelativeInfo(m_Path, state, info);
-		unsigned int point_index = 0;
-		WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, follow_distance, point_index);
-		double target_velocity = pursuite_point.v;
-		if(target_velocity &gt; m_CarInfo.max_speed_forward)
-			target_velocity = m_CarInfo.max_speed_forward;
-
-		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+		for(unsigned int i = info.iBack; i &lt; m_Path.size(); i++)
 		{
-			if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
-				m_Path.at(i).v = target_velocity;
-			else
-				m_Path.at(i).v = target_velocity*0.75;
-
+			m_Path.at(i).v = desiredVelocity;
 		}
+
+		return desiredVelocity;
 	}
 	else
 	{
 		double target_velocity = 0;
-		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
+		for(unsigned int i = info.iBack; i &lt; m_Path.size(); i++)
 			m_Path.at(i).v = target_velocity;
+
+		return target_velocity;
 	}
+
+	return max_velocity;
+ }
+
+ void LocalPlannerH::ExtractHorizonAndCalculateRecommendedSpeed()
+ {
+	 if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath &amp;&amp; m_TotalOriginalPath.size() &gt; 0)
+		{
+		 	m_PrevBrakingWayPoint = 0;
+		 	PlanningHelpers::FixPathDensity(m_TotalOriginalPath.at(m_iCurrentTotalPathId), m_pCurrentBehaviorState-&gt;m_pParams-&gt;pathDensity);
+		 	PlanningHelpers::SmoothPath(m_TotalOriginalPath.at(m_iCurrentTotalPathId), 0.49, 0.25, 0.05);
+		 	
+			PlanningHelpers::GenerateRecommendedSpeed(m_TotalOriginalPath.at(m_iCurrentTotalPathId), m_CarInfo.max_speed_forward, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
+			m_TotalOriginalPath.at(m_iCurrentTotalPathId).at(m_TotalOriginalPath.at(m_iCurrentTotalPathId).size()-1).v = 0;
+
+		}
+
+		 m_TotalPath.clear();
+
+		 for(unsigned int i = 0; i &lt; m_TotalOriginalPath.size(); i++)
+		{
+			vector&lt;WayPoint&gt; centerTrajectorySmoothed;
+			PlanningHelpers::ExtractPartFromPointToDistanceFast(m_TotalOriginalPath.at(i), state,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;horizonDistance ,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;pathDensity ,
+					centerTrajectorySmoothed,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingDataWeight,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingSmoothWeight,
+					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingToleranceError);
+
+			m_TotalPath.push_back(centerTrajectorySmoothed);
+		}
  }
 
  PlannerHNS::BehaviorState LocalPlannerH::DoOneStep(
@@ -852,73 +759,51 @@ bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const P
 		const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
 		const int&amp; goalID, PlannerHNS::RoadNetwork&amp; map	,
 		const bool&amp; bEmergencyStop,
-		const bool&amp; bGreenTrafficLight,
+		const std::vector&lt;TrafficLight&gt;&amp; trafficLight,
 		const bool&amp; bLive)
 {
 
+	 m_params.minFollowingDistance = m_InitialFollowingDistance + vehicleState.speed*1.5;
+
 	 if(!bLive)
 		 SimulateOdoPosition(dt, vehicleState);
 
 	UpdateCurrentLane(map, 3.0);
 
-	timespec costTimer;
-	UtilityH::GetTickCount(costTimer);
+
+	ExtractHorizonAndCalculateRecommendedSpeed();
+
+
+	m_PredictedTrajectoryObstacles = obj_list;
+	//m_TrajectoryPredictionForMovingObstacles.DoOneStep(map, vehicleState, state, m_TotalPath.at(m_iCurrentTotalPathId), m_PredictedTrajectoryObstacles, m_params.minFollowingDistance);
+
+	timespec t;
+	UtilityH::GetTickCount(t);
 	TrajectoryCost tc = m_TrajectoryCostsCalculatotor.DoOneStep(m_RollOuts, m_TotalPath, state,
 			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory, m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeLane, *m_pCurrentBehaviorState-&gt;m_pParams,
-			m_CarInfo,vehicleState, obj_list);
-	m_CostCalculationTime = UtilityH::GetTimeDiffNow(costTimer);
+			m_CarInfo,vehicleState, m_PredictedTrajectoryObstacles);
+	m_CostCalculationTime = UtilityH::GetTimeDiffNow(t);
+
+
+
+
+	UtilityH::GetTickCount(t);
+	CalculateImportantParameterForDecisionMaking(vehicleState, goalID, bEmergencyStop, trafficLight, tc);
 
 
-	timespec behTimer;
-	UtilityH::GetTickCount(behTimer);
-	CalculateImportantParameterForDecisionMaking(vehicleState, goalID, bEmergencyStop, bGreenTrafficLight, tc);
 
 	PlannerHNS::BehaviorState beh = GenerateBehaviorState(vehicleState);
-	m_BehaviorGenTime = UtilityH::GetTimeDiffNow(behTimer);
+	m_BehaviorGenTime = UtilityH::GetTimeDiffNow(t);
+
 
-	timespec t;
 	UtilityH::GetTickCount(t);
 	beh.bNewPlan = SelectSafeTrajectoryAndSpeedProfile(vehicleState);
-	m_RollOutsGenerationTime = UtilityH::GetTimeDiffNow(t);
 
-	if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enabTrajectoryVelocities)
-	{
-		UpdateVelocityDirectlyToTrajectory(beh, vehicleState, dt);
-	}
-	else if(beh.bNewPlan == true)
-	{
-		if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-		else
-			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed*0.25, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
-	}
 
-/**
- * Usage of predictive planning
- */
-//	timespec predictionTime;
-//	UtilityH::GetTickCount(predictionTime);
-//	if(UtilityH::GetTimeDiffNow(m_PredictionTimer) &gt; 0.5 || beh.bNewPlan)
-//	{
-//		CalculateObstacleCosts(map, vehicleState, obj_list);
-//		m_PredictionTime = UtilityH::GetTimeDiffNow(predictionTime);
-//	}
-//	bool bCollision = false;
-//	int wp_id = -1;
-//	for(unsigned int i=0; i &lt; m_Path.size(); i++)
-//	{
-//		if(m_Path.at(i).collisionCost &gt; 0)
-//		{
-//			bCollision = true;
-//			wp_id = i;
-//			beh.maxVelocity = m_Path.at(i).v;//PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
-//			break;
-//		}
-//	}
-//	std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
-//	std::cout &lt;&lt; &quot;Max Velocity = &quot; &lt;&lt; beh.maxVelocity &lt;&lt; &quot;, New Plan : &quot; &lt;&lt; beh.bNewPlan &lt;&lt;  std::endl;
-//	std::cout &lt;&lt; &quot;Collision = &quot; &lt;&lt; bCollision &lt;&lt; &quot;, @ WayPoint : &quot; &lt;&lt; wp_id &lt;&lt;  std::endl;
-//	std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
+
+	m_RollOutsGenerationTime = UtilityH::GetTimeDiffNow(t);
+
+	beh.maxVelocity = UpdateVelocityDirectlyToTrajectory(beh, vehicleState, dt);
 
 	return beh;
  }
</diff>
				<old_file>/*
 * CarState.cpp
 *
 *  Created on: Jun 20, 2016
 *      Author: hatem
 */

#include &quot;LocalPlannerH.h&quot;
#include &quot;UtilityH.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &quot;MappingHelpers.h&quot;
#include &quot;MatrixOperations.h&quot;
#include &quot;PlannerH.h&quot;

using namespace UtilityHNS;

namespace PlannerHNS
{

LocalPlannerH::LocalPlannerH()
{
	m_iSafeTrajectory = 0;
	m_iCurrentTotalPathId = 0;
	pLane = 0;
	m_CurrentVelocity =  m_CurrentVelocityD =0;
	m_CurrentSteering = m_CurrentSteeringD =0;
	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
	m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
	m_pCurrentBehaviorState = 0;
	m_pGoToGoalState = 0;
	m_pStopState= 0;
	m_pWaitState= 0;
	m_pMissionCompleteState= 0;
	m_pAvoidObstacleState = 0;
	m_pTrafficLightStopState = 0;
	m_pTrafficLightWaitState = 0;
	m_pStopSignStopState = 0;
	m_pStopSignWaitState = 0;
	m_pFollowState = 0;
	m_SimulationSteeringDelayFactor = 0.1;
	UtilityH::GetTickCount(m_SteerDelayTimer);
	m_PredictionTime = 0;
	InitBehaviorStates();
}

LocalPlannerH::~LocalPlannerH()
{
	delete m_pStopState;
	delete m_pMissionCompleteState ;
	delete m_pGoalState			;
	delete m_pGoToGoalState 		;
	delete m_pWaitState 			;
	delete m_pInitState 			;
	delete m_pFollowState			;
	delete m_pAvoidObstacleState	;
	delete m_pTrafficLightStopState;
	delete m_pTrafficLightWaitState;
	delete m_pStopSignWaitState	;
	delete m_pStopSignStopState;
}

void LocalPlannerH::Init(const ControllerParams&amp; ctrlParams, const PlannerHNS::PlanningParams&amp; params,const CAR_BASIC_INFO&amp; carInfo)
 	{
 		m_CarInfo = carInfo;
 		m_ControlParams = ctrlParams;
 		m_CurrentVelocity =  m_CurrentVelocityD =0;
 		m_CurrentSteering = m_CurrentSteeringD =0;
 		m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
 		m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
 		m_params = params;

 		if(m_pCurrentBehaviorState)
 			m_pCurrentBehaviorState-&gt;SetBehaviorsParams(&amp;m_params);
 	}

void LocalPlannerH::InitBehaviorStates()
{

	m_pStopState 				= new StopState(&amp;m_params, 0, 0);
	m_pMissionCompleteState 	= new MissionAccomplishedState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), 0);
	m_pGoalState				= new GoalState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pMissionCompleteState);
	m_pGoToGoalState 			= new ForwardState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoalState);
	m_pWaitState 				= new WaitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pInitState 				= new InitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pFollowState				= new FollowState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pAvoidObstacleState		= new SwerveState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pTrafficLightStopState	= new TrafficLightStopState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pTrafficLightWaitState	= new TrafficLightWaitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pStopSignWaitState		= new StopSignWaitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pStopSignStopState		= new StopSignStopState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pStopSignWaitState);

	m_pGoToGoalState-&gt;InsertNextState(m_pStopState);
	m_pGoToGoalState-&gt;InsertNextState(m_pWaitState);
	m_pGoToGoalState-&gt;InsertNextState(m_pFollowState);
	m_pGoToGoalState-&gt;InsertNextState(m_pAvoidObstacleState);
	m_pGoToGoalState-&gt;InsertNextState(m_pTrafficLightStopState);
	m_pGoToGoalState-&gt;InsertNextState(m_pStopSignStopState);

	m_pStopState-&gt;InsertNextState(m_pGoToGoalState);

	m_pTrafficLightStopState-&gt;InsertNextState(m_pTrafficLightWaitState);
	m_pTrafficLightWaitState-&gt;InsertNextState(m_pTrafficLightStopState);

	m_pStopSignWaitState-&gt;decisionMakingTime = 5.0;
	m_pStopSignWaitState-&gt;InsertNextState(m_pStopSignStopState);

	m_pCurrentBehaviorState = m_pInitState;
}

void LocalPlannerH::InitPolygons()
{
	double l2 = m_CarInfo.length/2.0;
	double w2 = m_CarInfo.width/2.0;

	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 0,0));
	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 0,0));
	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 0,0));
	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 0,0));
}

 void LocalPlannerH::FirstLocalizeMe(const WayPoint&amp; initCarPos)
 {
	pLane = initCarPos.pLane;
	state = initCarPos;
	m_OdometryState.pos.a = initCarPos.pos.a;
	m_OdometryState.pos.x = initCarPos.pos.x + (m_CarInfo.wheel_base/2.0 * cos(initCarPos.pos.a));
	m_OdometryState.pos.y = initCarPos.pos.y + (m_CarInfo.wheel_base/2.0 * sin(initCarPos.pos.a));
 }

 void LocalPlannerH::LocalizeMe(const double&amp; dt)
{
	//calculate the new x, y ,
	 WayPoint currPose = state;

	if(m_CurrentShift == SHIFT_POS_DD)
	{
		m_OdometryState.pos.x	 +=  m_CurrentVelocity * dt * cos(currPose.pos.a);
		m_OdometryState.pos.y	 +=  m_CurrentVelocity * dt * sin(currPose.pos.a);
		m_OdometryState.pos.a	 +=  m_CurrentVelocity * dt * tan(m_CurrentSteering)  / m_CarInfo.wheel_base;

	}
	else if(m_CurrentShift == SHIFT_POS_RR )
	{
		m_OdometryState.pos.x	 +=  -m_CurrentVelocity * dt * cos(currPose.pos.a);
		m_OdometryState.pos.y	 +=  -m_CurrentVelocity * dt * sin(currPose.pos.a);
		m_OdometryState.pos.a	 +=  -m_CurrentVelocity * dt * tan(m_CurrentSteering);
	}

	m_OdometryState.pos.a = atan2(sin(m_OdometryState.pos.a), cos(m_OdometryState.pos.a));
	m_OdometryState.pos.a = UtilityH::FixNegativeAngle(m_OdometryState.pos.a);

	state.pos.a = m_OdometryState.pos.a;
	state.pos.x = m_OdometryState.pos.x	 - (m_CurrentVelocity*dt* (m_CarInfo.wheel_base) * cos (m_OdometryState.pos.a));
	state.pos.y = m_OdometryState.pos.y	 - (m_CurrentVelocity*dt* (m_CarInfo.wheel_base/2.0) * sin (m_OdometryState.pos.a));
}

 void LocalPlannerH::UpdateState(const PlannerHNS::VehicleState&amp; state, const bool&amp; bUseDelay)
  {
	 if(!bUseDelay)
	 {
		 m_CurrentSteering 	= m_CurrentSteeringD;
		// std::cout &lt;&lt; &quot; No Delay &quot; &lt;&lt; std::endl;
	 }
	 else
	 {
		 double currSteerDeg = RAD2DEG * m_CurrentSteering;
		 double desiredSteerDeg = RAD2DEG * m_CurrentSteeringD;

		 double mFact = UtilityH::GetMomentumScaleFactor(state.speed);
		 double diff = desiredSteerDeg - currSteerDeg;
		 double diffSign = UtilityH::GetSign(diff);
		 double inc = 1.0*diffSign;
		 if(fabs(diff) &lt; 1.0 )
			 inc = diff;

//		 std::cout &lt;&lt; &quot;Delay: &quot; &lt;&lt; m_SimulationSteeringDelayFactor
//				 &lt;&lt; &quot;, Fact: &quot; &lt;&lt; mFact
//				 &lt;&lt; &quot;, Diff: &quot; &lt;&lt; diff
//				 &lt;&lt; &quot;, inc: &quot; &lt;&lt; inc &lt;&lt; std::endl;
		 if(UtilityH::GetTimeDiffNow(m_SteerDelayTimer) &gt; m_SimulationSteeringDelayFactor*mFact)
		 {
			 UtilityH::GetTickCount(m_SteerDelayTimer);
			 currSteerDeg += inc;
		 }

		 m_CurrentSteering = DEG2RAD * currSteerDeg;
	 }

	 m_CurrentShift 	= m_CurrentShiftD;
	 m_CurrentVelocity = m_CurrentVelocityD;
  }

 void LocalPlannerH::AddAndTransformContourPoints(const PlannerHNS::DetectedObject&amp; obj, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; contourPoints)
 {
	 contourPoints.clear();
	 WayPoint  p, p_center = obj.center;
	 p_center.pos.a += M_PI_2;
	 for(unsigned int i=0; i&lt; obj.contour.size(); i++)
	 {
		 p.pos = obj.contour.at(i);
		 //TransformPoint(p_center, p.pos);
		 contourPoints.push_back(p);
	 }

	 contourPoints.push_back(obj.center);
 }

 void LocalPlannerH::TransformPoint(const PlannerHNS::WayPoint&amp; refPose, PlannerHNS::GPSPoint&amp; p)
 {
 	PlannerHNS::Mat3 rotationMat(refPose.pos.a);
 	PlannerHNS::Mat3 translationMat(refPose.pos.x, refPose.pos.y);
	p = rotationMat*p;
	p = translationMat*p;
 }

 bool LocalPlannerH::GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; trafficLights, PlannerHNS::TrafficLight&amp; trafficL)
 {
	 for(unsigned int i = 0; i &lt; trafficLights.size(); i++)
	 {
		 double d = hypot(trafficLights.at(i).pos.y - state.pos.y, trafficLights.at(i).pos.x - state.pos.x);
		 if(d &lt;= trafficLights.at(i).stoppingDistance)
		 {
			 //double a = UtilityH::FixNegativeAngle(atan2(trafficLights.at(i).pos.y - state.pos.y, trafficLights.at(i).pos.x - state.pos.x));
			 double a_diff = UtilityH::AngleBetweenTwoAnglesPositive(UtilityH::FixNegativeAngle(trafficLights.at(i).pos.a) , UtilityH::FixNegativeAngle(state.pos.a));

			 if(a_diff &lt; M_PI_2 &amp;&amp; trafficLights.at(i).id != prevTrafficLightId)
			 {
				 //std::cout &lt;&lt; &quot;Detected Light, ID = &quot; &lt;&lt; trafficLights.at(i).id &lt;&lt; &quot;, Distance = &quot; &lt;&lt; d &lt;&lt; &quot;, Angle = &quot; &lt;&lt; trafficLights.at(i).pos.a*RAD2DEG &lt;&lt; &quot;, Car Heading = &quot; &lt;&lt; state.pos.a*RAD2DEG &lt;&lt; &quot;, Diff = &quot; &lt;&lt; a_diff*RAD2DEG &lt;&lt; std::endl;
				 trafficL = trafficLights.at(i);
				 return true;
			 }
		 }
	 }

	 return false;
 }

 void LocalPlannerH::CalculateImportantParameterForDecisionMaking(const PlannerHNS::VehicleState&amp; car_state,
		 const int&amp; goalID, const bool&amp; bEmergencyStop, const bool&amp; bGreenTrafficLight,
		 const TrajectoryCost&amp; bestTrajectory)
 {
 	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();

 	double critical_long_front_distance =  m_CarInfo.wheel_base/2.0 + m_CarInfo.length/2.0 + m_params.verticalSafetyDistance;
	//double critical_long_back_distance =  m_CarInfo.length/2.0 + m_params.verticalSafetyDistance - m_CarInfo.wheel_base/2.0;

 	pValues-&gt;minStoppingDistance = -pow(car_state.speed, 2)/m_CarInfo.max_deceleration;

 	pValues-&gt;iCentralTrajectory		= m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber/2;

 	if(pValues-&gt;iCurrSafeTrajectory &lt; 0)
 			pValues-&gt;iCurrSafeTrajectory = pValues-&gt;iCentralTrajectory;

	if(pValues-&gt;iPrevSafeTrajectory &lt; 0)
		pValues-&gt;iPrevSafeTrajectory = pValues-&gt;iCentralTrajectory;

 	pValues-&gt;stoppingDistances.clear();
 	pValues-&gt;currentVelocity 		= car_state.speed;
 	pValues-&gt;bTrafficIsRed 			= false;
 	pValues-&gt;currentTrafficLightID 	= -1;
// 	pValues-&gt;currentStopSignID		= -1;
 	pValues-&gt;bRePlan 				= false;
 	pValues-&gt;bFullyBlock 			= false;


 	pValues-&gt;distanceToNext = bestTrajectory.closest_obj_distance;
 	pValues-&gt;velocityOfNext = bestTrajectory.closest_obj_velocity;

 	if(pValues-&gt;distanceToNext &gt; m_params.minDistanceToAvoid)
 		pValues-&gt;iCurrSafeTrajectory = pValues-&gt;iCentralTrajectory;
 	else if(bestTrajectory.index&gt;=0)
 		pValues-&gt;iCurrSafeTrajectory = bestTrajectory.index;

	pValues-&gt;bFullyBlock = bestTrajectory.bBlocked;

 	if(bestTrajectory.lane_index &gt;=0)
 		pValues-&gt;iCurrSafeLane = bestTrajectory.lane_index;
 	else
 	{
 		PlannerHNS::RelativeInfo info;
 		PlannerHNS::PlanningHelpers::GetRelativeInfoRange(m_TotalPath, state, m_params.rollOutDensity*m_params.rollOutNumber/2.0 + 0.1, info);
 		pValues-&gt;iCurrSafeLane = info.iGlobalPath;
 	}


	if(NoWayTest(pValues-&gt;minStoppingDistance, pValues-&gt;iCurrSafeLane))
		pValues-&gt;currentGoalID = -1;
	else
		pValues-&gt;currentGoalID = goalID;

 	m_iSafeTrajectory = pValues-&gt;iCurrSafeTrajectory;
 	m_iCurrentTotalPathId = pValues-&gt;iCurrSafeLane;


// 	if(bestTrajectory.index == -1 &amp;&amp; pValues-&gt;distanceToNext &lt; m_pCurrentBehaviorState-&gt;m_pParams-&gt;minFollowingDistance)
// 		pValues-&gt;bFullyBlock = true;



 	int stopLineID = -1;
 	int stopSignID = -1;
 	int trafficLightID = -1;
 	double distanceToClosestStopLine = 0;

 	if(m_TotalPath.size()&gt;0)
 		distanceToClosestStopLine = PlanningHelpers::GetDistanceToClosestStopLineAndCheck(m_TotalPath.at(pValues-&gt;iCurrSafeLane), state, stopLineID, stopSignID, trafficLightID) - critical_long_front_distance;

 	if(distanceToClosestStopLine &gt; 0 &amp;&amp; distanceToClosestStopLine &lt; pValues-&gt;minStoppingDistance)
 	{
 		if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableTrafficLightBehavior)
 			pValues-&gt;currentTrafficLightID = trafficLightID;

 		if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableStopSignBehavior)
 			pValues-&gt;currentStopSignID = stopSignID;

		pValues-&gt;stoppingDistances.push_back(distanceToClosestStopLine);
		//std::cout &lt;&lt; &quot;From Local Planner =&gt; D: &quot; &lt;&lt; pValues-&gt;distanceToStop() &lt;&lt; &quot;, Prev SignID: &quot; &lt;&lt; pValues-&gt;prevStopSignID &lt;&lt; &quot;, Curr SignID: &quot; &lt;&lt; pValues-&gt;currentStopSignID &lt;&lt; endl;
 	}


// 	cout &lt;&lt; &quot;Distance To Closest: &quot; &lt;&lt; distanceToClosestStopLine &lt;&lt; &quot;, Stop LineID: &quot; &lt;&lt; stopLineID &lt;&lt; &quot;, Stop SignID: &quot; &lt;&lt; stopSignID &lt;&lt; &quot;, TFID: &quot; &lt;&lt; trafficLightID &lt;&lt; endl;

 	pValues-&gt;bTrafficIsRed = !bGreenTrafficLight;

 	if(bEmergencyStop)
	{
		pValues-&gt;bFullyBlock = true;
		pValues-&gt;distanceToNext = 1;
		pValues-&gt;velocityOfNext = 0;
	}
 	//cout &lt;&lt; &quot;Distances: &quot; &lt;&lt; pValues-&gt;stoppingDistances.size() &lt;&lt; &quot;, Distance To Stop : &quot; &lt;&lt; pValues-&gt;distanceToStop &lt;&lt; endl;
 }

double LocalPlannerH::PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState)
{
	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;

		//1- Calculate time prediction for each trajectory
	if(path.size() == 0) return 0;

//	SimulatedTrajectoryFollower predControl;
//	ControllerParams params;
//	params.Steering_Gain = PID_CONST(1.5, 0.0, 0.0);
//	params.Velocity_Gain = PID_CONST(0.2, 0.01, 0.1);
//	params.minPursuiteDistance = 3.0;
//
//	predControl.Init(params, m_CarInfo);
//	//double totalDistance = 0;
//	VehicleState CurrentState = vstatus;
//	VehicleState CurrentSteeringD;
//	bool bNewPath = true;
//	WayPoint localState = currState;
//	WayPoint prevState = currState;
//	int iPrevIndex = 0;
	double accum_time = 0;
//	double pred_max_time = 10.0;
//	double endDistance = pParams-&gt;microPlanDistance/2.0;
//
//	for(unsigned int i = 0 ; i &lt; path.size(); i++)
//	{
//		path.at(i).collisionCost = 0;
//		path.at(i).timeCost = -1;
//	}
//
//	int startIndex = PlanningHelpers::GetClosestPointIndex(path, state);
//	double total_distance = 0;
//	path.at(startIndex).timeCost = 0;
//	for(unsigned int i=startIndex+1; i&lt;path.size(); i++)
//	{
//		total_distance += hypot(path.at(i).pos.x- path.at(i-1).pos.x,path.at(i).pos.y- path.at(i-1).pos.y);
//		if(m_CurrentVelocity &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
//			accum_time = total_distance/m_CurrentVelocity;
//		path.at(i).timeCost = accum_time;
//		if(total_distance &gt; endDistance)
//			break;
//	}

//	while(totalDistance &lt; pParams-&gt;microPlanDistance/2.0 &amp;&amp; accum_time &lt; pred_max_time)
//	{
//		double dt = 0.05;
//		PlannerHNS::BehaviorState currMessage;
//		currMessage.state = FORWARD_STATE;
//		currMessage.maxVelocity = PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*CurrentState.speed*3.6);
//
//		ControllerParams c_params = m_ControlParams;
//		c_params.SteeringDelay = m_ControlParams.SteeringDelay / (1.0-UtilityH::GetMomentumScaleFactor(CurrentState.speed));
//		predControl.Init(c_params, m_CarInfo);
//		CurrentSteeringD = predControl.DoOneStep(dt, currMessage, path, localState, CurrentState, bNewPath);
//
//		if(bNewPath) // first call
//		{
//			if(predControl.m_iCalculatedIndex &gt; 0)
//			{
//				for(unsigned int j=0; j &lt; predControl.m_iCalculatedIndex; j++)
//					path.at(j).timeCost = -1;
//			}
//		}
//		else
//		{
//			if(predControl.m_iCalculatedIndex != iPrevIndex)
//				path.at(iPrevIndex).timeCost = accum_time;
//		}
//
//		accum_time+=dt;
//		bNewPath = false;
//
//		//Update State
//		CurrentState = CurrentSteeringD;
//
//		//Localize Me
//		localState.pos.x	 +=  CurrentState.speed * dt * cos(localState.pos.a);
//		localState.pos.y	 +=  CurrentState.speed * dt * sin(localState.pos.a);
//		localState.pos.a	 +=  CurrentState.speed * dt * tan(CurrentState.steer)  / m_CarInfo.wheel_base;
//
//		totalDistance += distance2points(prevState.pos, localState.pos);
//
//		prevState = localState;
//		iPrevIndex = predControl.m_iCalculatedIndex;
//	}

	return accum_time;
}

void LocalPlannerH::PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::WayPoint&amp; pos, const double&amp; predTime, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths)
{
	PlannerHNS::PlanningParams planningDefaultParams;
	planningDefaultParams.rollOutNumber = 0;
	planningDefaultParams.microPlanDistance = predTime*pos.v;

	planningDefaultParams.pathDensity = 0.5;
	//PlannerHNS::Lane* pMapLane  = MappingHelpers::GetClosestLaneFromMapDirectionBased(pos, map, 3.0);
	std::vector&lt;PlannerHNS::Lane*&gt; pMapLanes = MappingHelpers::GetClosestMultipleLanesFromMap(pos, map, 1.5);

	PlannerHNS::PlannerH planner;
	std::vector&lt;int&gt; LanesIds;
	std::vector&lt; std::vector&lt;PlannerHNS::WayPoint&gt; &gt;  rollOuts;
	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedPath;

	if(planningDefaultParams.microPlanDistance &gt; 0)
	{
		for(unsigned int i = 0; i &lt; pMapLanes.size(); i++)
		{
			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; loca_generatedPath;
			planner.PredictPlanUsingDP(pMapLanes.at(i), pos, planningDefaultParams.microPlanDistance, loca_generatedPath);
			if(loca_generatedPath.size() &gt; 0)
				generatedPath.insert(generatedPath.begin(),loca_generatedPath.begin(), loca_generatedPath.end());
		}
	}

//	planner.GenerateRunoffTrajectory(generatedPath, pos,
//			planningDefaultParams.enableLaneChange,
//			pos.v,
//			planningDefaultParams.microPlanDistance,
//			m_CarInfo.max_speed_forward,
//			planningDefaultParams.minSpeed,
//			planningDefaultParams.carTipMargin,
//			planningDefaultParams.rollInMargin,
//			planningDefaultParams.rollInSpeedFactor,
//			planningDefaultParams.pathDensity,
//			planningDefaultParams.rollOutDensity,
//			planningDefaultParams.rollOutNumber,
//			planningDefaultParams.smoothingDataWeight,
//			planningDefaultParams.smoothingSmoothWeight,
//			planningDefaultParams.smoothingToleranceError,
//			planningDefaultParams.speedProfileFactor,
//			planningDefaultParams.enableHeadingSmoothing,
//			rollOuts);

	if(generatedPath.size() &gt; 0)
	{
		//path = rollOuts.at(0);
		paths = generatedPath;

//		PlanningHelpers::GenerateRecommendedSpeed(path,
//				m_CarInfo.max_speed_forward,
//				planningDefaultParams.speedProfileFactor);
//		PlanningHelpers::SmoothSpeedProfiles(path, 0.15,0.35, 0.1);
	}

	if(pMapLanes.size() ==0 || paths.size() == 0)
	{
		paths.clear();
		generatedPath.clear();
	}
	else
	{
		//std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
		//std::cout &lt;&lt; &quot;Predicted Trajectories for Distance : &quot; &lt;&lt;  planningDefaultParams.microPlanDistance &lt;&lt; std::endl;
		for(unsigned int j=0; j &lt; paths.size(); j++)
		{
			if(paths.at(j).size()==0)
				continue;

			double timeDelay = 0;
			double total_distance = 0;
			paths.at(j).at(0).timeCost = 0;
			paths.at(j).at(0).v = pos.v;
			for(unsigned int i=1; i&lt;paths.at(j).size(); i++)
			{
				paths.at(j).at(i).v = pos.v;
				paths.at(j).at(i).pos.a = atan2(paths.at(j).at(i).pos.y - paths.at(j).at(i-1).pos.y, paths.at(j).at(i).pos.x - paths.at(j).at(i-1).pos.x);
				total_distance += distance2points(paths.at(j).at(i).pos, paths.at(j).at(i-1).pos);
				if(pos.v &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
					timeDelay = total_distance/pos.v;
				paths.at(j).at(i).timeCost = timeDelay;
			}

			//std::cout &lt;&lt; &quot;ID : &quot; &lt;&lt;  j &lt;&lt; &quot;, timeDelay : &quot; &lt;&lt; timeDelay &lt;&lt; &quot;, Distance : &quot; &lt;&lt; total_distance &lt;&lt; std::endl;
		}

		//std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
	}
}

bool LocalPlannerH::CalculateIntersectionVelocities(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; ego_path, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; predctedPath, const PlannerHNS::DetectedObject&amp; obj)
{
	bool bCollisionDetected = false;
	for(unsigned int k = 0; k &lt; predctedPath.size(); k++)
	{
		for(unsigned int j = 0; j &lt; predctedPath.at(k).size(); j++)
		{
			bool bCollisionFound =false;
			for(unsigned int i = 0; i &lt; ego_path.size(); i++)
			{
				if(ego_path.at(i).timeCost &gt; 0.0)
				{
					double collision_distance = hypot(ego_path.at(i).pos.x-predctedPath.at(k).at(j).pos.x, ego_path.at(i).pos.y-predctedPath.at(k).at(j).pos.y);
					double contact_distance = hypot(state.pos.x - ego_path.at(i).pos.x,state.pos.y - ego_path.at(i).pos.y);
					if(collision_distance &lt;= m_CarInfo.width  &amp;&amp; fabs(ego_path.at(i).timeCost - predctedPath.at(k).at(j).timeCost)&lt;4.0)
					{
						ego_path.at(i).collisionCost = 1;
						double a = UtilityH::AngleBetweenTwoAnglesPositive(ego_path.at(i).pos.a, predctedPath.at(k).at(j).pos.a);
						if(a &lt; M_PI_4/2.0)
							ego_path.at(i).v = obj.center.v;
						else
							ego_path.at(i).v = 0;
						predctedPath.at(k).at(j).collisionCost = 1;
						bCollisionFound = true;
						bCollisionDetected = true;
						break;
					}
				}
			}

			if(bCollisionFound)
				break;
		}
	}

	return bCollisionDetected;
}

bool LocalPlannerH::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
{
	double predTime = PredictTimeCostForTrajectory(m_Path, vstatus, state);
	m_PredictedPath.clear();
	bool bObstacleDetected = false;
	for(unsigned int i = 0; i &lt; obj_list.size(); i++)
	{
		//std::vector&lt;WayPoint&gt; predPath;
		PredictObstacleTrajectory(map, obj_list.at(i).center, 10.0, m_PredictedPath);
		bool bObstacle = CalculateIntersectionVelocities(m_Path, m_PredictedPath, obj_list.at(i));
		if(bObstacle)
			bObstacleDetected = true;
	}

	return bObstacleDetected;
}

 void LocalPlannerH::UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance)
 {
	 PlannerHNS::Lane* pMapLane = 0;
	PlannerHNS::Lane* pPathLane = 0;
	pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
	if(!pPathLane)
		pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, search_distance);

	if(pPathLane)
		pLane = pPathLane;
	else if(pMapLane)
		pLane = pMapLane;
	else
		pLane = 0;
 }

 void LocalPlannerH::SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState)
 {
	SetSimulatedTargetOdometryReadings(vehicleState.speed, vehicleState.steer, vehicleState.shift);
	UpdateState(vehicleState, true);
	LocalizeMe(dt);
 }

 bool LocalPlannerH::NoWayTest(const double&amp; min_distance, const int&amp; iGlobalPathIndex)
 {
	 if(m_TotalPath.size()==0) return false;

	 PlannerHNS::RelativeInfo info;
	 PlanningHelpers::GetRelativeInfo(m_TotalPath.at(iGlobalPathIndex), state, info);

	 double d = 0;
	 for(unsigned int i = info.iFront; i &lt; m_TotalPath.at(iGlobalPathIndex).size()-1; i++)
	 {
		 d+= hypot(m_TotalPath.at(iGlobalPathIndex).at(i+1).pos.y - m_TotalPath.at(iGlobalPathIndex).at(i).pos.y, m_TotalPath.at(iGlobalPathIndex).at(i+1).pos.x - m_TotalPath.at(iGlobalPathIndex).at(i).pos.x);
		 if(d &gt; min_distance)
			 return false;
	 }

	 return true;
 }

 bool LocalPlannerH::SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState)
 {
	 PlannerHNS::PreCalculatedConditions *preCalcPrams = m_pCurrentBehaviorState-&gt;GetCalcParams();

	bool bNewTrajectory = false;

	if(m_TotalPath.size()&gt;0)
	{
		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
		int index_limit = 0;//m_Path.size() - 20;
		if(index_limit&lt;=0)
			index_limit =  m_Path.size()/2.0;
		if(m_RollOuts.size() == 0
				|| currIndex &gt; index_limit
				|| m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan
				|| m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath
				|| m_pCurrentBehaviorState-&gt;m_Behavior == OBSTACLE_AVOIDANCE_STATE)
		{
			PlannerHNS::PlannerH planner;
			planner.GenerateRunoffTrajectory(m_TotalPath, state,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableLaneChange,
					vehicleState.speed,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;microPlanDistance,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;minSpeed,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;carTipMargin,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollInMargin,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollInSpeedFactor,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;pathDensity,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutDensity,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingDataWeight,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingSmoothWeight,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingToleranceError,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor,
					m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableHeadingSmoothing,
					preCalcPrams-&gt;iCurrSafeLane , preCalcPrams-&gt;iCurrSafeTrajectory,
					m_RollOuts, m_PathSection, m_SampledPoints);

			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = false;
			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = false;

			//cout &lt;&lt; &quot;Generating New Trajectories ! iPrev: &quot; &lt;&lt; preCalcPrams-&gt;iPrevSafeTrajectory &lt;&lt; &quot; , iSafe: &quot; &lt;&lt; preCalcPrams-&gt;iCurrSafeTrajectory &lt;&lt; endl;

			if(m_pCurrentBehaviorState-&gt;m_Behavior == OBSTACLE_AVOIDANCE_STATE)
				preCalcPrams-&gt;iPrevSafeTrajectory = preCalcPrams-&gt;iCurrSafeTrajectory;
			else
				preCalcPrams-&gt;iPrevSafeTrajectory = preCalcPrams-&gt;iCentralTrajectory;

			preCalcPrams-&gt;iPrevSafeLane = preCalcPrams-&gt;iCurrSafeLane;

			if(preCalcPrams-&gt;iPrevSafeLane &gt;= 0
					&amp;&amp; preCalcPrams-&gt;iPrevSafeLane &lt; m_RollOuts.size()
					&amp;&amp; preCalcPrams-&gt;iPrevSafeTrajectory &gt;= 0
					&amp;&amp; preCalcPrams-&gt;iPrevSafeTrajectory &lt; m_RollOuts.at(preCalcPrams-&gt;iPrevSafeLane).size())
			{
				//cout &lt;&lt; &quot;Select New Trajectories ! iPrev: &quot; &lt;&lt; preCalcPrams-&gt;iPrevSafeTrajectory &lt;&lt; &quot; , iSafe: &quot; &lt;&lt; preCalcPrams-&gt;iCurrSafeTrajectory &lt;&lt; endl;

				m_Path = m_RollOuts.at(preCalcPrams-&gt;iPrevSafeLane).at(preCalcPrams-&gt;iPrevSafeTrajectory);
//				PlanningHelpers::GenerateRecommendedSpeed(m_Path,
//						m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed,
//						m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
				bNewTrajectory = true;
			}
		}
	}

	return bNewTrajectory;
 }

 PlannerHNS::BehaviorState LocalPlannerH::GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState)
 {
	PlannerHNS::PreCalculatedConditions *preCalcPrams = m_pCurrentBehaviorState-&gt;GetCalcParams();

	m_pCurrentBehaviorState = m_pCurrentBehaviorState-&gt;GetNextState();
	PlannerHNS::BehaviorState currentBehavior;

	currentBehavior.state = m_pCurrentBehaviorState-&gt;m_Behavior;
	//if(currentBehavior.state == PlannerHNS::FOLLOW_STATE)
		currentBehavior.followDistance = preCalcPrams-&gt;distanceToNext;
	//else
	//	currentBehavior.followDistance = 0;

	if(preCalcPrams-&gt;bUpcomingRight)
		currentBehavior.indicator = PlannerHNS::INDICATOR_RIGHT;
	else if(preCalcPrams-&gt;bUpcomingLeft)
		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
	else
		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
	currentBehavior.minVelocity		= 0;
	currentBehavior.stopDistance 	= preCalcPrams-&gt;distanceToStop();
	currentBehavior.followVelocity 	= preCalcPrams-&gt;velocityOfNext;

	return currentBehavior;
 }

 void LocalPlannerH::UpdateVelocityDirectlyToTrajectory(const BehaviorState&amp; beh, const VehicleState&amp; CurrStatus, const double&amp; dt)
 {

	 RelativeInfo info;
	PlanningHelpers::GetRelativeInfo(m_Path, state, info);
	unsigned int point_index = 0;
	double critical_long_front_distance = 2.0;
	for(unsigned int i = 0; i &lt; m_Path.size(); i++)
		m_Path.at(i).v = m_CarInfo.min_speed_forward;

	if(beh.state == TRAFFIC_LIGHT_STOP_STATE || beh.state == STOP_SIGN_STOP_STATE)
	{
		PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.stopDistance - critical_long_front_distance, point_index);

		double inc = CurrStatus.speed;
		int iRange = point_index - info.iBack;
		//cout &lt;&lt; &quot;Range : &quot; &lt;&lt; iRange;
		if(iRange &gt; 0)
			inc = inc / (double)iRange;
		else
			inc = 0;

	//	cout &lt;&lt; &quot;Target Stopping Velocity: &quot;  &lt;&lt;  endl ;
		double target_velocity = CurrStatus.speed - inc;
		for(unsigned int i =  info.iBack; i &lt; point_index; i++)
		{
			if(target_velocity &gt; m_CarInfo.max_speed_forward)
				target_velocity = m_CarInfo.max_speed_forward;

			if(target_velocity &lt; m_CarInfo.min_speed_forward)
				target_velocity = m_CarInfo.min_speed_forward;

			 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
			 {
			//	 cout &lt;&lt; target_velocity &lt;&lt; &quot;, &quot; ;
				 m_Path.at(i).v = target_velocity;
			 }

			 target_velocity -= inc;
		}

		//cout &lt;&lt; endl &lt;&lt; endl;
	}
	else if(beh.state == FOLLOW_STATE)
	{
		double targe_acceleration = -pow(CurrStatus.speed, 2)/(2.0*(beh.followDistance - critical_long_front_distance));
		if(targe_acceleration &lt;= 0 &amp;&amp;  targe_acceleration &gt; m_CarInfo.max_deceleration/2.0)
		{
			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);

			double follow_distance = fabs(CurrStatus.speed) * (m_ControlParams.SteeringDelay+1);
			if(follow_distance &lt; m_ControlParams.minPursuiteDistance)
				follow_distance = m_ControlParams.minPursuiteDistance;

			RelativeInfo info;
			PlanningHelpers::GetRelativeInfo(m_Path, state, info);
			unsigned int point_index = 0;
			WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, follow_distance, point_index);
			double target_velocity = pursuite_point.v;
			if(target_velocity &gt; m_CarInfo.max_speed_forward)
				target_velocity = m_CarInfo.max_speed_forward;


			for(unsigned int i = 0; i &lt; m_Path.size(); i++)
			{
				if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
					m_Path.at(i).v = target_velocity;
				else
					m_Path.at(i).v = target_velocity*0.75;
			}
		}
		else
		{
			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);

			WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, beh.followDistance - critical_long_front_distance, point_index);

			double inc = CurrStatus.speed;
			int iRange = point_index - info.iBack;
			//cout &lt;&lt; &quot;Range : &quot; &lt;&lt; iRange;
			if(iRange &gt; 0)
				inc = inc / (double)iRange;
			else
				inc = 0;

			//cout &lt;&lt; &quot;Target Follow Velocity: &quot; &lt;&lt;  endl ;
			double target_velocity = CurrStatus.speed - inc;
			for(unsigned int i =  info.iBack; i &lt; point_index; i++)
			{
				if(target_velocity &gt; m_CarInfo.max_speed_forward)
					target_velocity = m_CarInfo.max_speed_forward;

				if(target_velocity &lt; m_CarInfo.min_speed_forward)
					target_velocity = m_CarInfo.min_speed_forward;

				 if(i &lt; m_Path.size() &amp;&amp; i &gt;= 0)
				 {
				//	 cout &lt;&lt; target_velocity &lt;&lt; &quot;, &quot; ;
					 if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
						 m_Path.at(i).v = target_velocity;
					 else
						 m_Path.at(i).v = target_velocity*0.75;
				 }

				 target_velocity -= inc;
			}
		}
	}
	else if(beh.state == FORWARD_STATE || beh.state == OBSTACLE_AVOIDANCE_STATE )
	{
		PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);

		double follow_distance = fabs(CurrStatus.speed) * (m_ControlParams.SteeringDelay+1);
		if(follow_distance &lt; m_ControlParams.minPursuiteDistance)
			follow_distance = m_ControlParams.minPursuiteDistance;

		RelativeInfo info;
		PlanningHelpers::GetRelativeInfo(m_Path, state, info);
		unsigned int point_index = 0;
		WayPoint pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(m_Path, info, follow_distance, point_index);
		double target_velocity = pursuite_point.v;
		if(target_velocity &gt; m_CarInfo.max_speed_forward)
			target_velocity = m_CarInfo.max_speed_forward;

		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
		{
			if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
				m_Path.at(i).v = target_velocity;
			else
				m_Path.at(i).v = target_velocity*0.75;

		}
	}
	else
	{
		double target_velocity = 0;
		for(unsigned int i = 0; i &lt; m_Path.size(); i++)
			m_Path.at(i).v = target_velocity;
	}
 }

 PlannerHNS::BehaviorState LocalPlannerH::DoOneStep(
		 const double&amp; dt,
		const PlannerHNS::VehicleState&amp; vehicleState,
		const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
		const int&amp; goalID, PlannerHNS::RoadNetwork&amp; map	,
		const bool&amp; bEmergencyStop,
		const bool&amp; bGreenTrafficLight,
		const bool&amp; bLive)
{

	 if(!bLive)
		 SimulateOdoPosition(dt, vehicleState);

	UpdateCurrentLane(map, 3.0);

	timespec costTimer;
	UtilityH::GetTickCount(costTimer);
	TrajectoryCost tc = m_TrajectoryCostsCalculatotor.DoOneStep(m_RollOuts, m_TotalPath, state,
			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory, m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeLane, *m_pCurrentBehaviorState-&gt;m_pParams,
			m_CarInfo,vehicleState, obj_list);
	m_CostCalculationTime = UtilityH::GetTimeDiffNow(costTimer);


	timespec behTimer;
	UtilityH::GetTickCount(behTimer);
	CalculateImportantParameterForDecisionMaking(vehicleState, goalID, bEmergencyStop, bGreenTrafficLight, tc);

	PlannerHNS::BehaviorState beh = GenerateBehaviorState(vehicleState);
	m_BehaviorGenTime = UtilityH::GetTimeDiffNow(behTimer);

	timespec t;
	UtilityH::GetTickCount(t);
	beh.bNewPlan = SelectSafeTrajectoryAndSpeedProfile(vehicleState);
	m_RollOutsGenerationTime = UtilityH::GetTimeDiffNow(t);

	if(m_pCurrentBehaviorState-&gt;m_pParams-&gt;enabTrajectoryVelocities)
	{
		UpdateVelocityDirectlyToTrajectory(beh, vehicleState, dt);
	}
	else if(beh.bNewPlan == true)
	{
		if(m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory == m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
		else
			PlanningHelpers::GenerateRecommendedSpeed(m_Path, m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed*0.25, m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
	}

/**
 * Usage of predictive planning
 */
//	timespec predictionTime;
//	UtilityH::GetTickCount(predictionTime);
//	if(UtilityH::GetTimeDiffNow(m_PredictionTimer) &gt; 0.5 || beh.bNewPlan)
//	{
//		CalculateObstacleCosts(map, vehicleState, obj_list);
//		m_PredictionTime = UtilityH::GetTimeDiffNow(predictionTime);
//	}
//	bool bCollision = false;
//	int wp_id = -1;
//	for(unsigned int i=0; i &lt; m_Path.size(); i++)
//	{
//		if(m_Path.at(i).collisionCost &gt; 0)
//		{
//			bCollision = true;
//			wp_id = i;
//			beh.maxVelocity = m_Path.at(i).v;//PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
//			break;
//		}
//	}
//	std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
//	std::cout &lt;&lt; &quot;Max Velocity = &quot; &lt;&lt; beh.maxVelocity &lt;&lt; &quot;, New Plan : &quot; &lt;&lt; beh.bNewPlan &lt;&lt;  std::endl;
//	std::cout &lt;&lt; &quot;Collision = &quot; &lt;&lt; bCollision &lt;&lt; &quot;, @ WayPoint : &quot; &lt;&lt; wp_id &lt;&lt;  std::endl;
//	std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;

	return beh;
 }

} /* namespace PlannerHNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/MappingHelpers.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/MappingHelpers.cpp">
				<diff>@@ -5,27 +5,19 @@
  *      Author: Hatem
  */
 
-#define _ENABLE_GPS_CONVERSIONS
 
 #include &quot;MappingHelpers.h&quot;
 #include &quot;MatrixOperations.h&quot;
 #include &quot;PlanningHelpers.h&quot;
 
-#include &quot;geo_pos_conv.hh&quot;
 #include &quot;math.h&quot;
 #include &lt;fstream&gt;
 
-#ifdef ENABLE_GPS_CONVERSIONS
-#include &quot;proj_api.h&quot;
-#endif
-
-
 using namespace UtilityHNS;
 using namespace std;
-#define FIND_LEFT_RIGHT_LANES
-#define _SMOOTH_MAP_WAYPOINTS
-#define RIGHT_INITIAL_TURNS_COST 100
-#define LEFT_INITIAL_TURNS_COST 100
+#define _FIND_LEFT_RIGHT_LANES
+#define RIGHT_INITIAL_TURNS_COST 0
+#define LEFT_INITIAL_TURNS_COST 0
 
 
 namespace PlannerHNS {
@@ -40,11 +32,11 @@ MappingHelpers::~MappingHelpers() {
 
 GPSPoint MappingHelpers::GetTransformationOrigin(const int&amp; bToyotaCityMap)
 {
-	if(bToyotaCityMap == 1)
-		return GPSPoint(-3700, 99427, -88,0); //toyota city
-	else if(bToyotaCityMap == 2)
-		return GPSPoint(14805.945, 84680.211, -39.59, 0); // for moriyama map
-	else
+//	if(bToyotaCityMap == 1)
+//		return GPSPoint(-3700, 99427, -88,0); //toyota city
+//	else if(bToyotaCityMap == 2)
+//		return GPSPoint(14805.945, 84680.211, -39.59, 0); // for moriyama map
+//	else
 		return GPSPoint();
 	//return GPSPoint(18221.1, 93546.1, -36.19, 0);
 }
@@ -102,6 +94,8 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
 		const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
 		const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+		const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+		const std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt;&amp; roadedge_data,
 		const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
 		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
 {
@@ -183,10 +177,6 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 			if(laneIDSeq != 0) //first lane
 			{
 				lane_obj.toIds.push_back(prev_lane_point.FLID);
-#ifdef SMOOTH_MAP_WAYPOINTS
-				PlanningHelpers::SmoothPath(lane_obj.points, 0.49, 0.15 , 0.01);
-				PlanningHelpers::CalcAngleAndCost(lane_obj.points);
-#endif
 				roadLanes.push_back(lane_obj);
 //				if(lane_obj.points.size() &lt;= 1)
 //					prev_FLID = 0;
@@ -204,7 +194,6 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		bool bFound = GetWayPoint(curr_lane_point.LnID, lane_obj.id, curr_lane_point.RefVel,curr_lane_point.DID,
 				dt_data, points_data,origin, wp);
 
-
 		if(curr_lane_point.LaneDir == 'L')
 		{
 			wp.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST));
@@ -257,18 +246,18 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 		}
 
 		//if(prev_lane_point.DID == curr_lane_point.DID &amp;&amp; curr_lane_point.LnID == prev_lane_point.FLID)
-		if(prevWayPoint.pos.x == wp.pos.x &amp;&amp; prevWayPoint.pos.y == wp.pos.y)
-		{
-			//if((prev_lane_point.FLID2 != 0 &amp;&amp; curr_lane_point.FLID2 != 0) || (prev_lane_point.FLID3 != 0 &amp;&amp; curr_lane_point.FLID3 != 0) || (prev_lane_point.FLID4 != 0 &amp;&amp; curr_lane_point.FLID4 != 0))
-			{
-				cout &lt;&lt; &quot;Prev WP, LnID: &quot; &lt;&lt; prev_lane_point.LnID &lt;&lt; &quot;,BLID: &quot; &lt;&lt; prev_lane_point.BLID &lt;&lt; &quot;,FLID: &quot; &lt;&lt; prev_lane_point.FLID &lt;&lt; &quot;,DID: &quot; &lt;&lt; prev_lane_point.DID
-						&lt;&lt; &quot;, Begin: &quot; &lt;&lt; prev_lane_point.BLID2 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.BLID3 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.BLID4
-						&lt;&lt; &quot;, End: &quot; &lt;&lt; prev_lane_point.FLID2 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.FLID3 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.FLID4 &lt;&lt; &quot;: &quot; &lt;&lt; prev_lane_point.LaneDir &lt;&lt;   endl;
-				cout &lt;&lt; &quot;Curr WP, LnID: &quot; &lt;&lt; curr_lane_point.LnID &lt;&lt; &quot;,BLID: &quot; &lt;&lt; curr_lane_point.BLID &lt;&lt; &quot;,FLID: &quot; &lt;&lt; curr_lane_point.FLID &lt;&lt; &quot;,DID: &quot; &lt;&lt; curr_lane_point.DID
-						&lt;&lt; &quot;, Begin: &quot; &lt;&lt; curr_lane_point.BLID2 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.BLID3 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.BLID4
-						&lt;&lt; &quot;, End: &quot; &lt;&lt; curr_lane_point.FLID2 &lt;&lt;  &quot;,&quot; &lt;&lt;curr_lane_point.FLID3 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.FLID4 &lt;&lt;   &quot;: &quot; &lt;&lt; curr_lane_point.LaneDir &lt;&lt; endl &lt;&lt; endl;
-			}
-		}
+//		if(prevWayPoint.pos.x == wp.pos.x &amp;&amp; prevWayPoint.pos.y == wp.pos.y)
+//		{
+//			//if((prev_lane_point.FLID2 != 0 &amp;&amp; curr_lane_point.FLID2 != 0) || (prev_lane_point.FLID3 != 0 &amp;&amp; curr_lane_point.FLID3 != 0) || (prev_lane_point.FLID4 != 0 &amp;&amp; curr_lane_point.FLID4 != 0))
+//			{
+//				cout &lt;&lt; &quot;Prev WP, LnID: &quot; &lt;&lt; prev_lane_point.LnID &lt;&lt; &quot;,BLID: &quot; &lt;&lt; prev_lane_point.BLID &lt;&lt; &quot;,FLID: &quot; &lt;&lt; prev_lane_point.FLID &lt;&lt; &quot;,DID: &quot; &lt;&lt; prev_lane_point.DID
+//						&lt;&lt; &quot;, Begin: &quot; &lt;&lt; prev_lane_point.BLID2 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.BLID3 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.BLID4
+//						&lt;&lt; &quot;, End: &quot; &lt;&lt; prev_lane_point.FLID2 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.FLID3 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.FLID4 &lt;&lt; &quot;: &quot; &lt;&lt; prev_lane_point.LaneDir &lt;&lt;   endl;
+//				cout &lt;&lt; &quot;Curr WP, LnID: &quot; &lt;&lt; curr_lane_point.LnID &lt;&lt; &quot;,BLID: &quot; &lt;&lt; curr_lane_point.BLID &lt;&lt; &quot;,FLID: &quot; &lt;&lt; curr_lane_point.FLID &lt;&lt; &quot;,DID: &quot; &lt;&lt; curr_lane_point.DID
+//						&lt;&lt; &quot;, Begin: &quot; &lt;&lt; curr_lane_point.BLID2 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.BLID3 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.BLID4
+//						&lt;&lt; &quot;, End: &quot; &lt;&lt; curr_lane_point.FLID2 &lt;&lt;  &quot;,&quot; &lt;&lt;curr_lane_point.FLID3 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.FLID4 &lt;&lt;   &quot;: &quot; &lt;&lt; curr_lane_point.LaneDir &lt;&lt; endl &lt;&lt; endl;
+//			}
+//		}
 
 		if(bFound)
 		{
@@ -394,167 +383,32 @@ void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;Utilit
 			{
 				pL-&gt;points.at(j).pLane  = pL;
 			}
+		}
+	}
 
 #ifdef FIND_LEFT_RIGHT_LANES
-			//Link left and right lanes
-			for(unsigned int rs_2 = 0; rs_2 &lt; map.roadSegments.size(); rs_2++)
-			{
-				for(unsigned int i2 =0; i2 &lt; map.roadSegments.at(rs_2).Lanes.size(); i2++)
-				{
-					int iCenter1 = pL-&gt;points.size()/2;
-					WayPoint wp_1 = pL-&gt;points.at(iCenter1);
-					int iCenter2 = PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs_2).Lanes.at(i2).points, wp_1 );
-					WayPoint closest_p = map.roadSegments.at(rs_2).Lanes.at(i2).points.at(iCenter2);
-					double mid_a1 = wp_1.pos.a;
-					double mid_a2 = closest_p.pos.a;
-					double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(mid_a1, mid_a2);
-					double distance = distance2points(wp_1.pos, closest_p.pos);
-
-					if(pL-&gt;id != map.roadSegments.at(rs_2).Lanes.at(i2).id &amp;&amp; angle_diff &lt; 0.05 &amp;&amp; distance &lt; 3.5 &amp;&amp; distance &gt; 2.5)
-					{
-						double perp_distance = 99999;
-						if(pL-&gt;points.size() &gt; 2 &amp;&amp; map.roadSegments.at(rs_2).Lanes.at(i2).points.size()&gt;2)
-						{
-							RelativeInfo info;
-							PlanningHelpers::GetRelativeInfo(pL-&gt;points, closest_p, info);
-							perp_distance = info.perp_distance;
-							//perp_distance = PlanningHelpers::GetPerpDistanceToVectorSimple(pL-&gt;points.at(iCenter1-1), pL-&gt;points.at(iCenter1+1), closest_p);
-						}
-
-						if(perp_distance &gt; 1.0 &amp;&amp; perp_distance &lt; 10.0)
-						{
-							pL-&gt;pRightLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
-							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
-							{
-								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
-								{
-									pL-&gt;points.at(i_internal).RightLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
-									pL-&gt;points.at(i_internal).pRight = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
-//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pLeft = &amp;pL-&gt;points.at(i_internal);
-								}
-							}
-						}
-						else if(perp_distance &lt; -1.0 &amp;&amp; perp_distance &gt; -10.0)
-						{
-							pL-&gt;pLeftLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
-							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
-							{
-								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
-								{
-									pL-&gt;points.at(i_internal).LeftLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
-									pL-&gt;points.at(i_internal).pLeft = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
-//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pRight = &amp;pL-&gt;points.at(i_internal);
-								}
-							}
-						}
-					}
-				}
-			}
+	FindAdjacentLanes(map);
 #endif
-		}
-	}
 
 	//Extract Signals and StopLines
 	// Signals
-	for(unsigned int is=0; is&lt; signal_data.size(); is++)
-	{
-		if(signal_data.at(is).Type == 2)
-		{
-			TrafficLight tl;
-			tl.id = signal_data.at(is).ID;
-			tl.stoppingDistance = 0;
+	ExtractSignalData(signal_data, vector_data, points_data, origin, map);
 
-			for(unsigned int iv = 0; iv &lt; vector_data.size(); iv++)
-			{
-				if(signal_data.at(is).VID == vector_data.at(iv).VID)
-				{
-					for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
-					{
-						if(vector_data.at(iv).PID == points_data.at(ip).PID)
-						{
-							tl.pos = GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, vector_data.at(iv).Hang*DEG2RAD);
-							break;
-						}
-					}
-				}
-			}
-			map.trafficLights.push_back(tl);
-		}
-	}
 
 	//Stop Lines
-	for(unsigned int ist=0; ist &lt; stop_line_data.size(); ist++)
-	{
-		StopLine sl;
-		sl.id = stop_line_data.at(ist).ID;
-
-		for(unsigned int il=0; il &lt; line_data.size(); il++)
-		{
-			if(stop_line_data.at(ist).LID == line_data.at(il).LID)
-			{
-				int s_id = line_data.at(il).BPID;
-				int e_id = line_data.at(il).FPID;
-				for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
-				{
-					if(points_data.at(ip).PID == s_id || points_data.at(ip).PID == e_id)
-					{
-						sl.points.push_back(GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, 0));
-					}
-				}
-			}
-		}
-		map.stopLines.push_back(sl);
-	}
+	ExtractStopLinesData(stop_line_data, line_data, points_data, origin, map);
 
-	//Link waypoints &amp;&amp; StopLines
-	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
-	{
-		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
-		{
-			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
-			{
-				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
-				for(unsigned int j = 0 ; j &lt; pWP-&gt;toIds.size(); j++)
-				{
-					pWP-&gt;pFronts.push_back(FindWaypoint(pWP-&gt;toIds.at(j), map));
-				}
-			}
 
-			for(unsigned int ic = 0; ic &lt; conn_data.size(); ic++)
-			{
-				UtilityHNS::AisanDataConnFileReader::DataConn data_conn = conn_data.at(ic);
-				ReplaceMyID(data_conn.LID , id_replace_list);
+	//Link waypoints
+	LinkMissingBranchingWayPoints(map);
 
-				if(map.roadSegments.at(rs).Lanes.at(i).id == data_conn.LID)
-				{
-					for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
-					{
-						if(map.trafficLights.at(itl).id == data_conn.SID)
-						{
-							map.trafficLights.at(itl).laneIds.push_back(map.roadSegments.at(rs).Lanes.at(i).id);
-							map.trafficLights.at(itl).pLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(i));
-							map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
-						}
-					}
+	//Link StopLines and Traffic Lights
+	LinkTrafficLightsAndStopLines(map);
+	//LinkTrafficLightsAndStopLinesConData(conn_data, id_replace_list, map);
 
-					for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
-					{
-						if(map.stopLines.at(isl).id == data_conn.SLID)
-						{
-							map.stopLines.at(isl).laneId = map.roadSegments.at(rs).Lanes.at(i).id;
-							map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
-							map.stopLines.at(isl).trafficLightID = data_conn.SID;
-							map.stopLines.at(isl).stopSignID = data_conn.SSID;
-							map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
-							WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
-							map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
-						}
-					}
-				}
-			}
+	//Curbs
+	ExtractCurbData(curb_data, line_data, points_data, origin, map);
 
-		}
-	}
 
 	cout &lt;&lt; &quot;Map loaded from data with &quot; &lt;&lt; roadLanes.size()  &lt;&lt; &quot; lanes&quot; &lt;&lt; endl;
 }
@@ -590,8 +444,12 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	string signal_info = vectoMapPath + &quot;signaldata.csv&quot;;
 	string stop_line_info = vectoMapPath + &quot;stopline.csv&quot;;
 	string vector_info = vectoMapPath + &quot;vector.csv&quot;;
+	string curb_info = vectoMapPath + &quot;curb.csv&quot;;
+	string roadedge_info = vectoMapPath + &quot;roadedge.csv&quot;;
+
 	string conn_info = vectoMapPath + &quot;dataconnection.csv&quot;;
 
+
 	string intersection_info = vectoMapPath + &quot;intersection.csv&quot;;
 
 	AisanCenterLinesFileReader  center_lanes(center_lines_info);
@@ -602,6 +460,8 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	AisanStopLineFileReader stop_line(stop_line_info);
 	AisanSignalFileReader signal(signal_info);
 	AisanVectorFileReader vec(vector_info);
+	AisanCurbFileReader curb(curb_info);
+	AisanRoadEdgeFileReader roadedge(roadedge_info);
 	AisanDataConnFileReader conn(conn_info);
 
 	//AisanAreasFileReader areas(node_info);
@@ -631,6 +491,13 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 	signal.ReadAllData(signal_data);
 	vector&lt;AisanVectorFileReader::AisanVector&gt; vector_data;
 	vec.ReadAllData(vector_data);
+
+	vector&lt;AisanCurbFileReader::AisanCurb&gt; curb_data;
+	curb.ReadAllData(curb_data);
+
+	vector&lt;AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
+	roadedge.ReadAllData(roadedge_data);
+
 	vector&lt;AisanDataConnFileReader::DataConn&gt; conn_data;
 	conn.ReadAllData(conn_data);
 
@@ -646,7 +513,9 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 		bToyotaCityMap = 2;
 
 	// use this to transform data to origin (0,0,0)
-	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data, line_data, stop_line_data, signal_data, vector_data,conn_data, GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
+	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data,
+			line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data, conn_data,
+			GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);
 
 	//use this when using the same coordinates as the map
 //	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data, GPSPoint(), map);
@@ -663,47 +532,8 @@ void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMa
 //	double distance = distance2points(origin.pos, lastPoint.pos);
 //
 	cout &lt;&lt; origin.pos.ToString() ;
-//
-//
-//	geo_pos_conv geo;
-//	geo.set_plane(6);
-//	geo.llh_to_xyz(origin2.pos.lon, origin2.pos.lat, 0);
-//
-//	origin2.pos.x = geo.x();
-//	origin2.pos.y = geo.y();
-//
-//	geo.llh_to_xyz(lastPoint2.pos.lon, lastPoint2.pos.lat, 0);
-//
-//	lastPoint2.pos.x = geo.x();
-//	lastPoint2.pos.y = geo.y();
-//
-//	double distance2 = distance2points(origin2.pos, lastPoint2.pos);
-//	cout &lt;&lt; origin2.pos.ToString() ;
-
 }
 
-void MappingHelpers::SaveTrajectoryLonLatToKMLFile(const string&amp; fileName, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; trajectory)
-  {
-  	vector&lt;vector&lt;string&gt; &gt; m_str_kml;
-
-  	for(unsigned l = 0 ; l &lt; trajectory.size(); l++)
-  	{
-  		vector&lt;string&gt;  lane_str_kml;
-		for(unsigned k = 0 ; k &lt; trajectory.at(l).size(); k++)
-		{
-			ostringstream gps_str;
-			gps_str.precision(12);
-			GPSPoint gps_p = trajectory.at(l).at(k).pos;
-			gps_str &lt;&lt; gps_p.x &lt;&lt; &quot;,&quot; &lt;&lt; gps_p.y &lt;&lt; &quot;,&quot; &lt;&lt; gps_p.z;
-			lane_str_kml.push_back(gps_str.str());
-		}
-		m_str_kml.push_back(lane_str_kml);
-  	}
-
-  	if(m_str_kml.size() &gt; 0)
-  		DataRW::WriteKMLFile(fileName, m_str_kml);
-  }
-
 void MappingHelpers::GetWayPoint(const int&amp; pid, const vector&lt;AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path)
 {
 
@@ -751,11 +581,11 @@ bool MappingHelpers::GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp;
 
 					wp.pos = GPSPoint(points.at(p).Ly + origin.x, points.at(p).Bx + origin.y, points.at(p).H + origin.z, dtpoints.at(dtp).Dir);
 
-
 					wp.pos.lat = points.at(p).L;
 					wp.pos.lon = points.at(p).B;
 					wp.pos.alt = points.at(p).H;
 					wp.pos.dir = dtpoints.at(dtp).Dir;
+					wp.iOriginalIndex = p;
 
 
 					way_point = wp;
@@ -810,9 +640,6 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 		{
 			//if(laneLinksList.at(j).roadId == roadLinksList.at(i).id)
 			{
-#ifdef SMOOTH_MAP_WAYPOINTS
-				PlanningHelpers::SmoothPath(laneLinksList.at(j).points, 0.49, 0.15 , 0.01);
-#endif
 				PlanningHelpers::CalcAngleAndCost(laneLinksList.at(j).points);
 				roadLinksList.at(i).Lanes.push_back(laneLinksList.at(j));
 			}
@@ -917,7 +744,7 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 					map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
 					map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
 					WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
-					map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
+					map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
 				}
 			}
 		}
@@ -927,46 +754,6 @@ void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
 
 }
 
-void MappingHelpers::WriteKML(const string&amp; kmlFile, const string&amp; kmlTemplat, RoadNetwork&amp; map)
-{
-	//First, Get the main element
-	TiXmlElement* pHeadElem = 0;
-	TiXmlElement* pElem = 0;
-
-	ifstream f(kmlTemplat.c_str());
-	if(!f.good())
-	{
-		cout &lt;&lt; &quot;Can't Open KML Template File: (&quot; &lt;&lt; kmlFile &lt;&lt; &quot;)&quot; &lt;&lt; endl;
-		return;
-	}
-
-	TiXmlDocument doc(kmlTemplat);
-	if(!doc.LoadFile())
-	{
-		cout &lt;&lt; doc.ErrorDesc() &lt;&lt; endl;
-	}
-	else
-		pElem = doc.FirstChildElement();
-
-	pHeadElem = GetHeadElement(pElem);
-
-	vector&lt;Lane&gt; allLanes;
-	vector&lt;RoadSegment&gt; roadSegments;
-
-	for(unsigned int j=0; j&lt; map.roadSegments.size(); j++)
-	{
-		allLanes.insert(allLanes.end(), map.roadSegments.at(j).Lanes.begin(),
-				map.roadSegments.at(j).Lanes.end());
-		roadSegments.push_back(map.roadSegments.at(j));
-	}
-
-	SetLaneLinksList(pHeadElem, allLanes);
-	SetRoadLinksList(pHeadElem, roadSegments);
-	SetStopLinesList(pHeadElem, map.stopLines);
-	SetTrafficLightsList(pHeadElem, map.trafficLights);
-
-	doc.SaveFile(kmlFile.c_str());
-}
 
 TiXmlElement* MappingHelpers::GetHeadElement(TiXmlElement* pMainElem)
 {
@@ -1001,319 +788,120 @@ TiXmlElement* MappingHelpers::GetDataFolder(const string&amp; folderName, TiXmlEleme
 	return 0;
 }
 
-void MappingHelpers::SetLaneLinksList(TiXmlElement* pElem, vector&lt;Lane&gt;&amp; lanes)
+WayPoint* MappingHelpers::GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const bool bDirectionBased)
 {
-	TiXmlElement* pLaneLinks = GetDataFolder(&quot;Lanes&quot;, pElem);
-	TiXmlNode* pE = pLaneLinks-&gt;FirstChild(&quot;Folder&quot;);
-	TiXmlNode* pN = pE;
-	TiXmlText * pText = 0;
-	TiXmlElement* pElement = 0;
-	int roadId = -1;
-	int roadsCount = 0;
-
-	if(lanes.size() ==0)
-		pE-&gt;Clear();
-
-	for(unsigned int i=0; i&lt; lanes.size(); i++)
+	double distance_to_nearest_lane = 1;
+	Lane* pLane = 0;
+	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
 	{
-		Lane* pLane = &amp;lanes.at(i);
-
-		if(pLane-&gt;roadId != roadId)
-		{
-			roadId = pLane-&gt;roadId;
-			roadsCount++;
-		}
-
-		if(i&gt;0)
-			pN = pE-&gt;Clone();
-
-		ostringstream name, desc;
-		name &lt;&lt; &quot;LID_&quot; &lt;&lt; pLane-&gt;id;
-		pElement = pN-&gt;FirstChild(&quot;name&quot;)-&gt;ToElement();
-		pText = new TiXmlText(name.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		desc &lt;&lt; &quot;LID_&quot; &lt;&lt; pLane-&gt;id &lt;&lt; &quot;_RSID_&quot; &lt;&lt; pLane-&gt;roadId &lt;&lt; &quot;_NUM_&quot; &lt;&lt; pLane-&gt;num &lt;&lt; &quot;_From_&quot;;
-		for(unsigned int j=0; j&lt; pLane-&gt;fromIds.size(); j++)
-			desc &lt;&lt; pLane-&gt;fromIds.at(j) &lt;&lt; &quot;_&quot;;
-
-		desc &lt;&lt; &quot;To&quot;;
-		for(unsigned int j=0; j&lt; pLane-&gt;toIds.size(); j++)
-			desc &lt;&lt; &quot;_&quot; &lt;&lt; pLane-&gt;toIds.at(j);
+		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane, bDirectionBased);
+		distance_to_nearest_lane += 1;
+	}
 
-		desc &lt;&lt; &quot;_Vel_&quot; &lt;&lt; pLane-&gt;speed;
+	if(!pLane) return 0;
 
-		pElement = pN-&gt;FirstChild(&quot;description&quot;)-&gt;ToElement();
-		pText = new TiXmlText(desc.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
+	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(pLane-&gt;points, pos);
 
-		ostringstream style;
-		pElement = pN-&gt;FirstChild(&quot;Placemark&quot;)-&gt;FirstChild(&quot;styleUrl&quot;)-&gt;ToElement();
-		style &lt;&lt; &quot;#mms_route_line_&quot; &lt;&lt; roadsCount%4;
-		pText = new TiXmlText(style.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
+	return &amp;pLane-&gt;points.at(closest_index);
+}
 
+vector&lt;WayPoint*&gt; MappingHelpers::GetClosestWaypointsListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance, const bool bDirectionBased)
+{
+	vector&lt;Lane*&gt; pLanes = GetClosestLanesListFromMap(pos, map, distance, bDirectionBased);
 
-		pElement = pN-&gt;FirstChild(&quot;Placemark&quot;)-&gt;FirstChild(&quot;LineString&quot;)-&gt;FirstChild(&quot;coordinates&quot;)-&gt;ToElement();
+	vector&lt;WayPoint*&gt; waypoints_list;
 
-		ostringstream val;
-		val.precision(18);
+	if(pLanes.size() == 0) return waypoints_list;
 
-		for(unsigned int j =0; j &lt; pLane-&gt;points.size() ; j++)
+	for(unsigned int i = 0; i &lt; pLanes.size(); i++)
+	{
+		if(pLanes.at(i))
 		{
-			GPSPoint p = pLane-&gt;points.at(j).pos;
-			val &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;,&quot; &lt;&lt; p.z &lt;&lt;  &quot; &quot;;
+			int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(pLanes.at(i)-&gt;points, pos);
+			waypoints_list.push_back(&amp;pLanes.at(i)-&gt;points.at(closest_index));
 		}
+	}
 
-		pText = new TiXmlText(val.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		TiXmlNode* pWPNode = pN-&gt;FirstChild(&quot;Folder&quot;);
-		TiXmlNode* pWPNodeCopy =  pWPNode;
-
-		ostringstream valInfo;
-		for(unsigned int j =0; j &lt; pLane-&gt;points.size() ; j++)
-		{
-			char action = 'F';
-			int cost = 0;
-
-			if(pLane-&gt;points.at(j).actionCost.size() &gt; 0)
-			{
-				if(pLane-&gt;points.at(j).actionCost.at(0).first == FORWARD_ACTION)
-					action = 'F';
-				else if(pLane-&gt;points.at(j).actionCost.at(0).first == LEFT_TURN_ACTION)
-					action = 'L';
-				else if(pLane-&gt;points.at(j).actionCost.at(0).first == RIGHT_TURN_ACTION)
-					action = 'R';
-
-				cost = 	pLane-&gt;points.at(j).actionCost.at(0).second;
-			}
+	return waypoints_list;
+}
 
-if(m_USING_VER_ZERO == 1)
+WayPoint* MappingHelpers::GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map)
 {
-			valInfo &lt;&lt; &quot;WPID_&quot; &lt;&lt; pLane-&gt;points.at(j).id
-					&lt;&lt; &quot;_C_&quot; &lt;&lt; action &lt;&lt; &quot;_&quot; &lt;&lt; cost &lt;&lt; &quot;_From_&quot;;
+	double distance_to_nearest_lane = 1;
+	Lane* pLane = 0;
+	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
+	{
+		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane);
+		distance_to_nearest_lane += 1;
+	}
 
-			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).fromIds.size(); k++)
-				valInfo &lt;&lt; pLane-&gt;points.at(j).fromIds.at(k) &lt;&lt; &quot;_&quot;;
+	if(!pLane) return 0;
 
-			valInfo &lt;&lt; &quot;To&quot;;
-			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).toIds.size(); k++)
-				valInfo &lt;&lt; &quot;_&quot; &lt;&lt; pLane-&gt;points.at(j).toIds.at(k);
+	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(pLane-&gt;points, pos);
 
+	if(closest_index&gt;2)
+		return &amp;pLane-&gt;points.at(closest_index-3);
+	else if(closest_index&gt;1)
+		return &amp;pLane-&gt;points.at(closest_index-2);
+	else if(closest_index&gt;0)
+		return &amp;pLane-&gt;points.at(closest_index-1);
+	else
+		return &amp;pLane-&gt;points.at(closest_index);
 }
-else
-{
-			valInfo &lt;&lt; &quot;WPID_&quot; &lt;&lt; pLane-&gt;points.at(j).id
-					&lt;&lt; &quot;_AC_&quot; &lt;&lt; action &lt;&lt; &quot;_&quot; &lt;&lt; cost &lt;&lt; &quot;_From_&quot;;
-
-			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).fromIds.size(); k++)
-				valInfo &lt;&lt; pLane-&gt;points.at(j).fromIds.at(k) &lt;&lt; &quot;_&quot;;
-
-			valInfo &lt;&lt; &quot;To&quot;;
-			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).toIds.size(); k++)
-				valInfo &lt;&lt; &quot;_&quot; &lt;&lt; pLane-&gt;points.at(j).toIds.at(k);
 
-			if(pLane-&gt;points.at(j).pLeft)
-				valInfo &lt;&lt; &quot;_Lid_&quot; &lt;&lt; pLane-&gt;points.at(j).pLeft-&gt;id;
-			else
-				valInfo &lt;&lt; &quot;_Lid_&quot; &lt;&lt; 0;
-
-			if(pLane-&gt;points.at(j).pRight)
-				valInfo &lt;&lt; &quot;_Rid_&quot; &lt;&lt; pLane-&gt;points.at(j).pRight-&gt;id;
-			else
-				valInfo &lt;&lt; &quot;_Rid_&quot; &lt;&lt; 0;
-}
+Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance, const bool bDirectionBased)
+{
+	vector&lt;pair&lt;double, Lane*&gt; &gt; laneLinksList;
+	double d = 0;
+	double min_d = 9999999999;
+	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
+	{
+		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
+		{
+			//Lane* pLane = &amp;pEdge-&gt;lanes.at(k);
+			 d = 0;
+			min_d = 9999999999;
+			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
+			{
 
-			valInfo &lt;&lt; &quot;_Vel_&quot; &lt;&lt; pLane-&gt;points.at(j).v;
-			valInfo &lt;&lt; &quot;_Dir_&quot; &lt;&lt; pLane-&gt;points.at(j).pos.a;
+				d = distance2points(map.roadSegments.at(j).Lanes.at(k).points.at(pindex).pos, pos.pos);
+				if(d &lt; min_d)
+					min_d = d;
+			}
 
-			valInfo &lt;&lt; &quot;,&quot;;
+			if(min_d &lt; distance)
+				laneLinksList.push_back(make_pair(min_d, &amp;map.roadSegments.at(j).Lanes.at(k)));
 		}
-
-		TiXmlElement* pWPElem = pWPNodeCopy-&gt;FirstChild(&quot;description&quot;)-&gt;ToElement();
-		pText = new TiXmlText(valInfo.str());
-		pWPElem-&gt;Clear();
-		pWPElem-&gt;LinkEndChild(pText);
-
-		if(i&gt;0)
-			pLaneLinks-&gt;InsertEndChild(*pN);
 	}
-}
 
-void MappingHelpers::SetRoadLinksList(TiXmlElement* pElem, vector&lt;RoadSegment&gt;&amp; roadSegments)
-{
-	TiXmlElement* pRoadLinks = GetDataFolder(&quot;RoadSegments&quot;, pElem);
-	TiXmlNode* pE = pRoadLinks-&gt;FirstChild(&quot;Placemark&quot;);
-	TiXmlNode* pN = pE;
-	TiXmlText * pText = 0;
-	TiXmlElement* pElement = 0;
-
-	if(roadSegments.size() ==0)
-		pE-&gt;Clear();
-
-	for(unsigned int i=0; i&lt; roadSegments.size(); i++)
-	{
-		RoadSegment* pRS = &amp;roadSegments.at(i);
-
-		if(i&gt;0)
-			pN = pE-&gt;Clone();
-
-		ostringstream name, desc;
-		name &lt;&lt; &quot;RSID_&quot; &lt;&lt; pRS-&gt;id;
-		pElement = pN-&gt;FirstChild(&quot;name&quot;)-&gt;ToElement();
-		pElement-&gt;Clear();
-		pText = new TiXmlText(name.str());
-		pElement-&gt;LinkEndChild(pText);
-
-		desc &lt;&lt; &quot;RSID_&quot; &lt;&lt; pRS-&gt;id;
-		pElement = pN-&gt;FirstChild(&quot;description&quot;)-&gt;ToElement();
-		pElement-&gt;Clear();
-		pText = new TiXmlText(desc.str());
-		pElement-&gt;LinkEndChild(pText);
-		if(i&gt;0)
-			pRoadLinks-&gt;InsertEndChild(*pN);
-	}
-}
-
-void MappingHelpers::SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines)
-{
-	TiXmlElement* pStopLiness = GetDataFolder(&quot;StopLines&quot;, pElem);
-	TiXmlNode* pE = pStopLiness-&gt;FirstChild(&quot;Placemark&quot;);
-	TiXmlNode* pN = pE;
-	TiXmlText * pText = 0;
-	TiXmlElement* pElement = 0;
-
-	if(stopLines.size() ==0)
-		pE-&gt;Clear();
+	if(laneLinksList.size() == 0) return 0;
 
-	for(unsigned int i=0; i&lt; stopLines.size(); i++)
+	min_d = 999999999;
+	Lane* closest_lane = 0;
+	for(unsigned int i = 0; i &lt; laneLinksList.size(); i++)
 	{
-		StopLine* pSL = &amp;stopLines.at(i);
-		if(i&gt;0)
-			pN = pE-&gt;Clone();
-
-		ostringstream name, desc;
-		name &lt;&lt; &quot;SLID_&quot; &lt;&lt; pSL-&gt;id &lt;&lt; &quot;_LnID_&quot; &lt;&lt; pSL-&gt;laneId &lt;&lt; &quot;_TSID_&quot; &lt;&lt; pSL-&gt;stopSignID &lt;&lt; &quot;_TLTID_&quot; &lt;&lt; pSL-&gt;trafficLightID;
-		pElement = pN-&gt;FirstChild(&quot;name&quot;)-&gt;ToElement();
-		pText = new TiXmlText(name.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-
-		pElement = pN-&gt;FirstChild(&quot;LineString&quot;)-&gt;FirstChild(&quot;coordinates&quot;)-&gt;ToElement();
+		RelativeInfo info;
+		PlanningHelpers::GetRelativeInfo(laneLinksList.at(i).second-&gt;points, pos, info);
 
-		ostringstream val;
-		val.precision(18);
+		if(info.perp_distance == 0 &amp;&amp; laneLinksList.at(i).first != 0)
+			continue;
 
-		for(unsigned int j =0; j &lt; pSL-&gt;points.size() ; j++)
+		if(bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; min_d &amp;&amp; fabs(info.angle_diff) &lt; 45)
 		{
-			GPSPoint p = pSL-&gt;points.at(j);
-			val &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;,&quot; &lt;&lt; p.z &lt;&lt;  &quot; &quot;;
+			min_d = fabs(info.perp_distance);
+			closest_lane = laneLinksList.at(i).second;
+		}
+		else if(!bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; min_d)
+		{
+			min_d = fabs(info.perp_distance);
+			closest_lane = laneLinksList.at(i).second;
 		}
-
-		pText = new TiXmlText(val.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		if(i&gt;0)
-			pStopLiness-&gt;InsertEndChild(*pN);
-	}
-}
-
-void MappingHelpers::SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights)
-{
-	TiXmlElement* pTrafficLights = GetDataFolder(&quot;TrafficLights&quot;, pElem);
-	TiXmlNode* pE = pTrafficLights-&gt;FirstChild(&quot;Placemark&quot;);
-	TiXmlNode* pN = pE;
-	TiXmlText * pText = 0;
-	TiXmlElement* pElement = 0;
-
-	if(trafficLights.size() ==0)
-		pE-&gt;Clear();
-
-	for(unsigned int i=0; i&lt; trafficLights.size(); i++)
-	{
-		TrafficLight* pTL = &amp;trafficLights.at(i);
-		if(i&gt;0)
-			pN = pE-&gt;Clone();
-
-		ostringstream name, desc;
-		name &lt;&lt; &quot;TLID_&quot; &lt;&lt; pTL-&gt;id &lt;&lt; &quot;_LnID&quot;;
-		for(unsigned int j=0; j&lt; pTL-&gt;laneIds.size(); j++)
-			name &lt;&lt; &quot;_&quot; &lt;&lt; pTL-&gt;laneIds.at(j);
-
-		pElement = pN-&gt;FirstChild(&quot;name&quot;)-&gt;ToElement();
-		pText = new TiXmlText(name.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		pElement = pN-&gt;FirstChild(&quot;Point&quot;)-&gt;FirstChild(&quot;coordinates&quot;)-&gt;ToElement();
-
-		ostringstream val;
-		val.precision(18);
-		val &lt;&lt; pTL-&gt;pos.x &lt;&lt; &quot;,&quot; &lt;&lt; pTL-&gt;pos.y &lt;&lt; &quot;,&quot; &lt;&lt; pTL-&gt;pos.z &lt;&lt;  &quot; &quot;;
-
-		pText = new TiXmlText(val.str());
-		pElement-&gt;Clear();
-		pElement-&gt;LinkEndChild(pText);
-
-		if(i&gt;0)
-			pTrafficLights-&gt;InsertEndChild(*pN);
-	}
-}
-
-void MappingHelpers::SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes)
-{
-
-}
-
-WayPoint* MappingHelpers::GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map)
-{
-	double distance_to_nearest_lane = 1;
-	Lane* pLane = 0;
-	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
-	{
-		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane);
-		distance_to_nearest_lane += 1;
-	}
-
-	if(!pLane) return 0;
-
-	int closest_index = PlanningHelpers::GetClosestNextPointIndex(pLane-&gt;points, pos);
-
-	return &amp;pLane-&gt;points.at(closest_index);
-}
-
-WayPoint* MappingHelpers::GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map)
-{
-	double distance_to_nearest_lane = 1;
-	Lane* pLane = 0;
-	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
-	{
-		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane);
-		distance_to_nearest_lane += 1;
 	}
 
-	if(!pLane) return 0;
-
-	int closest_index = PlanningHelpers::GetClosestNextPointIndex(pLane-&gt;points, pos);
-
-	if(closest_index&gt;2)
-		return &amp;pLane-&gt;points.at(closest_index-3);
-	else if(closest_index&gt;1)
-		return &amp;pLane-&gt;points.at(closest_index-2);
-	else if(closest_index&gt;0)
-		return &amp;pLane-&gt;points.at(closest_index-1);
-	else
-		return &amp;pLane-&gt;points.at(closest_index);
+	return closest_lane;
 }
 
-Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance)
+vector&lt;Lane*&gt; MappingHelpers::GetClosestLanesListFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance, const bool bDirectionBased)
 {
 	vector&lt;pair&lt;double, Lane*&gt; &gt; laneLinksList;
 	double d = 0;
@@ -1338,10 +926,10 @@ Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; ma
 		}
 	}
 
-	if(laneLinksList.size() == 0) return 0;
+	vector&lt;Lane*&gt; closest_lanes;
+	if(laneLinksList.size() == 0) return closest_lanes;
+
 
-	min_d = 999999999;
-	Lane* closest_lane = 0;
 	for(unsigned int i = 0; i &lt; laneLinksList.size(); i++)
 	{
 		RelativeInfo info;
@@ -1350,14 +938,17 @@ Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; ma
 		if(info.perp_distance == 0 &amp;&amp; laneLinksList.at(i).first != 0)
 			continue;
 
-		if(fabs(info.perp_distance) &lt; min_d &amp;&amp; fabs(info.angle_diff) &lt; 45)
+		if(bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; distance &amp;&amp; fabs(info.angle_diff) &lt; 45)
 		{
-			min_d = fabs(info.perp_distance);
-			closest_lane = laneLinksList.at(i).second;
+			closest_lanes.push_back(laneLinksList.at(i).second);
+		}
+		else if(!bDirectionBased &amp;&amp; fabs(info.perp_distance) &lt; distance)
+		{
+			closest_lanes.push_back(laneLinksList.at(i).second);
 		}
 	}
 
-	return closest_lane;
+	return closest_lanes;
 }
 
 Lane* MappingHelpers::GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance)
@@ -1481,110 +1072,6 @@ WayPoint* MappingHelpers::GetLastWaypoint(RoadNetwork&amp; map)
 	return 0;
 }
 
-
-void MappingHelpers::llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset)
-{
-#ifdef ENABLE_GPS_CONVERSIONS
-	projPJ pj_latlong, pj_utm;
-	pj_latlong = pj_init_plus(&quot;+proj=latlong +ellps=WGS84&quot;);
-	pj_utm = pj_init_plus(&quot;+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84&quot;);
-
-	projUV p_gps;
-	p_gps.u = lla_p.lon - netOffset.x;
-	p_gps.v = lla_p.lat - netOffset.y;
-
-	p_gps = pj_inv(p_gps, pj_utm);
-	p_gps.u *= DEG2RAD;
-	p_gps.v *= DEG2RAD;
-
-	GPSPoint p = lla_p;
-	p.x = p_gps.u;
-	p.y = p_gps.v;
-
-	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
-	{
-		pj_transform(pj_latlong, pj_utm, 1, 1, &amp;p.y, &amp;p.x, &amp;p.z);
-		p.x += netOffset.x;
-		p.y += netOffset.y;
-	}
-
-	lla_p = p;
-#endif
-}
-
-void MappingHelpers::llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin)
-{
-#ifdef ENABLE_GPS_CONVERSIONS
-	projPJ pj_latlong, pj_utm;
-	pj_latlong = pj_init_plus(&quot;+proj=latlong +ellps=WGS84&quot;);
-	pj_utm = pj_init_plus(&quot;+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84&quot;);
-
-	GPSPoint p = lla_p;
-
-	p.x = lla_p.lon * DEG2RAD;
-	p.y = lla_p.lat * DEG2RAD;
-
-	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
-	{
-		pj_transform(pj_latlong, pj_utm, 1, 1, &amp;p.y, &amp;p.x, &amp;p.z);
-		p.x -= origin.x;
-		p.y -= origin.y;
-		p.z -= origin.z;
-	}
-
-	lla_p = p;
-#endif
-
-}
-
-void MappingHelpers::xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset)
-{
-#ifdef ENABLE_GPS_CONVERSIONS
-	projPJ pj_latlong, pj_utm;
-	pj_latlong = pj_init_plus(&quot;+proj=latlong +ellps=WGS84&quot;);
-	pj_utm = pj_init_plus(&quot;+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84&quot;);
-
-	projUV p_gps;
-	p_gps.u = lla_p.y - netOffset.x;
-	p_gps.v = lla_p.x - netOffset.y;
-
-	p_gps = pj_inv(p_gps, pj_utm);
-	p_gps.u *= RAD2DEG;
-	p_gps.v *= RAD2DEG;
-
-	GPSPoint p = lla_p;
-	p.lon = p_gps.u;
-	p.lat = p_gps.v;
-
-	lla_p = p;
-#endif
-}
-
-void MappingHelpers::xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin)
-{
-#ifdef ENABLE_GPS_CONVERSIONS
-	projPJ pj_latlong, pj_utm;
-	pj_latlong = pj_init_plus(&quot;+proj=latlong +ellps=WGS84&quot;);
-	pj_utm = pj_init_plus(&quot;+proj=utm +ellps=WGS84 +datum=WGS84 +units=m&quot;);
-
-	GPSPoint p = xyz_p;
-
-	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
-	{
-		pj_transform(pj_utm,pj_latlong, 1, 1, &amp;p.lon, &amp;p.lat, &amp;p.alt);
-		p.lon = p.lon * RAD2DEG;
-		p.lat = p.lat * RAD2DEG;
-
-		p.lon -= origin.lon;
-		p.lat -= origin.lat;
-		p.alt -= origin.alt;
-	}
-
-	xyz_p = p;
-#endif
-
-}
-
 void MappingHelpers::GetUniqueNextLanes(const Lane* l,  const vector&lt;Lane*&gt;&amp; traversed_lanes, vector&lt;Lane*&gt;&amp; lanes_list)
 {
 	if(!l) return;
@@ -1608,7 +1095,7 @@ Lane* MappingHelpers::GetLaneFromPath(const WayPoint&amp; currPos, const std::vector
 {
 	if(currPath.size() &lt; 1) return 0;
 
-	int closest_index = PlanningHelpers::GetClosestNextPointIndex(currPath, currPos);
+	int closest_index = PlanningHelpers::GetClosestNextPointIndexFast(currPath, currPos);
 
 	return currPath.at(closest_index).pLane;
 }
@@ -1995,7 +1482,8 @@ pair&lt;ACTION_TYPE, double&gt; MappingHelpers::GetActionPairFromPrefix(const string&amp;
 	act_cost.second = 0;
 
 	vector&lt;string&gt; idstr = SplitString(str_ids, &quot;_&quot;);
-	if(idstr.size() == 2)
+
+	if(idstr.size() &gt;= 2)
 	{
 		if(idstr.at(0).size() &gt; 0 &amp;&amp; idstr.at(0).at(0) == 'L')
 			act_cost.first = LEFT_TURN_ACTION;
@@ -2032,110 +1520,283 @@ vector&lt;string&gt; MappingHelpers::SplitString(const string&amp; str, const string&amp; toke
 	return str_parts;
 }
 
-void MappingHelpers::CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,
-		const double&amp; maxLaneDistance, const double&amp; density,
-		const std::vector&lt;TrafficLight&gt;&amp; trafficLights,
-		const std::vector&lt;GPSPoint&gt;&amp; stopLines)
+void MappingHelpers::FindAdjacentLanes(RoadNetwork&amp; map)
 {
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		//Link Lanes
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+		{
+			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
+			//Link left and right lanes
+			for(unsigned int rs_2 = 0; rs_2 &lt; map.roadSegments.size(); rs_2++)
+			{
+				for(unsigned int i2 =0; i2 &lt; map.roadSegments.at(rs_2).Lanes.size(); i2++)
+				{
+					int iCenter1 = pL-&gt;points.size()/2;
+					WayPoint wp_1 = pL-&gt;points.at(iCenter1);
+					int iCenter2 = PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs_2).Lanes.at(i2).points, wp_1 );
+					WayPoint closest_p = map.roadSegments.at(rs_2).Lanes.at(i2).points.at(iCenter2);
+					double mid_a1 = wp_1.pos.a;
+					double mid_a2 = closest_p.pos.a;
+					double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(mid_a1, mid_a2);
+					double distance = distance2points(wp_1.pos, closest_p.pos);
 
-	//Read Data From csv file
-	LocalizationPathReader pathReader(pathFileName, ',');
-	vector&lt;LocalizationPathReader::LocalizationWayPoint&gt; path_data;
-	pathReader.ReadAllData(path_data);
-	PlannerHNS::RoadSegment segment;
-	segment.id = 1;
-
-	double d_accum = 0;
-	double laneMaxLength = maxLaneDistance;
-
-	std::vector&lt;WayPoint&gt; wayPointsList;
+					if(pL-&gt;id != map.roadSegments.at(rs_2).Lanes.at(i2).id &amp;&amp; angle_diff &lt; 0.05 &amp;&amp; distance &lt; 3.5 &amp;&amp; distance &gt; 2.5)
+					{
+						double perp_distance = 99999;
+						if(pL-&gt;points.size() &gt; 2 &amp;&amp; map.roadSegments.at(rs_2).Lanes.at(i2).points.size()&gt;2)
+						{
+							RelativeInfo info;
+							PlanningHelpers::GetRelativeInfo(pL-&gt;points, closest_p, info);
+							perp_distance = info.perp_distance;
+							//perp_distance = PlanningHelpers::GetPerpDistanceToVectorSimple(pL-&gt;points.at(iCenter1-1), pL-&gt;points.at(iCenter1+1), closest_p);
+						}
 
-	PlannerHNS::Lane lane;
-	lane.id = 1;
-	lane.num = 0;
-	lane.roadId = 1;
-	WayPoint p_prev;
+						if(perp_distance &gt; 1.0 &amp;&amp; perp_distance &lt; 10.0)
+						{
+							pL-&gt;pRightLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
+							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
+							{
+								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
+								{
+									pL-&gt;points.at(i_internal).RightLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
+									pL-&gt;points.at(i_internal).pRight = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
+//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pLeft = &amp;pL-&gt;points.at(i_internal);
+								}
+							}
+						}
+						else if(perp_distance &lt; -1.0 &amp;&amp; perp_distance &gt; -10.0)
+						{
+							pL-&gt;pLeftLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
+							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
+							{
+								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
+								{
+									pL-&gt;points.at(i_internal).LeftLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
+									pL-&gt;points.at(i_internal).pLeft = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
+//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pRight = &amp;pL-&gt;points.at(i_internal);
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+}
 
-	for(unsigned int i=0; i&lt; path_data.size() ; i++)
+void MappingHelpers::ExtractSignalData(const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
+			const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int is=0; is&lt; signal_data.size(); is++)
 	{
-		WayPoint p(path_data.at(i).x,path_data.at(i).y,path_data.at(i).z,0);
-		p.pos.lat = p.pos.x;
-		p.pos.lon = p.pos.y;
-		p.pos.alt = p.pos.z;
-		//p.pos.dir = p.pos.a;
-		//p.v = path_data.at(i).v;
-		p.laneId = lane.id;
-		p.id = i+1;
-		if(i&gt;0)
+		if(signal_data.at(is).Type == 2)
 		{
-			p.fromIds.push_back(i);
-			d_accum += hypot(p.pos.y-p_prev.pos.y, p.pos.x-p_prev.pos.x);
+			TrafficLight tl;
+			tl.id = signal_data.at(is).ID;
+			tl.linkID = signal_data.at(is).LinkID;
+			tl.stoppingDistance = 0;
+
+			for(unsigned int iv = 0; iv &lt; vector_data.size(); iv++)
+			{
+				if(signal_data.at(is).VID == vector_data.at(iv).VID)
+				{
+					for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
+					{
+						if(vector_data.at(iv).PID == points_data.at(ip).PID)
+						{
+							tl.pos = GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, vector_data.at(iv).Hang*DEG2RAD);
+							break;
+						}
+					}
+				}
+			}
+			map.trafficLights.push_back(tl);
 		}
+	}
+}
+
+void MappingHelpers::ExtractStopLinesData(const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
+			const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+			const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+			const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int ist=0; ist &lt; stop_line_data.size(); ist++)
+		{
+		StopLine sl;
+		sl.linkID = stop_line_data.at(ist).LinkID;
+		sl.id = stop_line_data.at(ist).ID;
 
-		if(i&lt;path_data.size()-1)
-			p.toIds.push_back(i+2);
+		for(unsigned int il=0; il &lt; line_data.size(); il++)
+		{
+			if(stop_line_data.at(ist).LID == line_data.at(il).LID)
+			{
+				int s_id = line_data.at(il).BPID;
+				int e_id = line_data.at(il).FPID;
+				for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
+				{
+					if(points_data.at(ip).PID == s_id || points_data.at(ip).PID == e_id)
+					{
+						sl.points.push_back(GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, 0));
+					}
+				}
+			}
+		}
+		map.stopLines.push_back(sl);
+	}
+}
 
-		wayPointsList.push_back(p);
+void MappingHelpers::ExtractCurbData(const std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt;&amp; curb_data,
+				const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
+				const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
+				const GPSPoint&amp; origin, RoadNetwork&amp; map)
+{
+	for(unsigned int ic=0; ic &lt; curb_data.size(); ic++)
+		{
+			Curb c;
+			c.id = curb_data.at(ic).ID;
 
-		p_prev = p;
+			for(unsigned int il=0; il &lt; line_data.size(); il++)
+			{
+				if(curb_data.at(ic).LID == line_data.at(il).LID)
+				{
+					int s_id = line_data.at(il).BPID;
+					int e_id = line_data.at(il).FPID;
+					for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
+					{
+						if(points_data.at(ip).PID == s_id)
+						{
+							c.points.push_back(GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, 0));
+							WayPoint wp;
+							wp.pos = c.points.at(0);
+							Lane* pLane = GetClosestLaneFromMap(wp, map, 5);
+							if(pLane)
+							{
+								c.laneId = pLane-&gt;id;
+								c.pLane = pLane;
+							}
+						}
+					}
+				}
+			}
+			map.curbs.push_back(c);
+		}
+}
 
-		if(d_accum &gt; laneMaxLength || i+1 == path_data.size())
+void MappingHelpers::LinkMissingBranchingWayPoints(RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+	{
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
 		{
-			if(segment.Lanes.size()&gt;0)
-				lane.fromIds.push_back(segment.Lanes.at(segment.Lanes.size()-1).id);
-			lane.toIds.push_back(lane.id+1);
-			lane.points = wayPointsList;
-			segment.Lanes.push_back(lane);
-
-			d_accum = 0;
-			PlannerHNS::Lane n_lane;
-			n_lane.id = lane.id+1;
-			n_lane.num = 0;
-			n_lane.roadId = 1;
-			lane = n_lane;
-			wayPointsList.clear();
+			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
+			{
+				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+				for(unsigned int j = 0 ; j &lt; pWP-&gt;toIds.size(); j++)
+				{
+					pWP-&gt;pFronts.push_back(FindWaypoint(pWP-&gt;toIds.at(j), map));
+				}
+			}
 		}
 	}
+}
 
-	if(segment.Lanes.size()&gt;0)
+void MappingHelpers::LinkTrafficLightsAndStopLines(RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
 	{
-		segment.Lanes.at(segment.Lanes.size()-1).toIds.clear();
-		if(density &gt; 0)
+		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
 		{
-			for(unsigned int i=0; i &lt; segment.Lanes.size(); i++)
-				PlanningHelpers::FixPathDensity(segment.Lanes.at(i).points, density);
-
-			int fnID=0;
-			for(unsigned int i=0; i &lt; segment.Lanes.size(); i++)
+			for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
 			{
-				if(segment.Lanes.at(i).points.size() &gt; 0)
+				for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
 				{
-					for(unsigned int j =0; j &lt; segment.Lanes.at(i).points.size(); j++)
+					WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+					if(map.trafficLights.at(itl).linkID == pWP-&gt;id)
 					{
-						fnID ++;
-						segment.Lanes.at(i).points.at(j).id = fnID ;
-						segment.Lanes.at(i).points.at(j).fromIds.clear();
-						segment.Lanes.at(i).points.at(j).toIds.clear();
-						if(!(i == 0 &amp;&amp; j == 0))
-							segment.Lanes.at(i).points.at(j).fromIds.push_back(fnID - 1);
-						if(!(i+1 ==  segment.Lanes.size() &amp;&amp; j+1 == segment.Lanes.at(i).points.size()))
-							segment.Lanes.at(i).points.at(j).toIds.push_back(fnID + 1);
+						map.trafficLights.at(itl).laneIds.push_back(pWP-&gt;laneId);
+						map.trafficLights.at(itl).pLanes.push_back(pWP-&gt;pLane);
+						map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
+						break;
 					}
 				}
 			}
 		}
 	}
 
-	PlannerHNS::RoadNetwork roadMap;
-	roadMap.roadSegments.push_back(segment);
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+		{
+			for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+			{
+				for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
+				{
+					for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
+					{
+						WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
+						if(map.stopLines.at(isl).linkID == pWP-&gt;id)
+						{
+							map.stopLines.at(isl).laneId = pWP-&gt;laneId;
+							map.stopLines.at(isl).pLane = pWP-&gt;pLane;
+							if(pWP-&gt;pLane-&gt;trafficlights.size() &gt; 0)
+								map.stopLines.at(isl).trafficLightID = pWP-&gt;pLane-&gt;trafficlights.at(0).id;
+							map.stopLines.at(isl).stopSignID = 100+isl;
+							map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
+							WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
+							map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
+							break;
+						}
+					}
+				}
+			}
+		}
+}
 
-	ostringstream fileName;
-	fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName;
-	fileName &lt;&lt; UtilityHNS:: UtilityH::GetFilePrefixHourMinuteSeconds();
-	fileName &lt;&lt; &quot;_RoadNetwork.kml&quot;;
-	string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+&quot;PlannerX_MapTemplate.kml&quot;;
+void MappingHelpers::LinkTrafficLightsAndStopLinesConData(const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
+		const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; id_replace_list, RoadNetwork&amp; map)
+{
+	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
+		{
+			for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
+			{
 
-	PlannerHNS::MappingHelpers::WriteKML(&quot;/home/hatem/SimuLogs/YardKML.kml&quot;,kml_templateFilePath , roadMap);
-}
+				for(unsigned int ic = 0; ic &lt; conn_data.size(); ic++)
+				{
+					UtilityHNS::AisanDataConnFileReader::DataConn data_conn = conn_data.at(ic);
+					ReplaceMyID(data_conn.LID , id_replace_list);
+
+					if(map.roadSegments.at(rs).Lanes.at(i).id == data_conn.LID)
+					{
+						for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
+						{
+							if(map.trafficLights.at(itl).id == data_conn.SID)
+							{
+								map.trafficLights.at(itl).laneIds.push_back(map.roadSegments.at(rs).Lanes.at(i).id);
+								map.trafficLights.at(itl).pLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(i));
+								map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
+							}
+						}
 
+						for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
+						{
+							if(map.stopLines.at(isl).id == data_conn.SLID)
+							{
+								map.stopLines.at(isl).laneId = map.roadSegments.at(rs).Lanes.at(i).id;
+								map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
+								map.stopLines.at(isl).trafficLightID = data_conn.SID;
+								map.stopLines.at(isl).stopSignID = data_conn.SSID;
+								map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
+								WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
+								map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndexFast(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
+							}
+						}
+					}
+				}
+
+			}
+		}
+
+}
 } /* namespace PlannerHNS */
</diff>
				<old_file>/*
 * MappingHelpers.cpp
 *
 *  Created on: Jul 2, 2016
 *      Author: Hatem
 */

#define _ENABLE_GPS_CONVERSIONS

#include &quot;MappingHelpers.h&quot;
#include &quot;MatrixOperations.h&quot;
#include &quot;PlanningHelpers.h&quot;

#include &quot;geo_pos_conv.hh&quot;
#include &quot;math.h&quot;
#include &lt;fstream&gt;

#ifdef ENABLE_GPS_CONVERSIONS
#include &quot;proj_api.h&quot;
#endif


using namespace UtilityHNS;
using namespace std;
#define FIND_LEFT_RIGHT_LANES
#define _SMOOTH_MAP_WAYPOINTS
#define RIGHT_INITIAL_TURNS_COST 100
#define LEFT_INITIAL_TURNS_COST 100


namespace PlannerHNS {

double MappingHelpers::m_USING_VER_ZERO = 0;

MappingHelpers::MappingHelpers() {
}

MappingHelpers::~MappingHelpers() {
}

GPSPoint MappingHelpers::GetTransformationOrigin(const int&amp; bToyotaCityMap)
{
	if(bToyotaCityMap == 1)
		return GPSPoint(-3700, 99427, -88,0); //toyota city
	else if(bToyotaCityMap == 2)
		return GPSPoint(14805.945, 84680.211, -39.59, 0); // for moriyama map
	else
		return GPSPoint();
	//return GPSPoint(18221.1, 93546.1, -36.19, 0);
}

Lane* MappingHelpers::GetLaneById(const int&amp; id,RoadNetwork&amp; map)
{
	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
	{
		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
		{
			if(map.roadSegments.at(rs).Lanes.at(i).id == id)
				return &amp;map.roadSegments.at(rs).Lanes.at(i);
		}
	}

	return 0;
}

int MappingHelpers::GetLaneIdByWaypointId(const int&amp; id,std::vector&lt;Lane&gt;&amp; lanes)
{
	for(unsigned int in_l= 0; in_l &lt; lanes.size(); in_l++)
	{
		for(unsigned int in_p = 0; in_p&lt;lanes.at(in_l).points.size(); in_p++)
		{
			if(id == lanes.at(in_l).points.at(in_p).id)
			{
				return lanes.at(in_l).points.at(in_p).laneId;
			}
		}
	}

	return 0;
}

int MappingHelpers::ReplaceMyID(int&amp; id,const std::vector&lt;std::pair&lt;int,int&gt; &gt;&amp; rep_list)
{
	for(unsigned int i=0; i &lt; rep_list.size(); i++)
	{
		if(rep_list.at(i).first == id)
		{
			id = rep_list.at(i).second;
			return id;
		}
	}

	return -1;
}

void MappingHelpers::ConstructRoadNetworkFromRosMessage(const std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt;&amp; lanes_data,
		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points_data,
		const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dt_data,
		const std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt;&amp; intersection_data,
		const std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt;&amp; area_data,
		const std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt;&amp; line_data,
		const std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt;&amp; stop_line_data,
		const std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt;&amp; signal_data,
		const std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt;&amp; vector_data,
		const std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt;&amp; conn_data,
		const GPSPoint&amp; origin, RoadNetwork&amp; map, const bool&amp; bSpecialFlag)
{
	vector&lt;Lane&gt; roadLanes;
	Lane lane_obj;
	int laneIDSeq = 0;
	WayPoint prevWayPoint;
	UtilityHNS::AisanLanesFileReader::AisanLane prev_lane_point;
	UtilityHNS::AisanLanesFileReader::AisanLane curr_lane_point;
	UtilityHNS::AisanLanesFileReader::AisanLane next_lane_point;
	vector&lt;pair&lt;int,int&gt; &gt; id_replace_list;

	for(unsigned int l= 0; l &lt; lanes_data.size(); l++)
	{
		curr_lane_point = lanes_data.at(l);

		if(l+1 &lt; lanes_data.size())
		{
			next_lane_point = lanes_data.at(l+1);
			if(curr_lane_point.FLID == next_lane_point.LnID &amp;&amp; curr_lane_point.DID == next_lane_point.DID)
			{
				next_lane_point.BLID = curr_lane_point.BLID;
				if(next_lane_point.LaneDir == 'F')
					next_lane_point.LaneDir = curr_lane_point.LaneDir;

				if(curr_lane_point.BLID2 != 0)
				{
					if(next_lane_point.BLID2 == 0)	next_lane_point.BLID2 = curr_lane_point.BLID2;
					else if(next_lane_point.BLID3 == 0)	next_lane_point.BLID3 = curr_lane_point.BLID2;
					else if(next_lane_point.BLID4 == 0)	next_lane_point.BLID4 = curr_lane_point.BLID2;
				}

				if(curr_lane_point.BLID3 != 0)
				{
					if(next_lane_point.BLID2 == 0)	next_lane_point.BLID2 = curr_lane_point.BLID3;
					else if(next_lane_point.BLID3 == 0)	next_lane_point.BLID3 = curr_lane_point.BLID3;
					else if(next_lane_point.BLID4 == 0)	next_lane_point.BLID4 = curr_lane_point.BLID3;
				}

				if(curr_lane_point.BLID3 != 0)
				{
					if(next_lane_point.BLID2 == 0)	next_lane_point.BLID2 = curr_lane_point.BLID4;
					else if(next_lane_point.BLID3 == 0)	next_lane_point.BLID3 = curr_lane_point.BLID4;
					else if(next_lane_point.BLID4 == 0)	next_lane_point.BLID4 = curr_lane_point.BLID4;
				}

				if(curr_lane_point.FLID2 != 0)
				{
					if(next_lane_point.FLID2 == 0)	next_lane_point.FLID2 = curr_lane_point.FLID2;
					else if(next_lane_point.FLID3 == 0)	next_lane_point.FLID3 = curr_lane_point.FLID2;
					else if(next_lane_point.FLID4 == 0)	next_lane_point.FLID4 = curr_lane_point.FLID2;
				}

				if(curr_lane_point.FLID3 != 0)
				{
					if(next_lane_point.FLID2 == 0)	next_lane_point.FLID2 = curr_lane_point.FLID3;
					else if(next_lane_point.FLID3 == 0)	next_lane_point.FLID3 = curr_lane_point.FLID3;
					else if(next_lane_point.FLID4 == 0)	next_lane_point.FLID4 = curr_lane_point.FLID3;
				}

				if(curr_lane_point.FLID3 != 0)
				{
					if(next_lane_point.FLID2 == 0)	next_lane_point.FLID2 = curr_lane_point.FLID4;
					else if(next_lane_point.FLID3 == 0)	next_lane_point.FLID3 = curr_lane_point.FLID4;
					else if(next_lane_point.FLID4 == 0)	next_lane_point.FLID4 = curr_lane_point.FLID4;
				}

				if(prev_lane_point.FLID == curr_lane_point.LnID)
					prev_lane_point.FLID = next_lane_point.LnID;

				id_replace_list.push_back(make_pair(curr_lane_point.LnID, next_lane_point.LnID));
				curr_lane_point = next_lane_point;
				l++;
			}
		}

		if(curr_lane_point.LnID != prev_lane_point.FLID)
		{
			if(laneIDSeq != 0) //first lane
			{
				lane_obj.toIds.push_back(prev_lane_point.FLID);
#ifdef SMOOTH_MAP_WAYPOINTS
				PlanningHelpers::SmoothPath(lane_obj.points, 0.49, 0.15 , 0.01);
				PlanningHelpers::CalcAngleAndCost(lane_obj.points);
#endif
				roadLanes.push_back(lane_obj);
//				if(lane_obj.points.size() &lt;= 1)
//					prev_FLID = 0;
			}

			laneIDSeq++;
			lane_obj = Lane();
			lane_obj.speed = curr_lane_point.LimitVel;
			lane_obj.id = curr_lane_point.LnID;
			lane_obj.fromIds.push_back(curr_lane_point.BLID);
			lane_obj.roadId = laneIDSeq;
		}

		WayPoint wp;
		bool bFound = GetWayPoint(curr_lane_point.LnID, lane_obj.id, curr_lane_point.RefVel,curr_lane_point.DID,
				dt_data, points_data,origin, wp);


		if(curr_lane_point.LaneDir == 'L')
		{
			wp.actionCost.push_back(make_pair(LEFT_TURN_ACTION, LEFT_INITIAL_TURNS_COST));
			//std::cout &lt;&lt; &quot; Left Lane : &quot; &lt;&lt; curr_lane_point.LnID &lt;&lt; std::endl ;
		}
		else  if(curr_lane_point.LaneDir == 'R')
		{
			wp.actionCost.push_back(make_pair(RIGHT_TURN_ACTION, RIGHT_INITIAL_TURNS_COST));
			//std::cout &lt;&lt; &quot; Right Lane : &quot; &lt;&lt; curr_lane_point.LnID &lt;&lt; std::endl ;
		}
		else
		{
			wp.actionCost.push_back(make_pair(FORWARD_ACTION, 0));
		}

		wp.fromIds.push_back(curr_lane_point.BLID);
		wp.toIds.push_back(curr_lane_point.FLID);

		//if(curr_lane_point.JCT &gt; 0)
		if(curr_lane_point.FLID2 &gt; 0)
		{
			lane_obj.toIds.push_back(curr_lane_point.FLID2);
			wp.toIds.push_back(curr_lane_point.FLID2);
		}
		if(curr_lane_point.FLID3 &gt; 0)
		{
			lane_obj.toIds.push_back(curr_lane_point.FLID3);
			wp.toIds.push_back(curr_lane_point.FLID3);
		}
		if(curr_lane_point.FLID4 &gt; 0)
		{
			lane_obj.toIds.push_back(curr_lane_point.FLID4);
			wp.toIds.push_back(curr_lane_point.FLID4);
		}

		if(curr_lane_point.BLID2 &gt; 0)
		{
			lane_obj.fromIds.push_back(curr_lane_point.BLID2);
			wp.fromIds.push_back(curr_lane_point.BLID2);
		}
		if(curr_lane_point.BLID3 &gt; 0)
		{
			lane_obj.fromIds.push_back(curr_lane_point.BLID3);
			wp.fromIds.push_back(curr_lane_point.BLID3);
		}
		if(curr_lane_point.BLID4 &gt; 0)
		{
			lane_obj.fromIds.push_back(curr_lane_point.BLID4);
			wp.fromIds.push_back(curr_lane_point.BLID4);
		}

		//if(prev_lane_point.DID == curr_lane_point.DID &amp;&amp; curr_lane_point.LnID == prev_lane_point.FLID)
		if(prevWayPoint.pos.x == wp.pos.x &amp;&amp; prevWayPoint.pos.y == wp.pos.y)
		{
			//if((prev_lane_point.FLID2 != 0 &amp;&amp; curr_lane_point.FLID2 != 0) || (prev_lane_point.FLID3 != 0 &amp;&amp; curr_lane_point.FLID3 != 0) || (prev_lane_point.FLID4 != 0 &amp;&amp; curr_lane_point.FLID4 != 0))
			{
				cout &lt;&lt; &quot;Prev WP, LnID: &quot; &lt;&lt; prev_lane_point.LnID &lt;&lt; &quot;,BLID: &quot; &lt;&lt; prev_lane_point.BLID &lt;&lt; &quot;,FLID: &quot; &lt;&lt; prev_lane_point.FLID &lt;&lt; &quot;,DID: &quot; &lt;&lt; prev_lane_point.DID
						&lt;&lt; &quot;, Begin: &quot; &lt;&lt; prev_lane_point.BLID2 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.BLID3 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.BLID4
						&lt;&lt; &quot;, End: &quot; &lt;&lt; prev_lane_point.FLID2 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.FLID3 &lt;&lt; &quot;,&quot; &lt;&lt; prev_lane_point.FLID4 &lt;&lt; &quot;: &quot; &lt;&lt; prev_lane_point.LaneDir &lt;&lt;   endl;
				cout &lt;&lt; &quot;Curr WP, LnID: &quot; &lt;&lt; curr_lane_point.LnID &lt;&lt; &quot;,BLID: &quot; &lt;&lt; curr_lane_point.BLID &lt;&lt; &quot;,FLID: &quot; &lt;&lt; curr_lane_point.FLID &lt;&lt; &quot;,DID: &quot; &lt;&lt; curr_lane_point.DID
						&lt;&lt; &quot;, Begin: &quot; &lt;&lt; curr_lane_point.BLID2 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.BLID3 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.BLID4
						&lt;&lt; &quot;, End: &quot; &lt;&lt; curr_lane_point.FLID2 &lt;&lt;  &quot;,&quot; &lt;&lt;curr_lane_point.FLID3 &lt;&lt;  &quot;,&quot; &lt;&lt; curr_lane_point.FLID4 &lt;&lt;   &quot;: &quot; &lt;&lt; curr_lane_point.LaneDir &lt;&lt; endl &lt;&lt; endl;
			}
		}

		if(bFound)
		{
			lane_obj.points.push_back(wp);
			prevWayPoint = wp;
		}
		else
			cout &lt;&lt; &quot; Strange ! point is not in the map !! &quot; &lt;&lt; endl;

		prev_lane_point = curr_lane_point;
	}

	//delete first two lanes !!!!! Don't know why , you don't know why ! , these two line cost you a lot .. ! why why , works for toyota map , but not with moriyama
	if(bSpecialFlag)
	{
		if(roadLanes.size() &gt; 0)
			roadLanes.erase(roadLanes.begin()+0);
		if(roadLanes.size() &gt; 0)
			roadLanes.erase(roadLanes.begin()+0);
	}

	roadLanes.push_back(lane_obj);

	for(unsigned int i =0; i &lt; roadLanes.size(); i++)
	{
		Lane* pL = &amp;roadLanes.at(i);
		ReplaceMyID(pL-&gt;id, id_replace_list);

		for(unsigned int j = 0 ; j &lt; pL-&gt;fromIds.size(); j++)
		{
			int id = ReplaceMyID(pL-&gt;fromIds.at(j), id_replace_list);
			if(id != -1)
				pL-&gt;fromIds.at(j) = id;
		}

		for(unsigned int j = 0 ; j &lt; pL-&gt;toIds.size(); j++)
		{
			int id = ReplaceMyID(pL-&gt;toIds.at(j), id_replace_list);
			if(id != -1)
				pL-&gt;toIds.at(j) = id;
		}

		for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
		{
			ReplaceMyID(pL-&gt;points.at(j).id, id_replace_list);
			ReplaceMyID(pL-&gt;points.at(j).laneId, id_replace_list);

			for(unsigned int jj = 0 ; jj &lt; pL-&gt;points.at(j).fromIds.size(); jj++)
			{
				int id = ReplaceMyID(pL-&gt;points.at(j).fromIds.at(jj), id_replace_list);
				if(id != -1)
					pL-&gt;points.at(j).fromIds.at(jj) = id;
			}

			for(unsigned int jj = 0 ; jj &lt; pL-&gt;points.at(j).toIds.size(); jj++)
			{
				int id = ReplaceMyID(pL-&gt;points.at(j).toIds.at(jj), id_replace_list);
				if(id != -1)
					pL-&gt;points.at(j).toIds.at(jj) = id;
			}
		}
	}

	//Link Lanes and lane's waypoints by pointers
	//For each lane, the previous code set the fromId as the id of the last waypoint of the previos lane.
	//here we fix that by finding from each fromID the corresponding point and replace the fromId by the LaneID associated with that point.
	for(unsigned int l= 0; l &lt; roadLanes.size(); l++)
	{
		for(unsigned int fp = 0; fp&lt; roadLanes.at(l).fromIds.size(); fp++)
		{
			roadLanes.at(l).fromIds.at(fp) = GetLaneIdByWaypointId(roadLanes.at(l).fromIds.at(fp), roadLanes);
		}

		for(unsigned int tp = 0; tp&lt; roadLanes.at(l).toIds.size(); tp++)
		{
			roadLanes.at(l).toIds.at(tp) = GetLaneIdByWaypointId(roadLanes.at(l).toIds.at(tp), roadLanes);
		}

		double sum_a = 0;
		for(unsigned int j = 0 ; j &lt; roadLanes.at(l).points.size(); j++)
		{
			sum_a += roadLanes.at(l).points.at(j).pos.a;
		}
		roadLanes.at(l).dir = sum_a/(double)roadLanes.at(l).points.size();
	}

	//map has one road segment
	RoadSegment roadSegment1;
	roadSegment1.id = 1;
	roadSegment1.Lanes = roadLanes;
	map.roadSegments.push_back(roadSegment1);

	//Link Lanes and lane's waypoints by pointers
	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
	{
		//Link Lanes
		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
		{
			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
			for(unsigned int j = 0 ; j &lt; pL-&gt;fromIds.size(); j++)
			{
				for(unsigned int l= 0; l &lt; map.roadSegments.at(rs).Lanes.size(); l++)
				{
					if(map.roadSegments.at(rs).Lanes.at(l).id == pL-&gt;fromIds.at(j))
					{
						pL-&gt;fromLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(l));
					}
				}
			}

			for(unsigned int j = 0 ; j &lt; pL-&gt;toIds.size(); j++)
			{
				for(unsigned int l= 0; l &lt; map.roadSegments.at(rs).Lanes.size(); l++)
				{
					if(map.roadSegments.at(rs).Lanes.at(l).id == pL-&gt;toIds.at(j))
					{
						pL-&gt;toLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(l));
					}
				}
			}

			for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
			{
				pL-&gt;points.at(j).pLane  = pL;
			}

#ifdef FIND_LEFT_RIGHT_LANES
			//Link left and right lanes
			for(unsigned int rs_2 = 0; rs_2 &lt; map.roadSegments.size(); rs_2++)
			{
				for(unsigned int i2 =0; i2 &lt; map.roadSegments.at(rs_2).Lanes.size(); i2++)
				{
					int iCenter1 = pL-&gt;points.size()/2;
					WayPoint wp_1 = pL-&gt;points.at(iCenter1);
					int iCenter2 = PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs_2).Lanes.at(i2).points, wp_1 );
					WayPoint closest_p = map.roadSegments.at(rs_2).Lanes.at(i2).points.at(iCenter2);
					double mid_a1 = wp_1.pos.a;
					double mid_a2 = closest_p.pos.a;
					double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(mid_a1, mid_a2);
					double distance = distance2points(wp_1.pos, closest_p.pos);

					if(pL-&gt;id != map.roadSegments.at(rs_2).Lanes.at(i2).id &amp;&amp; angle_diff &lt; 0.05 &amp;&amp; distance &lt; 3.5 &amp;&amp; distance &gt; 2.5)
					{
						double perp_distance = 99999;
						if(pL-&gt;points.size() &gt; 2 &amp;&amp; map.roadSegments.at(rs_2).Lanes.at(i2).points.size()&gt;2)
						{
							RelativeInfo info;
							PlanningHelpers::GetRelativeInfo(pL-&gt;points, closest_p, info);
							perp_distance = info.perp_distance;
							//perp_distance = PlanningHelpers::GetPerpDistanceToVectorSimple(pL-&gt;points.at(iCenter1-1), pL-&gt;points.at(iCenter1+1), closest_p);
						}

						if(perp_distance &gt; 1.0 &amp;&amp; perp_distance &lt; 10.0)
						{
							pL-&gt;pRightLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
							{
								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
								{
									pL-&gt;points.at(i_internal).RightLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
									pL-&gt;points.at(i_internal).pRight = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pLeft = &amp;pL-&gt;points.at(i_internal);
								}
							}
						}
						else if(perp_distance &lt; -1.0 &amp;&amp; perp_distance &gt; -10.0)
						{
							pL-&gt;pLeftLane = &amp;map.roadSegments.at(rs_2).Lanes.at(i2);
							for(unsigned int i_internal = 0; i_internal&lt; pL-&gt;points.size(); i_internal++)
							{
								if(i_internal&lt;map.roadSegments.at(rs_2).Lanes.at(i2).points.size())
								{
									pL-&gt;points.at(i_internal).LeftLaneId = map.roadSegments.at(rs_2).Lanes.at(i2).id;
									pL-&gt;points.at(i_internal).pLeft = &amp;map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal);
//									map.roadSegments.at(rs_2).Lanes.at(i2).points.at(i_internal).pRight = &amp;pL-&gt;points.at(i_internal);
								}
							}
						}
					}
				}
			}
#endif
		}
	}

	//Extract Signals and StopLines
	// Signals
	for(unsigned int is=0; is&lt; signal_data.size(); is++)
	{
		if(signal_data.at(is).Type == 2)
		{
			TrafficLight tl;
			tl.id = signal_data.at(is).ID;
			tl.stoppingDistance = 0;

			for(unsigned int iv = 0; iv &lt; vector_data.size(); iv++)
			{
				if(signal_data.at(is).VID == vector_data.at(iv).VID)
				{
					for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
					{
						if(vector_data.at(iv).PID == points_data.at(ip).PID)
						{
							tl.pos = GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, vector_data.at(iv).Hang*DEG2RAD);
							break;
						}
					}
				}
			}
			map.trafficLights.push_back(tl);
		}
	}

	//Stop Lines
	for(unsigned int ist=0; ist &lt; stop_line_data.size(); ist++)
	{
		StopLine sl;
		sl.id = stop_line_data.at(ist).ID;

		for(unsigned int il=0; il &lt; line_data.size(); il++)
		{
			if(stop_line_data.at(ist).LID == line_data.at(il).LID)
			{
				int s_id = line_data.at(il).BPID;
				int e_id = line_data.at(il).FPID;
				for(unsigned int ip = 0; ip &lt; points_data.size(); ip++)
				{
					if(points_data.at(ip).PID == s_id || points_data.at(ip).PID == e_id)
					{
						sl.points.push_back(GPSPoint(points_data.at(ip).Ly + origin.x, points_data.at(ip).Bx + origin.y, points_data.at(ip).H + origin.z, 0));
					}
				}
			}
		}
		map.stopLines.push_back(sl);
	}

	//Link waypoints &amp;&amp; StopLines
	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
	{
		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
		{
			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
			{
				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
				for(unsigned int j = 0 ; j &lt; pWP-&gt;toIds.size(); j++)
				{
					pWP-&gt;pFronts.push_back(FindWaypoint(pWP-&gt;toIds.at(j), map));
				}
			}

			for(unsigned int ic = 0; ic &lt; conn_data.size(); ic++)
			{
				UtilityHNS::AisanDataConnFileReader::DataConn data_conn = conn_data.at(ic);
				ReplaceMyID(data_conn.LID , id_replace_list);

				if(map.roadSegments.at(rs).Lanes.at(i).id == data_conn.LID)
				{
					for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
					{
						if(map.trafficLights.at(itl).id == data_conn.SID)
						{
							map.trafficLights.at(itl).laneIds.push_back(map.roadSegments.at(rs).Lanes.at(i).id);
							map.trafficLights.at(itl).pLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(i));
							map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
						}
					}

					for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
					{
						if(map.stopLines.at(isl).id == data_conn.SLID)
						{
							map.stopLines.at(isl).laneId = map.roadSegments.at(rs).Lanes.at(i).id;
							map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
							map.stopLines.at(isl).trafficLightID = data_conn.SID;
							map.stopLines.at(isl).stopSignID = data_conn.SSID;
							map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
							WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
							map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
						}
					}
				}
			}

		}
	}

	cout &lt;&lt; &quot;Map loaded from data with &quot; &lt;&lt; roadLanes.size()  &lt;&lt; &quot; lanes&quot; &lt;&lt; endl;
}

WayPoint* MappingHelpers::FindWaypoint(const int&amp; id, RoadNetwork&amp; map)
{
	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
	{
		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
		{
			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
			{
				if(map.roadSegments.at(rs).Lanes.at(i).points.at(p).id == id)
					return &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
			}
		}
	}

	return 0;
}

void MappingHelpers::ConstructRoadNetworkFromDataFiles(const std::string vectoMapPath, RoadNetwork&amp; map, const bool&amp; bZeroOrigin)
{
	/**
	 * Exporting the center lines
	 */
	string laneLinesDetails = vectoMapPath + &quot;point.csv&quot;;
	string center_lines_info = vectoMapPath + &quot;dtlane.csv&quot;;
	string lane_info = vectoMapPath + &quot;lane.csv&quot;;
	string node_info = vectoMapPath + &quot;node.csv&quot;;
	string area_info = vectoMapPath + &quot;area.csv&quot;;
	string line_info = vectoMapPath + &quot;line.csv&quot;;
	string signal_info = vectoMapPath + &quot;signaldata.csv&quot;;
	string stop_line_info = vectoMapPath + &quot;stopline.csv&quot;;
	string vector_info = vectoMapPath + &quot;vector.csv&quot;;
	string conn_info = vectoMapPath + &quot;dataconnection.csv&quot;;

	string intersection_info = vectoMapPath + &quot;intersection.csv&quot;;

	AisanCenterLinesFileReader  center_lanes(center_lines_info);
	AisanLanesFileReader lanes(lane_info);
	AisanPointsFileReader points(laneLinesDetails);
	AisanNodesFileReader nodes(node_info);
	AisanLinesFileReader lines(line_info);
	AisanStopLineFileReader stop_line(stop_line_info);
	AisanSignalFileReader signal(signal_info);
	AisanVectorFileReader vec(vector_info);
	AisanDataConnFileReader conn(conn_info);

	//AisanAreasFileReader areas(node_info);
	//AisanIntersectionFileReader intersections(node_info);



	vector&lt;AisanNodesFileReader::AisanNode&gt; nodes_data;
	nodes.ReadAllData(nodes_data);

	vector&lt;AisanLanesFileReader::AisanLane&gt; lanes_data;
	lanes.ReadAllData(lanes_data);

	vector&lt;AisanPointsFileReader::AisanPoints&gt; points_data;
	points.ReadAllData(points_data);

	vector&lt;AisanCenterLinesFileReader::AisanCenterLine&gt; dt_data;
	center_lanes.ReadAllData(dt_data);

	vector&lt;AisanAreasFileReader::AisanArea&gt; area_data;
	vector&lt;AisanIntersectionFileReader::AisanIntersection&gt; intersection_data;
	vector&lt;AisanLinesFileReader::AisanLine&gt; line_data;
	lines.ReadAllData(line_data);
	vector&lt;AisanStopLineFileReader::AisanStopLine&gt; stop_line_data;
	stop_line.ReadAllData(stop_line_data);
	vector&lt;AisanSignalFileReader::AisanSignal&gt; signal_data;
	signal.ReadAllData(signal_data);
	vector&lt;AisanVectorFileReader::AisanVector&gt; vector_data;
	vec.ReadAllData(vector_data);
	vector&lt;AisanDataConnFileReader::DataConn&gt; conn_data;
	conn.ReadAllData(conn_data);

	//Traffic Light Type from the file
	// 4 , 5 -&gt; pedestrian crossing light
	// 1 Red , 2 Green, 3 Yellow -&gt; traffic light that is important for cars (normal traffic lights )


	int bToyotaCityMap = 0;
	if((vectoMapPath.find(&quot;toyota&quot;) &gt;= 0 || vectoMapPath.find(&quot;Toyota&quot;) &gt;= 0) &amp;&amp; !bZeroOrigin)
		bToyotaCityMap = 1;
	else if((vectoMapPath.find(&quot;moriyama&quot;) &gt;= 0 || vectoMapPath.find(&quot;Moriyama&quot;) &gt;= 0) &amp;&amp; ! bZeroOrigin)
		bToyotaCityMap = 2;

	// use this to transform data to origin (0,0,0)
	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data, line_data, stop_line_data, signal_data, vector_data,conn_data, GetTransformationOrigin(bToyotaCityMap), map, bToyotaCityMap == 1);

	//use this when using the same coordinates as the map
//	ConstructRoadNetworkFromRosMessage(lanes_data, points_data, dt_data, intersection_data, area_data, GPSPoint(), map);



	WayPoint origin = GetFirstWaypoint(map);
//	WayPoint origin2 = GetFirstWaypoint(map);
//	WayPoint lastPoint2 = lastPoint;
//
//	llaToxyz(origin.pos, GPSPoint());
//	llaToxyz(lastPoint.pos, GPSPoint());
//
//	double distance = distance2points(origin.pos, lastPoint.pos);
//
	cout &lt;&lt; origin.pos.ToString() ;
//
//
//	geo_pos_conv geo;
//	geo.set_plane(6);
//	geo.llh_to_xyz(origin2.pos.lon, origin2.pos.lat, 0);
//
//	origin2.pos.x = geo.x();
//	origin2.pos.y = geo.y();
//
//	geo.llh_to_xyz(lastPoint2.pos.lon, lastPoint2.pos.lat, 0);
//
//	lastPoint2.pos.x = geo.x();
//	lastPoint2.pos.y = geo.y();
//
//	double distance2 = distance2points(origin2.pos, lastPoint2.pos);
//	cout &lt;&lt; origin2.pos.ToString() ;

}

void MappingHelpers::SaveTrajectoryLonLatToKMLFile(const string&amp; fileName, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; trajectory)
  {
  	vector&lt;vector&lt;string&gt; &gt; m_str_kml;

  	for(unsigned l = 0 ; l &lt; trajectory.size(); l++)
  	{
  		vector&lt;string&gt;  lane_str_kml;
		for(unsigned k = 0 ; k &lt; trajectory.at(l).size(); k++)
		{
			ostringstream gps_str;
			gps_str.precision(12);
			GPSPoint gps_p = trajectory.at(l).at(k).pos;
			gps_str &lt;&lt; gps_p.x &lt;&lt; &quot;,&quot; &lt;&lt; gps_p.y &lt;&lt; &quot;,&quot; &lt;&lt; gps_p.z;
			lane_str_kml.push_back(gps_str.str());
		}
		m_str_kml.push_back(lane_str_kml);
  	}

  	if(m_str_kml.size() &gt; 0)
  		DataRW::WriteKMLFile(fileName, m_str_kml);
  }

void MappingHelpers::GetWayPoint(const int&amp; pid, const vector&lt;AisanPointsFileReader::AisanPoints&gt;&amp; points, std::vector&lt;WayPoint&gt;&amp; path)
{

	for(unsigned int p =0; p &lt; points.size(); p++)
	{
		if(pid == points.at(p).PID)
		{
			WayPoint wp;
			wp.laneId = points.at(p).PID;
			wp.pos = GPSPoint(points.at(p).L, points.at(p).B, points.at(p).H, 0);
			path.push_back(wp);
			break;
		}
	}
}

bool MappingHelpers::GetWayPoint(const int&amp; id, const int&amp; laneID,const double&amp; refVel, const int&amp; did,
		const std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt;&amp; dtpoints,
		const std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt;&amp; points,
		const GPSPoint&amp; origin, WayPoint&amp; way_point)
{

	for(unsigned int dtp =0; dtp &lt; dtpoints.size(); dtp++)
	{
		if(dtpoints.at(dtp).DID == did)
		{
			for(unsigned int p =0; p &lt; points.size(); p++)
			{
				if(dtpoints.at(dtp).PID == points.at(p).PID)
				{
					WayPoint wp;
					wp.id = id;
					wp.laneId = laneID;
					wp.v = refVel;
//					double integ_part = points.at(p).L;
//					double deg = trunc(points.at(p).L);
//					double min = trunc((points.at(p).L - deg) * 100.0) / 60.0;
//					double sec = modf((points.at(p).L - deg) * 100.0, &amp;integ_part)/36.0;
//					double L =  deg + min + sec;
//
//					deg = trunc(points.at(p).B);
//					min = trunc((points.at(p).B - deg) * 100.0) / 60.0;
//					sec = modf((points.at(p).B - deg) * 100.0, &amp;integ_part)/36.0;
//					double B = deg + min + sec;

					wp.pos = GPSPoint(points.at(p).Ly + origin.x, points.at(p).Bx + origin.y, points.at(p).H + origin.z, dtpoints.at(dtp).Dir);


					wp.pos.lat = points.at(p).L;
					wp.pos.lon = points.at(p).B;
					wp.pos.alt = points.at(p).H;
					wp.pos.dir = dtpoints.at(dtp).Dir;


					way_point = wp;
					return 1;
				}
			}
		}
	}

	return 0;
}

void MappingHelpers::LoadKML(const std::string&amp; kmlFile, RoadNetwork&amp; map)
{
	//First, Get the main element
	TiXmlElement* pHeadElem = 0;
	TiXmlElement* pElem = 0;

	ifstream f(kmlFile.c_str());
	if(!f.good())
	{
		cout &lt;&lt; &quot;Can't Open KML Map File: (&quot; &lt;&lt; kmlFile &lt;&lt; &quot;)&quot; &lt;&lt; endl;
		return;
	}

	TiXmlDocument doc(kmlFile);
	try
	{
		doc.LoadFile();
	}
	catch(exception&amp; e)
	{
		cout &lt;&lt; &quot;KML Custom Reader Error, Can't Load .kml File, path is: &quot;&lt;&lt;  kmlFile &lt;&lt; endl;
		cout &lt;&lt; e.what() &lt;&lt; endl;
		return;
	}


	pElem = doc.FirstChildElement();
	pHeadElem = GetHeadElement(pElem);

	vector&lt;Lane&gt; laneLinksList = GetLanesList(pHeadElem);
	vector&lt;RoadSegment&gt; roadLinksList = GetRoadSegmentsList(pHeadElem);
	vector&lt;StopLine&gt; stopLines = GetStopLinesList(pHeadElem);
	vector&lt;TrafficLight&gt; trafficLights = GetTrafficLightsList(pHeadElem);


	//Fill the relations
	for(unsigned int i= 0; i&lt;roadLinksList.size(); i++ )
	{
		for(unsigned int j=0; j &lt; laneLinksList.size(); j++)
		{
			//if(laneLinksList.at(j).roadId == roadLinksList.at(i).id)
			{
#ifdef SMOOTH_MAP_WAYPOINTS
				PlanningHelpers::SmoothPath(laneLinksList.at(j).points, 0.49, 0.15 , 0.01);
#endif
				PlanningHelpers::CalcAngleAndCost(laneLinksList.at(j).points);
				roadLinksList.at(i).Lanes.push_back(laneLinksList.at(j));
			}
		}
	}

	map.roadSegments.clear();
	map.roadSegments = roadLinksList;

	//Link Lanes and lane's waypoints by pointers
	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
	{
		//Link Lanes
		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
		{
			Lane* pL = &amp;map.roadSegments.at(rs).Lanes.at(i);
			for(unsigned int j = 0 ; j &lt; pL-&gt;fromIds.size(); j++)
			{
				for(unsigned int l= 0; l &lt; map.roadSegments.at(rs).Lanes.size(); l++)
				{
					if(map.roadSegments.at(rs).Lanes.at(l).id == pL-&gt;fromIds.at(j))
					{
						pL-&gt;fromLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(l));
					}
				}
			}

			for(unsigned int j = 0 ; j &lt; pL-&gt;toIds.size(); j++)
			{
				for(unsigned int l= 0; l &lt; map.roadSegments.at(rs).Lanes.size(); l++)
				{
					if(map.roadSegments.at(rs).Lanes.at(l).id == pL-&gt;toIds.at(j))
					{
						pL-&gt;toLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(l));
					}
				}
			}

			for(unsigned int j = 0 ; j &lt; pL-&gt;points.size(); j++)
			{
				pL-&gt;points.at(j).pLane  = pL;
			}
		}
	}

	//Link waypoints
	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
	{
		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
		{
			for(unsigned int p= 0; p &lt; map.roadSegments.at(rs).Lanes.at(i).points.size(); p++)
			{
				WayPoint* pWP = &amp;map.roadSegments.at(rs).Lanes.at(i).points.at(p);
				for(unsigned int j = 0 ; j &lt; pWP-&gt;toIds.size(); j++)
				{
					pWP-&gt;pFronts.push_back(FindWaypoint(pWP-&gt;toIds.at(j), map));
					if(pWP-&gt;LeftLaneId &gt; 0)
					{
						pWP-&gt;pLeft = FindWaypoint(pWP-&gt;LeftLaneId, map);
						if(pWP-&gt;pLeft)
						{
							pWP-&gt;LeftLaneId = pWP-&gt;pLeft-&gt;laneId;
							pWP-&gt;pLane-&gt;pLeftLane = pWP-&gt;pLeft-&gt;pLane;
						}
					}

					if(pWP-&gt;RightLaneId &gt; 0)
					{
						pWP-&gt;pRight = FindWaypoint(pWP-&gt;RightLaneId, map);
						if(pWP-&gt;pRight)
						{
							pWP-&gt;RightLaneId = pWP-&gt;pRight-&gt;laneId;
							pWP-&gt;pLane-&gt;pRightLane = pWP-&gt;pRight-&gt;pLane;
						}
					}
				}
			}
		}
	}

	map.stopLines = stopLines;
	map.trafficLights = trafficLights;

	//Link waypoints &amp;&amp; StopLines
	for(unsigned int rs = 0; rs &lt; map.roadSegments.size(); rs++)
	{
		for(unsigned int i =0; i &lt; map.roadSegments.at(rs).Lanes.size(); i++)
		{
			for(unsigned int itl = 0; itl &lt; map.trafficLights.size(); itl++)
			{
				if(map.trafficLights.at(itl).CheckLane(map.roadSegments.at(rs).Lanes.at(i).id))
				{
					map.trafficLights.at(itl).pLanes.push_back(&amp;map.roadSegments.at(rs).Lanes.at(i));
					map.roadSegments.at(rs).Lanes.at(i).trafficlights.push_back(map.trafficLights.at(itl));
				}
			}

			for(unsigned int isl = 0; isl &lt; map.stopLines.size(); isl++)
			{
				if(map.stopLines.at(isl).laneId == map.roadSegments.at(rs).Lanes.at(i).id)
				{
					map.stopLines.at(isl).pLane = &amp;map.roadSegments.at(rs).Lanes.at(i);
					map.roadSegments.at(rs).Lanes.at(i).stopLines.push_back(map.stopLines.at(isl));
					WayPoint wp((map.stopLines.at(isl).points.at(0).x+map.stopLines.at(isl).points.at(1).x)/2.0, (map.stopLines.at(isl).points.at(0).y+map.stopLines.at(isl).points.at(1).y)/2.0, (map.stopLines.at(isl).points.at(0).z+map.stopLines.at(isl).points.at(1).z)/2.0, (map.stopLines.at(isl).points.at(0).a+map.stopLines.at(isl).points.at(1).a)/2.0);
					map.roadSegments.at(rs).Lanes.at(i).points.at(PlanningHelpers::GetClosestNextPointIndex(map.roadSegments.at(rs).Lanes.at(i).points, wp)).stopLineID = map.stopLines.at(isl).id;
				}
			}
		}
	}

	cout &lt;&lt; &quot;Map loaded from kml file with (&quot; &lt;&lt; laneLinksList.size()  &lt;&lt; &quot;) lanes, First Point ( &quot; &lt;&lt; GetFirstWaypoint(map).pos.ToString() &lt;&lt; &quot;)&quot;&lt;&lt; endl;

}

void MappingHelpers::WriteKML(const string&amp; kmlFile, const string&amp; kmlTemplat, RoadNetwork&amp; map)
{
	//First, Get the main element
	TiXmlElement* pHeadElem = 0;
	TiXmlElement* pElem = 0;

	ifstream f(kmlTemplat.c_str());
	if(!f.good())
	{
		cout &lt;&lt; &quot;Can't Open KML Template File: (&quot; &lt;&lt; kmlFile &lt;&lt; &quot;)&quot; &lt;&lt; endl;
		return;
	}

	TiXmlDocument doc(kmlTemplat);
	if(!doc.LoadFile())
	{
		cout &lt;&lt; doc.ErrorDesc() &lt;&lt; endl;
	}
	else
		pElem = doc.FirstChildElement();

	pHeadElem = GetHeadElement(pElem);

	vector&lt;Lane&gt; allLanes;
	vector&lt;RoadSegment&gt; roadSegments;

	for(unsigned int j=0; j&lt; map.roadSegments.size(); j++)
	{
		allLanes.insert(allLanes.end(), map.roadSegments.at(j).Lanes.begin(),
				map.roadSegments.at(j).Lanes.end());
		roadSegments.push_back(map.roadSegments.at(j));
	}

	SetLaneLinksList(pHeadElem, allLanes);
	SetRoadLinksList(pHeadElem, roadSegments);
	SetStopLinesList(pHeadElem, map.stopLines);
	SetTrafficLightsList(pHeadElem, map.trafficLights);

	doc.SaveFile(kmlFile.c_str());
}

TiXmlElement* MappingHelpers::GetHeadElement(TiXmlElement* pMainElem)
{
	TiXmlElement* pElem = pMainElem;
	if(pElem)
		pElem = pElem-&gt;FirstChildElement(&quot;Folder&quot;);
	if(pElem &amp;&amp; pElem-&gt;FirstChildElement(&quot;Folder&quot;))
		pElem = pElem-&gt;FirstChildElement(&quot;Folder&quot;);
	if(pElem &amp;&amp; pElem-&gt;FirstChildElement(&quot;Document&quot;))
		pElem = pElem-&gt;FirstChildElement(&quot;Document&quot;);

	if(!pElem)
		return 0;
	return pElem;
}

TiXmlElement* MappingHelpers::GetDataFolder(const string&amp; folderName, TiXmlElement* pMainElem)
{
	if(!pMainElem) return 0;

	TiXmlElement* pElem = pMainElem-&gt;FirstChildElement(&quot;Folder&quot;);

	string folderID=&quot;&quot;;
	for(; pElem; pElem=pElem-&gt;NextSiblingElement())
	{
		folderID=&quot;&quot;;
		if(pElem-&gt;FirstChildElement(&quot;name&quot;)-&gt;GetText()) //Map Name
			folderID = pElem-&gt;FirstChildElement(&quot;name&quot;)-&gt;GetText();
		if(folderID.compare(folderName)==0)
			return pElem;
	}
	return 0;
}

void MappingHelpers::SetLaneLinksList(TiXmlElement* pElem, vector&lt;Lane&gt;&amp; lanes)
{
	TiXmlElement* pLaneLinks = GetDataFolder(&quot;Lanes&quot;, pElem);
	TiXmlNode* pE = pLaneLinks-&gt;FirstChild(&quot;Folder&quot;);
	TiXmlNode* pN = pE;
	TiXmlText * pText = 0;
	TiXmlElement* pElement = 0;
	int roadId = -1;
	int roadsCount = 0;

	if(lanes.size() ==0)
		pE-&gt;Clear();

	for(unsigned int i=0; i&lt; lanes.size(); i++)
	{
		Lane* pLane = &amp;lanes.at(i);

		if(pLane-&gt;roadId != roadId)
		{
			roadId = pLane-&gt;roadId;
			roadsCount++;
		}

		if(i&gt;0)
			pN = pE-&gt;Clone();

		ostringstream name, desc;
		name &lt;&lt; &quot;LID_&quot; &lt;&lt; pLane-&gt;id;
		pElement = pN-&gt;FirstChild(&quot;name&quot;)-&gt;ToElement();
		pText = new TiXmlText(name.str());
		pElement-&gt;Clear();
		pElement-&gt;LinkEndChild(pText);

		desc &lt;&lt; &quot;LID_&quot; &lt;&lt; pLane-&gt;id &lt;&lt; &quot;_RSID_&quot; &lt;&lt; pLane-&gt;roadId &lt;&lt; &quot;_NUM_&quot; &lt;&lt; pLane-&gt;num &lt;&lt; &quot;_From_&quot;;
		for(unsigned int j=0; j&lt; pLane-&gt;fromIds.size(); j++)
			desc &lt;&lt; pLane-&gt;fromIds.at(j) &lt;&lt; &quot;_&quot;;

		desc &lt;&lt; &quot;To&quot;;
		for(unsigned int j=0; j&lt; pLane-&gt;toIds.size(); j++)
			desc &lt;&lt; &quot;_&quot; &lt;&lt; pLane-&gt;toIds.at(j);

		desc &lt;&lt; &quot;_Vel_&quot; &lt;&lt; pLane-&gt;speed;

		pElement = pN-&gt;FirstChild(&quot;description&quot;)-&gt;ToElement();
		pText = new TiXmlText(desc.str());
		pElement-&gt;Clear();
		pElement-&gt;LinkEndChild(pText);

		ostringstream style;
		pElement = pN-&gt;FirstChild(&quot;Placemark&quot;)-&gt;FirstChild(&quot;styleUrl&quot;)-&gt;ToElement();
		style &lt;&lt; &quot;#mms_route_line_&quot; &lt;&lt; roadsCount%4;
		pText = new TiXmlText(style.str());
		pElement-&gt;Clear();
		pElement-&gt;LinkEndChild(pText);


		pElement = pN-&gt;FirstChild(&quot;Placemark&quot;)-&gt;FirstChild(&quot;LineString&quot;)-&gt;FirstChild(&quot;coordinates&quot;)-&gt;ToElement();

		ostringstream val;
		val.precision(18);

		for(unsigned int j =0; j &lt; pLane-&gt;points.size() ; j++)
		{
			GPSPoint p = pLane-&gt;points.at(j).pos;
			val &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;,&quot; &lt;&lt; p.z &lt;&lt;  &quot; &quot;;
		}

		pText = new TiXmlText(val.str());
		pElement-&gt;Clear();
		pElement-&gt;LinkEndChild(pText);

		TiXmlNode* pWPNode = pN-&gt;FirstChild(&quot;Folder&quot;);
		TiXmlNode* pWPNodeCopy =  pWPNode;

		ostringstream valInfo;
		for(unsigned int j =0; j &lt; pLane-&gt;points.size() ; j++)
		{
			char action = 'F';
			int cost = 0;

			if(pLane-&gt;points.at(j).actionCost.size() &gt; 0)
			{
				if(pLane-&gt;points.at(j).actionCost.at(0).first == FORWARD_ACTION)
					action = 'F';
				else if(pLane-&gt;points.at(j).actionCost.at(0).first == LEFT_TURN_ACTION)
					action = 'L';
				else if(pLane-&gt;points.at(j).actionCost.at(0).first == RIGHT_TURN_ACTION)
					action = 'R';

				cost = 	pLane-&gt;points.at(j).actionCost.at(0).second;
			}

if(m_USING_VER_ZERO == 1)
{
			valInfo &lt;&lt; &quot;WPID_&quot; &lt;&lt; pLane-&gt;points.at(j).id
					&lt;&lt; &quot;_C_&quot; &lt;&lt; action &lt;&lt; &quot;_&quot; &lt;&lt; cost &lt;&lt; &quot;_From_&quot;;

			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).fromIds.size(); k++)
				valInfo &lt;&lt; pLane-&gt;points.at(j).fromIds.at(k) &lt;&lt; &quot;_&quot;;

			valInfo &lt;&lt; &quot;To&quot;;
			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).toIds.size(); k++)
				valInfo &lt;&lt; &quot;_&quot; &lt;&lt; pLane-&gt;points.at(j).toIds.at(k);

}
else
{
			valInfo &lt;&lt; &quot;WPID_&quot; &lt;&lt; pLane-&gt;points.at(j).id
					&lt;&lt; &quot;_AC_&quot; &lt;&lt; action &lt;&lt; &quot;_&quot; &lt;&lt; cost &lt;&lt; &quot;_From_&quot;;

			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).fromIds.size(); k++)
				valInfo &lt;&lt; pLane-&gt;points.at(j).fromIds.at(k) &lt;&lt; &quot;_&quot;;

			valInfo &lt;&lt; &quot;To&quot;;
			for(unsigned int k=0; k&lt; pLane-&gt;points.at(j).toIds.size(); k++)
				valInfo &lt;&lt; &quot;_&quot; &lt;&lt; pLane-&gt;points.at(j).toIds.at(k);

			if(pLane-&gt;points.at(j).pLeft)
				valInfo &lt;&lt; &quot;_Lid_&quot; &lt;&lt; pLane-&gt;points.at(j).pLeft-&gt;id;
			else
				valInfo &lt;&lt; &quot;_Lid_&quot; &lt;&lt; 0;

			if(pLane-&gt;points.at(j).pRight)
				valInfo &lt;&lt; &quot;_Rid_&quot; &lt;&lt; pLane-&gt;points.at(j).pRight-&gt;id;
			else
				valInfo &lt;&lt; &quot;_Rid_&quot; &lt;&lt; 0;
}

			valInfo &lt;&lt; &quot;_Vel_&quot; &lt;&lt; pLane-&gt;points.at(j).v;
			valInfo &lt;&lt; &quot;_Dir_&quot; &lt;&lt; pLane-&gt;points.at(j).pos.a;

			valInfo &lt;&lt; &quot;,&quot;;
		}

		TiXmlElement* pWPElem = pWPNodeCopy-&gt;FirstChild(&quot;description&quot;)-&gt;ToElement();
		pText = new TiXmlText(valInfo.str());
		pWPElem-&gt;Clear();
		pWPElem-&gt;LinkEndChild(pText);

		if(i&gt;0)
			pLaneLinks-&gt;InsertEndChild(*pN);
	}
}

void MappingHelpers::SetRoadLinksList(TiXmlElement* pElem, vector&lt;RoadSegment&gt;&amp; roadSegments)
{
	TiXmlElement* pRoadLinks = GetDataFolder(&quot;RoadSegments&quot;, pElem);
	TiXmlNode* pE = pRoadLinks-&gt;FirstChild(&quot;Placemark&quot;);
	TiXmlNode* pN = pE;
	TiXmlText * pText = 0;
	TiXmlElement* pElement = 0;

	if(roadSegments.size() ==0)
		pE-&gt;Clear();

	for(unsigned int i=0; i&lt; roadSegments.size(); i++)
	{
		RoadSegment* pRS = &amp;roadSegments.at(i);

		if(i&gt;0)
			pN = pE-&gt;Clone();

		ostringstream name, desc;
		name &lt;&lt; &quot;RSID_&quot; &lt;&lt; pRS-&gt;id;
		pElement = pN-&gt;FirstChild(&quot;name&quot;)-&gt;ToElement();
		pElement-&gt;Clear();
		pText = new TiXmlText(name.str());
		pElement-&gt;LinkEndChild(pText);

		desc &lt;&lt; &quot;RSID_&quot; &lt;&lt; pRS-&gt;id;
		pElement = pN-&gt;FirstChild(&quot;description&quot;)-&gt;ToElement();
		pElement-&gt;Clear();
		pText = new TiXmlText(desc.str());
		pElement-&gt;LinkEndChild(pText);
		if(i&gt;0)
			pRoadLinks-&gt;InsertEndChild(*pN);
	}
}

void MappingHelpers::SetStopLinesList(TiXmlElement* pElem, std::vector&lt;StopLine&gt;&amp; stopLines)
{
	TiXmlElement* pStopLiness = GetDataFolder(&quot;StopLines&quot;, pElem);
	TiXmlNode* pE = pStopLiness-&gt;FirstChild(&quot;Placemark&quot;);
	TiXmlNode* pN = pE;
	TiXmlText * pText = 0;
	TiXmlElement* pElement = 0;

	if(stopLines.size() ==0)
		pE-&gt;Clear();

	for(unsigned int i=0; i&lt; stopLines.size(); i++)
	{
		StopLine* pSL = &amp;stopLines.at(i);
		if(i&gt;0)
			pN = pE-&gt;Clone();

		ostringstream name, desc;
		name &lt;&lt; &quot;SLID_&quot; &lt;&lt; pSL-&gt;id &lt;&lt; &quot;_LnID_&quot; &lt;&lt; pSL-&gt;laneId &lt;&lt; &quot;_TSID_&quot; &lt;&lt; pSL-&gt;stopSignID &lt;&lt; &quot;_TLTID_&quot; &lt;&lt; pSL-&gt;trafficLightID;
		pElement = pN-&gt;FirstChild(&quot;name&quot;)-&gt;ToElement();
		pText = new TiXmlText(name.str());
		pElement-&gt;Clear();
		pElement-&gt;LinkEndChild(pText);


		pElement = pN-&gt;FirstChild(&quot;LineString&quot;)-&gt;FirstChild(&quot;coordinates&quot;)-&gt;ToElement();

		ostringstream val;
		val.precision(18);

		for(unsigned int j =0; j &lt; pSL-&gt;points.size() ; j++)
		{
			GPSPoint p = pSL-&gt;points.at(j);
			val &lt;&lt; p.x &lt;&lt; &quot;,&quot; &lt;&lt; p.y &lt;&lt; &quot;,&quot; &lt;&lt; p.z &lt;&lt;  &quot; &quot;;
		}

		pText = new TiXmlText(val.str());
		pElement-&gt;Clear();
		pElement-&gt;LinkEndChild(pText);

		if(i&gt;0)
			pStopLiness-&gt;InsertEndChild(*pN);
	}
}

void MappingHelpers::SetTrafficLightsList(TiXmlElement* pElem, std::vector&lt;TrafficLight&gt;&amp; trafficLights)
{
	TiXmlElement* pTrafficLights = GetDataFolder(&quot;TrafficLights&quot;, pElem);
	TiXmlNode* pE = pTrafficLights-&gt;FirstChild(&quot;Placemark&quot;);
	TiXmlNode* pN = pE;
	TiXmlText * pText = 0;
	TiXmlElement* pElement = 0;

	if(trafficLights.size() ==0)
		pE-&gt;Clear();

	for(unsigned int i=0; i&lt; trafficLights.size(); i++)
	{
		TrafficLight* pTL = &amp;trafficLights.at(i);
		if(i&gt;0)
			pN = pE-&gt;Clone();

		ostringstream name, desc;
		name &lt;&lt; &quot;TLID_&quot; &lt;&lt; pTL-&gt;id &lt;&lt; &quot;_LnID&quot;;
		for(unsigned int j=0; j&lt; pTL-&gt;laneIds.size(); j++)
			name &lt;&lt; &quot;_&quot; &lt;&lt; pTL-&gt;laneIds.at(j);

		pElement = pN-&gt;FirstChild(&quot;name&quot;)-&gt;ToElement();
		pText = new TiXmlText(name.str());
		pElement-&gt;Clear();
		pElement-&gt;LinkEndChild(pText);

		pElement = pN-&gt;FirstChild(&quot;Point&quot;)-&gt;FirstChild(&quot;coordinates&quot;)-&gt;ToElement();

		ostringstream val;
		val.precision(18);
		val &lt;&lt; pTL-&gt;pos.x &lt;&lt; &quot;,&quot; &lt;&lt; pTL-&gt;pos.y &lt;&lt; &quot;,&quot; &lt;&lt; pTL-&gt;pos.z &lt;&lt;  &quot; &quot;;

		pText = new TiXmlText(val.str());
		pElement-&gt;Clear();
		pElement-&gt;LinkEndChild(pText);

		if(i&gt;0)
			pTrafficLights-&gt;InsertEndChild(*pN);
	}
}

void MappingHelpers::SetTrafficSignsList(TiXmlElement* pElem, std::vector&lt;TrafficSign&gt;&amp; trafficSignes)
{

}

WayPoint* MappingHelpers::GetClosestWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map)
{
	double distance_to_nearest_lane = 1;
	Lane* pLane = 0;
	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
	{
		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane);
		distance_to_nearest_lane += 1;
	}

	if(!pLane) return 0;

	int closest_index = PlanningHelpers::GetClosestNextPointIndex(pLane-&gt;points, pos);

	return &amp;pLane-&gt;points.at(closest_index);
}

WayPoint* MappingHelpers::GetClosestBackWaypointFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map)
{
	double distance_to_nearest_lane = 1;
	Lane* pLane = 0;
	while(distance_to_nearest_lane &lt; 100 &amp;&amp; pLane == 0)
	{
		pLane = GetClosestLaneFromMap(pos, map, distance_to_nearest_lane);
		distance_to_nearest_lane += 1;
	}

	if(!pLane) return 0;

	int closest_index = PlanningHelpers::GetClosestNextPointIndex(pLane-&gt;points, pos);

	if(closest_index&gt;2)
		return &amp;pLane-&gt;points.at(closest_index-3);
	else if(closest_index&gt;1)
		return &amp;pLane-&gt;points.at(closest_index-2);
	else if(closest_index&gt;0)
		return &amp;pLane-&gt;points.at(closest_index-1);
	else
		return &amp;pLane-&gt;points.at(closest_index);
}

Lane* MappingHelpers::GetClosestLaneFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance)
{
	vector&lt;pair&lt;double, Lane*&gt; &gt; laneLinksList;
	double d = 0;
	double min_d = 9999999999;
	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
	{
		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
		{
			//Lane* pLane = &amp;pEdge-&gt;lanes.at(k);
			 d = 0;
			min_d = 9999999999;
			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
			{

				d = distance2points(map.roadSegments.at(j).Lanes.at(k).points.at(pindex).pos, pos.pos);
				if(d &lt; min_d)
					min_d = d;
			}

			if(min_d &lt; distance)
				laneLinksList.push_back(make_pair(min_d, &amp;map.roadSegments.at(j).Lanes.at(k)));
		}
	}

	if(laneLinksList.size() == 0) return 0;

	min_d = 999999999;
	Lane* closest_lane = 0;
	for(unsigned int i = 0; i &lt; laneLinksList.size(); i++)
	{
		RelativeInfo info;
		PlanningHelpers::GetRelativeInfo(laneLinksList.at(i).second-&gt;points, pos, info);

		if(info.perp_distance == 0 &amp;&amp; laneLinksList.at(i).first != 0)
			continue;

		if(fabs(info.perp_distance) &lt; min_d &amp;&amp; fabs(info.angle_diff) &lt; 45)
		{
			min_d = fabs(info.perp_distance);
			closest_lane = laneLinksList.at(i).second;
		}
	}

	return closest_lane;
}

Lane* MappingHelpers::GetClosestLaneFromMapDirectionBased(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance)
{
	vector&lt;pair&lt;double, WayPoint*&gt; &gt; laneLinksList;
	double d = 0;
	double min_d = 9999999999;
	int min_i = 0;
	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
	{
		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
		{
			//Lane* pLane = &amp;pEdge-&gt;lanes.at(k);
			d = 0;
			min_d = 9999999999;
			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
			{

				d = distance2points(map.roadSegments.at(j).Lanes.at(k).points.at(pindex).pos, pos.pos);
				if(d &lt; min_d)
				{
					min_d = d;
					min_i = pindex;
				}
			}

			if(min_d &lt; distance)
				laneLinksList.push_back(make_pair(min_d, &amp;map.roadSegments.at(j).Lanes.at(k).points.at(min_i)));
		}
	}

	if(laneLinksList.size() == 0) return 0;

	min_d = 999999999;
	Lane* closest_lane = 0;
	double a_diff = 0;
	for(unsigned int i = 0; i &lt; laneLinksList.size(); i++)
	{
		RelativeInfo info;
		PlanningHelpers::GetRelativeInfo(laneLinksList.at(i).second-&gt;pLane-&gt;points, pos, info);
		if(info.perp_distance == 0 &amp;&amp; laneLinksList.at(i).first != 0)
			continue;

		a_diff = UtilityH::AngleBetweenTwoAnglesPositive(laneLinksList.at(i).second-&gt;pos.a, pos.pos.a);

		if(fabs(info.perp_distance)&lt;min_d &amp;&amp; a_diff &lt;= M_PI_4)
		{
			min_d = fabs(info.perp_distance);
			closest_lane = laneLinksList.at(i).second-&gt;pLane;
		}
	}

	return closest_lane;
}


 std::vector&lt;Lane*&gt; MappingHelpers::GetClosestMultipleLanesFromMap(const WayPoint&amp; pos, RoadNetwork&amp; map, const double&amp; distance)
{
	vector&lt;Lane*&gt; lanesList;
	double d = 0;
	double a_diff = 0;
	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
	{
		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
		{
			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
			{
				d = distance2points(map.roadSegments.at(j).Lanes.at(k).points.at(pindex).pos, pos.pos);
				a_diff = UtilityH::AngleBetweenTwoAnglesPositive(map.roadSegments.at(j).Lanes.at(k).points.at(pindex).pos.a, pos.pos.a);

				if(d &lt;= distance &amp;&amp; a_diff &lt;= M_PI_4)
				{
					bool bLaneExist = false;
					for(unsigned int il = 0; il &lt; lanesList.size(); il++)
					{
						if(lanesList.at(il)-&gt;id == map.roadSegments.at(j).Lanes.at(k).id)
						{
							bLaneExist = true;
							break;
						}
					}

					if(!bLaneExist)
						lanesList.push_back(&amp;map.roadSegments.at(j).Lanes.at(k));

					break;
				}
			}
		}
	}

	return lanesList;
}

WayPoint MappingHelpers::GetFirstWaypoint(RoadNetwork&amp; map)
{
	for(unsigned int j=0; j&lt; map.roadSegments.size(); j ++)
	{
		for(unsigned int k=0; k&lt; map.roadSegments.at(j).Lanes.size(); k ++)
		{
			for(unsigned int pindex=0; pindex&lt; map.roadSegments.at(j).Lanes.at(k).points.size(); pindex ++)
			{
				WayPoint fp =  map.roadSegments.at(j).Lanes.at(k).points.at(pindex);
				return fp;
			}
		}
	}

	return WayPoint();
}

WayPoint* MappingHelpers::GetLastWaypoint(RoadNetwork&amp; map)
{
	if(map.roadSegments.size() &gt; 0 &amp;&amp; map.roadSegments.at(map.roadSegments.size()-1).Lanes.size() &gt; 0)
	{
		std::vector&lt;Lane&gt;* lanes = &amp;map.roadSegments.at(map.roadSegments.size()-1).Lanes;
		if(lanes-&gt;at(lanes-&gt;size()-1).points.size() &gt; 0)
			return &amp;lanes-&gt;at(lanes-&gt;size()-1).points.at(lanes-&gt;at(lanes-&gt;size()-1).points.size()-1);
	}

	return 0;
}


void MappingHelpers::llaToxyzSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset)
{
#ifdef ENABLE_GPS_CONVERSIONS
	projPJ pj_latlong, pj_utm;
	pj_latlong = pj_init_plus(&quot;+proj=latlong +ellps=WGS84&quot;);
	pj_utm = pj_init_plus(&quot;+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84&quot;);

	projUV p_gps;
	p_gps.u = lla_p.lon - netOffset.x;
	p_gps.v = lla_p.lat - netOffset.y;

	p_gps = pj_inv(p_gps, pj_utm);
	p_gps.u *= DEG2RAD;
	p_gps.v *= DEG2RAD;

	GPSPoint p = lla_p;
	p.x = p_gps.u;
	p.y = p_gps.v;

	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
	{
		pj_transform(pj_latlong, pj_utm, 1, 1, &amp;p.y, &amp;p.x, &amp;p.z);
		p.x += netOffset.x;
		p.y += netOffset.y;
	}

	lla_p = p;
#endif
}

void MappingHelpers::llaToxyz(GPSPoint&amp; lla_p, const GPSPoint&amp; origin)
{
#ifdef ENABLE_GPS_CONVERSIONS
	projPJ pj_latlong, pj_utm;
	pj_latlong = pj_init_plus(&quot;+proj=latlong +ellps=WGS84&quot;);
	pj_utm = pj_init_plus(&quot;+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84&quot;);

	GPSPoint p = lla_p;

	p.x = lla_p.lon * DEG2RAD;
	p.y = lla_p.lat * DEG2RAD;

	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
	{
		pj_transform(pj_latlong, pj_utm, 1, 1, &amp;p.y, &amp;p.x, &amp;p.z);
		p.x -= origin.x;
		p.y -= origin.y;
		p.z -= origin.z;
	}

	lla_p = p;
#endif

}

void MappingHelpers::xyzTollaSpecial(GPSPoint&amp; lla_p, const GPSPoint&amp; netOffset)
{
#ifdef ENABLE_GPS_CONVERSIONS
	projPJ pj_latlong, pj_utm;
	pj_latlong = pj_init_plus(&quot;+proj=latlong +ellps=WGS84&quot;);
	pj_utm = pj_init_plus(&quot;+proj=utm +zone=53 +ellps=WGS84 +datum=WGS84&quot;);

	projUV p_gps;
	p_gps.u = lla_p.y - netOffset.x;
	p_gps.v = lla_p.x - netOffset.y;

	p_gps = pj_inv(p_gps, pj_utm);
	p_gps.u *= RAD2DEG;
	p_gps.v *= RAD2DEG;

	GPSPoint p = lla_p;
	p.lon = p_gps.u;
	p.lat = p_gps.v;

	lla_p = p;
#endif
}

void MappingHelpers::xyzTolla(GPSPoint&amp; xyz_p, const GPSPoint&amp; origin)
{
#ifdef ENABLE_GPS_CONVERSIONS
	projPJ pj_latlong, pj_utm;
	pj_latlong = pj_init_plus(&quot;+proj=latlong +ellps=WGS84&quot;);
	pj_utm = pj_init_plus(&quot;+proj=utm +ellps=WGS84 +datum=WGS84 +units=m&quot;);

	GPSPoint p = xyz_p;

	if(pj_latlong != 0 &amp;&amp; pj_utm !=0 )
	{
		pj_transform(pj_utm,pj_latlong, 1, 1, &amp;p.lon, &amp;p.lat, &amp;p.alt);
		p.lon = p.lon * RAD2DEG;
		p.lat = p.lat * RAD2DEG;

		p.lon -= origin.lon;
		p.lat -= origin.lat;
		p.alt -= origin.alt;
	}

	xyz_p = p;
#endif

}

void MappingHelpers::GetUniqueNextLanes(const Lane* l,  const vector&lt;Lane*&gt;&amp; traversed_lanes, vector&lt;Lane*&gt;&amp; lanes_list)
{
	if(!l) return;

	for(unsigned int i=0; i&lt; l-&gt;toLanes.size(); i++)
	{
		bool bFound = false;
		for(unsigned int j = 0; j &lt; traversed_lanes.size(); j++)
		if(l-&gt;toLanes.at(i)-&gt;id == traversed_lanes.at(j)-&gt;id)
		{
			bFound = true;
			break;
		}

		if(!bFound)
			lanes_list.push_back(l-&gt;toLanes.at(i));
	}
}

Lane* MappingHelpers::GetLaneFromPath(const WayPoint&amp; currPos, const std::vector&lt;WayPoint&gt;&amp; currPath)
{
	if(currPath.size() &lt; 1) return 0;

	int closest_index = PlanningHelpers::GetClosestNextPointIndex(currPath, currPos);

	return currPath.at(closest_index).pLane;
}


std::vector&lt;StopLine&gt; MappingHelpers::GetStopLinesList(TiXmlElement* pElem)
{
	vector&lt;StopLine&gt; slList;
	TiXmlElement* pStopLines = GetDataFolder(&quot;StopLines&quot;, pElem);

	TiXmlElement* pE = pStopLines-&gt;FirstChildElement(&quot;Placemark&quot;);
	for( ; pE; pE=pE-&gt;NextSiblingElement())
	{
		string tfID;
		TiXmlElement* pNameXml =pE-&gt;FirstChildElement(&quot;name&quot;);

		if(pNameXml)
		{
		  tfID = pNameXml-&gt;GetText();

			StopLine sl;
			sl.id = GetIDsFromPrefix(tfID, &quot;SLID&quot;, &quot;LnID&quot;).at(0);
			sl.laneId = GetIDsFromPrefix(tfID, &quot;LnID&quot;, &quot;TSID&quot;).at(0);
			sl.stopSignID = GetIDsFromPrefix(tfID, &quot;TSID&quot;, &quot;TLTID&quot;).at(0);
			sl.trafficLightID = GetIDsFromPrefix(tfID, &quot;TLTID&quot;, &quot;&quot;).at(0);


			TiXmlElement* pPoints = pE-&gt;FirstChildElement(&quot;LineString&quot;)-&gt;FirstChildElement(&quot;coordinates&quot;);
			sl.points = GetPointsData(pPoints);

			slList.push_back(sl);
		}
	}

	return slList;
}

std::vector&lt;TrafficLight&gt; MappingHelpers::GetTrafficLightsList(TiXmlElement* pElem)
{
	vector&lt;TrafficLight&gt; tlList;
	TiXmlElement* pLightsLines = GetDataFolder(&quot;TrafficLights&quot;, pElem);

	TiXmlElement* pE = pLightsLines-&gt;FirstChildElement(&quot;Placemark&quot;);
	for( ; pE; pE=pE-&gt;NextSiblingElement())
	{
		string tfID;
		TiXmlElement* pNameXml =pE-&gt;FirstChildElement(&quot;name&quot;);

		if(pNameXml)
		{
		  tfID = pNameXml-&gt;GetText();

			TrafficLight tl;
			tl.id = GetIDsFromPrefix(tfID, &quot;SLID&quot;, &quot;LnID&quot;).at(0);
			tl.laneIds = GetIDsFromPrefix(tfID, &quot;LnID&quot;, &quot;&quot;);

			TiXmlElement* pPoints = pE-&gt;FirstChildElement(&quot;Point&quot;)-&gt;FirstChildElement(&quot;coordinates&quot;);
			tl.pos = GetPointsData(pPoints).at(0);

			tlList.push_back(tl);
		}
	}

	return tlList;
}

vector&lt;Lane&gt; MappingHelpers::GetLanesList(TiXmlElement* pElem)
{
	vector&lt;Lane&gt; llList;
	TiXmlElement* pLaneLinks = GetDataFolder(&quot;Lanes&quot;, pElem);

	TiXmlElement* pE = pLaneLinks-&gt;FirstChildElement(&quot;Folder&quot;);
	for( ; pE; pE=pE-&gt;NextSiblingElement())
	{
		string tfID;
		TiXmlElement* pNameXml =pE-&gt;FirstChildElement(&quot;description&quot;);
		if(pNameXml)
		{
		  tfID = pNameXml-&gt;GetText();

			Lane ll;
			ll.id = GetIDsFromPrefix(tfID, &quot;LID&quot;, &quot;RSID&quot;).at(0);
			ll.roadId = GetIDsFromPrefix(tfID, &quot;RSID&quot;, &quot;NUM&quot;).at(0);
			ll.num = GetIDsFromPrefix(tfID, &quot;NUM&quot;, &quot;From&quot;).at(0);
			ll.fromIds = GetIDsFromPrefix(tfID, &quot;From&quot;, &quot;To&quot;);
			ll.toIds = GetIDsFromPrefix(tfID, &quot;To&quot;, &quot;Vel&quot;);
			ll.speed = GetIDsFromPrefix(tfID, &quot;Vel&quot;, &quot;&quot;).at(0);
	if(m_USING_VER_ZERO == 1)
			ll.points = GetCenterLaneDataVer0(pE, ll.id);
	else
			ll.points = GetCenterLaneData(pE, ll.id);

			llList.push_back(ll);
		}
	}

	return llList;
}

vector&lt;RoadSegment&gt; MappingHelpers::GetRoadSegmentsList(TiXmlElement* pElem)
{
	vector&lt;RoadSegment&gt; rlList;
	TiXmlElement* pRoadLinks = GetDataFolder(&quot;RoadSegments&quot;, pElem);

	TiXmlElement* pE = pRoadLinks-&gt;FirstChildElement(&quot;Placemark&quot;);
	for( ; pE; pE=pE-&gt;NextSiblingElement())
	{
		string tfID;
		TiXmlElement* pNameXml =pE-&gt;FirstChildElement(&quot;description&quot;);
		if(pNameXml)
		  tfID = pNameXml-&gt;GetText();

		RoadSegment rl;
		rl.id = GetIDsFromPrefix(tfID, &quot;RSID&quot;, &quot;&quot;).at(0);
		rlList.push_back(rl);
	}

	return rlList;
}

std::vector&lt;GPSPoint&gt; MappingHelpers::GetPointsData(TiXmlElement* pElem)
{
	std::vector&lt;GPSPoint&gt; points;
	if(pElem)
	{
		string coordinate_list;
		if(!pElem-&gt;NoChildren())
			coordinate_list = pElem-&gt;GetText();

		istringstream str_stream(coordinate_list);
		string token, temp;

		while(getline(str_stream, token, ' '))
		{
			string lat, lon, alt;
			double numLat=0, numLon=0, numAlt=0;

			istringstream ss(token);

			getline(ss, lat, ',');
			getline(ss, lon, ',');
			getline(ss, alt, ',');

			numLat = atof(lat.c_str());
			numLon = atof(lon.c_str());
			numAlt = atof(alt.c_str());

			GPSPoint p;

			p.x = p.lat = numLat;
			p.y = p.lon = numLon;
			p.z = p.alt = numAlt;
			points.push_back(p);
		}
	}

	return points;
}

vector&lt;WayPoint&gt; MappingHelpers::GetCenterLaneData(TiXmlElement* pElem, const int&amp; currLaneID)
{
	vector&lt;WayPoint&gt; gps_points;

	TiXmlElement* pV = pElem-&gt;FirstChildElement(&quot;Placemark&quot;);

	if(pV)
	 pV = pV-&gt;FirstChildElement(&quot;LineString&quot;);

	if(pV)
		pV = pV-&gt;FirstChildElement(&quot;coordinates&quot;);

	if(pV)
	{
		string coordinate_list;
		if(!pV-&gt;NoChildren())
			coordinate_list = pV-&gt;GetText();

		istringstream str_stream(coordinate_list);
		string token, temp;


		while(getline(str_stream, token, ' '))
		{
			string lat, lon, alt;
			double numLat=0, numLon=0, numAlt=0;

			istringstream ss(token);

			getline(ss, lat, ',');
			getline(ss, lon, ',');
			getline(ss, alt, ',');

			numLat = atof(lat.c_str());
			numLon = atof(lon.c_str());
			numAlt = atof(alt.c_str());

			WayPoint wp;

			wp.pos.x = wp.pos.lat = numLat;
			wp.pos.y = wp.pos.lon = numLon;
			wp.pos.z = wp.pos.alt = numAlt;

			wp.laneId = currLaneID;
			gps_points.push_back(wp);
		}

		TiXmlElement* pInfoEl =pElem-&gt;FirstChildElement(&quot;Folder&quot;)-&gt;FirstChildElement(&quot;description&quot;);
		string additional_info;
		if(pInfoEl)
			additional_info = pInfoEl-&gt;GetText();
		additional_info.insert(additional_info.begin(), ',');
		additional_info.erase(additional_info.end()-1);
		vector&lt;string&gt; add_info_list = SplitString(additional_info, &quot;,&quot;);
		if(gps_points.size() == add_info_list.size())
		{
			for(unsigned int i=0; i&lt; gps_points.size(); i++)
			{
				gps_points.at(i).id =  GetIDsFromPrefix(add_info_list.at(i), &quot;WPID&quot;, &quot;AC&quot;).at(0);
				gps_points.at(i).actionCost.push_back(GetActionPairFromPrefix(add_info_list.at(i), &quot;AC&quot;, &quot;From&quot;));
				gps_points.at(i).fromIds =  GetIDsFromPrefix(add_info_list.at(i), &quot;From&quot;, &quot;To&quot;);
				gps_points.at(i).toIds =  GetIDsFromPrefix(add_info_list.at(i), &quot;To&quot;, &quot;Lid&quot;);

				vector&lt;int&gt; ids = GetIDsFromPrefix(add_info_list.at(i), &quot;Lid&quot;, &quot;Rid&quot;);
				if(ids.size() &gt; 0)
					gps_points.at(i).LeftLaneId =  ids.at(0);

				ids = GetIDsFromPrefix(add_info_list.at(i), &quot;Rid&quot;, &quot;Vel&quot;);
				if(ids.size() &gt; 0)
					gps_points.at(i).RightLaneId =  ids.at(0);

				vector&lt;double&gt; dnums = GetDoubleFromPrefix(add_info_list.at(i), &quot;Vel&quot;, &quot;Dir&quot;);
				if(dnums.size() &gt; 0)
					gps_points.at(i).v =  dnums.at(0);

				dnums = GetDoubleFromPrefix(add_info_list.at(i), &quot;Dir&quot;, &quot;&quot;);
				if(dnums.size() &gt; 0)
					gps_points.at(i).pos.a = gps_points.at(i).pos.dir =  dnums.at(0);
			}
		}
	}

	return gps_points;
}

vector&lt;WayPoint&gt; MappingHelpers::GetCenterLaneDataVer0(TiXmlElement* pElem, const int&amp; currLaneID)
{
	vector&lt;WayPoint&gt; gps_points;

	TiXmlElement* pV = pElem-&gt;FirstChildElement(&quot;Placemark&quot;);

	if(pV)
	 pV = pV-&gt;FirstChildElement(&quot;LineString&quot;);

	if(pV)
		pV = pV-&gt;FirstChildElement(&quot;coordinates&quot;);

	if(pV)
	{
		string coordinate_list;
		if(!pV-&gt;NoChildren())
			coordinate_list = pV-&gt;GetText();

		istringstream str_stream(coordinate_list);
		string token, temp;


		while(getline(str_stream, token, ' '))
		{
			string lat, lon, alt;
			double numLat=0, numLon=0, numAlt=0;

			istringstream ss(token);

			getline(ss, lat, ',');
			getline(ss, lon, ',');
			getline(ss, alt, ',');

			numLat = atof(lat.c_str());
			numLon = atof(lon.c_str());
			numAlt = atof(alt.c_str());

			WayPoint wp;

			wp.pos.x = wp.pos.lat = numLat;
			wp.pos.y = wp.pos.lon = numLon;
			wp.pos.z = wp.pos.alt = numAlt;

			wp.laneId = currLaneID;
			gps_points.push_back(wp);
		}

		TiXmlElement* pInfoEl =pElem-&gt;FirstChildElement(&quot;Folder&quot;)-&gt;FirstChildElement(&quot;description&quot;);
		string additional_info;
		if(pInfoEl)
			additional_info = pInfoEl-&gt;GetText();
		additional_info.insert(additional_info.begin(), ',');
		additional_info.erase(additional_info.end()-1);
		vector&lt;string&gt; add_info_list = SplitString(additional_info, &quot;,&quot;);
		if(gps_points.size() == add_info_list.size())
		{
			for(unsigned int i=0; i&lt; gps_points.size(); i++)
			{
				gps_points.at(i).id =  GetIDsFromPrefix(add_info_list.at(i), &quot;WPID&quot;, &quot;C&quot;).at(0);
				gps_points.at(i).fromIds =  GetIDsFromPrefix(add_info_list.at(i), &quot;From&quot;, &quot;To&quot;);
				gps_points.at(i).toIds =  GetIDsFromPrefix(add_info_list.at(i), &quot;To&quot;, &quot;Vel&quot;);
				gps_points.at(i).v =  GetDoubleFromPrefix(add_info_list.at(i), &quot;Vel&quot;, &quot;Dir&quot;).at(0);
				gps_points.at(i).pos.a = gps_points.at(i).pos.dir =  GetDoubleFromPrefix(add_info_list.at(i), &quot;Dir&quot;, &quot;&quot;).at(0);
//				if(currLaneID == 11115)
//				{
//
//					pair&lt;ACTION_TYPE, double&gt; act_cost;
//						act_cost.first = FORWARD_ACTION;
//						act_cost.second = 100;
//					gps_points.at(i).actionCost.push_back(act_cost);
//				}
			}
		}
	}

	return gps_points;
}

vector&lt;int&gt; MappingHelpers::GetIDsFromPrefix(const string&amp; str, const string&amp; prefix, const string&amp; postfix)
{
	int index1 = str.find(prefix)+prefix.size();
	int index2 = str.find(postfix, index1);
	if(index2 &lt; 0  || postfix.size() ==0)
		index2 = str.size();

	string str_ids = str.substr(index1, index2-index1);

	vector&lt;int&gt; ids;
	vector&lt;string&gt; idstr = SplitString(str_ids, &quot;_&quot;);

	for(unsigned  int i=0; i&lt; idstr.size(); i++ )
	{
		if(idstr.at(i).size()&gt;0)
		{
			int num = atoi(idstr.at(i).c_str());
			//if(num&gt;-1)
				ids.push_back(num);
		}
	}

	return ids;
}

vector&lt;double&gt; MappingHelpers::GetDoubleFromPrefix(const string&amp; str, const string&amp; prefix, const string&amp; postfix)
{
	int index1 = str.find(prefix)+prefix.size();
	int index2 = str.find(postfix, index1);
	if(index2 &lt; 0  || postfix.size() ==0)
		index2 = str.size();

	string str_ids = str.substr(index1, index2-index1);

	vector&lt;double&gt; ids;
	vector&lt;string&gt; idstr = SplitString(str_ids, &quot;_&quot;);

	for(unsigned  int i=0; i&lt; idstr.size(); i++ )
	{
		if(idstr.at(i).size()&gt;0)
		{
			double num = atof(idstr.at(i).c_str());
			//if(num&gt;-1)
				ids.push_back(num);
		}
	}

	return ids;
}

pair&lt;ACTION_TYPE, double&gt; MappingHelpers::GetActionPairFromPrefix(const string&amp; str, const string&amp; prefix, const string&amp; postfix)
{
	int index1 = str.find(prefix)+prefix.size();
	int index2 = str.find(postfix, index1);
	if(index2&lt;0  || postfix.size() ==0)
		index2 = str.size();

	string str_ids = str.substr(index1, index2-index1);

	pair&lt;ACTION_TYPE, double&gt; act_cost;
	act_cost.first = FORWARD_ACTION;
	act_cost.second = 0;

	vector&lt;string&gt; idstr = SplitString(str_ids, &quot;_&quot;);
	if(idstr.size() == 2)
	{
		if(idstr.at(0).size() &gt; 0 &amp;&amp; idstr.at(0).at(0) == 'L')
			act_cost.first = LEFT_TURN_ACTION;
		else if(idstr.at(0).size() &gt; 0 &amp;&amp; idstr.at(0).at(0) == 'R')
			act_cost.first = RIGHT_TURN_ACTION;
		if(idstr.at(1).size() &gt; 0)
			act_cost.second = atof(idstr.at(1).c_str());
	}

	return act_cost;
}

vector&lt;string&gt; MappingHelpers::SplitString(const string&amp; str, const string&amp; token)
{
	vector&lt;string&gt; str_parts;
	int iFirstPart = str.find(token);

	while(iFirstPart &gt;= 0)
	{
		iFirstPart++;
		int iSecondPart = str.find(token, iFirstPart);
		if(iSecondPart&gt;0)
		{
			str_parts.push_back(str.substr(iFirstPart,iSecondPart - iFirstPart));
		}
		else
		{
			str_parts.push_back(str.substr(iFirstPart,str.size() - iFirstPart));
		}

		iFirstPart = iSecondPart;
	}

	return str_parts;
}

void MappingHelpers::CreateKmlFromLocalizationPathFile(const std::string&amp; pathFileName,
		const double&amp; maxLaneDistance, const double&amp; density,
		const std::vector&lt;TrafficLight&gt;&amp; trafficLights,
		const std::vector&lt;GPSPoint&gt;&amp; stopLines)
{

	//Read Data From csv file
	LocalizationPathReader pathReader(pathFileName, ',');
	vector&lt;LocalizationPathReader::LocalizationWayPoint&gt; path_data;
	pathReader.ReadAllData(path_data);
	PlannerHNS::RoadSegment segment;
	segment.id = 1;

	double d_accum = 0;
	double laneMaxLength = maxLaneDistance;

	std::vector&lt;WayPoint&gt; wayPointsList;

	PlannerHNS::Lane lane;
	lane.id = 1;
	lane.num = 0;
	lane.roadId = 1;
	WayPoint p_prev;

	for(unsigned int i=0; i&lt; path_data.size() ; i++)
	{
		WayPoint p(path_data.at(i).x,path_data.at(i).y,path_data.at(i).z,0);
		p.pos.lat = p.pos.x;
		p.pos.lon = p.pos.y;
		p.pos.alt = p.pos.z;
		//p.pos.dir = p.pos.a;
		//p.v = path_data.at(i).v;
		p.laneId = lane.id;
		p.id = i+1;
		if(i&gt;0)
		{
			p.fromIds.push_back(i);
			d_accum += hypot(p.pos.y-p_prev.pos.y, p.pos.x-p_prev.pos.x);
		}

		if(i&lt;path_data.size()-1)
			p.toIds.push_back(i+2);

		wayPointsList.push_back(p);

		p_prev = p;

		if(d_accum &gt; laneMaxLength || i+1 == path_data.size())
		{
			if(segment.Lanes.size()&gt;0)
				lane.fromIds.push_back(segment.Lanes.at(segment.Lanes.size()-1).id);
			lane.toIds.push_back(lane.id+1);
			lane.points = wayPointsList;
			segment.Lanes.push_back(lane);

			d_accum = 0;
			PlannerHNS::Lane n_lane;
			n_lane.id = lane.id+1;
			n_lane.num = 0;
			n_lane.roadId = 1;
			lane = n_lane;
			wayPointsList.clear();
		}
	}

	if(segment.Lanes.size()&gt;0)
	{
		segment.Lanes.at(segment.Lanes.size()-1).toIds.clear();
		if(density &gt; 0)
		{
			for(unsigned int i=0; i &lt; segment.Lanes.size(); i++)
				PlanningHelpers::FixPathDensity(segment.Lanes.at(i).points, density);

			int fnID=0;
			for(unsigned int i=0; i &lt; segment.Lanes.size(); i++)
			{
				if(segment.Lanes.at(i).points.size() &gt; 0)
				{
					for(unsigned int j =0; j &lt; segment.Lanes.at(i).points.size(); j++)
					{
						fnID ++;
						segment.Lanes.at(i).points.at(j).id = fnID ;
						segment.Lanes.at(i).points.at(j).fromIds.clear();
						segment.Lanes.at(i).points.at(j).toIds.clear();
						if(!(i == 0 &amp;&amp; j == 0))
							segment.Lanes.at(i).points.at(j).fromIds.push_back(fnID - 1);
						if(!(i+1 ==  segment.Lanes.size() &amp;&amp; j+1 == segment.Lanes.at(i).points.size()))
							segment.Lanes.at(i).points.at(j).toIds.push_back(fnID + 1);
					}
				}
			}
		}
	}

	PlannerHNS::RoadNetwork roadMap;
	roadMap.roadSegments.push_back(segment);

	ostringstream fileName;
	fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName;
	fileName &lt;&lt; UtilityHNS:: UtilityH::GetFilePrefixHourMinuteSeconds();
	fileName &lt;&lt; &quot;_RoadNetwork.kml&quot;;
	string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+&quot;PlannerX_MapTemplate.kml&quot;;

	PlannerHNS::MappingHelpers::WriteKML(&quot;/home/hatem/SimuLogs/YardKML.kml&quot;,kml_templateFilePath , roadMap);
}

} /* namespace PlannerHNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/PlannerH.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/PlannerH.cpp">
				<diff>@@ -20,11 +20,11 @@ PlannerH::PlannerH()
 	//m_Params = params;
 }
 
- PlannerH::~PlannerH()
+PlannerH::~PlannerH()
 {
 }
 
- double PlannerH::PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, vector&lt;WayPoint&gt;&amp; generatedPath, const double pathDensity, const double smoothFactor)
+double PlannerH::PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, vector&lt;WayPoint&gt;&amp; generatedPath, const double pathDensity, const double smoothFactor)
  {
  	RSPlanner rs_planner(smoothFactor);
  	int numero = 0;
@@ -35,278 +35,126 @@ PlannerH::PlannerH()
  	return length;
  }
 
- double PlannerH::PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal,GridMap&amp; map, vector&lt;WayPoint&gt;&amp; genSmoothedPath,
-		 const double pathDensity , const double smoothFactor )
- {
- 	RSPlanner rs_planner(smoothFactor);
- 	int numero = 0;
- 	double t=0, u=0 , v=0;
- 	rs_planner.PATHDENSITY = pathDensity;
-
- 	genSmoothedPath.clear();
- 	genSmoothedPath.clear();
-
- 	double length = rs_planner.min_length_rs(start.pos.x, start.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(start.pos.a), goal.pos.x, goal.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(goal.pos.a), numero, t , u , v);
- 	rs_planner.constRS(numero, t, u , v, start.pos.x, start.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(start.pos.a), rs_planner.PATHDENSITY, genSmoothedPath);
-
- 	if(genSmoothedPath.size() == 0)
- 		return length;
-
- 	CELL_Info* pCellRet = 0;
-
- 	WayPoint p = genSmoothedPath.at(0);
- 	int nChanges = 0;
- 	double nMinChangeDistance = length;
- 	double d = 0;
-
- 	for(unsigned int i=0; i&lt;genSmoothedPath.size(); i++)
- 	{
- 		if(p.bDir != genSmoothedPath.at(i).bDir)
- 		{
- 			if(d &lt; nMinChangeDistance)
- 				nMinChangeDistance = d;
-
- 			d = 0;
-
- 			nChanges++;
- 		}
-
- 		d+= distance2points(p.pos, genSmoothedPath.at(i).pos);
-
- 		p = genSmoothedPath.at(i);
-
-// 		if(map.)
-// 			pCellRet = map.GetCellFromPointInnerMap(p.p);
-// 		else
- 		pCellRet = map.GetCellFromPoint(POINT2D(p.pos.x, p.pos.y));
-
- 		if(pCellRet)
- 		{
- 			if(pCellRet-&gt;nMovingPoints &gt; 0|| pCellRet-&gt;nStaticPoints &gt; 0 || pCellRet-&gt;heuristic == map.m_MaxHeuristics)
- 			{
- 				cout &lt;&lt; &quot;\n Obstacle Detected \n&quot;;
- 				genSmoothedPath.clear();
- 				return -1;
- 			}
- 		}
- 		else
- 		{
- 			cout &lt;&lt; &quot;\n Outside the Main Grid \n&quot;;
- 			genSmoothedPath.clear();
- 			return -1;
- 		}
- 	}
-
- 	if(nChanges &gt; 3 || nMinChangeDistance &lt; 3.2)
- 	{
- 		cout &lt;&lt; &quot;\n Too much gear changes \n&quot;;
- 		genSmoothedPath.clear();
- 		return -1;
- 	}
-
- //	pthread_mutex_lock(&amp;planning_mutex);
- //	m_CurrentPath.assign(genSmoothedPath.begin(), genSmoothedPath.end());
- //	m_CurrentSmoothPath.clear();
- //	//m_TotalPath.assign(m_CurrentPath.begin(), m_CurrentPath.end());
- //	m_CurrentSmoothPath.assign(m_CurrentPath.begin(), m_CurrentPath.end());
- //	//m_TotalSmoothPath.assign(m_CurrentSmoothPath.begin(), m_CurrentSmoothPath.end());
- //	pthread_mutex_unlock(&amp;planning_mutex);
+void PlannerH::GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths,const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
+		const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
+		const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
+		const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
+		const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
+		const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
+		std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
+		std::vector&lt;WayPoint&gt;&amp; sampledPoints_debug)
+{
 
- 	return length;
+	if(referencePaths.size()==0) return;
+	if(microPlanDistance &lt;=0 ) return;
+	rollOutsPaths.clear();
 
- }
-
- void PlannerH::GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths,const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
- 				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
- 				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
- 				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
- 				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
- 				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
- 				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
- 				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints)
- {
+	sampledPoints_debug.clear(); //for visualization only
 
-	 if(referencePaths.size()==0) return;
-	 if(microPlanDistance &lt;=0 ) return;
-	 rollOutsPaths.clear();
-	 vector&lt;vector&lt;WayPoint&gt; &gt; referenceSections;
-
-	 if(iCurrGlobalPath &gt; -1 &amp;&amp; iCurrGlobalPath &lt; referencePaths.size())
-	 {
-		 //1- extract current
-		 vector&lt;WayPoint&gt; currExtracted;
-		 vector&lt;WayPoint&gt; sideExtracted;
-
-		 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(iCurrGlobalPath), carPos,
-				 microPlanDistance, pathDensity, currExtracted,
-				 SmoothDataWeight, SmoothWeight, SmoothTolerance);
-
-		 //2- Find Left and Right lane change options Ids
-		 vector&lt;int&gt; sideLanes = PlanningHelpers::GetUniqueLeftRightIds(currExtracted);
-//		 cout &lt;&lt; &quot;Current Global ID: &quot; &lt;&lt; iCurrGlobalPath;
-//		 for(int k=0; k &lt; sideLanes.size(); k++)
-//			 cout &lt;&lt; sideLanes.at(k);
-//		 cout &lt;&lt; endl;
-
-		 for(unsigned int i = 0; i &lt; referencePaths.size(); i++)
-		 {
-			 if(i == iCurrGlobalPath)
-				 referenceSections.push_back(currExtracted);
-			 else
-			 {
-				 sideExtracted.clear();
-				 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(i), carPos,
-						 microPlanDistance, pathDensity, sideExtracted,
-						 SmoothDataWeight, SmoothWeight, SmoothTolerance);
-
-				 double d = 0;
-				 double can_lane_id = 0;
-				 bool bCanChangeLane = false;
-				 for(unsigned int iwp = 1; iwp &lt; sideExtracted.size(); iwp++)
-				 {
-					 d += hypot(sideExtracted.at(iwp).pos.y - sideExtracted.at(iwp-1).pos.y,
-							 sideExtracted.at(iwp).pos.x - sideExtracted.at(iwp-1).pos.x);
-					 if(d &gt; LANE_CHANGE_SMOOTH_FACTOR_DISTANCE)
-					 {
-						 if(PlanningHelpers::FindInList(sideLanes, sideExtracted.at(iwp).laneId) == true)
-						 {
-							 can_lane_id = sideExtracted.at(iwp).laneId;
-							 bCanChangeLane = true;
-							 break;
-						 }
-					 }
-				 }
-
-				 if(bCanChangeLane)
-				 {
-					 referenceSections.push_back(sideExtracted);
-					// cout &lt;&lt; &quot;Can Change To This Lane : &quot; &lt;&lt; can_lane_id  &lt;&lt; &quot;, Index: &quot; &lt;&lt; i &lt;&lt; endl;
-				 }
-				 else
-				 {
-					// cout &lt;&lt; &quot;Skip This Lane Index : &quot; &lt;&lt; i &lt;&lt; endl;
-					 referenceSections.push_back(vector&lt;WayPoint&gt;());
-				 }
-			 }
-		 }
-	 }
-	 else
-	 {
-		 for(unsigned int i = 0; i &lt; referencePaths.size(); i++)
-		 {
-			vector&lt;WayPoint&gt; centerTrajectorySmoothed;
-			 //Get position of the rear axe:
-			 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(i), carPos,
-					 microPlanDistance, pathDensity, centerTrajectorySmoothed,
-					 SmoothDataWeight, SmoothWeight, SmoothTolerance);
-
-			//sectionPath = centerTrajectorySmoothed; // for testing and visualization
-			 referenceSections.push_back(centerTrajectorySmoothed);
-		 }
-	 }
-
-	 for(unsigned int i = 0; i &lt; referenceSections.size(); i++)
-	 {
+	for(unsigned int i = 0; i &lt; referencePaths.size(); i++)
+	{
 		std::vector&lt;std::vector&lt;WayPoint&gt; &gt; local_rollOutPaths;
 		int s_index = 0, e_index = 0;
 		vector&lt;double&gt; e_distances;
-		if(referenceSections.at(i).size()&gt;0)
+		if(referencePaths.at(i).size()&gt;0)
 		{
-			PlanningHelpers::CalculateRollInTrajectories(carPos, speed, referenceSections.at(i), s_index, e_index, e_distances,
+			PlanningHelpers::CalculateRollInTrajectories(carPos, speed, referencePaths.at(i), s_index, e_index, e_distances,
 					local_rollOutPaths, microPlanDistance, maxSpeed, carTipMargin, rollInMargin,
-						 rollInSpeedFactor, pathDensity, rollOutDensity,rollOutNumber,
-						 SmoothDataWeight, SmoothWeight, SmoothTolerance, bHeadingSmooth, sampledPoints);
+					rollInSpeedFactor, pathDensity, rollOutDensity,rollOutNumber,
+					SmoothDataWeight, SmoothWeight, SmoothTolerance, bHeadingSmooth, sampledPoints_debug);
 		}
 		else
 		{
-			for(unsigned int j=0; j&lt; rollOutNumber+1; j++)
+			for(int j=0; j&lt; rollOutNumber+1; j++)
 			{
 				local_rollOutPaths.push_back(vector&lt;WayPoint&gt;());
 			}
 		}
 
 		rollOutsPaths.push_back(local_rollOutPaths);
-	 }
- }
+	}
+}
 
- double PlannerH::PlanUsingDPRandom(const WayPoint&amp; start,
- 		 const double&amp; maxPlanningDistance,
- 		 RoadNetwork&amp; map,
- 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
-  {
- 	PlannerHNS::WayPoint* pStart = PlannerHNS::MappingHelpers::GetClosestBackWaypointFromMap(start, map);
-
- 	if(!pStart)
- 	{
- 		GPSPoint sp = start.pos;
- 		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Can't Find Global Waypoint Nodes in the Map for Start (&quot; &lt;&lt;  sp.ToString() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
- 		return 0;
- 	}
-
- 	if(!pStart-&gt;pLane)
- 	{
- 		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Null Lane, Start (&quot; &lt;&lt; pStart-&gt;pLane &lt;&lt; &quot;)&quot; &lt;&lt; endl;
- 		return 0;
- 	}
-
-  	RelativeInfo start_info;
-  	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
-
-  	if(start_info.perp_distance &gt; START_POINT_MAX_DISTANCE)
-  	{
-  		GPSPoint sp = start.pos;
- 		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Start Distance to Lane is: &quot; &lt;&lt; start_info.perp_distance
- 		&lt;&lt; &quot;, Pose: &quot; &lt;&lt; sp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; start_info.perp_point.pos.ToString()
- 		&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
-  		return 0;
-  	}
-
-  	vector&lt;WayPoint*&gt; local_cell_to_delete;
-  	WayPoint* pLaneCell = 0;
- 	pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, local_cell_to_delete);
+double PlannerH::PlanUsingDPRandom(const WayPoint&amp; start,
+		const double&amp; maxPlanningDistance,
+		RoadNetwork&amp; map,
+		std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
+{
+	PlannerHNS::WayPoint* pStart = PlannerHNS::MappingHelpers::GetClosestBackWaypointFromMap(start, map);
 
-	if(!pLaneCell)
+	if(!pStart)
 	{
-		cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END.&quot; &lt;&lt; endl;
+		GPSPoint sp = start.pos;
+		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Can't Find Global Waypoint Nodes in the Map for Start (&quot; &lt;&lt;  sp.ToString() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
 		return 0;
 	}
 
+	if(!pStart-&gt;pLane)
+	{
+		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Null Lane, Start (&quot; &lt;&lt; pStart-&gt;pLane &lt;&lt; &quot;)&quot; &lt;&lt; endl;
+		return 0;
+	}
+
+	RelativeInfo start_info;
+	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
+
+	if(start_info.perp_distance &gt; START_POINT_MAX_DISTANCE)
+	{
+		GPSPoint sp = start.pos;
+		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Start Distance to Lane is: &quot; &lt;&lt; start_info.perp_distance
+				&lt;&lt; &quot;, Pose: &quot; &lt;&lt; sp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; start_info.perp_point.pos.ToString()
+				&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
+		return 0;
+	}
 
-  	vector&lt;WayPoint&gt; path;
-  	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
-  	const std::vector&lt;int&gt; globalPath;
-  	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
-  	paths.push_back(path);
+	vector&lt;WayPoint*&gt; local_cell_to_delete;
+	WayPoint* pLaneCell = 0;
+	pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, maxPlanningDistance, local_cell_to_delete);
+
+	if(!pLaneCell)
+	{
+		cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END.&quot; &lt;&lt; endl;
+		return 0;
+	}
 
 
-  	cout &lt;&lt; endl &lt;&lt;&quot;Info: PlannerH -&gt; Plan (B) Path With Size (&quot; &lt;&lt; (int)path.size() &lt;&lt; &quot;), MultiPaths No(&quot; &lt;&lt; paths.size() &lt;&lt; &quot;) Extraction Time : &quot; &lt;&lt; endl;
+	vector&lt;WayPoint&gt; path;
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	const std::vector&lt;int&gt; globalPath;
+	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
+	cout &lt;&lt; endl &lt;&lt;&quot;Info: PlannerH -&gt; Plan (B) Path With Size (&quot; &lt;&lt; (int)path.size() &lt;&lt; &quot;), MultiPaths No(&quot; &lt;&lt; paths.size() &lt;&lt; &quot;) Extraction Time : &quot; &lt;&lt; endl;
 
+	//PlanningHelpers::CreateManualBranch(path, 0, FORWARD_RIGHT_DIR);
+	//cout &lt;&lt; &quot;Right Branch Created with Size: &quot; &lt;&lt; path.size()  &lt;&lt; endl;
+	//PlanningHelpers::CreateManualBranch(path, 0, FORWARD_LEFT_DIR);
+	paths.push_back(path);
 
-  	if(path.size()&lt;2)
-  	{
-  		cout &lt;&lt; endl &lt;&lt; &quot;Err: PlannerH -&gt; Invalid Path, Car Should Stop.&quot; &lt;&lt; endl;
-  		if(pLaneCell)
-  			DeleteWaypoints(local_cell_to_delete);
-  		return 0 ;
-  	}
+	if(path.size()&lt;2)
+	{
+		cout &lt;&lt; endl &lt;&lt; &quot;Err: PlannerH -&gt; Invalid Path, Car Should Stop.&quot; &lt;&lt; endl;
+		if(pLaneCell)
+			DeleteWaypoints(local_cell_to_delete);
+		return 0 ;
+	}
 
-  	if(pLaneCell)
-  		DeleteWaypoints(local_cell_to_delete);
+	if(pLaneCell)
+		DeleteWaypoints(local_cell_to_delete);
 
-  	double totalPlanningDistance = path.at(path.size()-1).cost;
-  	return totalPlanningDistance;
-  }
+	double totalPlanningDistance = path.at(path.size()-1).cost;
+	return totalPlanningDistance;
+}
 
 double PlannerH::PlanUsingDP(const WayPoint&amp; start,
-		 const WayPoint&amp; goalPos,
-		 const double&amp; maxPlanningDistance,
-		 const bool bEnableLaneChange,
-		 const std::vector&lt;int&gt;&amp; globalPath,
-		 RoadNetwork&amp; map,
-		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, vector&lt;WayPoint*&gt;* all_cell_to_delete)
- {
+		const WayPoint&amp; goalPos,
+		const double&amp; maxPlanningDistance,
+		const bool bEnableLaneChange,
+		const std::vector&lt;int&gt;&amp; globalPath,
+		RoadNetwork&amp; map,
+		std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, vector&lt;WayPoint*&gt;* all_cell_to_delete)
+{
 	PlannerHNS::WayPoint* pStart = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(start, map);
 	PlannerHNS::WayPoint* pGoal = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(goalPos, map);
+	bool bEnableGoalBranching = false;
 
 	if(!pStart ||  !pGoal)
 	{
@@ -322,151 +170,329 @@ double PlannerH::PlanUsingDP(const WayPoint&amp; start,
 		return 0;
 	}
 
- 	RelativeInfo start_info, goal_info;
- 	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
- 	PlanningHelpers::GetRelativeInfo(pGoal-&gt;pLane-&gt;points, goalPos, goal_info);
+	RelativeInfo start_info, goal_info;
+	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
+	PlanningHelpers::GetRelativeInfo(pGoal-&gt;pLane-&gt;points, goalPos, goal_info);
 
- 	if(start_info.perp_distance &gt; START_POINT_MAX_DISTANCE)
- 	{
- 		GPSPoint sp = start.pos;
-		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Start Distance to Lane is: &quot; &lt;&lt; start_info.perp_distance
-		&lt;&lt; &quot;, Pose: &quot; &lt;&lt; sp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; start_info.perp_point.pos.ToString()
-		&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
- 		return 0;
- 	}
+	vector&lt;WayPoint&gt; start_path, goal_path;
 
- 	if(goal_info.perp_distance &gt; GOAL_POINT_MAX_DISTANCE)
+	if(fabs(start_info.perp_distance) &gt; START_POINT_MAX_DISTANCE)
 	{
-		GPSPoint gp = goalPos.pos;
-		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Goal Distance to Lane is: &quot; &lt;&lt; goal_info.perp_distance
-		&lt;&lt; &quot;, Pose: &quot; &lt;&lt; gp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; goal_info.perp_point.pos.ToString()
-		&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pGoal-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
-		return 0;
+		//if(fabs(start_info.perp_distance) &gt; 20)
+		{
+			GPSPoint sp = start.pos;
+			cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Start Distance to Lane is: &quot; &lt;&lt; start_info.perp_distance
+					&lt;&lt; &quot;, Pose: &quot; &lt;&lt; sp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; start_info.perp_point.pos.ToString()
+					&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
+			return 0;
+		}
+		// 		else
+		// 		{
+		// 			//PlanUsingReedShepp(start, *pStart, start_path, 1.0, 1);
+		// 		}
+	}
+
+	if(fabs(goal_info.perp_distance) &gt; GOAL_POINT_MAX_DISTANCE)
+	{
+		if(fabs(start_info.perp_distance) &gt; 20)
+		{
+			GPSPoint gp = goalPos.pos;
+			cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Goal Distance to Lane is: &quot; &lt;&lt; goal_info.perp_distance
+					&lt;&lt; &quot;, Pose: &quot; &lt;&lt; gp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; goal_info.perp_point.pos.ToString()
+					&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pGoal-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
+			return 0;
+		}
+		else
+		{
+			WayPoint wp = *pGoal;
+			wp.pos.x = (goalPos.pos.x+pGoal-&gt;pos.x)/2.0;
+			wp.pos.y = (goalPos.pos.y+pGoal-&gt;pos.y)/2.0;
+			goal_path.push_back(wp);
+			goal_path.push_back(goalPos);
+		}
 	}
 
- 	vector&lt;WayPoint*&gt; local_cell_to_delete;
- 	WayPoint* pLaneCell = 0;
- 	char bPlan = 'A';
+	vector&lt;WayPoint*&gt; local_cell_to_delete;
+	WayPoint* pLaneCell = 0;
+	char bPlan = 'A';
 
- 	if(all_cell_to_delete)
- 		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, *all_cell_to_delete);
- 	else
- 		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, local_cell_to_delete);
+	if(all_cell_to_delete)
+		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, *all_cell_to_delete);
+	else
+		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, local_cell_to_delete);
 
- 	if(!pLaneCell)
- 	{
- 		bPlan = 'B';
- 		cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (A) Failed, Trying Plan (B).&quot; &lt;&lt; endl;
+	if(!pLaneCell)
+	{
+		bPlan = 'B';
+		cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (A) Failed, Trying Plan (B).&quot; &lt;&lt; endl;
 
- 		if(all_cell_to_delete)
- 		 	pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, *all_cell_to_delete);
+		if(all_cell_to_delete)
+			pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, *all_cell_to_delete);
 		else
 			pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, local_cell_to_delete);
 
- 		if(!pLaneCell)
- 		{
- 			bPlan = 'Z';
- 			cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END.&quot; &lt;&lt; endl;
- 			return 0;
- 		}
- 	}
-
- 	vector&lt;WayPoint&gt; path;
- 	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
- 	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
- 	if(bPlan == 'A')
- 	{
- 		PlanningHelpers::ExtractPlanAlernatives(path, paths);
- 	}
- 	else if (bPlan == 'B')
- 	{
+		if(!pLaneCell)
+		{
+			bPlan = 'Z';
+			cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END.&quot; &lt;&lt; endl;
+			return 0;
+		}
+	}
+
+	vector&lt;WayPoint&gt; path;
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
+	if(path.size()==0) return 0;
+
+	paths.clear();
+
+	if(bPlan == 'A')
+	{
+		PlanningHelpers::ExtractPlanAlernatives(path, paths);
+	}
+	else if (bPlan == 'B')
+	{
 		paths.push_back(path);
- 	}
+	}
+
+	//attach start path to beginning of all paths, but goal path to only the path connected to the goal path.
+	for(unsigned int i=0; i&lt; paths.size(); i++ )
+	{
+		paths.at(i).insert(paths.at(i).begin(), start_path.begin(), start_path.end());
+		if(paths.at(i).size() &gt; 0)
+		{
+			//if(hypot(paths.at(i).at(paths.at(i).size()-1).pos.y-goal_info.perp_point.pos.y, paths.at(i).at(paths.at(i).size()-1).pos.x-goal_info.perp_point.pos.x) &lt; 1.5)
+			{
+
+				if(paths.at(i).size() &gt; 0 &amp;&amp; goal_path.size() &gt; 0)
+				{
+					goal_path.insert(goal_path.begin(), paths.at(i).end()-5, paths.at(i).end());
+					PlanningHelpers::SmoothPath(goal_path, 0.25, 0.25);
+					PlanningHelpers::FixPathDensity(goal_path, 0.75);
+					PlanningHelpers::SmoothPath(goal_path, 0.25, 0.35);
+					paths.at(i).erase(paths.at(i).end()-5, paths.at(i).end());
+					paths.at(i).insert(paths.at(i).end(), goal_path.begin(), goal_path.end());
+				}
+			}
+		}
+	}
 
- 	cout &lt;&lt; endl &lt;&lt;&quot;Info: PlannerH -&gt; Plan (&quot; &lt;&lt; bPlan &lt;&lt; &quot;) Path With Size (&quot; &lt;&lt; (int)path.size() &lt;&lt; &quot;), MultiPaths No(&quot; &lt;&lt; paths.size() &lt;&lt; &quot;) Extraction Time : &quot; &lt;&lt; endl;
+	cout &lt;&lt; endl &lt;&lt;&quot;Info: PlannerH -&gt; Plan (&quot; &lt;&lt; bPlan &lt;&lt; &quot;) Path With Size (&quot; &lt;&lt; (int)path.size() &lt;&lt; &quot;), MultiPaths No(&quot; &lt;&lt; paths.size() &lt;&lt; &quot;) Extraction Time : &quot; &lt;&lt; endl;
 
 
- 	if(path.size()&lt;2)
- 	{
- 		cout &lt;&lt; endl &lt;&lt; &quot;Err: PlannerH -&gt; Invalid Path, Car Should Stop.&quot; &lt;&lt; endl;
- 		if(pLaneCell &amp;&amp; !all_cell_to_delete)
- 			DeleteWaypoints(local_cell_to_delete);
- 		return 0 ;
- 	}
+	if(path.size()&lt;2)
+	{
+		cout &lt;&lt; endl &lt;&lt; &quot;Err: PlannerH -&gt; Invalid Path, Car Should Stop.&quot; &lt;&lt; endl;
+		if(pLaneCell &amp;&amp; !all_cell_to_delete)
+			DeleteWaypoints(local_cell_to_delete);
+		return 0 ;
+	}
 
- 	if(pLaneCell &amp;&amp; !all_cell_to_delete)
- 		DeleteWaypoints(local_cell_to_delete);
+	if(pLaneCell &amp;&amp; !all_cell_to_delete)
+		DeleteWaypoints(local_cell_to_delete);
 
- 	double totalPlanningDistance = path.at(path.size()-1).cost;
- 	return totalPlanningDistance;
- }
+	double totalPlanningDistance = path.at(path.size()-1).cost;
+	return totalPlanningDistance;
+}
 
- double PlannerH::PredictPlanUsingDP(Lane* l, const WayPoint&amp; start, const double&amp; maxPlanningDistance,
-			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
-  {
-  	if(!l)
-  	{
-  		cout &lt;&lt;endl&lt;&lt; &quot;Err: PredictPlanUsingDP, PlannerH -&gt; Null Lane !!&quot; &lt;&lt; endl;
-  		return 0;
-  	}
-
-  	WayPoint carPos = start;
-  	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
-  	vector&lt;WayPoint*&gt; all_cell_to_delete;
-  	vector&lt;int&gt; globalPath;
-
-  	RelativeInfo info;
-  	PlanningHelpers::GetRelativeInfo(l-&gt;points, carPos, info);
-  	WayPoint closest_p = l-&gt;points.at(info.iBack);
-  	WayPoint* pStartWP = &amp;l-&gt;points.at(info.iBack);
-
-  	if(distance2points(closest_p.pos, carPos.pos) &gt; 8)
-  	{
- 		cout &lt;&lt;endl&lt;&lt; &quot;Err: PredictiveDP PlannerH -&gt; Distance to Lane is: &quot; &lt;&lt; distance2points(closest_p.pos, carPos.pos)
- 		&lt;&lt; &quot;, Pose: &quot; &lt;&lt; carPos.pos.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; closest_p.pos.ToString()
- 		&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; l-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
-  		return 0;
-  	}
-
-  	vector&lt;WayPoint*&gt; pLaneCells;
-  	int nPaths =  PlanningHelpers::PredictiveDP(pStartWP, maxPlanningDistance, all_cell_to_delete, pLaneCells);
-
-  	if(nPaths==0)
-  	{
-  		cout &lt;&lt;endl&lt;&lt; &quot;Err PlannerH -&gt; Null Tree Head.&quot; &lt;&lt; endl;
-  		return 0;
-  	}
-
-  	double totalPlanDistance  = 0;
-  	for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
-  	{
-  		std::vector&lt;WayPoint&gt; path;
-  		PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), pStartWP, globalPath, path, tempCurrentForwardPathss);
-  		if(path.size()&gt;0)
-  			totalPlanDistance+= path.at(path.size()-1).cost;
-
-  		PlanningHelpers::FixPathDensity(path, 0.5);
-  		PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
-
-  		paths.push_back(path);
-  	}
-
-  	DeleteWaypoints(all_cell_to_delete);
-
-  	return totalPlanDistance;
-  }
-
- void PlannerH::DeleteWaypoints(vector&lt;WayPoint*&gt;&amp; wps)
- {
- 	for(unsigned int i=0; i&lt;wps.size(); i++)
- 	{
- 		if(wps.at(i))
- 		{
- 			delete wps.at(i);
- 			wps.at(i) = 0;
- 		}
- 	}
- 	wps.clear();
- }
+double PlannerH::PredictPlanUsingDP(Lane* l, const WayPoint&amp; start, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
+{
+	if(!l)
+	{
+		cout &lt;&lt;endl&lt;&lt; &quot;Err: PredictPlanUsingDP, PlannerH -&gt; Null Lane !!&quot; &lt;&lt; endl;
+		return 0;
+	}
+
+	WayPoint carPos = start;
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	vector&lt;WayPoint*&gt; all_cell_to_delete;
+	vector&lt;int&gt; globalPath;
+
+	RelativeInfo info;
+	PlanningHelpers::GetRelativeInfo(l-&gt;points, carPos, info);
+	WayPoint closest_p = l-&gt;points.at(info.iBack);
+	WayPoint* pStartWP = &amp;l-&gt;points.at(info.iBack);
+
+	if(distance2points(closest_p.pos, carPos.pos) &gt; 8)
+	{
+		cout &lt;&lt;endl&lt;&lt; &quot;Err: PredictiveDP PlannerH -&gt; Distance to Lane is: &quot; &lt;&lt; distance2points(closest_p.pos, carPos.pos)
+ 				&lt;&lt; &quot;, Pose: &quot; &lt;&lt; carPos.pos.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; closest_p.pos.ToString()
+ 				&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; l-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
+		return 0;
+	}
+
+	vector&lt;WayPoint*&gt; pLaneCells;
+	int nPaths =  PlanningHelpers::PredictiveDP(pStartWP, maxPlanningDistance, all_cell_to_delete, pLaneCells);
+
+	if(nPaths==0)
+	{
+		cout &lt;&lt;endl&lt;&lt; &quot;Err PlannerH -&gt; Null Tree Head.&quot; &lt;&lt; endl;
+		return 0;
+	}
+
+	double totalPlanDistance  = 0;
+	for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
+	{
+		std::vector&lt;WayPoint&gt; path;
+		PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), pStartWP, globalPath, path, tempCurrentForwardPathss);
+		if(path.size()&gt;0)
+			totalPlanDistance+= path.at(path.size()-1).cost;
+
+		PlanningHelpers::FixPathDensity(path, 0.5);
+		PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
+		PlanningHelpers::CalcAngleAndCost(path);
+
+		paths.push_back(path);
+	}
+
+	DeleteWaypoints(all_cell_to_delete);
+
+	return totalPlanDistance;
+}
+
+double PlannerH::PredictTrajectoriesUsingDP(const WayPoint&amp; startPose, std::vector&lt;WayPoint*&gt; closestWPs, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches , const bool bDirectionBased)
+{
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	vector&lt;WayPoint*&gt; all_cell_to_delete;
+	vector&lt;int&gt; globalPath;
+
+	vector&lt;WayPoint*&gt; pLaneCells;
+	vector&lt;int&gt; unique_lanes;
+	std::vector&lt;WayPoint&gt; path;
+	for(unsigned int j = 0 ; j &lt; closestWPs.size(); j++)
+	{
+		pLaneCells.clear();
+		int nPaths =  PlanningHelpers::PredictiveIgnorIdsDP(closestWPs.at(j), maxPlanningDistance, all_cell_to_delete, pLaneCells, unique_lanes);
+		for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
+		{
+			path.clear();
+			PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), closestWPs.at(j), globalPath, path, tempCurrentForwardPathss);
+
+			for(unsigned int k = 0; k&lt; path.size(); k++)
+			{
+				bool bFoundLaneID = false;
+				for(unsigned int l_id = 0 ; l_id &lt; unique_lanes.size(); l_id++)
+				{
+					if(path.at(k).laneId == unique_lanes.at(l_id))
+					{
+						bFoundLaneID = true;
+						break;
+					}
+				}
+
+				if(!bFoundLaneID)
+					unique_lanes.push_back(path.at(k).laneId);
+			}
+
+			if(path.size()&gt;0)
+			{
+				path.insert(path.begin(), startPose);
+				if(!bDirectionBased)
+					path.at(0).pos.a = path.at(1).pos.a;
+
+				PlanningHelpers::FixPathDensity(path, 1.0);
+				PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
+				paths.push_back(path);
+			}
+		}
+	}
+
+	if(bDirectionBased &amp;&amp; bFindBranches)
+	{
+		WayPoint p1, p2;
+		if(paths.size()&gt; 0 &amp;&amp; paths.at(0).size() &gt; 0)
+			p2 = p1 = paths.at(0).at(0);
+		else
+			p2 = p1 = startPose;
+
+		p2.pos.y = p1.pos.y + maxPlanningDistance*0.5*sin(p1.pos.a);
+		p2.pos.x = p1.pos.x + maxPlanningDistance*0.5*cos(p1.pos.a);
+
+		vector&lt;WayPoint&gt; l_branch;
+		vector&lt;WayPoint&gt; r_branch;
+
+		PlanningHelpers::CreateManualBranchFromTwoPoints(p1, p2, maxPlanningDistance*0.75, FORWARD_RIGHT_DIR,r_branch);
+		PlanningHelpers::CreateManualBranchFromTwoPoints(p1, p2, maxPlanningDistance*0.75, FORWARD_LEFT_DIR, l_branch);
+
+		paths.push_back(l_branch);
+		paths.push_back(r_branch);
+	}
+
+	DeleteWaypoints(all_cell_to_delete);
+
+	return 1;
+}
+
+double PlannerH::PredictPlanUsingDP(const WayPoint&amp; startPose, WayPoint* closestWP, const double&amp; maxPlanningDistance, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, const bool&amp; bFindBranches)
+{
+	if(!closestWP || !closestWP-&gt;pLane)
+	{
+		cout &lt;&lt;endl&lt;&lt; &quot;Err: PredictPlanUsingDP, PlannerH -&gt; Null Lane !!&quot; &lt;&lt; endl;
+		return 0;
+	}
+
+	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
+	vector&lt;WayPoint*&gt; all_cell_to_delete;
+	vector&lt;int&gt; globalPath;
+
+	vector&lt;WayPoint*&gt; pLaneCells;
+	int nPaths =  PlanningHelpers::PredictiveDP(closestWP, maxPlanningDistance, all_cell_to_delete, pLaneCells);
+
+	if(nPaths==0)
+	{
+		cout &lt;&lt;endl&lt;&lt; &quot;Err PlannerH -&gt; Null Tree Head.&quot; &lt;&lt; endl;
+		return 0;
+	}
+
+	double totalPlanDistance  = 0;
+	for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
+	{
+		std::vector&lt;WayPoint&gt; path;
+		PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), closestWP, globalPath, path, tempCurrentForwardPathss);
+		if(path.size()&gt;0)
+		{
+			totalPlanDistance+= path.at(path.size()-1).cost;
+			path.insert(path.begin(), startPose);
+			//path.at(0).pos.a = path.at(1).pos.a;;
+		}
+
+
+		PlanningHelpers::FixPathDensity(path, 0.5);
+		PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);
+		paths.push_back(path);
+
+		if(bFindBranches)
+		{
+			int max_branch_index = path.size() &gt; 5 ? 5 : path.size();
+			vector&lt;WayPoint&gt; l_branch;
+			vector&lt;WayPoint&gt; r_branch;
+			l_branch.insert(l_branch.begin(), path.begin(), path.begin()+5);
+			r_branch.insert(r_branch.begin(), path.begin(), path.begin()+5);
+
+			PlanningHelpers::CreateManualBranch(r_branch, 0, FORWARD_RIGHT_DIR);
+			PlanningHelpers::CreateManualBranch(l_branch, 0, FORWARD_LEFT_DIR);
+
+			paths.push_back(l_branch);
+			paths.push_back(r_branch);
+		}
+	}
+
+	DeleteWaypoints(all_cell_to_delete);
+
+	return totalPlanDistance;
+}
+
+void PlannerH::DeleteWaypoints(vector&lt;WayPoint*&gt;&amp; wps)
+{
+	for(unsigned int i=0; i&lt;wps.size(); i++)
+	{
+		if(wps.at(i))
+		{
+			delete wps.at(i);
+			wps.at(i) = 0;
+		}
+	}
+	wps.clear();
+}
 
 }
</diff>
				<old_file>/*
 * HelperFunctions.cpp
 *
 *  Created on: May 14, 2016
 *      Author: hatem
 */

#include &quot;PlannerH.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &quot;MappingHelpers.h&quot;
#include &lt;iostream&gt;

using namespace std;
using namespace UtilityHNS;

namespace PlannerHNS
{
PlannerH::PlannerH()
{
	//m_Params = params;
}

 PlannerH::~PlannerH()
{
}

 double PlannerH::PlanUsingReedShepp(const WayPoint&amp; start, const WayPoint&amp; goal, vector&lt;WayPoint&gt;&amp; generatedPath, const double pathDensity, const double smoothFactor)
 {
 	RSPlanner rs_planner(smoothFactor);
 	int numero = 0;
 	double t=0, u=0 , v=0;
 	rs_planner.PATHDENSITY = pathDensity;
 	double length = rs_planner.min_length_rs(start.pos.x, start.pos.y, start.pos.a, goal.pos.x, goal.pos.y, goal.pos.a, numero, t , u , v);
 	rs_planner.constRS(numero, t, u , v, start.pos.x, start.pos.y, start.pos.a, rs_planner.PATHDENSITY, generatedPath);
 	return length;
 }

 double PlannerH::PlanUsingReedSheppWithObstacleDetection(const WayPoint&amp; start, const WayPoint&amp; goal,GridMap&amp; map, vector&lt;WayPoint&gt;&amp; genSmoothedPath,
		 const double pathDensity , const double smoothFactor )
 {
 	RSPlanner rs_planner(smoothFactor);
 	int numero = 0;
 	double t=0, u=0 , v=0;
 	rs_planner.PATHDENSITY = pathDensity;

 	genSmoothedPath.clear();
 	genSmoothedPath.clear();

 	double length = rs_planner.min_length_rs(start.pos.x, start.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(start.pos.a), goal.pos.x, goal.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(goal.pos.a), numero, t , u , v);
 	rs_planner.constRS(numero, t, u , v, start.pos.x, start.pos.y, UtilityHNS::UtilityH::SplitPositiveAngle(start.pos.a), rs_planner.PATHDENSITY, genSmoothedPath);

 	if(genSmoothedPath.size() == 0)
 		return length;

 	CELL_Info* pCellRet = 0;

 	WayPoint p = genSmoothedPath.at(0);
 	int nChanges = 0;
 	double nMinChangeDistance = length;
 	double d = 0;

 	for(unsigned int i=0; i&lt;genSmoothedPath.size(); i++)
 	{
 		if(p.bDir != genSmoothedPath.at(i).bDir)
 		{
 			if(d &lt; nMinChangeDistance)
 				nMinChangeDistance = d;

 			d = 0;

 			nChanges++;
 		}

 		d+= distance2points(p.pos, genSmoothedPath.at(i).pos);

 		p = genSmoothedPath.at(i);

// 		if(map.)
// 			pCellRet = map.GetCellFromPointInnerMap(p.p);
// 		else
 		pCellRet = map.GetCellFromPoint(POINT2D(p.pos.x, p.pos.y));

 		if(pCellRet)
 		{
 			if(pCellRet-&gt;nMovingPoints &gt; 0|| pCellRet-&gt;nStaticPoints &gt; 0 || pCellRet-&gt;heuristic == map.m_MaxHeuristics)
 			{
 				cout &lt;&lt; &quot;\n Obstacle Detected \n&quot;;
 				genSmoothedPath.clear();
 				return -1;
 			}
 		}
 		else
 		{
 			cout &lt;&lt; &quot;\n Outside the Main Grid \n&quot;;
 			genSmoothedPath.clear();
 			return -1;
 		}
 	}

 	if(nChanges &gt; 3 || nMinChangeDistance &lt; 3.2)
 	{
 		cout &lt;&lt; &quot;\n Too much gear changes \n&quot;;
 		genSmoothedPath.clear();
 		return -1;
 	}

 //	pthread_mutex_lock(&amp;planning_mutex);
 //	m_CurrentPath.assign(genSmoothedPath.begin(), genSmoothedPath.end());
 //	m_CurrentSmoothPath.clear();
 //	//m_TotalPath.assign(m_CurrentPath.begin(), m_CurrentPath.end());
 //	m_CurrentSmoothPath.assign(m_CurrentPath.begin(), m_CurrentPath.end());
 //	//m_TotalSmoothPath.assign(m_CurrentSmoothPath.begin(), m_CurrentSmoothPath.end());
 //	pthread_mutex_unlock(&amp;planning_mutex);

 	return length;

 }

 void PlannerH::GenerateRunoffTrajectory(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; referencePaths,const WayPoint&amp; carPos, const bool&amp; bEnableLaneChange, const double&amp; speed, const double&amp; microPlanDistance,
 				const double&amp; maxSpeed,const double&amp; minSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
 				const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
 				const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
 				const double&amp; SmoothTolerance, const double&amp; speedProfileFactor, const bool&amp; bHeadingSmooth,
 				const int&amp; iCurrGlobalPath, const int&amp; iCurrLocalTraj,
 				std::vector&lt;std::vector&lt;std::vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOutsPaths,
 				std::vector&lt;WayPoint&gt;&amp; sectionPath, std::vector&lt;WayPoint&gt;&amp; sampledPoints)
 {

	 if(referencePaths.size()==0) return;
	 if(microPlanDistance &lt;=0 ) return;
	 rollOutsPaths.clear();
	 vector&lt;vector&lt;WayPoint&gt; &gt; referenceSections;

	 if(iCurrGlobalPath &gt; -1 &amp;&amp; iCurrGlobalPath &lt; referencePaths.size())
	 {
		 //1- extract current
		 vector&lt;WayPoint&gt; currExtracted;
		 vector&lt;WayPoint&gt; sideExtracted;

		 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(iCurrGlobalPath), carPos,
				 microPlanDistance, pathDensity, currExtracted,
				 SmoothDataWeight, SmoothWeight, SmoothTolerance);

		 //2- Find Left and Right lane change options Ids
		 vector&lt;int&gt; sideLanes = PlanningHelpers::GetUniqueLeftRightIds(currExtracted);
//		 cout &lt;&lt; &quot;Current Global ID: &quot; &lt;&lt; iCurrGlobalPath;
//		 for(int k=0; k &lt; sideLanes.size(); k++)
//			 cout &lt;&lt; sideLanes.at(k);
//		 cout &lt;&lt; endl;

		 for(unsigned int i = 0; i &lt; referencePaths.size(); i++)
		 {
			 if(i == iCurrGlobalPath)
				 referenceSections.push_back(currExtracted);
			 else
			 {
				 sideExtracted.clear();
				 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(i), carPos,
						 microPlanDistance, pathDensity, sideExtracted,
						 SmoothDataWeight, SmoothWeight, SmoothTolerance);

				 double d = 0;
				 double can_lane_id = 0;
				 bool bCanChangeLane = false;
				 for(unsigned int iwp = 1; iwp &lt; sideExtracted.size(); iwp++)
				 {
					 d += hypot(sideExtracted.at(iwp).pos.y - sideExtracted.at(iwp-1).pos.y,
							 sideExtracted.at(iwp).pos.x - sideExtracted.at(iwp-1).pos.x);
					 if(d &gt; LANE_CHANGE_SMOOTH_FACTOR_DISTANCE)
					 {
						 if(PlanningHelpers::FindInList(sideLanes, sideExtracted.at(iwp).laneId) == true)
						 {
							 can_lane_id = sideExtracted.at(iwp).laneId;
							 bCanChangeLane = true;
							 break;
						 }
					 }
				 }

				 if(bCanChangeLane)
				 {
					 referenceSections.push_back(sideExtracted);
					// cout &lt;&lt; &quot;Can Change To This Lane : &quot; &lt;&lt; can_lane_id  &lt;&lt; &quot;, Index: &quot; &lt;&lt; i &lt;&lt; endl;
				 }
				 else
				 {
					// cout &lt;&lt; &quot;Skip This Lane Index : &quot; &lt;&lt; i &lt;&lt; endl;
					 referenceSections.push_back(vector&lt;WayPoint&gt;());
				 }
			 }
		 }
	 }
	 else
	 {
		 for(unsigned int i = 0; i &lt; referencePaths.size(); i++)
		 {
			vector&lt;WayPoint&gt; centerTrajectorySmoothed;
			 //Get position of the rear axe:
			 PlanningHelpers::ExtractPartFromPointToDistance(referencePaths.at(i), carPos,
					 microPlanDistance, pathDensity, centerTrajectorySmoothed,
					 SmoothDataWeight, SmoothWeight, SmoothTolerance);

			//sectionPath = centerTrajectorySmoothed; // for testing and visualization
			 referenceSections.push_back(centerTrajectorySmoothed);
		 }
	 }

	 for(unsigned int i = 0; i &lt; referenceSections.size(); i++)
	 {
		std::vector&lt;std::vector&lt;WayPoint&gt; &gt; local_rollOutPaths;
		int s_index = 0, e_index = 0;
		vector&lt;double&gt; e_distances;
		if(referenceSections.at(i).size()&gt;0)
		{
			PlanningHelpers::CalculateRollInTrajectories(carPos, speed, referenceSections.at(i), s_index, e_index, e_distances,
					local_rollOutPaths, microPlanDistance, maxSpeed, carTipMargin, rollInMargin,
						 rollInSpeedFactor, pathDensity, rollOutDensity,rollOutNumber,
						 SmoothDataWeight, SmoothWeight, SmoothTolerance, bHeadingSmooth, sampledPoints);
		}
		else
		{
			for(unsigned int j=0; j&lt; rollOutNumber+1; j++)
			{
				local_rollOutPaths.push_back(vector&lt;WayPoint&gt;());
			}
		}

		rollOutsPaths.push_back(local_rollOutPaths);
	 }
 }

 double PlannerH::PlanUsingDPRandom(const WayPoint&amp; start,
 		 const double&amp; maxPlanningDistance,
 		 RoadNetwork&amp; map,
 		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
  {
 	PlannerHNS::WayPoint* pStart = PlannerHNS::MappingHelpers::GetClosestBackWaypointFromMap(start, map);

 	if(!pStart)
 	{
 		GPSPoint sp = start.pos;
 		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Can't Find Global Waypoint Nodes in the Map for Start (&quot; &lt;&lt;  sp.ToString() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
 		return 0;
 	}

 	if(!pStart-&gt;pLane)
 	{
 		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Null Lane, Start (&quot; &lt;&lt; pStart-&gt;pLane &lt;&lt; &quot;)&quot; &lt;&lt; endl;
 		return 0;
 	}

  	RelativeInfo start_info;
  	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);

  	if(start_info.perp_distance &gt; START_POINT_MAX_DISTANCE)
  	{
  		GPSPoint sp = start.pos;
 		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Start Distance to Lane is: &quot; &lt;&lt; start_info.perp_distance
 		&lt;&lt; &quot;, Pose: &quot; &lt;&lt; sp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; start_info.perp_point.pos.ToString()
 		&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
  		return 0;
  	}

  	vector&lt;WayPoint*&gt; local_cell_to_delete;
  	WayPoint* pLaneCell = 0;
 	pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, local_cell_to_delete);

	if(!pLaneCell)
	{
		cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END.&quot; &lt;&lt; endl;
		return 0;
	}


  	vector&lt;WayPoint&gt; path;
  	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
  	const std::vector&lt;int&gt; globalPath;
  	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
  	paths.push_back(path);


  	cout &lt;&lt; endl &lt;&lt;&quot;Info: PlannerH -&gt; Plan (B) Path With Size (&quot; &lt;&lt; (int)path.size() &lt;&lt; &quot;), MultiPaths No(&quot; &lt;&lt; paths.size() &lt;&lt; &quot;) Extraction Time : &quot; &lt;&lt; endl;


  	if(path.size()&lt;2)
  	{
  		cout &lt;&lt; endl &lt;&lt; &quot;Err: PlannerH -&gt; Invalid Path, Car Should Stop.&quot; &lt;&lt; endl;
  		if(pLaneCell)
  			DeleteWaypoints(local_cell_to_delete);
  		return 0 ;
  	}

  	if(pLaneCell)
  		DeleteWaypoints(local_cell_to_delete);

  	double totalPlanningDistance = path.at(path.size()-1).cost;
  	return totalPlanningDistance;
  }

double PlannerH::PlanUsingDP(const WayPoint&amp; start,
		 const WayPoint&amp; goalPos,
		 const double&amp; maxPlanningDistance,
		 const bool bEnableLaneChange,
		 const std::vector&lt;int&gt;&amp; globalPath,
		 RoadNetwork&amp; map,
		 std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths, vector&lt;WayPoint*&gt;* all_cell_to_delete)
 {
	PlannerHNS::WayPoint* pStart = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(start, map);
	PlannerHNS::WayPoint* pGoal = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(goalPos, map);

	if(!pStart ||  !pGoal)
	{
		GPSPoint sp = start.pos;
		GPSPoint gp = goalPos.pos;
		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Can't Find Global Waypoint Nodes in the Map for Start (&quot; &lt;&lt;  sp.ToString() &lt;&lt; &quot;) and Goal (&quot; &lt;&lt; gp.ToString() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
		return 0;
	}

	if(!pStart-&gt;pLane || !pGoal-&gt;pLane)
	{
		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Null Lane, Start (&quot; &lt;&lt; pStart-&gt;pLane &lt;&lt; &quot;) and Goal (&quot; &lt;&lt; pGoal-&gt;pLane &lt;&lt; &quot;)&quot; &lt;&lt; endl;
		return 0;
	}

 	RelativeInfo start_info, goal_info;
 	PlanningHelpers::GetRelativeInfo(pStart-&gt;pLane-&gt;points, start, start_info);
 	PlanningHelpers::GetRelativeInfo(pGoal-&gt;pLane-&gt;points, goalPos, goal_info);

 	if(start_info.perp_distance &gt; START_POINT_MAX_DISTANCE)
 	{
 		GPSPoint sp = start.pos;
		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Start Distance to Lane is: &quot; &lt;&lt; start_info.perp_distance
		&lt;&lt; &quot;, Pose: &quot; &lt;&lt; sp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; start_info.perp_point.pos.ToString()
		&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pStart-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
 		return 0;
 	}

 	if(goal_info.perp_distance &gt; GOAL_POINT_MAX_DISTANCE)
	{
		GPSPoint gp = goalPos.pos;
		cout &lt;&lt; endl &lt;&lt; &quot;Error: PlannerH -&gt; Goal Distance to Lane is: &quot; &lt;&lt; goal_info.perp_distance
		&lt;&lt; &quot;, Pose: &quot; &lt;&lt; gp.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; goal_info.perp_point.pos.ToString()
		&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; pGoal-&gt;pLane-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
		return 0;
	}

 	vector&lt;WayPoint*&gt; local_cell_to_delete;
 	WayPoint* pLaneCell = 0;
 	char bPlan = 'A';

 	if(all_cell_to_delete)
 		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, *all_cell_to_delete);
 	else
 		pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeV2(pStart, *pGoal, globalPath, maxPlanningDistance,bEnableLaneChange, local_cell_to_delete);

 	if(!pLaneCell)
 	{
 		bPlan = 'B';
 		cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (A) Failed, Trying Plan (B).&quot; &lt;&lt; endl;

 		if(all_cell_to_delete)
 		 	pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, *all_cell_to_delete);
		else
			pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, local_cell_to_delete);

 		if(!pLaneCell)
 		{
 			bPlan = 'Z';
 			cout &lt;&lt; endl &lt;&lt; &quot;PlannerH -&gt; Plan (B) Failed, Sorry we Don't have plan (C) This is the END.&quot; &lt;&lt; endl;
 			return 0;
 		}
 	}

 	vector&lt;WayPoint&gt; path;
 	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
 	PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPath, path, tempCurrentForwardPathss);
 	if(bPlan == 'A')
 	{
 		PlanningHelpers::ExtractPlanAlernatives(path, paths);
 	}
 	else if (bPlan == 'B')
 	{
		paths.push_back(path);
 	}

 	cout &lt;&lt; endl &lt;&lt;&quot;Info: PlannerH -&gt; Plan (&quot; &lt;&lt; bPlan &lt;&lt; &quot;) Path With Size (&quot; &lt;&lt; (int)path.size() &lt;&lt; &quot;), MultiPaths No(&quot; &lt;&lt; paths.size() &lt;&lt; &quot;) Extraction Time : &quot; &lt;&lt; endl;


 	if(path.size()&lt;2)
 	{
 		cout &lt;&lt; endl &lt;&lt; &quot;Err: PlannerH -&gt; Invalid Path, Car Should Stop.&quot; &lt;&lt; endl;
 		if(pLaneCell &amp;&amp; !all_cell_to_delete)
 			DeleteWaypoints(local_cell_to_delete);
 		return 0 ;
 	}

 	if(pLaneCell &amp;&amp; !all_cell_to_delete)
 		DeleteWaypoints(local_cell_to_delete);

 	double totalPlanningDistance = path.at(path.size()-1).cost;
 	return totalPlanningDistance;
 }

 double PlannerH::PredictPlanUsingDP(Lane* l, const WayPoint&amp; start, const double&amp; maxPlanningDistance,
			std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; paths)
  {
  	if(!l)
  	{
  		cout &lt;&lt;endl&lt;&lt; &quot;Err: PredictPlanUsingDP, PlannerH -&gt; Null Lane !!&quot; &lt;&lt; endl;
  		return 0;
  	}

  	WayPoint carPos = start;
  	vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
  	vector&lt;WayPoint*&gt; all_cell_to_delete;
  	vector&lt;int&gt; globalPath;

  	RelativeInfo info;
  	PlanningHelpers::GetRelativeInfo(l-&gt;points, carPos, info);
  	WayPoint closest_p = l-&gt;points.at(info.iBack);
  	WayPoint* pStartWP = &amp;l-&gt;points.at(info.iBack);

  	if(distance2points(closest_p.pos, carPos.pos) &gt; 8)
  	{
 		cout &lt;&lt;endl&lt;&lt; &quot;Err: PredictiveDP PlannerH -&gt; Distance to Lane is: &quot; &lt;&lt; distance2points(closest_p.pos, carPos.pos)
 		&lt;&lt; &quot;, Pose: &quot; &lt;&lt; carPos.pos.ToString() &lt;&lt; &quot;, LanePose:&quot; &lt;&lt; closest_p.pos.ToString()
 		&lt;&lt; &quot;, LaneID: &quot; &lt;&lt; l-&gt;id &lt;&lt; &quot; -&gt; Check origin and vector map. &quot; &lt;&lt; endl;
  		return 0;
  	}

  	vector&lt;WayPoint*&gt; pLaneCells;
  	int nPaths =  PlanningHelpers::PredictiveDP(pStartWP, maxPlanningDistance, all_cell_to_delete, pLaneCells);

  	if(nPaths==0)
  	{
  		cout &lt;&lt;endl&lt;&lt; &quot;Err PlannerH -&gt; Null Tree Head.&quot; &lt;&lt; endl;
  		return 0;
  	}

  	double totalPlanDistance  = 0;
  	for(unsigned int i = 0; i&lt; pLaneCells.size(); i++)
  	{
  		std::vector&lt;WayPoint&gt; path;
  		PlanningHelpers::TraversePathTreeBackwards(pLaneCells.at(i), pStartWP, globalPath, path, tempCurrentForwardPathss);
  		if(path.size()&gt;0)
  			totalPlanDistance+= path.at(path.size()-1).cost;

  		PlanningHelpers::FixPathDensity(path, 0.5);
  		PlanningHelpers::SmoothPath(path, 0.3 , 0.3,0.1);

  		paths.push_back(path);
  	}

  	DeleteWaypoints(all_cell_to_delete);

  	return totalPlanDistance;
  }

 void PlannerH::DeleteWaypoints(vector&lt;WayPoint*&gt;&amp; wps)
 {
 	for(unsigned int i=0; i&lt;wps.size(); i++)
 	{
 		if(wps.at(i))
 		{
 			delete wps.at(i);
 			wps.at(i) = 0;
 		}
 	}
 	wps.clear();
 }

}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/PlanningHelpers.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/PlanningHelpers.cpp">
				<diff>@@ -20,6 +20,7 @@ using namespace std;
 namespace PlannerHNS {
 
 
+std::vector&lt;std::pair&lt;GPSPoint, GPSPoint&gt; &gt; PlanningHelpers::m_TestingClosestPoint;
 
 PlanningHelpers::PlanningHelpers()
 {
@@ -83,6 +84,7 @@ bool PlanningHelpers::GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoin
 	return true;
 }
 
+
 bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex )
 {
 	if(trajectory.size() &lt; 2) return false;
@@ -99,7 +101,11 @@ bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, c
 	}
 	else
 	{
-		info.iFront = GetClosestNextPointIndex(trajectory, p, prevIndex);
+		info.iFront = GetClosestNextPointIndexFast(trajectory, p, prevIndex);
+//		WayPoint p2 = p;
+//		int old_index = GetClosestNextPointIndex(trajectory, p2, prevIndex);
+//		if(old_index != info.iFront)
+//			cout &lt;&lt; &quot; Alert Alert !!!! fast: &quot; &lt;&lt; info.iFront &lt;&lt; &quot;, slow: &quot; &lt;&lt; old_index  &lt;&lt; endl;
 
 		if(info.iFront &gt; 0)
 			info.iBack = info.iFront -1;
@@ -157,6 +163,49 @@ bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, c
 	return true;
 }
 
+bool PlanningHelpers::GetThreePointsInfo(const WayPoint&amp; p0, const WayPoint&amp; p1, const WayPoint&amp; p2, WayPoint&amp; perp_p, double&amp; long_d, double lat_d)
+{
+
+	if(p0.pos.x == p1.pos.x &amp;&amp; p0.pos.y == p1.pos.y) return false;
+	if(p0.pos.x == p2.pos.x &amp;&amp; p0.pos.y == p2.pos.y) return false;
+	if(p1.pos.x == p2.pos.x &amp;&amp; p1.pos.y == p2.pos.y) return false;
+
+	perp_p = p1;
+	WayPoint first_p = p0;
+	double angle_x = atan2(p1.pos.y-p0.pos.y, p1.pos.x-p0.pos.x);
+
+	Mat3 rotationMat(-angle_x);
+	Mat3 translationMat(-p2.pos.x, -p2.pos.y);
+	Mat3 invRotationMat(angle_x);
+	Mat3 invTranslationMat(p2.pos.x, p2.pos.y);
+
+	first_p.pos = translationMat*first_p.pos;
+	first_p.pos = rotationMat*first_p.pos;
+
+	perp_p.pos = translationMat*perp_p.pos;
+	perp_p.pos = rotationMat*perp_p.pos;
+
+	if(perp_p.pos.x-first_p.pos.x == 0) return false;
+
+	double m = (perp_p.pos.y-first_p.pos.y)/(perp_p.pos.x-first_p.pos.x);
+	lat_d = perp_p.pos.y - m*perp_p.pos.x; // solve for x = 0
+
+	if(isnan(lat_d) || isinf(lat_d)) return false;
+
+	if(perp_p.pos.x &lt; 0)
+		return false;
+
+	perp_p.pos.x = 0; // on the same y axis of the car
+	perp_p.pos.y = lat_d; //perp distance between the car and the trajectory
+
+	perp_p.pos = invRotationMat  * perp_p.pos;
+	perp_p.pos = invTranslationMat  * perp_p.pos;
+
+	long_d = hypot(perp_p.pos.y - first_p.pos.y, perp_p.pos.x - first_p.pos.x);
+
+	return true;
+}
+
 WayPoint PlanningHelpers::GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index)
 {
 	WayPoint follow_point;
@@ -173,7 +222,7 @@ WayPoint PlanningHelpers::GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;
 		follow_point.pos.y = init_p.perp_point.pos.y + distance * sin(follow_point.pos.a);
 	}
 	//condition 2, if far after the last point on the trajectory
-	else if(init_p.iFront == trajectory.size() -1)
+	else if(init_p.iFront == (int)trajectory.size() - 1)
 	{
 		follow_point = trajectory.at(init_p.iFront);
 		follow_point.pos.x = init_p.perp_point.pos.x + distance * cos(follow_point.pos.a);
@@ -182,7 +231,7 @@ WayPoint PlanningHelpers::GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;
 	else
 	{
 		double d = init_p.to_front_distance;
-		while(local_i &lt; trajectory.size()-1 &amp;&amp; d &lt; distance)
+		while(local_i &lt; (int)trajectory.size()-1 &amp;&amp; d &lt; distance)
 		{
 			local_i++;
 			d += hypot(trajectory.at(local_i).pos.y - trajectory.at(local_i-1).pos.y, trajectory.at(local_i).pos.x - trajectory.at(local_i-1).pos.x);
@@ -211,7 +260,7 @@ double PlanningHelpers::GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;
 	else if(p2.iBack &gt;= p1.iFront)
 	{
 		double d_on_path = p1.to_front_distance + p2.from_back_distance;
-		for(unsigned int i = p1.iFront; i &lt; p2.iBack; i++)
+		for(int i = p1.iFront; i &lt; p2.iBack; i++)
 			d_on_path += hypot(trajectory.at(i+1).pos.y - trajectory.at(i).pos.y, trajectory.at(i+1).pos.x - trajectory.at(i).pos.x);
 
 		return d_on_path;
@@ -219,7 +268,7 @@ double PlanningHelpers::GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;
 	else if(p2.iFront &lt;= p1.iBack)
 	{
 		double d_on_path = p1.from_back_distance + p2.to_front_distance;
-		for(unsigned int i = p2.iFront; i &lt; p1.iBack; i++)
+		for(int i = p2.iFront; i &lt; p1.iBack; i++)
 			d_on_path += hypot(trajectory.at(i+1).pos.y - trajectory.at(i).pos.y, trajectory.at(i+1).pos.x - trajectory.at(i).pos.x);
 
 		return -d_on_path;
@@ -230,7 +279,7 @@ double PlanningHelpers::GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;
 	}
 }
 
-int PlanningHelpers::GetClosestNextPointIndex(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
+int PlanningHelpers::GetClosestNextPointIndex_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
 {
 	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;
 
@@ -247,14 +296,18 @@ int PlanningHelpers::GetClosestNextPointIndex(const vector&lt;WayPoint&gt;&amp; trajectory
 		}
 	}
 
+//	cout &lt;&lt; &quot;Slow=&gt; Start: &quot; &lt;&lt; 0;
+//	cout &lt;&lt; &quot;, End: &quot; &lt;&lt; trajectory.size();
+//	cout &lt;&lt; &quot;, Minimum Before: &quot; &lt;&lt; min_index;
+
 	if(min_index &lt; (int)trajectory.size()-2)
 	{
 		GPSPoint curr, next;
 		curr = trajectory.at(min_index).pos;
 		next = trajectory.at(min_index+1).pos;
-		POINT2D v_1(p.pos.x - curr.x   ,p.pos.y - curr.y);
+		GPSPoint v_1(p.pos.x - curr.x   ,p.pos.y - curr.y,0,0);
 		double norm1 = pointNorm(v_1);
-		POINT2D v_2(next.x - curr.x,next.y - curr.y);
+		GPSPoint v_2(next.x - curr.x,next.y - curr.y,0,0);
 		double norm2 = pointNorm(v_2);
 		double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
 		double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
@@ -262,20 +315,220 @@ int PlanningHelpers::GetClosestNextPointIndex(const vector&lt;WayPoint&gt;&amp; trajectory
 			min_index = min_index+1;
 	}
 
+//	cout &lt;&lt; &quot;, Minimum After: &quot; &lt;&lt; min_index &lt;&lt; &quot;, Big O: &quot; &lt;&lt; trajectory.size() &lt;&lt; endl;
+
 	return min_index;
 }
 
-int PlanningHelpers::GetClosestNextPointIndexDirection(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
+int PlanningHelpers::GetClosestNextPointIndexFastV2(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex)
 {
-	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;
+
+	int size = (int)trajectory.size();
+
+		if(size &lt; 2 || prevIndex &lt; 0) return 0;
+
+		double d = 0, minD = 9999999999;
+
+
+		double resolution = hypot(trajectory[1].pos.y -trajectory[0].pos.y , trajectory[1].pos.x -trajectory[0].pos.x);
+		double d_to_zero = hypot(p.pos.y -trajectory[0].pos.y , p.pos.x - trajectory[0].pos.x);
+		double d_to_size = hypot(trajectory[size-1].pos.y - p.pos.y , trajectory[size-1].pos.x - p.pos.x);
+
+		int iStart = d_to_zero / resolution;
+		WayPoint perp_p;
+		double lat_d = 0;
+		double long_d = 0;
+
+		if(iStart &gt; 0 &amp;&amp; iStart &lt; size-1 &amp;&amp;  GetThreePointsInfo(trajectory.at(0), trajectory.at(iStart), p, perp_p, long_d, lat_d))
+		{
+	//		m_TestingClosestPoint.push_back(make_pair(trajectory.at(0).pos, p.pos));
+	//		m_TestingClosestPoint.push_back(make_pair(trajectory.at(iStart).pos, p.pos));
+			iStart = long_d / resolution;
+		}
+
+		if(iStart&gt;0)
+			iStart--;
+
+		int iEnd = size - (d_to_size / resolution);
+
+		if(iEnd &gt;= 0 &amp;&amp; iEnd &lt; size-2 &amp;&amp;  GetThreePointsInfo(trajectory.at(size-1), trajectory.at(iEnd), p, perp_p, long_d, lat_d))
+		{
+	//		m_TestingClosestPoint.push_back(make_pair(trajectory.at(size-1).pos, p.pos));
+	//		m_TestingClosestPoint.push_back(make_pair(trajectory.at(iEnd).pos, p.pos));
+			iEnd = size - (long_d / resolution);
+		}
+
+		if(iEnd &lt; size-1)
+			iEnd++;
+
+	//	cout &lt;&lt; &quot;Fast=&gt;&quot;;
+	//	cout &lt;&lt; &quot; Start: &quot; &lt;&lt; iStart;
+	//	cout &lt;&lt; &quot;, End: &quot; &lt;&lt; iEnd;
+
+		double d_from_start = d_to_zero;
+		if(iStart &lt; size)
+			d_from_start = hypot(trajectory[iStart].pos.y - p.pos.y , trajectory[iStart].pos.x - p.pos.x);
+
+		double d_from_end = d_to_size;
+		if(iEnd &gt;= 0)
+			d_from_end = hypot(trajectory[iEnd].pos.y - p.pos.y , trajectory[iEnd].pos.x - p.pos.x);
+
+		if(iStart &gt;= size &amp;&amp; iEnd &lt; 0)
+		{
+			if(d_to_zero &lt; d_to_size)
+			{
+				iStart = 0;
+				iEnd = size/2 -1;
+			}
+			else
+			{
+				iStart = size/2;
+				iEnd = size - 1;
+			}
+		}
+		else
+		{
+			if(iStart &gt;=size || (d_from_start &gt; d_to_zero))
+				iStart = 0;
+
+			if(iEnd &lt; 0 || (d_from_end &gt; d_to_size))
+				iEnd = size-1;
+		}
+
+		if(iStart &gt; iEnd)
+			iEnd = size-1;
+
+		int min_index  =  iStart;
+
+		int ncout = 0;
+		for(int i=iStart; i&lt;= iEnd; i++)
+		{
+			d  = distance2pointsSqr(trajectory[i].pos, p.pos);
+			if(d &lt; minD)
+			{
+				min_index = i;
+				minD = d;
+			}
+			ncout++;
+		}
+
+	//	cout &lt;&lt; &quot;, Minimum Before: &quot; &lt;&lt; min_index;
+
+		if(min_index &lt; size-2)
+		{
+			GPSPoint curr, next;
+			curr = trajectory[min_index].pos;
+			next = trajectory[min_index+1].pos;
+			GPSPoint v_1(p.pos.x - curr.x   ,p.pos.y - curr.y,0,0);
+			double norm1 = pointNorm(v_1);
+			GPSPoint v_2(next.x - curr.x,next.y - curr.y,0,0);
+			double norm2 = pointNorm(v_2);
+			double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
+			double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
+			if(a &lt;= M_PI_2)
+				min_index = min_index+1;
+		}
+
+	//	m_TestingClosestPoint.push_back(make_pair(trajectory.at(min_index).pos, p.pos));
+
+	//	cout &lt;&lt; &quot;, Minimum After: &quot; &lt;&lt; min_index &lt;&lt; &quot;, Big O: &quot; &lt;&lt; ncout &lt;&lt; endl;
+	//	cout &lt;&lt; &quot;d_zero: &quot; &lt;&lt; d_to_zero &lt;&lt; &quot;, d_start: &quot; &lt;&lt; d_from_start &lt;&lt; endl;
+	//	cout &lt;&lt; &quot;d_size: &quot; &lt;&lt; d_to_size &lt;&lt; &quot;, d_end: &quot; &lt;&lt; d_from_end &lt;&lt; endl;
+		return min_index;
+
+
+}
+
+int PlanningHelpers::GetClosestNextPointIndexFast(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
+{
+	int size = (int)trajectory.size();
+
+		if(size &lt; 2 || prevIndex &lt; 0) return 0;
+
+		double d = 0, minD = 9999999999;
+		int min_index  = prevIndex;
+		int iStart = prevIndex;
+		int iEnd = size;
+		double resolution = hypot(trajectory[1].pos.y -trajectory[0].pos.y , trajectory[1].pos.x -trajectory[0].pos.x);
+
+		//divide every 5 meters
+		int skip_factor = 5;
+		int skip = skip_factor/resolution;
+
+		for(int i=0; i&lt; size; i+=skip)
+		{
+			if(i+skip/2 &lt; size)
+				d  = (distance2pointsSqr(trajectory[i].pos, p.pos) + distance2pointsSqr(trajectory[i+skip/2].pos, p.pos))/2.0;
+			else
+				d  = distance2pointsSqr(trajectory[i].pos, p.pos);
+			if(d &lt; minD)
+			{
+				iStart = i-skip;
+				iEnd = i+skip;
+				minD = d;
+				min_index = i;
+			}
+		}
+
+		if((size - skip/2 - 1) &gt; 0)
+			d  = (distance2pointsSqr(trajectory[size-1].pos, p.pos) + distance2pointsSqr(trajectory[size - skip/2 -1 ].pos, p.pos))/2.0;
+		else
+			d  = distance2pointsSqr(trajectory[size-1].pos, p.pos);
+
+		if(d &lt; minD)
+		{
+			iStart = size-skip;
+			iEnd = size+skip;
+			minD = d;
+			min_index = size-1;
+		}
+
+		if(iStart &lt; 0) iStart = 0;
+		if(iEnd &gt;= size) iEnd = size -1;
+
+		for(int i=iStart; i&lt; iEnd; i++)
+		{
+			d  = distance2pointsSqr(trajectory[i].pos, p.pos);
+			if(d &lt; minD)
+			{
+				min_index = i;
+				minD = d;
+			}
+		}
+
+		if(min_index &lt; size-2)
+		{
+			GPSPoint curr, next;
+			curr = trajectory[min_index].pos;
+			next = trajectory[min_index+1].pos;
+			GPSPoint v_1(p.pos.x - curr.x   ,p.pos.y - curr.y,0,0);
+			double norm1 = pointNorm(v_1);
+			GPSPoint v_2(next.x - curr.x,next.y - curr.y,0,0);
+			double norm2 = pointNorm(v_2);
+			double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
+			double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
+			if(a &lt;= M_PI_2)
+				min_index = min_index+1;
+		}
+
+		//m_TestingClosestPoint.push_back(make_pair(trajectory.at(min_index).pos, p.pos));
+
+		return min_index;
+}
+
+int PlanningHelpers::GetClosestNextPointIndexDirectionFast(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
+{
+	int size = (int)trajectory.size();
+
+	if(size &lt; 2 || prevIndex &lt; 0) return 0;
 
 	double d = 0, minD = 9999999999;
 	int min_index  = prevIndex;
 
-	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
+	for(unsigned int i=prevIndex; i&lt; size; i++)
 	{
-		d  = distance2pointsSqr(trajectory.at(i).pos, p.pos);
-		double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(trajectory.at(i).pos.a, p.pos.a)*RAD2DEG;
+		d  = distance2pointsSqr(trajectory[i].pos, p.pos);
+		double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(trajectory[i].pos.a, p.pos.a)*RAD2DEG;
 
 		if(d &lt; minD &amp;&amp; angle_diff &lt; 45)
 		{
@@ -289,9 +542,9 @@ int PlanningHelpers::GetClosestNextPointIndexDirection(const vector&lt;WayPoint&gt;&amp; t
 		GPSPoint curr, next;
 		curr = trajectory.at(min_index).pos;
 		next = trajectory.at(min_index+1).pos;
-		POINT2D v_1(p.pos.x - curr.x   ,p.pos.y - curr.y);
+		GPSPoint v_1(p.pos.x - curr.x   ,p.pos.y - curr.y,0,0);
 		double norm1 = pointNorm(v_1);
-		POINT2D v_2(next.x - curr.x,next.y - curr.y);
+		GPSPoint v_2(next.x - curr.x,next.y - curr.y,0,0);
 		double norm2 = pointNorm(v_2);
 		double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
 		double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
@@ -337,7 +590,7 @@ WayPoint PlanningHelpers::GetPerpendicularOnTrajectory_obsolete(const vector&lt;Way
 	}
 	else
 	{
-		int next_index = GetClosestNextPointIndex(trajectory, p, prevIndex);
+		int next_index = GetClosestNextPointIndexFast(trajectory, p, prevIndex);
 
 		if(next_index == 0)
 		{
@@ -406,7 +659,7 @@ double PlanningHelpers::GetPerpDistanceToTrajectorySimple_obsolete(const vector&lt;
 	}
 	else
 	{
-		next_index = GetClosestNextPointIndex(trajectory, p, prevIndex);
+		next_index = GetClosestNextPointIndexFast(trajectory, p, prevIndex);
 		if(next_index == 0)
 		{
 			p0 = trajectory[next_index];
@@ -508,7 +761,7 @@ WayPoint PlanningHelpers::GetNextPointOnTrajectory_obsolete(const vector&lt;WayPoin
 	p2 = trajectory.at(local_currIndex);
 	p1 = trajectory.at(local_currIndex+1);
 
-	POINT2D uv(p1.pos.x - p2.pos.x, p1.pos.y - p2.pos.y);
+	GPSPoint uv(p1.pos.x - p2.pos.x, p1.pos.y - p2.pos.y ,0,0);
 	double v_norm = pointNorm(uv);
 
 	assert(v_norm != 0);
@@ -638,6 +891,115 @@ double PlanningHelpers::GetDistanceToClosestStopLineAndCheck(const std::vector&lt;W
 	return -1;
 }
 
+void PlanningHelpers::CreateManualBranchFromTwoPoints(WayPoint&amp; p1,WayPoint&amp; p2 , const double&amp; distance, const DIRECTION_TYPE&amp; direction, std::vector&lt;WayPoint&gt;&amp; path)
+{
+	WayPoint endWP, midWP;
+
+	double branch_angle = 0;
+	if(direction == FORWARD_RIGHT_DIR)
+	{
+		branch_angle = p1.pos.a-M_PI_2;
+	}
+	else if(direction == FORWARD_LEFT_DIR)
+	{
+		branch_angle = p1.pos.a+M_PI_2;
+	}
+	endWP.pos.y = p2.pos.y + distance*sin(branch_angle);
+	endWP.pos.x = p2.pos.x + distance*cos(branch_angle);
+
+	midWP = p2;
+	midWP.pos.x = (p1.pos.x+p2.pos.x)/2.0;
+	midWP.pos.y = (p1.pos.y+p2.pos.y)/2.0;
+	endWP.bDir = midWP.bDir = direction;
+
+	path.clear();
+	path.push_back(p1);
+	path.push_back(p2);
+	path.push_back(endWP);
+
+	PlanningHelpers::SmoothPath(path, 0.35, 0.25);
+	PlanningHelpers::FixPathDensity(path, 1.5);
+	PlanningHelpers::SmoothPath(path, 0.35, 0.25);
+	PlanningHelpers::FixPathDensity(path, 1);
+	PlanningHelpers::SmoothPath(path, 0.25, 0.35);
+
+
+	PlanningHelpers::CalcAngleAndCost(path);
+
+	for(unsigned int i=0; i &lt; path.size(); i++)
+	{
+		if(direction == FORWARD_LEFT_DIR)
+		{
+			path.at(i).state = INITIAL_STATE;
+			path.at(i).beh_state = BEH_BRANCH_LEFT_STATE;
+			path.at(i).laneId = -1;
+		}
+		if(direction == FORWARD_RIGHT_DIR)
+		{
+			path.at(i).state = INITIAL_STATE;
+			path.at(i).beh_state = BEH_BRANCH_RIGHT_STATE;
+			path.at(i).laneId = -2;
+		}
+	}
+}
+
+void PlanningHelpers::CreateManualBranch(std::vector&lt;WayPoint&gt;&amp; path, const int&amp; degree, const DIRECTION_TYPE&amp; direction)
+{
+	if(path.size() &lt; 5) return;
+
+	//start branch point
+	WayPoint branch_start = path.at(path.size()-5);
+	WayPoint last_wp = path.at(path.size()-1);
+
+
+	WayPoint endWP;
+	vector&lt;WayPoint&gt; goal_path;
+	double branch_angle = 0;
+	if(direction == FORWARD_RIGHT_DIR)
+	{
+		branch_angle = last_wp.pos.a-M_PI_2;
+	}
+	else if(direction == FORWARD_LEFT_DIR)
+	{
+		branch_angle = last_wp.pos.a+M_PI_2;
+	}
+	endWP.pos.y = last_wp.pos.y + 10*sin(branch_angle);
+	endWP.pos.x = last_wp.pos.x + 10*cos(branch_angle);
+
+	WayPoint wp = last_wp;
+	wp.pos.x = (last_wp.pos.x+endWP.pos.x)/2.0;
+	wp.pos.y = (last_wp.pos.y+endWP.pos.y)/2.0;
+	endWP.bDir = wp.bDir = direction;
+	goal_path.push_back(wp);
+	goal_path.push_back(endWP);
+
+	goal_path.insert(goal_path.begin(), path.end()-5, path.end());
+	PlanningHelpers::SmoothPath(goal_path, 0.25, 0.25);
+	PlanningHelpers::FixPathDensity(goal_path, 0.75);
+	PlanningHelpers::SmoothPath(goal_path, 0.25, 0.35);
+
+	path.erase(path.end()-5, path.end());
+	path.insert(path.end(), goal_path.begin(), goal_path.end());
+
+	PlanningHelpers::CalcAngleAndCost(path);
+
+	for(unsigned int i=0; i &lt; path.size(); i++)
+	{
+		if(direction == FORWARD_LEFT_DIR)
+		{
+			path.at(i).state = INITIAL_STATE;
+			path.at(i).beh_state = BEH_BRANCH_LEFT_STATE;
+		}
+		if(direction == FORWARD_RIGHT_DIR)
+		{
+			path.at(i).state = INITIAL_STATE;
+			path.at(i).beh_state = BEH_BRANCH_RIGHT_STATE;
+		}
+	}
+
+
+}
+
 void PlanningHelpers::FixPathDensity(vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity)
 {
 	if(path.size() == 0 || distanceDensity==0) return;
@@ -855,15 +1217,18 @@ void PlanningHelpers::ExtractPartFromPointToDistance(const vector&lt;WayPoint&gt;&amp; ori
 		const double&amp; pathDensity, vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance)
 {
 	extractedPath.clear();
-	unsigned int close_index = GetClosestNextPointIndexDirection(originalPath, pos);
-	vector&lt;WayPoint&gt; tempPath;
+	unsigned int close_index = GetClosestNextPointIndexDirectionFast(originalPath, pos);
+//	int i_slow = GetClosestNextPointIndexDirection(originalPath, pos);
+//	if(close_index != i_slow)
+//		cout &lt;&lt; &quot;Aler Alert !!! fast: &quot; &lt;&lt; close_index &lt;&lt; &quot;, slow: &quot; &lt;&lt; i_slow  &lt;&lt; endl;
+	//vector&lt;WayPoint&gt; tempPath;
 	double d_limit = 0;
 	if(close_index &gt;= 5) close_index -=5;
 	else close_index = 0;
 
 	for(unsigned int i=close_index; i&lt; originalPath.size(); i++)
 	{
-		tempPath.push_back(originalPath.at(i));
+		extractedPath.push_back(originalPath.at(i));
 
 		if(i&gt;0)
 			d_limit += hypot(originalPath.at(i).pos.y - originalPath.at(i-1).pos.y, originalPath.at(i).pos.x - originalPath.at(i-1).pos.x);
@@ -872,21 +1237,61 @@ void PlanningHelpers::ExtractPartFromPointToDistance(const vector&lt;WayPoint&gt;&amp; ori
 			break;
 	}
 
-	if(tempPath.size() &lt; 2)
+	if(extractedPath.size() &lt; 2)
 	{
-		cout &lt;&lt; endl &lt;&lt; &quot;### Planner Z . Extracted Rollout Path is too Small, Size = &quot; &lt;&lt; tempPath.size() &lt;&lt; endl;
+		cout &lt;&lt; endl &lt;&lt; &quot;### Planner Z . Extracted Rollout Path is too Small, Size = &quot; &lt;&lt; extractedPath.size() &lt;&lt; endl;
 		return;
 	}
 
-	FixPathDensity(tempPath, pathDensity);
-	SmoothPath(tempPath, SmoothDataWeight, SmoothWeight , SmoothTolerance);
-	CalcAngleAndCost(tempPath);
+	FixPathDensity(extractedPath, pathDensity);
+	SmoothPath(extractedPath, SmoothDataWeight, SmoothWeight , SmoothTolerance);
+	CalcAngleAndCost(extractedPath);
 
-	extractedPath = tempPath;
+	//extractedPath = tempPath;
 	//tempPath.clear();
 	//TestQuadraticSpline(extractedPath, tempPath);
 }
 
+void PlanningHelpers::ExtractPartFromPointToDistanceFast(const vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
+		const double&amp; pathDensity, vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance)
+{
+	extractedPath.clear();
+	RelativeInfo info;
+	GetRelativeInfo(originalPath, pos, info);
+	double d = 0;
+	if(info.iBack &gt; 0)
+		info.iBack--;
+
+	for(int i=info.iBack; i &gt;=  0; i--)
+	{
+		extractedPath.insert(extractedPath.begin(),  originalPath.at(i));
+		if(i &lt; originalPath.size())
+			d += hypot(originalPath.at(i).pos.y - originalPath.at(i+1).pos.y, originalPath.at(i).pos.x - originalPath.at(i+1).pos.x);
+		if(d &gt; 10)
+			break;
+	}
+
+	//extractedPath.push_back(info.perp_point);
+	d = 0;
+	for(int i=info.iBack+1; i &lt; (int)originalPath.size(); i++)
+	{
+		extractedPath.push_back(originalPath.at(i));
+		if(i &gt; 0)
+			d += hypot(originalPath.at(i).pos.y - originalPath.at(i-1).pos.y, originalPath.at(i).pos.x - originalPath.at(i-1).pos.x);
+		if(d &gt; minDistance)
+			break;
+	}
+
+	if(extractedPath.size() &lt; 2)
+	{
+		cout &lt;&lt; endl &lt;&lt; &quot;### Planner Z . Extracted Rollout Path is too Small, Size = &quot; &lt;&lt; extractedPath.size() &lt;&lt; endl;
+		return;
+	}
+
+	FixPathDensity(extractedPath, pathDensity);
+	CalcAngleAndCost(extractedPath);
+}
+
 void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
 		int&amp; end_index, vector&lt;double&gt;&amp; end_laterals ,
 		vector&lt;vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
@@ -923,8 +1328,8 @@ void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const
 //	{
 //		unsigned int num_of_strait_points = carTipMargin / pathDensity;
 //		int closest_for_each_iteration = 0;
-//		WayPoint np = GetPerpendicularOnTrajectory(originalCenter, rearPos, dummyd, closest_for_each_iteration);
-//		np.pos = rearPos.pos;
+//		WayPoint np = GetPerpendicularOnTrajectory_obsolete(originalCenter, carPos, dummyd, closest_for_each_iteration);
+//		np.pos = carPos.pos;
 //
 //		RollOutStratPath.push_back(np);
 //		for(unsigned int i = 0; i &lt; num_of_strait_points; i++)
@@ -932,12 +1337,12 @@ void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const
 //			p = RollOutStratPath.at(i);
 //			p.pos.x = p.pos.x +  pathDensity*cos(p.pos.a);
 //			p.pos.y = p.pos.y +  pathDensity*sin(p.pos.a);
-//			np = GetPerpendicularOnTrajectory(originalCenter, p, dummyd, closest_for_each_iteration);
+//			np = GetPerpendicularOnTrajectory_obsolete(originalCenter, p, dummyd, closest_for_each_iteration);
 //			np.pos = p.pos;
 //			RollOutStratPath.push_back(np);
 //		}
 //
-//		initial_roll_in_distance = GetPerpDistanceToTrajectorySimple(originalCenter, RollOutStratPath.at(RollOutStratPath.size()-1), close_index);
+//		initial_roll_in_distance = GetPerpDistanceToTrajectorySimple_obsolete(originalCenter, RollOutStratPath.at(RollOutStratPath.size()-1), close_index);
 //	}
 	///***   -------------------------------- ***///
 
@@ -1290,35 +1695,42 @@ void PlanningHelpers::SmoothWayPointsDirections(vector&lt;WayPoint&gt;&amp; path_in, doubl
 	path_in = newpath;
 }
 
-void PlanningHelpers::GenerateRecommendedSpeed(vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor)
+void PlanningHelpers::SmoothGlobalPathSpeed(vector&lt;WayPoint&gt;&amp; path)
 {
-	FixPathDensity(path, 0.5);
-
 	CalcAngleAndCostAndCurvatureAnd2D(path);
+	SmoothSpeedProfiles(path, 0.45,0.25, 0.01);
+}
 
-	SmoothCurvatureProfiles(path, 0.3, 0.49, 0.01);
+void PlanningHelpers::GenerateRecommendedSpeed(vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor)
+{
+	CalcAngleAndCostAndCurvatureAnd2D(path);
+	SmoothCurvatureProfiles(path, 0.4, 0.3, 0.01);
+	double v = 0;
 
 	for(unsigned int i = 0 ; i &lt; path.size(); i++)
 	{
 		double k_ratio = path.at(i).cost*10.0;
+		double local_max = (path.at(i).v &gt;= 0 &amp;&amp; max_speed &gt; path.at(i).v) ? path.at(i).v : max_speed;
 
 		if(k_ratio &gt;= 9.5)
-			path.at(i).v = max_speed;
+			v = local_max;
 		else if(k_ratio &lt;= 8.5)
-			path.at(i).v = 1.0*speedProfileFactor;
+			v = 1.0*speedProfileFactor;
 		else
 		{
 			k_ratio = k_ratio - 8.5;
-			path.at(i).v = (max_speed - 1.0) * k_ratio + 1.0;
-			path.at(i).v = path.at(i).v*speedProfileFactor;
+			v = (local_max - 1.0) * k_ratio + 1.0;
+			v = v*speedProfileFactor;
 		}
 
-		if(path.at(i).v &gt; max_speed)
-			path.at(i).v = max_speed;
+		if(v &gt; local_max)
+			path.at(i).v = local_max;
+		else
+			path.at(i).v = v;
 
 	}
 
-	//SmoothSpeedProfiles(path, 0.15,0.45, 0.1);
+	SmoothSpeedProfiles(path, 0.4,0.3, 0.01);
 }
 
 WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
@@ -1471,6 +1883,7 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
 	WayPoint* pZero = 0;
 	WayPoint* wp    = new WayPoint();
 	*wp = *pStart;
+	wp-&gt;cost = 0;
 	nextLeafToTrace.push_back(make_pair(pZero, wp));
 	all_cells_to_delete.push_back(wp);
 
@@ -1509,11 +1922,11 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
 				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
 				distance += d;
 
-				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
-				{
-					//if(wp-&gt;actionCost.at(a).first == FORWARD_ACTION)
-						d += wp-&gt;actionCost.at(a).second;
-				}
+//				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
+//				{
+//					//if(wp-&gt;actionCost.at(a).first == FORWARD_ACTION)
+//						d += wp-&gt;actionCost.at(a).second;
+//				}
 
 				wp-&gt;cost = pH-&gt;cost + d;
 				wp-&gt;pBacks.push_back(pH);
@@ -1575,6 +1988,80 @@ WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
 	return pGoalCell;
 }
 
+int PlanningHelpers::PredictiveIgnorIdsDP(WayPoint* pStart, const double&amp; DistanceLimit,
+		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete,vector&lt;WayPoint*&gt;&amp; end_waypoints, std::vector&lt;int&gt;&amp; lanes_ids)
+{
+	if(!pStart) return 0;
+
+		vector&lt;pair&lt;WayPoint*, WayPoint*&gt; &gt;nextLeafToTrace;
+
+		WayPoint* pZero = 0;
+		WayPoint* wp    = new WayPoint();
+		*wp = *pStart;
+		wp-&gt;pLeft = 0;
+		wp-&gt;pRight = 0;
+		nextLeafToTrace.push_back(make_pair(pZero, wp));
+		all_cells_to_delete.push_back(wp);
+
+		double 		distance 		= 0;
+		end_waypoints.clear();
+		double 		nCounter 		= 0;
+
+		while(nextLeafToTrace.size()&gt;0)
+		{
+			nCounter++;
+
+			WayPoint* pH 	= nextLeafToTrace.at(0).second;
+
+			assert(pH != 0);
+
+			nextLeafToTrace.erase(nextLeafToTrace.begin()+0);
+
+			for(unsigned int i =0; i&lt; pH-&gt;pFronts.size(); i++)
+			{
+				if(pH-&gt;pFronts.at(i) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pFronts.at(i)))
+				{
+					if(pH-&gt;cost &lt; DistanceLimit)
+					{
+						wp = new WayPoint();
+						*wp = *pH-&gt;pFronts.at(i);
+
+						double d = distance2points(wp-&gt;pos, pH-&gt;pos);
+						distance += d;
+						wp-&gt;cost = pH-&gt;cost + d;
+						wp-&gt;pBacks.push_back(pH);
+						wp-&gt;pLeft = 0;
+						wp-&gt;pRight = 0;
+
+						bool bFoundLane = false;
+						for(unsigned int k = 0 ; k &lt; lanes_ids.size(); k++)
+						{
+							if(wp-&gt;laneId == lanes_ids.at(k))
+							{
+								bFoundLane = true;
+								break;
+							}
+						}
+
+						if(!bFoundLane)
+							nextLeafToTrace.push_back(make_pair(pH, wp));
+						all_cells_to_delete.push_back(wp);
+					}
+					else
+					{
+						end_waypoints.push_back(pH);
+					}
+				}
+			}
+		}
+
+		while(nextLeafToTrace.size()!=0)
+			nextLeafToTrace.pop_back();
+		//closed_nodes.clear();
+
+		return end_waypoints.size();
+}
+
 int PlanningHelpers::PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
 		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete,vector&lt;WayPoint*&gt;&amp; end_waypoints)
 {
@@ -1782,6 +2269,9 @@ WayPoint* PlanningHelpers::GetMinCostCell(const vector&lt;WayPoint*&gt;&amp; cells, const
 
 void PlanningHelpers::ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths)
 {
+	if(singlePath.size() == 0)
+		return;
+
 	allPaths.clear();
 	std::vector&lt;WayPoint&gt; path;
 	path.push_back(singlePath.at(0));
@@ -1957,23 +2447,31 @@ void PlanningHelpers::CalcContourPointsForDetectedObjects(const WayPoint&amp; currPo
 	obj_list = res_list;
 }
 
-double PlanningHelpers::GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance)
+double PlanningHelpers::GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const RelativeInfo&amp; info, int&amp; prev_index, const double&amp; reasonable_brake_distance)
 {
-	int iStart = GetClosestNextPointIndex(path, pose);
+	if(path.size()==0) return 0;
 
-	double d = 0;
-	double min_v = 99999;
-	for(unsigned int i=iStart; i&lt; path.size(); i++)
-	{
-		d  += distance2points(path.at(i).pos, pose.pos);
 
-		if(path.at(i).v &lt; min_v)
-			min_v = path.at(i).v;
+	double min_v = path.at(info.iBack).v;
+	double d = info.to_front_distance;
 
-		if(d &gt;= distance)
-			return min_v;
+	int local_i = info.iFront;
+	while(local_i &lt; path.size()-1 &amp;&amp; d &lt; reasonable_brake_distance)
+	{
+		local_i++;
+		d += hypot(path.at(local_i).pos.y - path.at(local_i-1).pos.y, path.at(local_i).pos.x - path.at(local_i-1).pos.x);
+		if(path.at(local_i).v &lt; min_v)
+			min_v = path.at(local_i).v;
 	}
-	return 0;
+
+	if(local_i &lt; prev_index &amp;&amp; prev_index &lt; path.size())
+	{
+		min_v = path.at(prev_index).v;
+	}
+	else
+		prev_index = local_i;
+
+	return min_v;
 }
 
 void PlanningHelpers::WritePathToFile(const string&amp; fileName, const vector&lt;WayPoint&gt;&amp; path)
</diff>
				<old_file>/*
 * PlanningHelpers.cpp
 *
 *  Created on: Jun 16, 2016
 *      Author: hatem
 */

#include &quot;PlanningHelpers.h&quot;
#include &quot;MatrixOperations.h&quot;
#include &lt;string&gt;
//#include &quot;spline.hpp&quot;



using namespace UtilityHNS;
using namespace std;



namespace PlannerHNS {



PlanningHelpers::PlanningHelpers()
{
}

PlanningHelpers::~PlanningHelpers()
{
}

bool PlanningHelpers::GetRelativeInfoRange(const std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; trajectories, const WayPoint&amp; p,const double&amp; searchDistance, RelativeInfo&amp; info)
{
	if(trajectories.size() == 0) return false;

	vector&lt;RelativeInfo&gt; infos;
	for(unsigned int i=0; i &lt; trajectories.size(); i++)
	{
		RelativeInfo info_item;
		GetRelativeInfo(trajectories.at(i), p, info_item);
		double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(info_item.perp_point.pos.a, p.pos.a)*RAD2DEG;
		if(angle_diff &lt; 75)
		{
			info_item.iGlobalPath = i;
			infos.push_back(info_item);
		}
	}

	if(infos.size() == 0)
		return false;
	else if(infos.size() == 1)
	{
		info = infos.at(0);
		return true;
	}

	double minCost = 9999999999;
	int min_index = 0;

	for(unsigned int i=0 ; i&lt; infos.size(); i++)
	{
		if(searchDistance &gt; 0)
		{
			double laneChangeCost = trajectories.at(infos.at(i).iGlobalPath).at(infos.at(i).iFront).laneChangeCost;
			if(fabs(infos.at(i).perp_distance) &lt; searchDistance &amp;&amp; laneChangeCost &lt; minCost)
			{
				min_index = i;
				minCost = laneChangeCost;
			}
		}
		else
		{
			if(fabs(infos.at(i).perp_distance) &lt; minCost)
			{
				min_index = i;
				minCost = infos.at(i).perp_distance;
			}
		}
	}

	info = infos.at(min_index);

	return true;
}

bool PlanningHelpers::GetRelativeInfo(const std::vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, RelativeInfo&amp; info, const int&amp; prevIndex )
{
	if(trajectory.size() &lt; 2) return false;

	WayPoint p0, p1;
	if(trajectory.size()==2)
	{
		p0 = trajectory.at(0);
		p1 = WayPoint((trajectory.at(0).pos.x+trajectory.at(1).pos.x)/2.0,
					  (trajectory.at(0).pos.y+trajectory.at(1).pos.y)/2.0,
					  (trajectory.at(0).pos.z+trajectory.at(1).pos.z)/2.0, trajectory.at(0).pos.a);
		info.iFront = 1;
		info.iBack = 0;
	}
	else
	{
		info.iFront = GetClosestNextPointIndex(trajectory, p, prevIndex);

		if(info.iFront &gt; 0)
			info.iBack = info.iFront -1;
		else
			info.iBack = 0;

		if(info.iFront == 0)
		{
			p0 = trajectory.at(info.iFront);
			p1 = trajectory.at(info.iFront+1);
		}
		else if(info.iFront &gt; 0 &amp;&amp; info.iFront &lt; trajectory.size()-1)
		{
			p0 = trajectory.at(info.iFront-1);
			p1 = trajectory.at(info.iFront);
		}
		else
		{
			p0 = trajectory.at(info.iFront-1);
			p1 = WayPoint((p0.pos.x+trajectory.at(info.iFront).pos.x)/2.0, (p0.pos.y+trajectory.at(info.iFront).pos.y)/2.0, (p0.pos.z+trajectory.at(info.iFront).pos.z)/2.0, p0.pos.a);
		}
	}

	WayPoint prevWP = p0;
	Mat3 rotationMat(-p1.pos.a);
	Mat3 translationMat(-p.pos.x, -p.pos.y);
	Mat3 invRotationMat(p1.pos.a);
	Mat3 invTranslationMat(p.pos.x, p.pos.y);

	p0.pos = translationMat*p0.pos;
	p0.pos = rotationMat*p0.pos;

	p1.pos = translationMat*p1.pos;
	p1.pos = rotationMat*p1.pos;

	double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
	info.perp_distance = p1.pos.y - m*p1.pos.x; // solve for x = 0

	if(isnan(info.perp_distance) || isinf(info.perp_distance)) info.perp_distance = 0;

	info.to_front_distance = fabs(p1.pos.x); // distance on the x axes


	info.perp_point = p1;
	info.perp_point.pos.x = 0; // on the same y axis of the car
	info.perp_point.pos.y = info.perp_distance; //perp distance between the car and the trajectory

	info.perp_point.pos = invRotationMat  * info.perp_point.pos;
	info.perp_point.pos = invTranslationMat  * info.perp_point.pos;

	info.from_back_distance = hypot(info.perp_point.pos.y - prevWP.pos.y, info.perp_point.pos.x - prevWP.pos.x);

	info.angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(p1.pos.a, p.pos.a)*RAD2DEG;

	return true;
}

WayPoint PlanningHelpers::GetFollowPointOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; init_p, const double&amp; distance, unsigned int&amp; point_index)
{
	WayPoint follow_point;

	if(trajectory.size()==0) return follow_point;

	//condition 1, if far behind the first point on the trajectory
	int local_i = init_p.iFront;

	if(init_p.iBack == 0 &amp;&amp; init_p.iBack == init_p.iFront &amp;&amp; init_p.from_back_distance &gt; distance)
	{
		follow_point = trajectory.at(init_p.iFront);
		follow_point.pos.x = init_p.perp_point.pos.x + distance * cos(follow_point.pos.a);
		follow_point.pos.y = init_p.perp_point.pos.y + distance * sin(follow_point.pos.a);
	}
	//condition 2, if far after the last point on the trajectory
	else if(init_p.iFront == trajectory.size() -1)
	{
		follow_point = trajectory.at(init_p.iFront);
		follow_point.pos.x = init_p.perp_point.pos.x + distance * cos(follow_point.pos.a);
		follow_point.pos.y = init_p.perp_point.pos.y + distance * sin(follow_point.pos.a);
	}
	else
	{
		double d = init_p.to_front_distance;
		while(local_i &lt; trajectory.size()-1 &amp;&amp; d &lt; distance)
		{
			local_i++;
			d += hypot(trajectory.at(local_i).pos.y - trajectory.at(local_i-1).pos.y, trajectory.at(local_i).pos.x - trajectory.at(local_i-1).pos.x);
		}

		double d_part = distance - d;

		follow_point = trajectory.at(local_i);
		follow_point.pos.x = follow_point.pos.x + d_part * cos(follow_point.pos.a);
		follow_point.pos.y = follow_point.pos.y + d_part * sin(follow_point.pos.a);
	}

	point_index = local_i;

	return follow_point;
}

double PlanningHelpers::GetExactDistanceOnTrajectory(const std::vector&lt;WayPoint&gt;&amp; trajectory, const RelativeInfo&amp; p1,const RelativeInfo&amp; p2)
{
	if(trajectory.size() == 0) return 0;

	if(p2.iFront == p1.iFront &amp;&amp; p2.iBack == p1.iBack)
	{
		return p2.to_front_distance - p1.to_front_distance;
	}
	else if(p2.iBack &gt;= p1.iFront)
	{
		double d_on_path = p1.to_front_distance + p2.from_back_distance;
		for(unsigned int i = p1.iFront; i &lt; p2.iBack; i++)
			d_on_path += hypot(trajectory.at(i+1).pos.y - trajectory.at(i).pos.y, trajectory.at(i+1).pos.x - trajectory.at(i).pos.x);

		return d_on_path;
	}
	else if(p2.iFront &lt;= p1.iBack)
	{
		double d_on_path = p1.from_back_distance + p2.to_front_distance;
		for(unsigned int i = p2.iFront; i &lt; p1.iBack; i++)
			d_on_path += hypot(trajectory.at(i+1).pos.y - trajectory.at(i).pos.y, trajectory.at(i+1).pos.x - trajectory.at(i).pos.x);

		return -d_on_path;
	}
	else
	{
		return 0;
	}
}

int PlanningHelpers::GetClosestNextPointIndex(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
{
	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;

	double d = 0, minD = 9999999999;
	int min_index  = prevIndex;

	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
	{
		d  = distance2pointsSqr(trajectory.at(i).pos, p.pos);
		if(d &lt; minD)
		{
			min_index = i;
			minD = d;
		}
	}

	if(min_index &lt; (int)trajectory.size()-2)
	{
		GPSPoint curr, next;
		curr = trajectory.at(min_index).pos;
		next = trajectory.at(min_index+1).pos;
		POINT2D v_1(p.pos.x - curr.x   ,p.pos.y - curr.y);
		double norm1 = pointNorm(v_1);
		POINT2D v_2(next.x - curr.x,next.y - curr.y);
		double norm2 = pointNorm(v_2);
		double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
		double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
		if(a &lt;= M_PI_2)
			min_index = min_index+1;
	}

	return min_index;
}

int PlanningHelpers::GetClosestNextPointIndexDirection(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
{
	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;

	double d = 0, minD = 9999999999;
	int min_index  = prevIndex;

	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
	{
		d  = distance2pointsSqr(trajectory.at(i).pos, p.pos);
		double angle_diff = UtilityH::AngleBetweenTwoAnglesPositive(trajectory.at(i).pos.a, p.pos.a)*RAD2DEG;

		if(d &lt; minD &amp;&amp; angle_diff &lt; 45)
		{
			min_index = i;
			minD = d;
		}
	}

	if(min_index &lt; (int)trajectory.size()-2)
	{
		GPSPoint curr, next;
		curr = trajectory.at(min_index).pos;
		next = trajectory.at(min_index+1).pos;
		POINT2D v_1(p.pos.x - curr.x   ,p.pos.y - curr.y);
		double norm1 = pointNorm(v_1);
		POINT2D v_2(next.x - curr.x,next.y - curr.y);
		double norm2 = pointNorm(v_2);
		double dot_pro = v_1.x*v_2.x + v_1.y*v_2.y;
		double a = UtilityH::FixNegativeAngle(acos(dot_pro/(norm1*norm2)));
		if(a &lt;= M_PI_2)
			min_index = min_index+1;
	}

	return min_index;
}

int PlanningHelpers::GetClosestPointIndex_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex )
{
	if(trajectory.size() == 0 || prevIndex &lt; 0) return 0;

	double d = 0, minD = 9999999999;
	int min_index  = prevIndex;

	for(unsigned int i=prevIndex; i&lt; trajectory.size(); i++)
	{
		d  = distance2pointsSqr(trajectory.at(i).pos, p.pos);
		if(d &lt; minD)
		{
			min_index = i;
			minD = d;
		}
	}

	return min_index;
}

WayPoint PlanningHelpers::GetPerpendicularOnTrajectory_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p, double&amp; distance, const int&amp; prevIndex )
{
	if(trajectory.size() &lt; 2) return p;

	WayPoint p0, p1, p2, perp;
	if(trajectory.size()==2)
	{
		p0 = trajectory.at(0);
		p1 = WayPoint((trajectory.at(0).pos.x+trajectory.at(1).pos.x)/2.0,
					  (trajectory.at(0).pos.y+trajectory.at(1).pos.y)/2.0,
					  (trajectory.at(0).pos.z+trajectory.at(1).pos.z)/2.0, trajectory.at(0).pos.a);
		p2 = trajectory.at(1);
	}
	else
	{
		int next_index = GetClosestNextPointIndex(trajectory, p, prevIndex);

		if(next_index == 0)
		{
			p0 = trajectory[next_index];
			p1 = trajectory[next_index+1];
			p2 = trajectory[next_index+2];
		}
		else if(next_index &gt; 0 &amp;&amp; next_index &lt; trajectory.size()-1)
		{
			p0 = trajectory[next_index-1];
			p1 = trajectory[next_index];
			p2 = trajectory[next_index+1];
		}
		else
		{
			p0 = trajectory[next_index-1];
			p2 = trajectory[next_index];

			p1 = WayPoint((p0.pos.x+p2.pos.x)/2.0, (p0.pos.y+p2.pos.y)/2.0, (p0.pos.z+p2.pos.z)/2.0, p0.pos.a);

		}
	}

	Mat3 rotationMat(-p1.pos.a);
	Mat3 translationMat(-p.pos.x, -p.pos.y);
	Mat3 invRotationMat(p1.pos.a);
	Mat3 invTranslationMat(p.pos.x, p.pos.y);

	p0.pos = translationMat*p0.pos;
	p0.pos = rotationMat*p0.pos;

	p1.pos = translationMat*p1.pos;
	p1.pos = rotationMat*p1.pos;

	p2.pos = translationMat*p2.pos;
	p2.pos= rotationMat*p2.pos;

	double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
	double d = p1.pos.y - m*p1.pos.x; // solve for x = 0
	distance = p1.pos.x; // distance on the x axes

	perp = p1;
	perp.pos.x = 0; // on the same y axis of the car
	perp.pos.y = d; //perp distance between the car and the trajectory

	perp.pos = invRotationMat  * perp.pos;
	perp.pos = invTranslationMat  * perp.pos;

	return perp;
}

double PlanningHelpers::GetPerpDistanceToTrajectorySimple_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const WayPoint&amp; p,const int&amp; prevIndex)
{

	if(trajectory.size() &lt; 2)
		return 0;

	WayPoint p0, p1, p2;
	int next_index = 0;
	if(trajectory.size()==2)
	{
		p0 = trajectory.at(0);
		p2 = trajectory.at(1);
		p1 = WayPoint((p0.pos.x+p2.pos.x)/2.0, (p0.pos.y+p2.pos.y)/2.0, (p0.pos.z+p2.pos.z)/2.0, p0.pos.a);

	}
	else
	{
		next_index = GetClosestNextPointIndex(trajectory, p, prevIndex);
		if(next_index == 0)
		{
			p0 = trajectory[next_index];
			p1 = trajectory[next_index+1];
			p2 = trajectory[next_index+2];
		}
		else if(next_index &gt; 0 &amp;&amp; next_index &lt; trajectory.size()-1)
		{
			p0 = trajectory[next_index-1];
			p1 = trajectory[next_index];
			p2 = trajectory[next_index+1];
		}
		else
		{
			p0 = trajectory[next_index-1];
			p2 = trajectory[next_index];

			p1 = WayPoint((p0.pos.x+p2.pos.x)/2.0, (p0.pos.y+p2.pos.y)/2.0, (p0.pos.z+p2.pos.z)/2.0, p0.pos.a);

		}

	}


	Mat3 rotationMat(-p1.pos.a);
	Mat3 translationMat(-p.pos.x, -p.pos.y);

	p0.pos = translationMat*p0.pos;
	p0.pos = rotationMat*p0.pos;

	p1.pos = translationMat*p1.pos;
	p1.pos = rotationMat*p1.pos;

	p2.pos = translationMat*p2.pos;
	p2.pos = rotationMat*p2.pos;

	double m = (p1.pos.y-p0.pos.y)/(p1.pos.x-p0.pos.x);
	double d = p1.pos.y - m*p1.pos.x;

	if(isnan(d) || isinf(d))
	{
	  //assert(false);
	  d = 0;
	}

	return d;
}

double PlanningHelpers::GetPerpDistanceToVectorSimple_obsolete(const WayPoint&amp; point1, const WayPoint&amp; point2, const WayPoint&amp; pose)
{
	WayPoint p1 = point1, p2 = point2;
	Mat3 rotationMat(-p1.pos.a);
	Mat3 translationMat(-pose.pos.x, -pose.pos.y);

	p1.pos = translationMat*p1.pos;
	p1.pos = rotationMat*p1.pos;

	p2.pos = translationMat*p2.pos;
	p2.pos = rotationMat*p2.pos;

	double m = (p2.pos.y-p1.pos.y)/(p2.pos.x-p1.pos.x);
	double d = p2.pos.y - m*p2.pos.x;

	if(isnan(d) || isinf(d))
	{
	  //assert(false);
	  d = 0;
	}

	return d;
}

WayPoint PlanningHelpers::GetNextPointOnTrajectory_obsolete(const vector&lt;WayPoint&gt;&amp; trajectory, const double&amp; distance, const int&amp; currIndex)
{
	assert(trajectory.size()&gt;0);

	int local_currIndex = currIndex;

	if(local_currIndex &lt; 0 || local_currIndex &gt;= trajectory.size())
		return trajectory.at(0);

	WayPoint p1 = trajectory.at(local_currIndex);
	WayPoint p2;

	double d = 0;
	while(local_currIndex &lt; (trajectory.size()-1) &amp;&amp; d &lt; distance)
	{
		local_currIndex++;
		p2 = p1;
		p1 = trajectory.at(local_currIndex);
		d += distance2points(p1.pos, p2.pos);
	}

	if(local_currIndex &gt;= trajectory.size()-1)
	  return p1;

	double distance_diff = distance -  d;

	p2 = trajectory.at(local_currIndex);
	p1 = trajectory.at(local_currIndex+1);

	POINT2D uv(p1.pos.x - p2.pos.x, p1.pos.y - p2.pos.y);
	double v_norm = pointNorm(uv);

	assert(v_norm != 0);

	uv.x = (uv.x / v_norm) * distance_diff;
	uv.y = (uv.y / v_norm) * distance_diff;

	double ydiff = p1.pos.y-p2.pos.y;
	double xdiff = p1.pos.x-p2.pos.x;
	double a =  atan2(ydiff,xdiff);

	WayPoint abs_waypoint = p2;

	abs_waypoint.pos.x = p2.pos.x + uv.x;
	abs_waypoint.pos.y = p2.pos.y + uv.y;
	abs_waypoint.pos.a = a;

	return abs_waypoint;
}

double PlanningHelpers::GetDistanceOnTrajectory_obsolete(const std::vector&lt;WayPoint&gt;&amp; path, const int&amp; start_index, const WayPoint&amp; p)
{

	int end_point_index = GetClosestPointIndex_obsolete(path, p);
	if(end_point_index &gt; 0)
		end_point_index--;

	double padding_distance = distance2points(path.at(end_point_index).pos, p.pos);

	double d_on_path = 0;
	if(end_point_index &gt;= start_index)
	{
		for(unsigned int i = start_index; i &lt; end_point_index; i++)
			d_on_path += distance2points(path.at(i).pos, path.at(i+1).pos);

		d_on_path += padding_distance;
	}
	else
	{
		for(unsigned int i = start_index; i &gt; end_point_index; i--)
			d_on_path -= distance2points(path.at(i).pos, path.at(i-1).pos);
	}

	return d_on_path;
}

bool PlanningHelpers::CompareTrajectories(const std::vector&lt;WayPoint&gt;&amp; path1, const std::vector&lt;WayPoint&gt;&amp; path2)
{
	if(path1.size() != path2.size())
		return false;

	for(unsigned int i=0; i&lt; path1.size(); i++)
	{
		if(path1.at(i).v != path2.at(i).v || path1.at(i).pos.x != path2.at(i).pos.x || path1.at(i).pos.y != path2.at(i).pos.y || path1.at(i).pos.alt != path2.at(i).pos.alt || path1.at(i).pos.lon != path2.at(i).pos.lon)
			return false;
	}

	return true;
}

double PlanningHelpers::GetDistanceToClosestStopLineAndCheck(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; p, int&amp; stopLineID, int&amp; stopSignID, int&amp; trafficLightID, const int&amp; prevIndex)
{

//	trafficLightID = stopSignID = stopLineID = -1;
//
//	RelativeInfo info;
//	GetRelativeInfo(path, p, info);
//
//	for(unsigned int i=info.iBack; i&lt;path.size(); i++)
//	{
//		if(path.at(i).pLane &amp;&amp; path.at(i).pLane-&gt;stopLines.size() &gt; 0)
//		{
//			stopSignID = path.at(i).pLane-&gt;stopLines.at(0).stopSignID;
//			trafficLightID = path.at(i).pLane-&gt;stopLines.at(0).trafficLightID;
//			return 1;
////			for(unsigned int j = 0; j &lt; path.at(i).pLane-&gt;stopLines.size(); j++)
////			{
////				RelativeInfo local_info;
////				WayPoint stopLineWP;
////				stopLineWP.pos = path.at(i).pLane-&gt;stopLines.at(j).points.at(0);
////
////				GetRelativeInfo(path, stopLineWP, local_info, i);
////
////				double d = GetExactDistanceOnTrajectory(path, info, local_info);
////				if(d &gt; 0)
////				{
////						stopSignID = path.at(i).pLane-&gt;stopLines.at(j).stopSignID;
////						trafficLightID = path.at(i).pLane-&gt;stopLines.at(j).trafficLightID;
////						return d;
////				}
////			}
//		}
//	}

	trafficLightID = stopSignID = stopLineID = -1;

	RelativeInfo info;
	GetRelativeInfo(path, p, info, prevIndex);

	for(unsigned int i=info.iBack; i&lt;path.size(); i++)
	{
		if(path.at(i).stopLineID &gt; 0 &amp;&amp; path.at(i).pLane)
		{
			for(unsigned int j = 0; j &lt; path.at(i).pLane-&gt;stopLines.size(); j++)
			{
				if(path.at(i).pLane-&gt;stopLines.at(j).id == path.at(i).stopLineID)
				{
					stopLineID = path.at(i).stopLineID;

					RelativeInfo stop_info;
					WayPoint stopLineWP ;
					stopLineWP.pos = path.at(i).pLane-&gt;stopLines.at(j).points.at(0);
					GetRelativeInfo(path, stopLineWP, stop_info);
					double localDistance = GetExactDistanceOnTrajectory(path, info, stop_info);

					if(localDistance&gt;0)
					{
						stopSignID = path.at(i).pLane-&gt;stopLines.at(j).stopSignID;
						trafficLightID = path.at(i).pLane-&gt;stopLines.at(j).trafficLightID;
						return localDistance;
					}
				}
			}
		}
	}

	return -1;
}

void PlanningHelpers::FixPathDensity(vector&lt;WayPoint&gt;&amp; path, const double&amp; distanceDensity)
{
	if(path.size() == 0 || distanceDensity==0) return;

	double d = 0, a = 0;
	double margin = distanceDensity*0.01;
	double remaining = 0;
	int nPoints = 0;
	vector&lt;WayPoint&gt; fixedPath;
	fixedPath.push_back(path.at(0));
	for(unsigned int si = 0, ei=1; ei &lt; path.size(); )
	{
		d += hypot(path.at(ei).pos.x- path.at(ei-1).pos.x, path.at(ei).pos.y- path.at(ei-1).pos.y) + remaining;
		a = atan2(path.at(ei).pos.y - path.at(si).pos.y, path.at(ei).pos.x - path.at(si).pos.x);

		if(d &lt; distanceDensity - margin ) // skip
		{
			ei++;
			remaining = 0;
		}
		else if(d &gt; (distanceDensity +  margin)) // skip
		{
			WayPoint pm = path.at(si);
			nPoints = d  / distanceDensity;
			for(int k = 0; k &lt; nPoints; k++)
			{
				pm.pos.x = pm.pos.x + distanceDensity * cos(a);
				pm.pos.y = pm.pos.y + distanceDensity * sin(a);
				fixedPath.push_back(pm);
			}
			remaining = d - nPoints*distanceDensity;
			si++;
			path.at(si).pos = pm.pos;
			d = 0;
			ei++;
		}
		else
		{
			d = 0;
			remaining = 0;
			fixedPath.push_back(path.at(ei));
			ei++;
			si = ei - 1;
		}
	}

	path = fixedPath;
}

void PlanningHelpers::SmoothPath(vector&lt;WayPoint&gt;&amp; path, double weight_data,
		double weight_smooth, double tolerance)
{

	if (path.size() &lt;= 2 )
	{
		cout &lt;&lt; &quot;Can't Smooth Path, Path_in Size=&quot; &lt;&lt; path.size() &lt;&lt; endl;
		return;
	}

	const vector&lt;WayPoint&gt;&amp; path_in = path;
	vector&lt;WayPoint&gt; smoothPath_out =  path_in;

	double change = tolerance;
	double xtemp, ytemp;
	int nIterations = 0;

	int size = path_in.size();

	while (change &gt;= tolerance)
	{
		change = 0.0;
		for (int i = 1; i &lt; size - 1; i++)
		{
//			if (smoothPath_out[i].pos.a != smoothPath_out[i - 1].pos.a)
//				continue;

			xtemp = smoothPath_out[i].pos.x;
			ytemp = smoothPath_out[i].pos.y;

			smoothPath_out[i].pos.x += weight_data
					* (path_in[i].pos.x - smoothPath_out[i].pos.x);
			smoothPath_out[i].pos.y += weight_data
					* (path_in[i].pos.y - smoothPath_out[i].pos.y);

			smoothPath_out[i].pos.x += weight_smooth
					* (smoothPath_out[i - 1].pos.x + smoothPath_out[i + 1].pos.x
							- (2.0 * smoothPath_out[i].pos.x));
			smoothPath_out[i].pos.y += weight_smooth
					* (smoothPath_out[i - 1].pos.y + smoothPath_out[i + 1].pos.y
							- (2.0 * smoothPath_out[i].pos.y));

			change += fabs(xtemp - smoothPath_out[i].pos.x);
			change += fabs(ytemp - smoothPath_out[i].pos.y);

		}
		nIterations++;
	}

	path = smoothPath_out;
}

//double PlanningHelpers::CalcAngleAndCostSimple(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost)
//{
//	if(path.size() &lt;= 2) return 0;
//
//	path[0].pos.a = atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x );
//	path[0].cost = lastCost;
//
//	for(int j = 1; j &lt; path.size()-1; j++)
//	{
//		path[j].pos.a 	= atan2(path[j+1].pos.y - path[j].pos.y, path[j+1].pos.x - path[j].pos.x );
//		path[j].cost 	= path[j-1].cost +  hypot(path[j-1].pos.y- path[j].pos.y, path[j-1].pos.x- path[j].pos.x);
//	}
//
//	int j = (int)path.size()-1;
//
//	path[j].pos.a 	= path[j-1].pos.a;
//	path[j].cost 	= path[j-1].cost + hypot(path[j-1].pos.y- path[j].pos.y, path[j-1].pos.x- path[j].pos.x);
//
//	for(int j = 0; j &lt; path.size()-1; j++)
//	{
//		if(path.at(j).pos.x == path.at(j+1).pos.x &amp;&amp; path.at(j).pos.y == path.at(j+1).pos.y)
//			path.at(j).pos.a = path.at(j+1).pos.a;
//	}
//
//	return path[j].cost;
//}

double PlanningHelpers::CalcAngleAndCost(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost, const bool&amp; bSmooth)
{
	if(path.size() &lt;= 2) return 0;

	path[0].pos.a = UtilityH::FixNegativeAngle(atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x ));
	path[0].cost = lastCost;

	for(int j = 1; j &lt; path.size()-1; j++)
	{
		path[j].pos.a 		= UtilityH::FixNegativeAngle(atan2(path[j+1].pos.y - path[j].pos.y, path[j+1].pos.x - path[j].pos.x ));
		path[j].cost 	= path[j-1].cost +  distance2points(path[j-1].pos, path[j].pos);
	}

	int j = (int)path.size()-1;

	path[j].pos.a 		= path[j-1].pos.a;
	path[j].cost 	= path[j-1].cost + distance2points(path[j-1].pos, path[j].pos);

	for(int j = 0; j &lt; path.size()-1; j++)
	{
		if(path.at(j).pos.x == path.at(j+1).pos.x &amp;&amp; path.at(j).pos.y == path.at(j+1).pos.y)
			path.at(j).pos.a = path.at(j+1).pos.a;
	}

	return path[j].cost;
}

double PlanningHelpers::CalcAngleAndCostAndCurvatureAnd2D(vector&lt;WayPoint&gt;&amp; path, const double&amp; lastCost)
{
	path[0].pos.a 	= atan2(path[1].pos.y - path[0].pos.y, path[1].pos.x - path[0].pos.x );
	path[0].cost 	= lastCost;

	double k = 0;
	GPSPoint center;

	for(unsigned int j = 1; j &lt; path.size()-1; j++)
	{
		k =  CalcCircle(path[j-1].pos,path[j].pos, path[j+1].pos, center);
		if(k &gt; 150.0 || isnan(k))
			k = 150.0;

		if(k&lt;1.0)
			path[j].cost = 0;
		else
			path[j].cost = 1.0-1.0/k;

		path[j].pos.a 	= atan2(path[j+1].pos.y - path[j].pos.y, path[j+1].pos.x - path[j].pos.x );
	}
	unsigned int j = path.size()-1;

	path[0].cost    = path[1].cost;
	path[j].cost 	= path[j-1].cost;
	path[j].pos.a 	= path[j-1].pos.a;
	path[j].cost 	= path[j-1].cost ;

	return path[j].cost;
}

double PlanningHelpers::CalcCircle(const GPSPoint&amp; pt1, const GPSPoint&amp; pt2, const GPSPoint&amp; pt3, GPSPoint&amp; center)
{
	double yDelta_a= pt2.y - pt1.y;
	double xDelta_a= pt2.x - pt1.x;
	double yDelta_b= pt3.y - pt2.y;
	double xDelta_b= pt3.x - pt2.x;

	if (fabs(xDelta_a) &lt;= 0.000000000001 &amp;&amp; fabs(yDelta_b) &lt;= 0.000000000001)
	{
		center.x= 0.5*(pt2.x + pt3.x);
		center.y= 0.5*(pt1.y + pt2.y);
		return distance2points(center,pt1);
	}

	double aSlope=yDelta_a/xDelta_a;
	double bSlope=yDelta_b/xDelta_b;
	if (fabs(aSlope-bSlope) &lt;= 0.000000000001)
	{
		return 100000;
	}

	center.x= (aSlope*bSlope*(pt1.y - pt3.y) + bSlope*(pt1.x + pt2 .x) - aSlope*(pt2.x+pt3.x) )/(2.0* (bSlope-aSlope) );
	center.y = -1.0*(center.x - (pt1.x+pt2.x)/2.0)/aSlope +  (pt1.y+pt2.y)/2.0;

	return  distance2points(center,pt1);
}

void PlanningHelpers::ExtractPartFromPointToDistance(const vector&lt;WayPoint&gt;&amp; originalPath, const WayPoint&amp; pos, const double&amp; minDistance,
		const double&amp; pathDensity, vector&lt;WayPoint&gt;&amp; extractedPath, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight, const double&amp; SmoothTolerance)
{
	extractedPath.clear();
	unsigned int close_index = GetClosestNextPointIndexDirection(originalPath, pos);
	vector&lt;WayPoint&gt; tempPath;
	double d_limit = 0;
	if(close_index &gt;= 5) close_index -=5;
	else close_index = 0;

	for(unsigned int i=close_index; i&lt; originalPath.size(); i++)
	{
		tempPath.push_back(originalPath.at(i));

		if(i&gt;0)
			d_limit += hypot(originalPath.at(i).pos.y - originalPath.at(i-1).pos.y, originalPath.at(i).pos.x - originalPath.at(i-1).pos.x);

		if(d_limit &gt; minDistance)
			break;
	}

	if(tempPath.size() &lt; 2)
	{
		cout &lt;&lt; endl &lt;&lt; &quot;### Planner Z . Extracted Rollout Path is too Small, Size = &quot; &lt;&lt; tempPath.size() &lt;&lt; endl;
		return;
	}

	FixPathDensity(tempPath, pathDensity);
	SmoothPath(tempPath, SmoothDataWeight, SmoothWeight , SmoothTolerance);
	CalcAngleAndCost(tempPath);

	extractedPath = tempPath;
	//tempPath.clear();
	//TestQuadraticSpline(extractedPath, tempPath);
}

void PlanningHelpers::CalculateRollInTrajectories(const WayPoint&amp; carPos, const double&amp; speed, const vector&lt;WayPoint&gt;&amp; originalCenter, int&amp; start_index,
		int&amp; end_index, vector&lt;double&gt;&amp; end_laterals ,
		vector&lt;vector&lt;WayPoint&gt; &gt;&amp; rollInPaths, const double&amp; max_roll_distance,
		const double&amp; maxSpeed, const double&amp;  carTipMargin, const double&amp; rollInMargin,
		const double&amp; rollInSpeedFactor, const double&amp; pathDensity, const double&amp; rollOutDensity,
		const int&amp; rollOutNumber, const double&amp; SmoothDataWeight, const double&amp; SmoothWeight,
		const double&amp; SmoothTolerance, const bool&amp; bHeadingSmooth,
		std::vector&lt;WayPoint&gt;&amp; sampledPoints)
{
	WayPoint p;
	double dummyd = 0;

	int iLimitIndex = (carTipMargin/0.3)/pathDensity;
	if(iLimitIndex &gt;= originalCenter.size())
		iLimitIndex = originalCenter.size() - 1;

	//Get Closest Index
	RelativeInfo info;
	GetRelativeInfo(originalCenter, carPos, info);
	double remaining_distance = 0;
	int close_index = info.iBack;
	for(unsigned int i=close_index; i&lt; originalCenter.size()-1; i++)
	  {
		if(i&gt;0)
			remaining_distance += distance2points(originalCenter[i].pos, originalCenter[i+1].pos);
	  }

	double initial_roll_in_distance = info.perp_distance ; //GetPerpDistanceToTrajectorySimple(originalCenter, carPos, close_index);


	vector&lt;WayPoint&gt; RollOutStratPath;
	///***   Smoothing From Car Heading Section ***///
//	if(bHeadingSmooth)
//	{
//		unsigned int num_of_strait_points = carTipMargin / pathDensity;
//		int closest_for_each_iteration = 0;
//		WayPoint np = GetPerpendicularOnTrajectory(originalCenter, rearPos, dummyd, closest_for_each_iteration);
//		np.pos = rearPos.pos;
//
//		RollOutStratPath.push_back(np);
//		for(unsigned int i = 0; i &lt; num_of_strait_points; i++)
//		{
//			p = RollOutStratPath.at(i);
//			p.pos.x = p.pos.x +  pathDensity*cos(p.pos.a);
//			p.pos.y = p.pos.y +  pathDensity*sin(p.pos.a);
//			np = GetPerpendicularOnTrajectory(originalCenter, p, dummyd, closest_for_each_iteration);
//			np.pos = p.pos;
//			RollOutStratPath.push_back(np);
//		}
//
//		initial_roll_in_distance = GetPerpDistanceToTrajectorySimple(originalCenter, RollOutStratPath.at(RollOutStratPath.size()-1), close_index);
//	}
	///***   -------------------------------- ***///


	//printf(&quot;\n Lateral Distance: %f&quot; , initial_roll_in_distance);

	//calculate the starting index
	double d_limit = 0;
	unsigned int far_index = close_index;

	//calculate end index
	double start_distance = rollInSpeedFactor*speed+rollInMargin;
	if(start_distance &gt; remaining_distance)
		start_distance = remaining_distance;

	d_limit = 0;
	for(unsigned int i=close_index; i&lt; originalCenter.size(); i++)
	  {
		  if(i&gt;0)
			  d_limit += distance2points(originalCenter[i].pos, originalCenter[i-1].pos);

		  if(d_limit &gt;= start_distance)
		  {
			  far_index = i;
			  break;
		  }
	  }

	int centralTrajectoryIndex = rollOutNumber/2;
	vector&lt;double&gt; end_distance_list;
	for(int i=0; i&lt; rollOutNumber+1; i++)
	  {
		  double end_roll_in_distance = rollOutDensity*(i - centralTrajectoryIndex);
		  end_distance_list.push_back(end_roll_in_distance);
	  }

	start_index = close_index;
	end_index = far_index;
	end_laterals = end_distance_list;

	//calculate the actual calculation starting index
	d_limit = 0;
	unsigned int smoothing_start_index = start_index;
	unsigned int smoothing_end_index = end_index;

	for(unsigned int i=smoothing_start_index; i&lt; originalCenter.size(); i++)
	{
		if(i &gt; 0)
			d_limit += distance2points(originalCenter[i].pos, originalCenter[i-1].pos);
		if(d_limit &gt; carTipMargin)
			break;

		smoothing_start_index++;
	}

	d_limit = 0;
	for(unsigned int i=end_index; i&lt; originalCenter.size(); i++)
	{
		if(i &gt; 0)
			d_limit += distance2points(originalCenter[i].pos, originalCenter[i-1].pos);
		if(d_limit &gt; carTipMargin)
			break;

		smoothing_end_index++;
	}

	int nSteps = end_index - smoothing_start_index;


	vector&lt;double&gt; inc_list;
	rollInPaths.clear();
	vector&lt;double&gt; inc_list_inc;
	for(int i=0; i&lt; rollOutNumber+1; i++)
	{
		double diff = end_laterals.at(i)-initial_roll_in_distance;
		inc_list.push_back(diff/(double)nSteps);
		rollInPaths.push_back(vector&lt;WayPoint&gt;());
		inc_list_inc.push_back(0);
	}



	vector&lt;vector&lt;WayPoint&gt; &gt; execluded_from_smoothing;
	for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
		execluded_from_smoothing.push_back(vector&lt;WayPoint&gt;());



	//Insert First strait points within the tip of the car range
	for(unsigned int j = start_index; j &lt; smoothing_start_index; j++)
	{
		p = originalCenter.at(j);
		double original_speed = p.v;
	  for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
	  {
		  p.pos.x = originalCenter.at(j).pos.x -  initial_roll_in_distance*cos(p.pos.a + M_PI_2);
		  p.pos.y = originalCenter.at(j).pos.y -  initial_roll_in_distance*sin(p.pos.a + M_PI_2);
		  if(i!=centralTrajectoryIndex)
			  p.v = original_speed * LANE_CHANGE_SPEED_FACTOR;
		  else
			  p.v = original_speed ;

		  if(j &lt; iLimitIndex)
			  execluded_from_smoothing.at(i).push_back(p);
		  else
			  rollInPaths.at(i).push_back(p);

		  sampledPoints.push_back(p);
	  }
	}

	for(unsigned int j = smoothing_start_index; j &lt; end_index; j++)
	  {
		  p = originalCenter.at(j);
		  double original_speed = p.v;
		  for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
		  {
			  inc_list_inc[i] += inc_list[i];
			  double d = inc_list_inc[i];
			  p.pos.x = originalCenter.at(j).pos.x -  initial_roll_in_distance*cos(p.pos.a + M_PI_2) - d*cos(p.pos.a+ M_PI_2);
			  p.pos.y = originalCenter.at(j).pos.y -  initial_roll_in_distance*sin(p.pos.a + M_PI_2) - d*sin(p.pos.a+ M_PI_2);
			  if(i!=centralTrajectoryIndex)
				  p.v = original_speed * LANE_CHANGE_SPEED_FACTOR;
			  else
				  p.v = original_speed ;

			  rollInPaths.at(i).push_back(p);

			  sampledPoints.push_back(p);
		  }
	  }

	//Insert last strait points to make better smoothing
	for(unsigned int j = end_index; j &lt; smoothing_end_index; j++)
	{
		p = originalCenter.at(j);
		double original_speed = p.v;
	  for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
	  {
		  double d = end_laterals.at(i);
		  p.pos.x  = originalCenter.at(j).pos.x - d*cos(p.pos.a + M_PI_2);
		  p.pos.y  = originalCenter.at(j).pos.y - d*sin(p.pos.a + M_PI_2);
		  if(i!=centralTrajectoryIndex)
			  p.v = original_speed * LANE_CHANGE_SPEED_FACTOR;
		  else
			  p.v = original_speed ;
		  rollInPaths.at(i).push_back(p);

		  sampledPoints.push_back(p);
	  }
	}

	for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
		rollInPaths.at(i).insert(rollInPaths.at(i).begin(), execluded_from_smoothing.at(i).begin(), execluded_from_smoothing.at(i).end());

	///***   Smoothing From Car Heading Section ***///
//	if(bHeadingSmooth)
//	{
//		for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
//		{
//			unsigned int cut_index = GetClosestNextPointIndex(rollInPaths.at(i), RollOutStratPath.at(RollOutStratPath.size()-1));
//			rollInPaths.at(i).erase(rollInPaths.at(i).begin(), rollInPaths.at(i).begin()+cut_index);
//			rollInPaths.at(i).insert(rollInPaths.at(i).begin(), RollOutStratPath.begin(), RollOutStratPath.end());
//		}
//	}
	///***   -------------------------------- ***///

	for(unsigned int i=0; i&lt; rollOutNumber+1 ; i++)
	{
		SmoothPath(rollInPaths.at(i), SmoothDataWeight, SmoothWeight, SmoothTolerance);
	}

	d_limit = 0;
	for(unsigned int j = smoothing_end_index; j &lt; originalCenter.size(); j++)
	  {
		if(j &gt; 0)
			d_limit += distance2points(originalCenter.at(j).pos, originalCenter.at(j-1).pos);

		if(d_limit &gt; max_roll_distance)
			break;

			p = originalCenter.at(j);
			double original_speed = p.v;
		  for(unsigned int i=0; i&lt; rollInPaths.size() ; i++)
		  {
			  double d = end_laterals.at(i);
			  p.pos.x  = originalCenter.at(j).pos.x - d*cos(p.pos.a + M_PI_2);
			  p.pos.y  = originalCenter.at(j).pos.y - d*sin(p.pos.a + M_PI_2);

			  if(i!=centralTrajectoryIndex)
				  p.v = original_speed * LANE_CHANGE_SPEED_FACTOR;
			  else
				  p.v = original_speed ;

			  rollInPaths.at(i).push_back(p);

			  sampledPoints.push_back(p);
		  }
	  }

//	for(unsigned int i=0; i&lt; rollInPaths.size(); i++)
//		CalcAngleAndCost(rollInPaths.at(i));
}

bool PlanningHelpers::FindInList(const std::vector&lt;int&gt;&amp; list,const int&amp; x)
{
	for(unsigned int i = 0 ; i &lt; list.size(); i++)
	{
		if(list.at(i) == x)
			return true;
	}
	return false;
}

void PlanningHelpers::RemoveWithValue(std::vector&lt;int&gt;&amp; list,const int&amp; x)
{
	for(unsigned int i = 0 ; i &lt; list.size(); i++)
	{
		if(list.at(i) == x)
		{
			list.erase(list.begin()+i);
		}
	}
}

std::vector&lt;int&gt; PlanningHelpers::GetUniqueLeftRightIds(const std::vector&lt;WayPoint&gt;&amp; path)
{
	 vector&lt;int&gt; sideLanes;
	for(unsigned int iwp = 0; iwp &lt; path.size(); iwp++)
	 {
		 if(path.at(iwp).LeftLaneId&gt;0)
		 {
			 bool bFound = false;
			 for(unsigned int is = 0 ; is &lt; sideLanes.size(); is++)
			 {
				 if(sideLanes.at(is) == path.at(iwp).LeftLaneId)
				 {
					 bFound = true;
					 break;
				 }
			 }

			 if(!bFound)
				 sideLanes.push_back(path.at(iwp).LeftLaneId);
		 }

		 if(path.at(iwp).RightLaneId&gt;0)
		 {
			 bool bFound = false;
			 for(unsigned int is = 0 ; is &lt; sideLanes.size(); is++)
			 {
				 if(sideLanes.at(is) == path.at(iwp).RightLaneId)
				 {
					 bFound = true;
					 break;
				 }
			 }

			 if(!bFound)
				 sideLanes.push_back(path.at(iwp).RightLaneId);
		 }

		 //RemoveWithValue(sideLanes, path.at(iwp).laneId);
	 }
	return sideLanes;
}

void PlanningHelpers::SmoothSpeedProfiles(vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	)
{

	if (path_in.size() &lt;= 1)
		return;
	vector&lt;WayPoint&gt; newpath = path_in;

	double change = tolerance;
	double xtemp;
	int nIterations = 0;
	int size = newpath.size();

	while (change &gt;= tolerance)
	{
		change = 0.0;
		for (int i = 1; i &lt; size -1; i++)
		{
			xtemp = newpath[i].v;
			newpath[i].v += weight_data * (path_in[i].v - newpath[i].v);
			newpath[i].v += weight_smooth * (newpath[i - 1].v + newpath[i + 1].v - (2.0 * newpath[i].v));
			change += fabs(xtemp - newpath[i].v);

		}
		nIterations++;
	}

	path_in = newpath;
}

void PlanningHelpers::SmoothCurvatureProfiles(vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance)
{
	if (path_in.size() &lt;= 1)
			return;
	vector&lt;WayPoint&gt; newpath = path_in;

	double change = tolerance;
	double xtemp;
	int nIterations = 0;
	int size = newpath.size();

	while (change &gt;= tolerance)
	{
		change = 0.0;
		for (int i = 1; i &lt; size -1; i++)
		{
			xtemp = newpath[i].cost;
			newpath[i].cost += weight_data * (path_in[i].cost - newpath[i].cost);
			newpath[i].cost += weight_smooth * (newpath[i - 1].cost + newpath[i + 1].cost - (2.0 * newpath[i].cost));
			change += fabs(xtemp - newpath[i].cost);

		}
		nIterations++;
	}
	path_in = newpath;
}

void PlanningHelpers::SmoothWayPointsDirections(vector&lt;WayPoint&gt;&amp; path_in, double weight_data, double weight_smooth, double tolerance	)
{

	if (path_in.size() &lt;= 1)
		return;

	vector&lt;WayPoint&gt; newpath = path_in;

	double change = tolerance;
	double xtemp;
	int nIterations = 0;
	int size = newpath.size();

	while (change &gt;= tolerance)
	{
		change = 0.0;
		for (int i = 1; i &lt; size -1; i++)
		{
			xtemp = newpath[i].pos.a;
			newpath[i].pos.a += weight_data * (path_in[i].pos.a - newpath[i].pos.a);
			newpath[i].pos.a += weight_smooth * (newpath[i - 1].pos.a + newpath[i + 1].pos.a - (2.0 * newpath[i].pos.a));
			change += fabs(xtemp - newpath[i].pos.a);

		}
		nIterations++;
	}
	path_in = newpath;
}

void PlanningHelpers::GenerateRecommendedSpeed(vector&lt;WayPoint&gt;&amp; path, const double&amp; max_speed, const double&amp; speedProfileFactor)
{
	FixPathDensity(path, 0.5);

	CalcAngleAndCostAndCurvatureAnd2D(path);

	SmoothCurvatureProfiles(path, 0.3, 0.49, 0.01);

	for(unsigned int i = 0 ; i &lt; path.size(); i++)
	{
		double k_ratio = path.at(i).cost*10.0;

		if(k_ratio &gt;= 9.5)
			path.at(i).v = max_speed;
		else if(k_ratio &lt;= 8.5)
			path.at(i).v = 1.0*speedProfileFactor;
		else
		{
			k_ratio = k_ratio - 8.5;
			path.at(i).v = (max_speed - 1.0) * k_ratio + 1.0;
			path.at(i).v = path.at(i).v*speedProfileFactor;
		}

		if(path.at(i).v &gt; max_speed)
			path.at(i).v = max_speed;

	}

	//SmoothSpeedProfiles(path, 0.15,0.45, 0.1);
}

WayPoint* PlanningHelpers::BuildPlanningSearchTreeV2(WayPoint* pStart,
		const WayPoint&amp; goalPos,
		const vector&lt;int&gt;&amp; globalPath,
		const double&amp; DistanceLimit,
		const bool&amp; bEnableLaneChange,
		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete)
{
	if(!pStart) return NULL;

	vector&lt;pair&lt;WayPoint*, WayPoint*&gt; &gt;nextLeafToTrace;

	WayPoint* pZero = 0;
	WayPoint* wp    = new WayPoint();
	*wp = *pStart;
	nextLeafToTrace.push_back(make_pair(pZero, wp));
	all_cells_to_delete.push_back(wp);

	double 		distance 		= 0;
	WayPoint* 	pGoalCell 		= 0;
	double 		nCounter 		= 0;


	while(nextLeafToTrace.size()&gt;0)
	{
		nCounter++;

		unsigned int min_cost_index = 0;
		double min_cost = 99999999999;

		for(unsigned int i=0; i &lt; nextLeafToTrace.size(); i++)
		{
			if(nextLeafToTrace.at(i).second-&gt;cost &lt; min_cost)
			{
				min_cost = nextLeafToTrace.at(i).second-&gt;cost;
				min_cost_index = i;
			}
		}

		WayPoint* pH 	= nextLeafToTrace.at(min_cost_index).second;

		assert(pH != 0);

		nextLeafToTrace.erase(nextLeafToTrace.begin()+min_cost_index);

		double distance_to_goal = distance2points(pH-&gt;pos, goalPos.pos);
		double angle_to_goal = UtilityH::AngleBetweenTwoAnglesPositive(UtilityH::FixNegativeAngle(pH-&gt;pos.a), UtilityH::FixNegativeAngle(goalPos.pos.a));
		if( distance_to_goal &lt;= 0.1 &amp;&amp; angle_to_goal &lt; M_PI_4)
		{
			cout &lt;&lt; &quot;Goal Found, LaneID: &quot; &lt;&lt; pH-&gt;laneId &lt;&lt;&quot;, Distance : &quot; &lt;&lt; distance_to_goal &lt;&lt; &quot;, Angle: &quot; &lt;&lt; angle_to_goal*RAD2DEG &lt;&lt; endl;
			pGoalCell = pH;
			break;
		}
		else
		{

			if(pH-&gt;pLeft &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pLeft-&gt;pLane) &amp;&amp; bEnableLaneChange)
			{
				wp = new WayPoint();
				*wp = *pH-&gt;pLeft;
				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
				distance += d;

				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
				{
					//if(wp-&gt;actionCost.at(a).first == LEFT_TURN_ACTION)
						d += wp-&gt;actionCost.at(a).second;
				}

				wp-&gt;cost = pH-&gt;cost + d;
				wp-&gt;pRight = pH;
				wp-&gt;pLeft = 0;

				nextLeafToTrace.push_back(make_pair(pH, wp));
				all_cells_to_delete.push_back(wp);
			}

			if(pH-&gt;pRight &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pRight-&gt;pLane) &amp;&amp; bEnableLaneChange)
			{
				wp = new WayPoint();
				*wp = *pH-&gt;pRight;
				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
				distance += d;

				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
				{
					//if(wp-&gt;actionCost.at(a).first == RIGHT_TURN_ACTION)
						d += wp-&gt;actionCost.at(a).second;
				}

				wp-&gt;cost = pH-&gt;cost + d ;
				wp-&gt;pLeft = pH;
				wp-&gt;pRight = 0;
				nextLeafToTrace.push_back(make_pair(pH, wp));
				all_cells_to_delete.push_back(wp);
			}

			for(unsigned int i =0; i&lt; pH-&gt;pFronts.size(); i++)
			{
				if(CheckLaneIdExits(globalPath, pH-&gt;pLane) &amp;&amp; pH-&gt;pFronts.at(i) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pFronts.at(i)))
				{
					wp = new WayPoint();
					*wp = *pH-&gt;pFronts.at(i);

					double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
					distance += d;

					for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
					{
						//if(wp-&gt;actionCost.at(a).first == FORWARD_ACTION)
							d += wp-&gt;actionCost.at(a).second;
					}

					wp-&gt;cost = pH-&gt;cost + d;
					wp-&gt;pBacks.push_back(pH);

					nextLeafToTrace.push_back(make_pair(pH, wp));
					all_cells_to_delete.push_back(wp);
				}
			}
		}

		if(distance &gt; DistanceLimit &amp;&amp; globalPath.size()==0)
		{
			//if(!pGoalCell)
			cout &lt;&lt; &quot;Goal Not Found, LaneID: &quot; &lt;&lt; pH-&gt;laneId &lt;&lt;&quot;, Distance : &quot; &lt;&lt; distance &lt;&lt; endl;
			pGoalCell = pH;
			break;
		}

		//pGoalCell = pH;
	}

	while(nextLeafToTrace.size()!=0)
		nextLeafToTrace.pop_back();
	//closed_nodes.clear();

	return pGoalCell;
}

WayPoint* PlanningHelpers::BuildPlanningSearchTreeStraight(WayPoint* pStart,
		const double&amp; DistanceLimit,
		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete)
{
	if(!pStart) return NULL;

	vector&lt;pair&lt;WayPoint*, WayPoint*&gt; &gt;nextLeafToTrace;

	WayPoint* pZero = 0;
	WayPoint* wp    = new WayPoint();
	*wp = *pStart;
	nextLeafToTrace.push_back(make_pair(pZero, wp));
	all_cells_to_delete.push_back(wp);

	double 		distance 		= 0;
	WayPoint* 	pGoalCell 		= 0;
	double 		nCounter 		= 0;

	while(nextLeafToTrace.size()&gt;0)
	{
		nCounter++;

		unsigned int min_cost_index = 0;
		double min_cost = 99999999999;

		for(unsigned int i=0; i &lt; nextLeafToTrace.size(); i++)
		{
			if(nextLeafToTrace.at(i).second-&gt;cost &lt; min_cost)
			{
				min_cost = nextLeafToTrace.at(i).second-&gt;cost;
				min_cost_index = i;
			}
		}

		WayPoint* pH 	= nextLeafToTrace.at(min_cost_index).second;
		assert(pH != 0);

		nextLeafToTrace.erase(nextLeafToTrace.begin()+min_cost_index);

		for(unsigned int i =0; i&lt; pH-&gt;pFronts.size(); i++)
		{
			if(pH-&gt;pFronts.at(i) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pFronts.at(i)))
			{
				wp = new WayPoint();
				*wp = *pH-&gt;pFronts.at(i);

				double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
				distance += d;

				for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
				{
					//if(wp-&gt;actionCost.at(a).first == FORWARD_ACTION)
						d += wp-&gt;actionCost.at(a).second;
				}

				wp-&gt;cost = pH-&gt;cost + d;
				wp-&gt;pBacks.push_back(pH);
				if(wp-&gt;cost &lt; DistanceLimit)
				{
					nextLeafToTrace.push_back(make_pair(pH, wp));
					all_cells_to_delete.push_back(wp);
				}
				else
					delete wp;
			}
		}

//		if(pH-&gt;pLeft &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pLeft-&gt;pLane))
//		{
//			wp = new WayPoint();
//			*wp = *pH-&gt;pLeft;
//			double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);
//
//			for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
//			{
//				//if(wp-&gt;actionCost.at(a).first == LEFT_TURN_ACTION)
//					d += wp-&gt;actionCost.at(a).second;
//			}
//
//			wp-&gt;cost = pH-&gt;cost + d + LANE_CHANGE_COST;
//			wp-&gt;pRight = pH;
//			wp-&gt;pRight = 0;
//
//			nextLeafToTrace.push_back(make_pair(pH, wp));
//			all_cells_to_delete.push_back(wp);
//		}
//
//		if(pH-&gt;pRight &amp;&amp; !CheckLaneExits(all_cells_to_delete, pH-&gt;pRight-&gt;pLane))
//		{
//			wp = new WayPoint();
//			*wp = *pH-&gt;pRight;
//			double d = hypot(wp-&gt;pos.y - pH-&gt;pos.y, wp-&gt;pos.x - pH-&gt;pos.x);;
//
//			for(unsigned int a = 0; a &lt; wp-&gt;actionCost.size(); a++)
//			{
//				//if(wp-&gt;actionCost.at(a).first == RIGHT_TURN_ACTION)
//					d += wp-&gt;actionCost.at(a).second;
//			}
//
//			wp-&gt;cost = pH-&gt;cost + d + LANE_CHANGE_COST;
//			wp-&gt;pLeft = pH;
//			wp-&gt;pRight = 0;
//			nextLeafToTrace.push_back(make_pair(pH, wp));
//			all_cells_to_delete.push_back(wp);
//		}

		pGoalCell = pH;
	}

	while(nextLeafToTrace.size()!=0)
		nextLeafToTrace.pop_back();

	return pGoalCell;
}

int PlanningHelpers::PredictiveDP(WayPoint* pStart, const double&amp; DistanceLimit,
		vector&lt;WayPoint*&gt;&amp; all_cells_to_delete,vector&lt;WayPoint*&gt;&amp; end_waypoints)
{
	if(!pStart) return 0;

	vector&lt;pair&lt;WayPoint*, WayPoint*&gt; &gt;nextLeafToTrace;

	WayPoint* pZero = 0;
	WayPoint* wp    = new WayPoint();
	*wp = *pStart;
	wp-&gt;pLeft = 0;
	wp-&gt;pRight = 0;
	nextLeafToTrace.push_back(make_pair(pZero, wp));
	all_cells_to_delete.push_back(wp);

	double 		distance 		= 0;
	end_waypoints.clear();
	double 		nCounter 		= 0;

	while(nextLeafToTrace.size()&gt;0)
	{
		nCounter++;

		WayPoint* pH 	= nextLeafToTrace.at(0).second;

		assert(pH != 0);

		nextLeafToTrace.erase(nextLeafToTrace.begin()+0);

		for(unsigned int i =0; i&lt; pH-&gt;pFronts.size(); i++)
		{
			if(pH-&gt;pFronts.at(i) &amp;&amp; !CheckNodeExits(all_cells_to_delete, pH-&gt;pFronts.at(i)))
			{
				if(pH-&gt;cost &lt; DistanceLimit)
				{
					wp = new WayPoint();
					*wp = *pH-&gt;pFronts.at(i);

					double d = distance2points(wp-&gt;pos, pH-&gt;pos);
					distance += d;
					wp-&gt;cost = pH-&gt;cost + d;
					wp-&gt;pBacks.push_back(pH);
					wp-&gt;pLeft = 0;
					wp-&gt;pRight = 0;

					nextLeafToTrace.push_back(make_pair(pH, wp));
					all_cells_to_delete.push_back(wp);
				}
				else
				{
					end_waypoints.push_back(pH);
				}
			}
		}
	}

	while(nextLeafToTrace.size()!=0)
		nextLeafToTrace.pop_back();
	//closed_nodes.clear();

	return end_waypoints.size();
}

bool PlanningHelpers::CheckLaneIdExits(const std::vector&lt;int&gt;&amp; lanes, const Lane* pL)
{
	if(lanes.size()==0) return true;

	for(unsigned int i=0; i&lt; lanes.size(); i++)
	{
		if(lanes.at(i) == pL-&gt;id)
			return true;
	}

	return false;
}

WayPoint* PlanningHelpers::CheckLaneExits(const vector&lt;WayPoint*&gt;&amp; nodes, const Lane* pL)
{
	if(nodes.size()==0) return 0;

	for(unsigned int i=0; i&lt; nodes.size(); i++)
	{
		if(nodes.at(i)-&gt;pLane == pL)
			return nodes.at(i);
	}

	return 0;
}

WayPoint* PlanningHelpers::CheckNodeExits(const vector&lt;WayPoint*&gt;&amp; nodes, const WayPoint* pL)
{
	if(nodes.size()==0) return 0;

	for(unsigned int i=0; i&lt; nodes.size(); i++)
	{
		if(nodes.at(i)-&gt;id == pL-&gt;id)
			return nodes.at(i);
	}

	return 0;
}

WayPoint* PlanningHelpers::CreateLaneHeadCell(Lane* pLane, WayPoint* pLeft, WayPoint* pRight,
		WayPoint* pBack)
{
	if(!pLane) return 0;
	if(pLane-&gt;points.size()==0) return 0;

	WayPoint* c = new WayPoint;
	c-&gt;pLane 		= pLane;
	c-&gt;pos 			= pLane-&gt;points.at(0).pos;
	c-&gt;v			= pLane-&gt;speed;
	c-&gt;laneId  		= pLane-&gt;id;
	c-&gt;pLeft 		= pLeft;
	if(pLeft)
		c-&gt;cost		= pLeft-&gt;cost;

	c-&gt;pRight		= pRight;
	if(pRight)
		c-&gt;cost = pRight-&gt;cost;

	if(pBack)
	{
		pBack-&gt;pFronts.push_back(c);
		c-&gt;pBacks.push_back(pBack);
		c-&gt;cost = pBack-&gt;cost + distance2points(c-&gt;pos, pBack-&gt;pos);

		for(unsigned int i=0; i&lt; c-&gt;pBacks.size(); i++)
		{
				if(c-&gt;pBacks.at(i)-&gt;cost &lt; c-&gt;cost)
					c-&gt;cost = c-&gt;pBacks.at(i)-&gt;cost;
		}
	}
	return c;
}

double PlanningHelpers::GetLanePoints(Lane* l, const WayPoint&amp; prevWayPointIndex,
		const double&amp; minDistance , const double&amp; prevCost, vector&lt;WayPoint&gt;&amp; points)
{
	if(l == NULL || minDistance&lt;=0) return 0;

	int index = 0;
	WayPoint  p1, p2;
	WayPoint idx;

	p2 = p1 = l-&gt;points.at(index);
	p1.pLane = l;
	p1.cost = prevCost;
	p2.cost = p1.cost + distance2points(p1.pos, p2.pos);

	points.push_back(p1);

	for(unsigned int i=index+1; i&lt;l-&gt;points.size(); i++)
	{

		p2 = l-&gt;points.at(i);
		p2.pLane = l;
		p2.cost = p1.cost + distance2points(p1.pos, p2.pos);
		points.push_back(p2);

		if(p2.cost &gt;= minDistance)
				break;
		p1 = p2;
	}
	return p2.cost;
}

WayPoint* PlanningHelpers::GetMinCostCell(const vector&lt;WayPoint*&gt;&amp; cells, const vector&lt;int&gt;&amp; globalPathIds)
{
	if(cells.size() == 1)
	{
//		for(unsigned int j = 0; j &lt; cells.at(0)-&gt;actionCost.size(); j++)
//			cout &lt;&lt; &quot;Cost (&quot; &lt;&lt; cells.at(0)-&gt;laneId &lt;&lt; &quot;) of going : &quot; &lt;&lt; cells.at(0)-&gt;actionCost.at(j).first &lt;&lt; &quot;, is : &quot; &lt;&lt; cells.at(0)-&gt;actionCost.at(j).second &lt;&lt; endl;
		return cells.at(0);
	}

	WayPoint* pC = cells.at(0); //cost is distance
	for(unsigned int i=1; i &lt; cells.size(); i++)
	{
		bool bFound = false;
		if(globalPathIds.size()==0)
			bFound = true;

		int iLaneID = cells.at(i)-&gt;id;
		for(unsigned int j=0; j &lt; globalPathIds.size(); j++)
		{
			if(globalPathIds.at(j) == iLaneID)
			{
				bFound = true;
				break;
			}
		}

//		for(unsigned int j = 0; j &lt; cells.at(0)-&gt;actionCost.size(); j++)
//			cout &lt;&lt; &quot;Cost (&quot;&lt;&lt; i &lt;&lt;&quot;) of going : &quot; &lt;&lt; cells.at(0)-&gt;actionCost.at(j).first &lt;&lt; &quot;, is : &quot; &lt;&lt; cells.at(0)-&gt;actionCost.at(j).second &lt;&lt; endl;


		if(cells.at(i)-&gt;cost &lt; pC-&gt;cost &amp;&amp; bFound == true)
			pC = cells.at(i);
	}


	return pC;
}

void PlanningHelpers::ExtractPlanAlernatives(const std::vector&lt;WayPoint&gt;&amp; singlePath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; allPaths)
{
	allPaths.clear();
	std::vector&lt;WayPoint&gt; path;
	path.push_back(singlePath.at(0));
	double skip_distance = 8;
	double d = 0;
	bool bStartSkip = false;
	for(unsigned int i= 1; i &lt; singlePath.size(); i++)
	{
		if(singlePath.at(i).bDir != FORWARD_DIR &amp;&amp; singlePath.at(i).pLane &amp;&amp; singlePath.at(i).pFronts.size() &gt; 0)
		{

			bStartSkip = true;
			WayPoint start_point = singlePath.at(i-1);

			cout &lt;&lt; &quot;Current Velocity = &quot; &lt;&lt; start_point.v &lt;&lt; endl;

			RelativeInfo start_info;
			PlanningHelpers::GetRelativeInfo(start_point.pLane-&gt;points, start_point, start_info);
			vector&lt;WayPoint*&gt; local_cell_to_delete;
			PlannerHNS::WayPoint* pStart = &amp;start_point.pLane-&gt;points.at(start_info.iFront);
			WayPoint* pLaneCell =  PlanningHelpers::BuildPlanningSearchTreeStraight(pStart, BACKUP_STRAIGHT_PLAN_DISTANCE, local_cell_to_delete);
			if(pLaneCell)
			{
				vector&lt;WayPoint&gt; straight_path;
				vector&lt;vector&lt;WayPoint&gt; &gt; tempCurrentForwardPathss;
				vector&lt;int&gt; globalPathIds;
				PlanningHelpers::TraversePathTreeBackwards(pLaneCell, pStart, globalPathIds, straight_path, tempCurrentForwardPathss);
				if(straight_path.size() &gt; 2)
				{
					straight_path.insert(straight_path.begin(), path.begin(), path.end());
					for(unsigned int ic = 0; ic &lt; straight_path.size(); ic++)
						straight_path.at(ic).laneChangeCost = 1;
					allPaths.push_back(straight_path);
				}
			}
		}

		if(bStartSkip)
		{
			d += hypot(singlePath.at(i).pos.y - singlePath.at(i-1).pos.y, singlePath.at(i).pos.x - singlePath.at(i-1).pos.x);
			if(d &gt; skip_distance)
			{
				d = 0;
				bStartSkip = false;
			}
		}

		if(!bStartSkip)
			path.push_back(singlePath.at(i));
	}

	allPaths.push_back(path);
}

void PlanningHelpers::TraversePathTreeBackwards(WayPoint* pHead, WayPoint* pStartWP,const vector&lt;int&gt;&amp; globalPathIds,
		vector&lt;WayPoint&gt;&amp; localPath, std::vector&lt;std::vector&lt;WayPoint&gt; &gt;&amp; localPaths)
{
	if(pHead != NULL &amp;&amp; pHead != pStartWP)
	{
		if(pHead-&gt;pBacks.size()&gt;0)
		{
			localPaths.push_back(localPath);
			TraversePathTreeBackwards(GetMinCostCell(pHead-&gt;pBacks, globalPathIds),pStartWP, globalPathIds, localPath, localPaths);
			pHead-&gt;bDir = FORWARD_DIR;
			localPath.push_back(*pHead);
		}
		else if(pHead-&gt;pLeft &amp;&amp; pHead-&gt;cost &gt; 0)
		{
			//vector&lt;Vector2D&gt; forward_path;
			//TravesePathTreeForwards(pHead-&gt;pLeft, forward_path, FORWARD_RIGHT);
			//localPaths.push_back(forward_path);
			cout &lt;&lt; &quot;Global Lane Change  Right &quot; &lt;&lt; endl;
			TraversePathTreeBackwards(pHead-&gt;pLeft,pStartWP, globalPathIds, localPath, localPaths);
			pHead-&gt;bDir = FORWARD_RIGHT_DIR;
			localPath.push_back(*pHead);
		}
		else if(pHead-&gt;pRight &amp;&amp; pHead-&gt;cost &gt; 0)
		{
			//vector&lt;Vector2D&gt; forward_path;
			//TravesePathTreeForwards(pHead-&gt;pRight, forward_path, FORWARD_LEFT);
			//localPaths.push_back(forward_path);

			cout &lt;&lt; &quot;Global Lane Change  Left &quot; &lt;&lt; endl;
			TraversePathTreeBackwards(pHead-&gt;pRight,pStartWP, globalPathIds, localPath, localPaths);
			pHead-&gt;bDir = FORWARD_LEFT_DIR;
			localPath.push_back(*pHead);
		}
//		else
//			cout &lt;&lt; &quot;Err: PlannerZ -&gt; NULL Back Pointer &quot; &lt;&lt; pHead;
	}
	else
		assert(pHead);
}

ACTION_TYPE PlanningHelpers::GetBranchingDirection(WayPoint&amp; currWP, WayPoint&amp; nextWP)
{
	ACTION_TYPE t = FORWARD_ACTION;

//	//first Get the average of the next 3 waypoint directions
//	double angle = 0;
//	if(nextWP.pLane-&gt;id == 487)
//		angle = 11;
//
//	int counter = 0;
//	angle = 0;
//
//	for(unsigned int i=0; i &lt; nextWP.pLane-&gt;points.size() &amp;&amp; counter &lt; 10; i++, counter++)
//	{
//		angle += nextWP.pLane-&gt;points.at(i).pos.a;
//	}
//	angle = angle / counter;
//
//	//Get Circular angle for correct subtraction
//	double circle_angle = UtilityH::GetCircularAngle(currWP.pos.a, angle);
//
//	if( currWP.pos.a - circle_angle &gt; (7.5*DEG2RAD))
//	{
//		t = RIGHT_TURN_ACTION;
//		cout &lt;&lt; &quot;Right Lane, Average Angle = &quot; &lt;&lt; angle*RAD2DEG &lt;&lt; &quot;, Circle Angle = &quot; &lt;&lt; circle_angle*RAD2DEG &lt;&lt; &quot;, currAngle = &quot; &lt;&lt; currWP.pos.a*RAD2DEG &lt;&lt; endl;
//	}
//	else if( currWP.pos.a - circle_angle &lt; (-7.5*DEG2RAD))
//	{
//		t = LEFT_TURN_ACTION;
//		cout &lt;&lt; &quot;Left Lane, Average Angle = &quot; &lt;&lt; angle*RAD2DEG &lt;&lt; &quot;, Circle Angle = &quot; &lt;&lt; circle_angle*RAD2DEG &lt;&lt; &quot;, currAngle = &quot; &lt;&lt; currWP.pos.a*RAD2DEG &lt;&lt; endl;
//	}

	return t;
}

void PlanningHelpers::CalcContourPointsForDetectedObjects(const WayPoint&amp; currPose, vector&lt;DetectedObject&gt;&amp; obj_list, const double&amp; filterDistance)
{
	vector&lt;DetectedObject&gt; res_list;
	for(unsigned int i = 0; i &lt; obj_list.size(); i++)
	{
		GPSPoint center = obj_list.at(i).center.pos;
		double distance = distance2points(center, currPose.pos);

		if(distance &lt; filterDistance)
		{
			DetectedObject obj = obj_list.at(i);

			Mat3 rotationMat(center.a);
			Mat3 translationMat(center.x, center.y);
			double w2 = obj.w/2.0;
			double h2 = obj.l/2.0;
			double z = center.z + obj.h/2.0;

			GPSPoint left_bottom(-w2, -h2, z,0);
			GPSPoint right_bottom(w2,-h2, z,0);
			GPSPoint right_top(w2,h2, z,0);
			GPSPoint left_top(-w2,h2, z,0);

			left_bottom 	= rotationMat * left_bottom;
			right_bottom 	= rotationMat * right_bottom;
			right_top 		= rotationMat * right_top;
			left_top 		= rotationMat * left_top;

			left_bottom 	= translationMat * left_bottom;
			right_bottom 	= translationMat * right_bottom;
			right_top 		= translationMat * right_top;
			left_top 		= translationMat * left_top;

			obj.contour.clear();
			obj.contour.push_back(left_bottom);
			obj.contour.push_back(right_bottom);
			obj.contour.push_back(right_top);
			obj.contour.push_back(left_top);

			res_list.push_back(obj);
		}
	}

	obj_list = res_list;
}

double PlanningHelpers::GetVelocityAhead(const std::vector&lt;WayPoint&gt;&amp; path, const WayPoint&amp; pose, const double&amp; distance)
{
	int iStart = GetClosestNextPointIndex(path, pose);

	double d = 0;
	double min_v = 99999;
	for(unsigned int i=iStart; i&lt; path.size(); i++)
	{
		d  += distance2points(path.at(i).pos, pose.pos);

		if(path.at(i).v &lt; min_v)
			min_v = path.at(i).v;

		if(d &gt;= distance)
			return min_v;
	}
	return 0;
}

void PlanningHelpers::WritePathToFile(const string&amp; fileName, const vector&lt;WayPoint&gt;&amp; path)
{
	DataRW  dataFile;
	ostringstream str_header;
	str_header &lt;&lt; &quot;laneID&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;wpID&quot;  &lt;&lt; &quot;,&quot; &quot;x&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;y&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;a&quot;&lt;&lt;&quot;,&quot;&lt;&lt; &quot;cost&quot; &lt;&lt; &quot;,&quot; &lt;&lt; &quot;Speed&quot; &lt;&lt; &quot;,&quot; ;
	vector&lt;string&gt; dataList;
	 for(unsigned int i=0; i&lt;path.size(); i++)
	 {
		 ostringstream strwp;
		 strwp &lt;&lt; path.at(i).laneId &lt;&lt; &quot;,&quot; &lt;&lt; path.at(i).id &lt;&lt;&quot;,&quot;&lt;&lt;path.at(i).pos.x&lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).pos.y
				 &lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).pos.a &lt;&lt; &quot;,&quot; &lt;&lt; path.at(i).cost &lt;&lt; &quot;,&quot; &lt;&lt; path.at(i).v &lt;&lt; &quot;,&quot;;
		 dataList.push_back(strwp.str());
	 }

	 dataFile.WriteLogData(&quot;&quot;, fileName, str_header.str(), dataList);
}

void PlanningHelpers::TestQuadraticSpline (const std::vector&lt;WayPoint&gt;&amp; center_line, std::vector&lt;WayPoint&gt;&amp; path)
{

//  int N = center_line.size();
//  int i;
//	int ibcbeg;
//	int ibcend;
//	int j;
//	int jhi;
//	int k;
//	double t[N];
//	double tval;
//	double y[N];
//	double ybcbeg;
//	double ybcend;
//	double *ypp;
//	double yppval;
//	double ypval;
//	double yval;
//
//  cout &lt;&lt; &quot;\n&quot;;
//  cout &lt;&lt; &quot;TEST24\n&quot;;
//  cout &lt;&lt; &quot;  SPLINE_QUADRATIC_VAL evaluates a\n&quot;;
//  cout &lt;&lt; &quot;    quadratic spline.\n&quot;;
//  cout &lt;&lt; &quot;\n&quot;;
//  cout &lt;&lt; &quot;  Runge''s function, evenly spaced knots.\n&quot;;
//
//  for ( i = 0; i &lt; N; i++ )
//  {
//    t[i] =  center_line.at(i).pos.x;
//    y[i] =  center_line.at(i).pos.y;
//  }
//
//  //
//  //  Try various boundary conditions.
//  //
//    for ( k = 0; k &lt;= 4; k++ )
//    {
//      if ( k == 0 )
//      {
//        ibcbeg = 0;
//        ybcbeg = 0.0;
//
//        ibcend = 0;
//        ybcend = 0.0;
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Boundary condition 0 at both ends:\n&quot;;
//        cout &lt;&lt; &quot;  Spline is quadratic in boundary intervals.\n&quot;;
//      }
//      else if ( k == 1 )
//      {
//        ibcbeg = 1;
//        ybcbeg = t[0];
//
//        ibcend = 1;
//        ybcend = t[N-1] ;
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Boundary condition 1 at both ends:\n&quot;;
//        cout &lt;&lt; &quot;  Y'(left) =  &quot; &lt;&lt; ybcbeg &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Y'(right) = &quot; &lt;&lt; ybcend &lt;&lt; &quot;\n&quot;;
//
//      }
//      else if ( k == 2 )
//      {
//        ibcbeg = 2;
//        ybcbeg = fpprunge ( t[0] );
//
//        ibcend = 2;
//        ybcend = fpprunge ( t[N-1] );
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Boundary condition 2 at both ends:\n&quot;;
//        cout &lt;&lt; &quot;  YP''(left) =  &quot; &lt;&lt; ybcbeg &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  YP''(right) = &quot; &lt;&lt; ybcend &lt;&lt; &quot;\n&quot;;
//      }
//      else if ( k == 3 )
//      {
//        ibcbeg = 2;
//        ybcbeg = 0.0;
//
//        ibcend = 2;
//        ybcend = 0.0;
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  Natural spline:\n&quot;;
//        cout &lt;&lt; &quot;  YP''(left) =  &quot; &lt;&lt; ybcbeg &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  YP''(right) = &quot; &lt;&lt; ybcend &lt;&lt; &quot;\n&quot;;
//      }
//      else if ( k == 4 )
//      {
//        ibcbeg = 3;
//        ibcend = 3;
//
//        cout &lt;&lt; &quot;\n&quot;;
//        cout &lt;&lt; &quot;  \&quot;Not-a-knot\&quot; spline:\n&quot;;
//      }
//
//      ypp = spline_cubic_set ( N, t, y, ibcbeg, ybcbeg, ibcend, ybcend );
//
//      cout &lt;&lt; &quot;\n&quot;;
//      cout &lt;&lt; &quot;  SPLINE''(T), F''(T):\n&quot;;
//      cout &lt;&lt; &quot;\n&quot;;
//      for ( i = 0; i &lt; N; i++ )
//      {
//        cout &lt;&lt; ypp[i] &lt;&lt; &quot;  &quot;
//             &lt;&lt; fpprunge ( t[i] ) &lt;&lt; &quot;\n&quot;;
//      }
//
//      cout &lt;&lt; &quot;\n&quot;;
//      cout &lt;&lt; &quot;  T, SPLINE(T), F(T)\n&quot;;
//      cout &lt;&lt; &quot;\n&quot;;
//
//      for ( i = 0; i &lt;= N; i++ )
//      {
//        if ( i == 0 )
//        {
//          jhi = 1;
//        }
//        else if ( i &lt; N )
//        {
//          jhi = 2;
//        }
//        else
//        {
//          jhi = 2;
//        }
//
//        for ( j = 1; j &lt;= jhi; j++ )
//        {
//          if ( i == 0 )
//          {
//            tval = t[0] - 1.0;
//          }
//          else if ( i &lt; N )
//          {
//            tval = (
//                ( double ) ( jhi - j + 1 ) * t[i-1]
//              + ( double ) (       j - 1 ) * t[i] )
//              / ( double ) ( jhi         );
//          }
//          else
//          {
//            if ( j == 1 )
//            {
//              tval = t[N-1];
//            }
//            else
//            {
//              tval = t[N-1] + 1.0;
//            }
//          }
//
//          yval = spline_cubic_val ( N, t, y, ypp, tval, &amp;ypval, &amp;yppval );
//
//          cout &lt;&lt; tval &lt;&lt; &quot;  &quot;
//               &lt;&lt; yval &lt;&lt; &quot;  &quot;
//               &lt;&lt; frunge ( tval ) &lt;&lt; &quot;\n&quot;;
//        }
//      }
//      delete [] ypp;
//    }
//
//    return;
}

double PlanningHelpers::frunge ( double x )
{
  double fx;

  fx = 1.0 / ( 1.0 + 25.0 * x * x );

  return fx;
}

double PlanningHelpers::fprunge ( double x )
{
  double bot;
  double fx;

  bot = 1.0 + 25.0 * x * x;
  fx = -50.0 * x / ( bot * bot );

  return fx;
}

double PlanningHelpers::fpprunge ( double x )
{
  double bot;
  double fx;

  bot = 1.0 + 25.0 * x * x;
  fx = ( -50.0 + 3750.0 * x * x ) / ( bot * bot * bot );

  return fx;
}


} /* namespace PlannerHNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/TrajectoryCosts.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/TrajectoryCosts.cpp">
				<diff>@@ -15,6 +15,12 @@ namespace PlannerHNS
 TrajectoryCosts::TrajectoryCosts()
 {
 	m_PrevCostIndex = -1;
+	m_WeightPriority = 0.125;
+	m_WeightTransition = 0.13;
+	m_WeightLong = 1.0;
+	m_WeightLat = 1.0;
+	m_WeightLaneChange = 1.0;
+	m_LateralSkipDistance = 10;
 }
 
 TrajectoryCosts::~TrajectoryCosts()
@@ -51,19 +57,22 @@ TrajectoryCost TrajectoryCosts::DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt;
 
 	CalculateTransitionCosts(m_TrajectoryCosts, currIndex, params);
 
-	vector&lt;WayPoint&gt; contourPoints;
+
 	WayPoint p;
+	m_AllContourPoints.clear();
 	for(unsigned int io=0; io&lt;obj_list.size(); io++)
 	{
 		for(unsigned int icon=0; icon &lt; obj_list.at(io).contour.size(); icon++)
 		{
 			p.pos = obj_list.at(io).contour.at(icon);
 			p.v = obj_list.at(io).center.v;
-			contourPoints.push_back(p);
+			p.id = io;
+			p.cost = sqrt(obj_list.at(io).w*obj_list.at(io).w + obj_list.at(io).l*obj_list.at(io).l);
+			m_AllContourPoints.push_back(p);
 		}
 	}
 
-	CalculateLateralAndLongitudinalCosts(m_TrajectoryCosts, rollOuts, totalPaths, currState, contourPoints, params, carInfo, vehicleState);
+	CalculateLateralAndLongitudinalCosts(m_TrajectoryCosts, rollOuts, totalPaths, currState, m_AllContourPoints, params, carInfo, vehicleState);
 
 	NormalizeCosts(m_TrajectoryCosts);
 
@@ -72,10 +81,10 @@ TrajectoryCost TrajectoryCosts::DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt;
 	double smallestDistance = 9999999999;
 	double velo_of_next = 0;
 
-//	cout &lt;&lt; &quot;Trajectory Costs Log : CurrIndex: &quot; &lt;&lt; currIndex &lt;&lt; &quot; --------------------- &quot; &lt;&lt; endl;
+	//cout &lt;&lt; &quot;Trajectory Costs Log : CurrIndex: &quot; &lt;&lt; currIndex &lt;&lt; &quot; --------------------- &quot; &lt;&lt; endl;
 	for(unsigned int ic = 0; ic &lt; m_TrajectoryCosts.size(); ic++)
 	{
-//		cout &lt;&lt; m_TrajectoryCosts.at(ic).ToString();
+		//cout &lt;&lt; m_TrajectoryCosts.at(ic).ToString();
 		if(!m_TrajectoryCosts.at(ic).bBlocked &amp;&amp; m_TrajectoryCosts.at(ic).cost &lt; smallestCost)
 		{
 			smallestCost = m_TrajectoryCosts.at(ic).cost;
@@ -89,7 +98,7 @@ TrajectoryCost TrajectoryCosts::DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt;
 		}
 	}
 
-//	cout &lt;&lt; &quot;Smallest Distance: &quot; &lt;&lt;  smallestDistance &lt;&lt; &quot;------------------------------------------------------------- &quot; &lt;&lt; endl;
+	//cout &lt;&lt; &quot;Smallest Distance: &quot; &lt;&lt;  smallestDistance &lt;&lt; &quot;------------------------------------------------------------- &quot; &lt;&lt; endl;
 
 	//All is blocked !
 	if(smallestIndex == -1 &amp;&amp; m_PrevCostIndex &lt; (int)m_TrajectoryCosts.size())
@@ -127,8 +136,7 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 	double critical_long_front_distance =  carInfo.wheel_base/2.0 + carInfo.length/2.0 + params.verticalSafetyDistance;
 	double critical_long_back_distance =  carInfo.length/2.0 + params.verticalSafetyDistance - carInfo.wheel_base/2.0;
 	int iCostIndex = 0;
-	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
-	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);
+
 	PlannerHNS::Mat3 invRotationMat(currState.pos.a-M_PI_2);
 	PlannerHNS::Mat3 invTranslationMat(currState.pos.x, currState.pos.y);
 
@@ -163,12 +171,6 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 	top_left_car = invRotationMat*top_left_car;
 	top_left_car = invTranslationMat*top_left_car;
 
-//	m_SafetyBox.clear();
-//	m_SafetyBox.push_back(bottom_left);
-//	m_SafetyBox.push_back(bottom_right);
-//	m_SafetyBox.push_back(top_right);
-//	m_SafetyBox.push_back(top_left);
-
 	m_SafetyBorder.points.clear();
 	m_SafetyBorder.points.push_back(bottom_left) ;
 	m_SafetyBorder.points.push_back(bottom_right) ;
@@ -184,16 +186,28 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 			RelativeInfo car_info;
 			PlanningHelpers::GetRelativeInfo(totalPaths.at(il), currState, car_info);
 
+
 			for(unsigned int it=0; it&lt; rollOuts.at(il).size(); it++)
 			{
+				int skip_id = -1;
 				for(unsigned int icon = 0; icon &lt; contourPoints.size(); icon++)
 				{
+					if(skip_id == contourPoints.at(icon).id)
+						continue;
+
 					RelativeInfo obj_info;
 					PlanningHelpers::GetRelativeInfo(totalPaths.at(il), contourPoints.at(icon), obj_info);
 					double longitudinalDist = PlanningHelpers::GetExactDistanceOnTrajectory(totalPaths.at(il), car_info, obj_info);
 					if(obj_info.iFront == 0 &amp;&amp; longitudinalDist &gt; 0)
 						longitudinalDist = -longitudinalDist;
 
+					double direct_distance = hypot(obj_info.perp_point.pos.y-contourPoints.at(icon).pos.y, obj_info.perp_point.pos.x-contourPoints.at(icon).pos.x);
+					if(contourPoints.at(icon).v &lt; 0.1 &amp;&amp; direct_distance &gt; (m_LateralSkipDistance+contourPoints.at(icon).cost))
+					{
+						skip_id = contourPoints.at(icon).id;
+						continue;
+					}
+
 					double close_in_percentage = 1;
 //					close_in_percentage = ((longitudinalDist- critical_long_front_distance)/params.rollInMargin)*4.0;
 //
@@ -206,7 +220,7 @@ void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost
 
 					double lateralDist = fabs(obj_info.perp_distance - distance_from_center);
 
-					if(longitudinalDist &lt; -carInfo.length || lateralDist &gt; 6)
+					if(longitudinalDist &lt; -carInfo.length || longitudinalDist &gt; params.minFollowingDistance || lateralDist &gt; m_LateralSkipDistance)
 					{
 						continue;
 					}
@@ -261,6 +275,7 @@ void TrajectoryCosts::NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts)
 		totalLongitudinalCosts += trajectoryCosts.at(ic).longitudinal_cost;
 	}
 
+//	cout &lt;&lt; &quot;------ Normalizing Step &quot; &lt;&lt; endl;
 	for(unsigned int ic = 0; ic&lt; trajectoryCosts.size(); ic++)
 	{
 		if(totalPriorities != 0)
@@ -288,13 +303,30 @@ void TrajectoryCosts::NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts)
 		else
 			trajectoryCosts.at(ic).longitudinal_cost = 0;
 
-		trajectoryCosts.at(ic).cost = (
-				trajectoryCosts.at(ic).priority_cost +
-				trajectoryCosts.at(ic).lane_change_cost +
-				trajectoryCosts.at(ic).lateral_cost +
-				trajectoryCosts.at(ic).longitudinal_cost +
-				1.5*trajectoryCosts.at(ic).transition_cost) / 5.0;
+		trajectoryCosts.at(ic).priority_cost = m_WeightPriority*trajectoryCosts.at(ic).priority_cost;
+		trajectoryCosts.at(ic).transition_cost = m_WeightTransition*trajectoryCosts.at(ic).transition_cost;
+		trajectoryCosts.at(ic).lane_change_cost = m_WeightLaneChange*trajectoryCosts.at(ic).lane_change_cost;
+		trajectoryCosts.at(ic).lateral_cost = m_WeightLat*trajectoryCosts.at(ic).lateral_cost;
+		trajectoryCosts.at(ic).longitudinal_cost = m_WeightLong*trajectoryCosts.at(ic).longitudinal_cost;
+
+
+		trajectoryCosts.at(ic).cost = m_WeightPriority*trajectoryCosts.at(ic).priority_cost/5.0 +
+				m_WeightLaneChange*trajectoryCosts.at(ic).lane_change_cost/5.0 +
+				m_WeightLat*trajectoryCosts.at(ic).lateral_cost/5.0 +
+				m_WeightLong*trajectoryCosts.at(ic).longitudinal_cost/5.0 +
+				m_WeightTransition*trajectoryCosts.at(ic).transition_cost/5.0;
+
+//		cout &lt;&lt; &quot;Index: &quot; &lt;&lt; ic
+//						&lt;&lt; &quot;, Priority: &quot; &lt;&lt; trajectoryCosts.at(ic).priority_cost
+//						&lt;&lt; &quot;, Transition: &quot; &lt;&lt; trajectoryCosts.at(ic).transition_cost
+//						&lt;&lt; &quot;, Lat: &quot; &lt;&lt; trajectoryCosts.at(ic).lateral_cost
+//						&lt;&lt; &quot;, Long: &quot; &lt;&lt; trajectoryCosts.at(ic).longitudinal_cost
+//						&lt;&lt; &quot;, Change: &quot; &lt;&lt; trajectoryCosts.at(ic).lane_change_cost
+//						&lt;&lt; &quot;, Avg: &quot; &lt;&lt; trajectoryCosts.at(ic).cost
+//						&lt;&lt; endl;
 	}
+
+//	cout &lt;&lt; &quot;------------------------ &quot; &lt;&lt; endl;
 }
 
 vector&lt;TrajectoryCost&gt; TrajectoryCosts::CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts,
@@ -355,6 +387,48 @@ bool TrajectoryCosts::ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt;
 }
 
 
+bool TrajectoryCosts::CalculateIntersectionVelocities(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::DetectedObject&amp; obj, const WayPoint&amp; currState,const CAR_BASIC_INFO&amp; carInfo, WayPoint&amp; collisionPoint)
+{
+	bool bCollisionDetected = false;
+	m_CollisionPoints.clear();
+
+	for(unsigned int k = 0; k &lt; obj.predTrajectories.size(); k++)
+	{
+		for(unsigned int j = 0; j &lt; obj.predTrajectories.at(k).size(); j++)
+		{
+			bool bCollisionFound =false;
+			for(unsigned int i = 0; i &lt; path.size(); i++)
+			{
+				if(path.at(i).timeCost &gt; 0.0)
+				{
+					double collision_distance = hypot(path.at(i).pos.x-obj.predTrajectories.at(k).at(j).pos.x, path.at(i).pos.y-obj.predTrajectories.at(k).at(j).pos.y);
+					double contact_distance = hypot(currState.pos.x - path.at(i).pos.x,currState.pos.y - path.at(i).pos.y);
+					if(collision_distance &lt;= carInfo.width  &amp;&amp; fabs(path.at(i).timeCost - obj.predTrajectories.at(k).at(j).timeCost)&lt;3.0)
+					{
+						//m_CollisionPoints.push_back(path.at(i));
+						collisionPoint = path.at(i);
+						return true;
+//						double a = UtilityHNS::UtilityH::AngleBetweenTwoAnglesPositive(path.at(i).pos.a, obj.predTrajectories.at(k).at(j).pos.a)*RAD2DEG;
+//						if(a &lt; 10)
+//							path.at(i).v = obj.center.v;
+//						else
+//							path.at(i).v = 0;
+//						//obj.predTrajectories.at(k).at(j).collisionCost = 1;
+						bCollisionFound = true;
+						bCollisionDetected = true;
+						break;
+					}
+				}
+			}
+
+			if(bCollisionFound)
+				break;
+		}
+	}
+
+	return bCollisionDetected;
+}
+
 
 
 
</diff>
				<old_file>/*
 * TrajectoryCosts.cpp
 *
 *  Created on: Dec 14, 2016
 *      Author: user
 */

#include &quot;TrajectoryCosts.h&quot;
#include &quot;MatrixOperations.h&quot;

namespace PlannerHNS
{


TrajectoryCosts::TrajectoryCosts()
{
	m_PrevCostIndex = -1;
}

TrajectoryCosts::~TrajectoryCosts()
{
}

TrajectoryCost TrajectoryCosts::DoOneStep(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts,
		const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths, const WayPoint&amp; currState, const int&amp; currIndex,
		const int&amp; currLaneIndex,
		const PlanningParams&amp; params, const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState,
		const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
{
	TrajectoryCost bestTrajectory;
	bestTrajectory.bBlocked = true;
	bestTrajectory.closest_obj_distance = params.horizonDistance;
	bestTrajectory.closest_obj_velocity = 0;
	bestTrajectory.index = -1;

	if(!ValidateRollOutsInput(rollOuts) || rollOuts.size() != totalPaths.size()) return bestTrajectory;

	if(m_PrevCostIndex == -1)
		m_PrevCostIndex = params.rollOutNumber/2;

	m_TrajectoryCosts.clear();

	for(unsigned int il = 0; il &lt; rollOuts.size(); il++)
	{
		if(rollOuts.at(il).size()&gt;0 &amp;&amp; rollOuts.at(il).at(0).size()&gt;0)
		{
			vector&lt;TrajectoryCost&gt; costs = CalculatePriorityAndLaneChangeCosts(rollOuts.at(il), il, params);
			m_TrajectoryCosts.insert(m_TrajectoryCosts.end(), costs.begin(), costs.end());
		}
	}

	CalculateTransitionCosts(m_TrajectoryCosts, currIndex, params);

	vector&lt;WayPoint&gt; contourPoints;
	WayPoint p;
	for(unsigned int io=0; io&lt;obj_list.size(); io++)
	{
		for(unsigned int icon=0; icon &lt; obj_list.at(io).contour.size(); icon++)
		{
			p.pos = obj_list.at(io).contour.at(icon);
			p.v = obj_list.at(io).center.v;
			contourPoints.push_back(p);
		}
	}

	CalculateLateralAndLongitudinalCosts(m_TrajectoryCosts, rollOuts, totalPaths, currState, contourPoints, params, carInfo, vehicleState);

	NormalizeCosts(m_TrajectoryCosts);

	int smallestIndex = -1;
	double smallestCost = 9999999999;
	double smallestDistance = 9999999999;
	double velo_of_next = 0;

//	cout &lt;&lt; &quot;Trajectory Costs Log : CurrIndex: &quot; &lt;&lt; currIndex &lt;&lt; &quot; --------------------- &quot; &lt;&lt; endl;
	for(unsigned int ic = 0; ic &lt; m_TrajectoryCosts.size(); ic++)
	{
//		cout &lt;&lt; m_TrajectoryCosts.at(ic).ToString();
		if(!m_TrajectoryCosts.at(ic).bBlocked &amp;&amp; m_TrajectoryCosts.at(ic).cost &lt; smallestCost)
		{
			smallestCost = m_TrajectoryCosts.at(ic).cost;
			smallestIndex = ic;
		}

		if(m_TrajectoryCosts.at(ic).closest_obj_distance &lt; smallestDistance)
		{
			smallestDistance = m_TrajectoryCosts.at(ic).closest_obj_distance;
			velo_of_next = m_TrajectoryCosts.at(ic).closest_obj_velocity;
		}
	}

//	cout &lt;&lt; &quot;Smallest Distance: &quot; &lt;&lt;  smallestDistance &lt;&lt; &quot;------------------------------------------------------------- &quot; &lt;&lt; endl;

	//All is blocked !
	if(smallestIndex == -1 &amp;&amp; m_PrevCostIndex &lt; (int)m_TrajectoryCosts.size())
	{
		bestTrajectory.bBlocked = true;
		bestTrajectory.lane_index = currLaneIndex;
		bestTrajectory.index = currIndex;
		bestTrajectory.closest_obj_distance = smallestDistance;
		bestTrajectory.closest_obj_velocity = velo_of_next;
		//bestTrajectory.index = smallestIndex;
	}
	else if(smallestIndex &gt;= 0)
	{
		bestTrajectory = m_TrajectoryCosts.at(smallestIndex);
		//bestTrajectory.index = smallestIndex;
	}

//	cout &lt;&lt; &quot;smallestI: &quot; &lt;&lt;  smallestIndex &lt;&lt; &quot;, C_Size: &quot; &lt;&lt; m_TrajectoryCosts.size()
//			&lt;&lt; &quot;, LaneI: &quot; &lt;&lt; bestTrajectory.lane_index &lt;&lt; &quot;TrajI: &quot; &lt;&lt; bestTrajectory.index
//			&lt;&lt; &quot;, prevSmalI: &quot; &lt;&lt; m_PrevCostIndex &lt;&lt; &quot;, distance: &quot; &lt;&lt; bestTrajectory.closest_obj_distance
//			&lt;&lt; &quot;, Blocked: &quot; &lt;&lt; bestTrajectory.bBlocked
//			&lt;&lt; endl;

	m_PrevCostIndex = smallestIndex;

	return bestTrajectory;
}

void TrajectoryCosts::CalculateLateralAndLongitudinalCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts,
		const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts, const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; totalPaths,
		const WayPoint&amp; currState, const vector&lt;WayPoint&gt;&amp; contourPoints, const PlanningParams&amp; params,
		const CAR_BASIC_INFO&amp; carInfo, const VehicleState&amp; vehicleState)
{
	double critical_lateral_distance =  carInfo.width/2.0 + params.horizontalSafetyDistancel;
	double critical_long_front_distance =  carInfo.wheel_base/2.0 + carInfo.length/2.0 + params.verticalSafetyDistance;
	double critical_long_back_distance =  carInfo.length/2.0 + params.verticalSafetyDistance - carInfo.wheel_base/2.0;
	int iCostIndex = 0;
	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);
	PlannerHNS::Mat3 invRotationMat(currState.pos.a-M_PI_2);
	PlannerHNS::Mat3 invTranslationMat(currState.pos.x, currState.pos.y);

	double corner_slide_distance = critical_lateral_distance/2.0;
	double ratio_to_angle = corner_slide_distance/carInfo.max_steer_angle;
	double slide_distance = vehicleState.steer * ratio_to_angle;

	GPSPoint bottom_left(-critical_lateral_distance ,-critical_long_back_distance,  currState.pos.z, 0);
	GPSPoint bottom_right(critical_lateral_distance, -critical_long_back_distance,  currState.pos.z, 0);

	GPSPoint top_right_car(critical_lateral_distance, carInfo.wheel_base/3.0 + carInfo.length/3.0,  currState.pos.z, 0);
	GPSPoint top_left_car(-critical_lateral_distance, carInfo.wheel_base/3.0 + carInfo.length/3.0, currState.pos.z, 0);

	GPSPoint top_right(critical_lateral_distance - slide_distance, critical_long_front_distance,  currState.pos.z, 0);
	GPSPoint top_left(-critical_lateral_distance - slide_distance , critical_long_front_distance, currState.pos.z, 0);

	bottom_left = invRotationMat*bottom_left;
	bottom_left = invTranslationMat*bottom_left;

	top_right = invRotationMat*top_right;
	top_right = invTranslationMat*top_right;

	bottom_right = invRotationMat*bottom_right;
	bottom_right = invTranslationMat*bottom_right;

	top_left = invRotationMat*top_left;
	top_left = invTranslationMat*top_left;

	top_right_car = invRotationMat*top_right_car;
	top_right_car = invTranslationMat*top_right_car;

	top_left_car = invRotationMat*top_left_car;
	top_left_car = invTranslationMat*top_left_car;

//	m_SafetyBox.clear();
//	m_SafetyBox.push_back(bottom_left);
//	m_SafetyBox.push_back(bottom_right);
//	m_SafetyBox.push_back(top_right);
//	m_SafetyBox.push_back(top_left);

	m_SafetyBorder.points.clear();
	m_SafetyBorder.points.push_back(bottom_left) ;
	m_SafetyBorder.points.push_back(bottom_right) ;
	m_SafetyBorder.points.push_back(top_right_car) ;
	m_SafetyBorder.points.push_back(top_right) ;
	m_SafetyBorder.points.push_back(top_left) ;
	m_SafetyBorder.points.push_back(top_left_car) ;

	for(unsigned int il=0; il &lt; rollOuts.size(); il++)
	{
		if(rollOuts.at(il).size() &gt; 0 &amp;&amp; rollOuts.at(il).at(0).size()&gt;0)
		{
			RelativeInfo car_info;
			PlanningHelpers::GetRelativeInfo(totalPaths.at(il), currState, car_info);

			for(unsigned int it=0; it&lt; rollOuts.at(il).size(); it++)
			{
				for(unsigned int icon = 0; icon &lt; contourPoints.size(); icon++)
				{
					RelativeInfo obj_info;
					PlanningHelpers::GetRelativeInfo(totalPaths.at(il), contourPoints.at(icon), obj_info);
					double longitudinalDist = PlanningHelpers::GetExactDistanceOnTrajectory(totalPaths.at(il), car_info, obj_info);
					if(obj_info.iFront == 0 &amp;&amp; longitudinalDist &gt; 0)
						longitudinalDist = -longitudinalDist;

					double close_in_percentage = 1;
//					close_in_percentage = ((longitudinalDist- critical_long_front_distance)/params.rollInMargin)*4.0;
//
//					if(close_in_percentage &lt;= 0 || close_in_percentage &gt; 1) close_in_percentage = 1;

					double distance_from_center = trajectoryCosts.at(iCostIndex).distance_from_center;

					if(close_in_percentage &lt; 1)
						distance_from_center = distance_from_center - distance_from_center * (1.0-close_in_percentage);

					double lateralDist = fabs(obj_info.perp_distance - distance_from_center);

					if(longitudinalDist &lt; -carInfo.length || lateralDist &gt; 6)
					{
						continue;
					}

					longitudinalDist = longitudinalDist - critical_long_front_distance;

					if(m_SafetyBorder.PointInsidePolygon(m_SafetyBorder, contourPoints.at(icon).pos) == true)
						trajectoryCosts.at(iCostIndex).bBlocked = true;

					if(lateralDist &lt;= critical_lateral_distance
							&amp;&amp; longitudinalDist &gt;= -carInfo.length/1.5
							&amp;&amp; longitudinalDist &lt; params.minFollowingDistance)
						trajectoryCosts.at(iCostIndex).bBlocked = true;


					trajectoryCosts.at(iCostIndex).lateral_cost += 1.0/lateralDist;
					trajectoryCosts.at(iCostIndex).longitudinal_cost += 1.0/fabs(longitudinalDist);


					if(longitudinalDist &gt;= -critical_long_front_distance &amp;&amp; longitudinalDist &lt; trajectoryCosts.at(iCostIndex).closest_obj_distance)
					{
						trajectoryCosts.at(iCostIndex).closest_obj_distance = longitudinalDist;
						trajectoryCosts.at(iCostIndex).closest_obj_velocity = contourPoints.at(icon).v;
					}
				}

				iCostIndex++;
			}
		}
	}
}

void TrajectoryCosts::NormalizeCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts)
{
	//Normalize costs
	double totalPriorities = 0;
	double totalChange = 0;
	double totalLateralCosts = 0;
	double totalLongitudinalCosts = 0;
	double transitionCosts = 0;

	for(unsigned int ic = 0; ic&lt; trajectoryCosts.size(); ic++)
	{
		totalPriorities += trajectoryCosts.at(ic).priority_cost;
		transitionCosts += trajectoryCosts.at(ic).transition_cost;
	}

	for(unsigned int ic = 0; ic&lt; trajectoryCosts.size(); ic++)
	{
		totalChange += trajectoryCosts.at(ic).lane_change_cost;
		totalLateralCosts += trajectoryCosts.at(ic).lateral_cost;
		totalLongitudinalCosts += trajectoryCosts.at(ic).longitudinal_cost;
	}

	for(unsigned int ic = 0; ic&lt; trajectoryCosts.size(); ic++)
	{
		if(totalPriorities != 0)
			trajectoryCosts.at(ic).priority_cost = trajectoryCosts.at(ic).priority_cost / totalPriorities;
		else
			trajectoryCosts.at(ic).priority_cost = 0;

		if(transitionCosts != 0)
			trajectoryCosts.at(ic).transition_cost = trajectoryCosts.at(ic).transition_cost / transitionCosts;
		else
			trajectoryCosts.at(ic).transition_cost = 0;

		if(totalChange != 0)
			trajectoryCosts.at(ic).lane_change_cost = trajectoryCosts.at(ic).lane_change_cost / totalChange;
		else
			trajectoryCosts.at(ic).lane_change_cost = 0;

		if(totalLateralCosts != 0)
			trajectoryCosts.at(ic).lateral_cost = trajectoryCosts.at(ic).lateral_cost / totalLateralCosts;
		else
			trajectoryCosts.at(ic).lateral_cost = 0;

		if(totalLongitudinalCosts != 0)
			trajectoryCosts.at(ic).longitudinal_cost = trajectoryCosts.at(ic).longitudinal_cost / totalLongitudinalCosts;
		else
			trajectoryCosts.at(ic).longitudinal_cost = 0;

		trajectoryCosts.at(ic).cost = (
				trajectoryCosts.at(ic).priority_cost +
				trajectoryCosts.at(ic).lane_change_cost +
				trajectoryCosts.at(ic).lateral_cost +
				trajectoryCosts.at(ic).longitudinal_cost +
				1.5*trajectoryCosts.at(ic).transition_cost) / 5.0;
	}
}

vector&lt;TrajectoryCost&gt; TrajectoryCosts::CalculatePriorityAndLaneChangeCosts(const vector&lt;vector&lt;WayPoint&gt; &gt;&amp; laneRollOuts,
		const int&amp; lane_index, const PlanningParams&amp; params)
{
	vector&lt;TrajectoryCost&gt; costs;
	TrajectoryCost tc;
	int centralIndex = params.rollOutNumber/2;

	tc.lane_index = lane_index;
	for(unsigned int it=0; it&lt; laneRollOuts.size(); it++)
	{
		tc.index = it;
		tc.relative_index = it - centralIndex;
		tc.distance_from_center = params.rollOutDensity*tc.relative_index;
		tc.priority_cost = fabs(tc.distance_from_center);
		tc.closest_obj_distance = params.horizonDistance;
		tc.lane_change_cost = laneRollOuts.at(it).at(0).laneChangeCost;

//		if(laneRollOuts.at(it).at(0).bDir == FORWARD_LEFT_DIR || laneRollOuts.at(it).at(0).bDir == FORWARD_RIGHT_DIR)
//			tc.lane_change_cost = 1;
//		else if(laneRollOuts.at(it).at(0).bDir == BACKWARD_DIR || laneRollOuts.at(it).at(0).bDir == BACKWARD_RIGHT_DIR || laneRollOuts.at(it).at(0).bDir == BACKWARD_LEFT_DIR)
//			tc.lane_change_cost = 2;
//		else
//			tc.lane_change_cost = 0;

		costs.push_back(tc);
	}

	return costs;
}

void TrajectoryCosts::CalculateTransitionCosts(vector&lt;TrajectoryCost&gt;&amp; trajectoryCosts, const int&amp; currTrajectoryIndex, const PlanningParams&amp; params)
{
	for(int ic = 0; ic&lt; trajectoryCosts.size(); ic++)
	{
		trajectoryCosts.at(ic).transition_cost = fabs(params.rollOutDensity * (ic - currTrajectoryIndex));
	}
}

/**
 * @brief Validate input, each trajectory must have at least 1 way point
 * @param rollOuts
 * @return true if data isvalid for cost calculation
 */
bool TrajectoryCosts::ValidateRollOutsInput(const vector&lt;vector&lt;vector&lt;WayPoint&gt; &gt; &gt;&amp; rollOuts)
{
	if(rollOuts.size()==0)
		return false;

	for(unsigned int il = 0; il &lt; rollOuts.size(); il++)
	{
		if(rollOuts.at(il).size() == 0)
			return false;
	}

	return true;
}



















































}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_planner/src/geo_pos_conv.cpp" new_path="">
				<diff>@@ -1,197 +0,0 @@
-/*
- *  Copyright (c) 2015, Nagoya University
- *  All rights reserved.
- *
- *  Redistribution and use in source and binary forms, with or without
- *  modification, are permitted provided that the following conditions are met:
- *
- *  * Redistributions of source code must retain the above copyright notice, this
- *    list of conditions and the following disclaimer.
- *
- *  * Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- *  * Neither the name of Autoware nor the names of its
- *    contributors may be used to endorse or promote products derived from
- *    this software without specific prior written permission.
- *
- *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
- *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
- *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
- *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
- *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
- *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
- *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-*/
-
-#include &lt;geo_pos_conv.hh&gt;
-
-double geo_pos_conv::x() const
-{
-	return m_x;
-}
-
-double geo_pos_conv::y() const
-{
-	return m_y;
-}
-
-double geo_pos_conv::z() const
-{
-	return m_z;
-}
-
-void geo_pos_conv::set_plane(double lat,   double lon)
-{
-	m_PLato = lat;
-	m_PLo = lon;
-}
-
-void geo_pos_conv::set_plane(int num)
-{
-        if(num==6){
-		m_PLo = 2.373647782712;   //
-		m_PLato= 0.628318530717;  //
-        }else if(num==7) {
-		m_PLo = 2.39400995732;   //
-		m_PLato=  0.628318530717;  //
-	} else if(num==9){
-		m_PLo =  2.4405520707;    //
-		m_PLato =  0.628318530717;  //
-	}
-}
-
-void geo_pos_conv::set_xyz(double cx, double cy, double cz)
-{
-	m_x = cx;
-	m_y = cy;
-	m_z = cz;
-	conv_xyz2llh();
-}
-
-void geo_pos_conv::set_llh_nmea_degrees(double latd,double lond, double h)
-{
-	double lat, lad, lod, lon;
-	//1234.56 -&gt; 12'34.56 -&gt; 12+ 34.56/60
-
-	lad = floor(latd/100.);
-	lat = latd-lad*100.;
-	lod = floor(lond/100.);
-	lon = lond-lod*100.;
-
-	//Changing Longitude and Latitude to Radians
-	m_lat= (lad+lat/60.0) *M_PI/180;
-	m_lon= (lod+lon/60.0) *M_PI/180;
-	m_h  =  h;
-
-	conv_llh2xyz();
-}
-
-void geo_pos_conv::llh_to_xyz(double lat, double lon, double ele)
-{
-	m_lat = lat * M_PI/180;
-	m_lon = lon * M_PI/180;
-	m_h = ele;
-
-	conv_llh2xyz();
-}
-
-void geo_pos_conv::conv_llh2xyz(void)
-{
-	double PS;           //
-	double PSo;          //
-	double PDL;          //
-	double Pt;           //
-	double PN;           //
-	double PW;           // 
-    
-	double PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9;
-	double PA, PB, PC, PD, PE, PF, PG, PH, PI;
-	double Pe;           //
-	double Pet;          //
-	double Pnn;          //  
-	double AW,FW,Pmo;
-
-	Pmo = 0.9999;
-
-	/*WGS84 Parameters*/
-	AW = 6378137.0; //Semimajor Axis
-	FW = 1.0/298.257222101; //298.257223563 //Geometrical flattening
-    
-	Pe  = (double) sqrt(2.0*FW - pow(FW,2));
-	Pet = (double) sqrt( pow(Pe,2) / (1.0 - pow(Pe,2)) );
-    
-	PA = (double) 1.0 + 3.0/4.0*pow(Pe,2) + 45.0/64.0* pow(Pe,4) + 175.0/256.0*pow(Pe,6) 
-		+ 11025.0/16384.0*pow(Pe,8) + 43659.0/65536.0*pow(Pe,10) + 693693.0/1048576.0*pow(Pe,12)
-		+ 19324305.0/29360128.0*pow(Pe,14) + 4927697775.0/7516192768.0*pow(Pe,16);
-    
-	PB = (double) 3.0/4.0*pow(Pe,2) + 15.0/16.0*pow(Pe,4) + 525.0/512.0*pow(Pe,6) + 2205.0/2048.0*pow(Pe,8)
-		+ 72765.0/65536.0*pow(Pe,10) + 297297.0/262144.0*pow(Pe,12) + 135270135.0/117440512.0*pow(Pe,14) 
-		+ 547521975.0/469762048.0*pow(Pe,16);
-    
-	PC = (double) 15.0/64.0*pow(Pe,4) + 105.0/256.0*pow(Pe,6) + 2205.0/4096.0*pow(Pe,8) + 10395.0/16384.0*pow(Pe,10)
-		+ 1486485.0/2097152.0*pow(Pe,12) + 45090045.0/58720256.0*pow(Pe,14)+ 766530765.0/939524096.0*pow(Pe,16);
-    
-	PD = (double) 35.0/512.0*pow(Pe,6) + 315.0/2048.0*pow(Pe,8) + 31185.0/131072.0*pow(Pe,10)
-		+ 165165.0/524288.0*pow(Pe,12) + 45090045.0/117440512.0*pow(Pe,14) + 209053845.0/469762048.0*pow(Pe,16);
-    
-	PE = (double) 315.0/16384.0*pow(Pe,8) + 3465.0/65536.0*pow(Pe,10) + 99099.0/1048576.0*pow(Pe,12) + 
-		4099095.0/29360128.0*pow(Pe,14) + 348423075.0/1879048192.0*pow(Pe,16);
-    
-	PF = (double) 693.0/131072.0*pow(Pe,10) + 9009.0/524288.0*pow(Pe,12) +  4099095.0/117440512.0*pow(Pe,14)
-		+ 26801775.0/469762048.0*pow(Pe,16);
-    
-	PG = (double) 3003.0/2097152.0*pow(Pe,12) + 315315.0/58720256.0*pow(Pe,14) + 11486475.0/939524096.0*pow(Pe,16);
-    
-	PH = (double) 45045.0/117440512.0*pow(Pe,14) + 765765.0/469762048.0*pow(Pe,16);
-    
-	PI = (double) 765765.0/7516192768.0*pow(Pe,16);
-    
-    
-	PB1 = (double) AW * (1.0 - pow(Pe,2)) * PA;
-	PB2 = (double) AW * (1.0 - pow(Pe,2)) * PB/-2.0;
-	PB3 = (double) AW * (1.0 - pow(Pe,2)) * PC/4.0;
-	PB4 = (double) AW * (1.0 - pow(Pe,2)) * PD/-6.0;
-	PB5 = (double) AW * (1.0 - pow(Pe,2)) * PE/8.0;
-	PB6 = (double) AW * (1.0 - pow(Pe,2)) * PF/-10.0;
-	PB7 = (double) AW * (1.0 - pow(Pe,2)) * PG/12.0;
-	PB8 = (double) AW * (1.0 - pow(Pe,2)) * PH/-14.0;
-	PB9 = (double) AW * (1.0 - pow(Pe,2)) * PI/16.0;
-    
-    
-	PS = (double) PB1*m_lat + PB2*sin(2.0*m_lat) + PB3*sin(4.0*m_lat) + PB4*sin(6.0*m_lat) 
-		+ PB5*sin(8.0*m_lat) + PB6*sin(10.0*m_lat) + PB7*sin(12.0*m_lat) + PB8*sin(14.0*m_lat)
-		+ PB9*sin(16.0*m_lat);
-    
-	PSo = (double) PB1*m_PLato + PB2*sin(2.0*m_PLato) + PB3*sin(4.0*m_PLato) + PB4*sin(6.0*m_PLato) 
-		+ PB5*sin(8.0*m_PLato) + PB6*sin(10.0*m_PLato) + PB7*sin(12.0*m_PLato) + PB8*sin(14.0*m_PLato)
-		+ PB9*sin(16.0*m_PLato);
-    
-	PDL = (double) m_lon - m_PLo;
-	Pt  = (double) tan(m_lat);
-	PW  = (double) sqrt(1.0 - pow(Pe,2)*pow(sin(m_lat),2));
-	PN  = (double) AW / PW;
-	Pnn = (double) sqrt( pow(Pet,2) * pow(cos(m_lat),2));
-    
-	m_x = (double) ( (PS - PSo) + (1.0/2.0)*PN*pow(cos(m_lat),2.0)*Pt*pow(PDL,2.0) 
-			 + (1.0/24.0) * PN * pow(cos(m_lat),4) * Pt * (5.0-pow(Pt,2) + 9.0*pow(Pnn,2) + 4.0*pow(Pnn,4))*pow(PDL,4)
-			 - (1.0/720.0) * PN * pow(cos(m_lat),6) * Pt * 
-			 (-61.0 + 58.0*pow(Pt,2) - pow(Pt,4) - 270.0*pow(Pnn,2) + 330.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,6)
-			 - (1.0/40320.0) * PN * pow(cos(m_lat),8) * Pt * 
-			 (-1385.0 + 3111*pow(Pt,2) - 543*pow(Pt,4) + pow(Pt,6)) * pow(PDL,8) ) * Pmo ; 
-    
-	m_y = (double) ( PN*cos(m_lat)*PDL - 1.0/6.0* PN * pow(cos(m_lat),3) * (-1 + pow(Pt,2) - pow(Pnn,2))*pow(PDL,3)
-			 -1.0/120.0*PN*pow(cos(m_lat),5) * (-5.0+18.0*pow(Pt,2)-pow(Pt,4)-14.0*pow(Pnn,2)+58.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,5)
-			 -1.0/5040.0*PN*pow(cos(m_lat),7)* (-61.0+479.0*pow(Pt,2)-179.0*pow(Pt,4)+pow(Pt,6))*pow(PDL,7) ) * Pmo;
-    
-	m_z = m_h;
-}
-
-void geo_pos_conv::conv_xyz2llh(void)
-{
-	// n/a
-}
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;geo_pos_conv.hh&gt;

double geo_pos_conv::x() const
{
	return m_x;
}

double geo_pos_conv::y() const
{
	return m_y;
}

double geo_pos_conv::z() const
{
	return m_z;
}

void geo_pos_conv::set_plane(double lat,   double lon)
{
	m_PLato = lat;
	m_PLo = lon;
}

void geo_pos_conv::set_plane(int num)
{
        if(num==6){
		m_PLo = 2.373647782712;   //
		m_PLato= 0.628318530717;  //
        }else if(num==7) {
		m_PLo = 2.39400995732;   //
		m_PLato=  0.628318530717;  //
	} else if(num==9){
		m_PLo =  2.4405520707;    //
		m_PLato =  0.628318530717;  //
	}
}

void geo_pos_conv::set_xyz(double cx, double cy, double cz)
{
	m_x = cx;
	m_y = cy;
	m_z = cz;
	conv_xyz2llh();
}

void geo_pos_conv::set_llh_nmea_degrees(double latd,double lond, double h)
{
	double lat, lad, lod, lon;
	//1234.56 -&gt; 12'34.56 -&gt; 12+ 34.56/60

	lad = floor(latd/100.);
	lat = latd-lad*100.;
	lod = floor(lond/100.);
	lon = lond-lod*100.;

	//Changing Longitude and Latitude to Radians
	m_lat= (lad+lat/60.0) *M_PI/180;
	m_lon= (lod+lon/60.0) *M_PI/180;
	m_h  =  h;

	conv_llh2xyz();
}

void geo_pos_conv::llh_to_xyz(double lat, double lon, double ele)
{
	m_lat = lat * M_PI/180;
	m_lon = lon * M_PI/180;
	m_h = ele;

	conv_llh2xyz();
}

void geo_pos_conv::conv_llh2xyz(void)
{
	double PS;           //
	double PSo;          //
	double PDL;          //
	double Pt;           //
	double PN;           //
	double PW;           // 
    
	double PB1, PB2, PB3, PB4, PB5, PB6, PB7, PB8, PB9;
	double PA, PB, PC, PD, PE, PF, PG, PH, PI;
	double Pe;           //
	double Pet;          //
	double Pnn;          //  
	double AW,FW,Pmo;

	Pmo = 0.9999;

	/*WGS84 Parameters*/
	AW = 6378137.0; //Semimajor Axis
	FW = 1.0/298.257222101; //298.257223563 //Geometrical flattening
    
	Pe  = (double) sqrt(2.0*FW - pow(FW,2));
	Pet = (double) sqrt( pow(Pe,2) / (1.0 - pow(Pe,2)) );
    
	PA = (double) 1.0 + 3.0/4.0*pow(Pe,2) + 45.0/64.0* pow(Pe,4) + 175.0/256.0*pow(Pe,6) 
		+ 11025.0/16384.0*pow(Pe,8) + 43659.0/65536.0*pow(Pe,10) + 693693.0/1048576.0*pow(Pe,12)
		+ 19324305.0/29360128.0*pow(Pe,14) + 4927697775.0/7516192768.0*pow(Pe,16);
    
	PB = (double) 3.0/4.0*pow(Pe,2) + 15.0/16.0*pow(Pe,4) + 525.0/512.0*pow(Pe,6) + 2205.0/2048.0*pow(Pe,8)
		+ 72765.0/65536.0*pow(Pe,10) + 297297.0/262144.0*pow(Pe,12) + 135270135.0/117440512.0*pow(Pe,14) 
		+ 547521975.0/469762048.0*pow(Pe,16);
    
	PC = (double) 15.0/64.0*pow(Pe,4) + 105.0/256.0*pow(Pe,6) + 2205.0/4096.0*pow(Pe,8) + 10395.0/16384.0*pow(Pe,10)
		+ 1486485.0/2097152.0*pow(Pe,12) + 45090045.0/58720256.0*pow(Pe,14)+ 766530765.0/939524096.0*pow(Pe,16);
    
	PD = (double) 35.0/512.0*pow(Pe,6) + 315.0/2048.0*pow(Pe,8) + 31185.0/131072.0*pow(Pe,10)
		+ 165165.0/524288.0*pow(Pe,12) + 45090045.0/117440512.0*pow(Pe,14) + 209053845.0/469762048.0*pow(Pe,16);
    
	PE = (double) 315.0/16384.0*pow(Pe,8) + 3465.0/65536.0*pow(Pe,10) + 99099.0/1048576.0*pow(Pe,12) + 
		4099095.0/29360128.0*pow(Pe,14) + 348423075.0/1879048192.0*pow(Pe,16);
    
	PF = (double) 693.0/131072.0*pow(Pe,10) + 9009.0/524288.0*pow(Pe,12) +  4099095.0/117440512.0*pow(Pe,14)
		+ 26801775.0/469762048.0*pow(Pe,16);
    
	PG = (double) 3003.0/2097152.0*pow(Pe,12) + 315315.0/58720256.0*pow(Pe,14) + 11486475.0/939524096.0*pow(Pe,16);
    
	PH = (double) 45045.0/117440512.0*pow(Pe,14) + 765765.0/469762048.0*pow(Pe,16);
    
	PI = (double) 765765.0/7516192768.0*pow(Pe,16);
    
    
	PB1 = (double) AW * (1.0 - pow(Pe,2)) * PA;
	PB2 = (double) AW * (1.0 - pow(Pe,2)) * PB/-2.0;
	PB3 = (double) AW * (1.0 - pow(Pe,2)) * PC/4.0;
	PB4 = (double) AW * (1.0 - pow(Pe,2)) * PD/-6.0;
	PB5 = (double) AW * (1.0 - pow(Pe,2)) * PE/8.0;
	PB6 = (double) AW * (1.0 - pow(Pe,2)) * PF/-10.0;
	PB7 = (double) AW * (1.0 - pow(Pe,2)) * PG/12.0;
	PB8 = (double) AW * (1.0 - pow(Pe,2)) * PH/-14.0;
	PB9 = (double) AW * (1.0 - pow(Pe,2)) * PI/16.0;
    
    
	PS = (double) PB1*m_lat + PB2*sin(2.0*m_lat) + PB3*sin(4.0*m_lat) + PB4*sin(6.0*m_lat) 
		+ PB5*sin(8.0*m_lat) + PB6*sin(10.0*m_lat) + PB7*sin(12.0*m_lat) + PB8*sin(14.0*m_lat)
		+ PB9*sin(16.0*m_lat);
    
	PSo = (double) PB1*m_PLato + PB2*sin(2.0*m_PLato) + PB3*sin(4.0*m_PLato) + PB4*sin(6.0*m_PLato) 
		+ PB5*sin(8.0*m_PLato) + PB6*sin(10.0*m_PLato) + PB7*sin(12.0*m_PLato) + PB8*sin(14.0*m_PLato)
		+ PB9*sin(16.0*m_PLato);
    
	PDL = (double) m_lon - m_PLo;
	Pt  = (double) tan(m_lat);
	PW  = (double) sqrt(1.0 - pow(Pe,2)*pow(sin(m_lat),2));
	PN  = (double) AW / PW;
	Pnn = (double) sqrt( pow(Pet,2) * pow(cos(m_lat),2));
    
	m_x = (double) ( (PS - PSo) + (1.0/2.0)*PN*pow(cos(m_lat),2.0)*Pt*pow(PDL,2.0) 
			 + (1.0/24.0) * PN * pow(cos(m_lat),4) * Pt * (5.0-pow(Pt,2) + 9.0*pow(Pnn,2) + 4.0*pow(Pnn,4))*pow(PDL,4)
			 - (1.0/720.0) * PN * pow(cos(m_lat),6) * Pt * 
			 (-61.0 + 58.0*pow(Pt,2) - pow(Pt,4) - 270.0*pow(Pnn,2) + 330.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,6)
			 - (1.0/40320.0) * PN * pow(cos(m_lat),8) * Pt * 
			 (-1385.0 + 3111*pow(Pt,2) - 543*pow(Pt,4) + pow(Pt,6)) * pow(PDL,8) ) * Pmo ; 
    
	m_y = (double) ( PN*cos(m_lat)*PDL - 1.0/6.0* PN * pow(cos(m_lat),3) * (-1 + pow(Pt,2) - pow(Pnn,2))*pow(PDL,3)
			 -1.0/120.0*PN*pow(cos(m_lat),5) * (-5.0+18.0*pow(Pt,2)-pow(Pt,4)-14.0*pow(Pnn,2)+58.0*pow(Pt,2)*pow(Pnn,2))*pow(PDL,5)
			 -1.0/5040.0*PN*pow(cos(m_lat),7)* (-61.0+479.0*pow(Pt,2)-179.0*pow(Pt,4)+pow(Pt,6))*pow(PDL,7) ) * Pmo;
    
	m_z = m_h;
}

void geo_pos_conv::conv_xyz2llh(void)
{
	// n/a
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/AlternativeVisualizer.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/AlternativeVisualizer.h">
				<diff>@@ -9,7 +9,6 @@
 #define AlternativeVisualizer_H_
 #include &lt;iostream&gt;
 #include &quot;DrawObjBase.h&quot;
-#include &quot;GridMap.h&quot;
 #include &quot;RoadNetwork.h&quot;
 #include &quot;CarState.h&quot;
 #include &quot;DrawingHelpers.h&quot;
@@ -40,7 +39,6 @@ public:
 
 public:
     PlannerHNS::RoadNetwork m_RoadMap;
-	PlannerHNS::GridMap* m_pMap;
 	PlannerHNS::WayPoint m_start;
 	PlannerHNS::WayPoint m_goal;
 	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawLanes;
</diff>
				<old_file>/*
 * AlternativeVisualizer.h
 *
 *  Created on: Jun 17, 2016
 *      Author: hatem
 */

#ifndef AlternativeVisualizer_H_
#define AlternativeVisualizer_H_
#include &lt;iostream&gt;
#include &quot;DrawObjBase.h&quot;
#include &quot;GridMap.h&quot;
#include &quot;RoadNetwork.h&quot;
#include &quot;CarState.h&quot;
#include &quot;DrawingHelpers.h&quot;
#include &quot;TrajectoryFollower.h&quot;
#include &quot;SimulatedTrajectoryFollower.h&quot;
#include &quot;Graph2dBase.h&quot;

namespace Graphics
{

class AlternativeVisualizer : public DrawObjBase
{
public:
	AlternativeVisualizer();
	virtual ~AlternativeVisualizer();

	void DrawSimu();
	void DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY);
	void OnLeftClick(const double&amp; x, const double&amp; y);
	void OnRightClick(const double&amp; x, const double&amp; y);
	void OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key);
	void LoadMaterials();
	void Reset();
    bool IsInitState();
    void UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2);
    void AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a);


public:
    PlannerHNS::RoadNetwork m_RoadMap;
	PlannerHNS::GridMap* m_pMap;
	PlannerHNS::WayPoint m_start;
	PlannerHNS::WayPoint m_goal;
	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawLanes;
	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawCenterLines;
	std::vector&lt;PlannerHNS::WayPoint&gt; m_GeneratedPath;

private:
	void PrepareVectorMapForDrawing();
	void DrawVectorMap();
	void DrawGPSData();
	void TransToCarCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
	void TransToWorldCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
	void medianfilter(std::vector&lt;double&gt; signal, std::vector&lt;double&gt;&amp; result, int nOrder);

};

} /* namespace Graphics */

#endif /* AlternativeVisualizer_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/Graph2dBase.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/Graph2dBase.h">
				<diff>@@ -23,14 +23,14 @@ public:
 	double DrawGraph();
 	void InsertPoint(const double&amp; x, const double&amp; y);
 	void InsertPointTimeStamp(const timespec&amp; tStamp, const double&amp; y);
-	void InsertPointsList(const std::vector&lt;PlannerHNS::POINT2D&gt;&amp; points);
+	void InsertPointsList(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; points);
 
 
 protected:
 	double w,h;
 	double nPoints;
-	std::vector&lt;PlannerHNS::POINT2D&gt; xy_arr;
-	std::vector&lt;PlannerHNS::POINT2D&gt; xy_arr_original;
+	std::vector&lt;PlannerHNS::GPSPoint&gt; xy_arr;
+	std::vector&lt;PlannerHNS::GPSPoint&gt; xy_arr_original;
 
 	double axes_color[3];
 	double graph_color[3];
@@ -38,8 +38,8 @@ protected:
 	std::string x_name;
 	std::string y_name;
 	std::string str_comment;
-	PlannerHNS::POINT2D max_point;
-	PlannerHNS::POINT2D min_point;
+	PlannerHNS::GPSPoint max_point;
+	PlannerHNS::GPSPoint min_point;
 
 	timespec m_PrevTimeStamp;
 };
</diff>
				<old_file>/*
 * Graph2dBase.h
 *
 *  Created on: Oct 8, 2016
 *      Author: hatem
 */

#ifndef GRAPH2DBASE_H_
#define GRAPH2DBASE_H_

#include &quot;DrawingHelpers.h&quot;
#include &quot;RoadNetwork.h&quot;
#include &lt;vector&gt;

namespace Graphics {

class Graph2dBase {
public:
	void ReInitGraphResolution(double width, double height, int nMaxPoints, double a_color[], double g_color[]);
	Graph2dBase(double width, double height, int nMaxPoints, double max_y, double min_y, std::string str_title, std::string str_x, std::string str_y, double a_color[], double g_color[]);
	void UpdateComment(const std::string&amp; str_com);
	virtual ~Graph2dBase();
	double DrawGraph();
	void InsertPoint(const double&amp; x, const double&amp; y);
	void InsertPointTimeStamp(const timespec&amp; tStamp, const double&amp; y);
	void InsertPointsList(const std::vector&lt;PlannerHNS::POINT2D&gt;&amp; points);


protected:
	double w,h;
	double nPoints;
	std::vector&lt;PlannerHNS::POINT2D&gt; xy_arr;
	std::vector&lt;PlannerHNS::POINT2D&gt; xy_arr_original;

	double axes_color[3];
	double graph_color[3];
	std::string graph_title;
	std::string x_name;
	std::string y_name;
	std::string str_comment;
	PlannerHNS::POINT2D max_point;
	PlannerHNS::POINT2D min_point;

	timespec m_PrevTimeStamp;
};

} /* namespace Graphics */

#endif /* GRAPH2DBASE_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/PlannerTestDraw.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/PlannerTestDraw.h">
				<diff>@@ -9,7 +9,6 @@
 #define PLANNERTESTDRAW_H_
 #include &lt;iostream&gt;
 #include &quot;DrawObjBase.h&quot;
-#include &quot;GridMap.h&quot;
 #include &quot;RoadNetwork.h&quot;
 #include &quot;CarState.h&quot;
 #include &quot;DrawingHelpers.h&quot;
@@ -21,6 +20,12 @@
 namespace Graphics
 {
 
+#define STEERING_AXIS 0
+#define ACCELERATION_AXIS 1
+#define BRAKE_AXIS 2
+#define BUTTON_INDEX 0
+#define START_BUTTON_VALUE 512
+
 class PlannerTestDraw : public DrawObjBase
 {
 public:
@@ -41,6 +46,7 @@ public:
 	 static void* PlanningThreadStaticEntryPoint(void* pThis);
 	 static void* ControlThreadStaticEntryPoint(void* pThis);
 	 static void* SimulationThreadStaticEntryPoint(void* pThis);
+	 static void* GameWheelThreadStaticEntryPoint(void* pThis);
 
 
 	 void InitStartAndGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2);
@@ -48,13 +54,13 @@ public:
 
 public:
 	 PlannerHNS::RoadNetwork m_RoadMap;
-	PlannerHNS::GridMap* m_pMap;
+
 	std::vector&lt;PlannerHNS::WayPoint&gt; m_goals;
 	int m_iCurrentGoal;
 	PlannerHNS::WayPoint m_start;
 	bool				 m_bMakeNewPlan;
-	bool 				m_bResetForSimulation;
-	bool			m_bGreenTrafficLight;
+	bool 				 m_bResetForSimulation;
+	bool				 m_bGreenTrafficLight;
 //	PlannerHNS::WayPoint m_SlowDown;
 //	PlannerHNS::WayPoint m_GoNormal;
 	bool m_bStartSlow;
@@ -66,6 +72,8 @@ public:
 	pthread_t planning_thread_tid;
 	pthread_t control_thread_tid;
 	pthread_t simulation_thread_tid;
+	pthread_t game_wheel_thread_tid;
+
 	bool m_bCancelThread;
 	PlannerHNS::ControllerParams m_ControlParams;
 	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
@@ -95,7 +103,11 @@ public:
 
 	std::vector&lt;PlannerHNS::WayPoint*&gt; m_all_cell_to_delete;
 
-
+	//Game Wheel Controller
+	double m_SteeringAngle;
+	double m_Acceleration;
+	double m_Braking;
+	bool   m_bStart;
 
 private:
 	void PrepareVectorMapForDrawing();
</diff>
				<old_file>/*
 * PlannerTestDraw.h
 *
 *  Created on: Jun 17, 2016
 *      Author: hatem
 */

#ifndef PLANNERTESTDRAW_H_
#define PLANNERTESTDRAW_H_
#include &lt;iostream&gt;
#include &quot;DrawObjBase.h&quot;
#include &quot;GridMap.h&quot;
#include &quot;RoadNetwork.h&quot;
#include &quot;CarState.h&quot;
#include &quot;DrawingHelpers.h&quot;
#include &quot;TrajectoryFollower.h&quot;
#include &quot;SimulatedTrajectoryFollower.h&quot;
#include &quot;Graph2dBase.h&quot;
#include &quot;LocalPlannerH.h&quot;

namespace Graphics
{

class PlannerTestDraw : public DrawObjBase
{
public:
	PlannerTestDraw();
	virtual ~PlannerTestDraw();

	void DrawSimu();
	void DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY);
	void OnLeftClick(const double&amp; x, const double&amp; y);
	void OnRightClick(const double&amp; x, const double&amp; y);
	void OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key);
	void LoadMaterials();
	void Reset();
    bool IsInitState();
    void UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2);
    void AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a);

	 static void* PlanningThreadStaticEntryPoint(void* pThis);
	 static void* ControlThreadStaticEntryPoint(void* pThis);
	 static void* SimulationThreadStaticEntryPoint(void* pThis);


	 void InitStartAndGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2);


public:
	 PlannerHNS::RoadNetwork m_RoadMap;
	PlannerHNS::GridMap* m_pMap;
	std::vector&lt;PlannerHNS::WayPoint&gt; m_goals;
	int m_iCurrentGoal;
	PlannerHNS::WayPoint m_start;
	bool				 m_bMakeNewPlan;
	bool 				m_bResetForSimulation;
	bool			m_bGreenTrafficLight;
//	PlannerHNS::WayPoint m_SlowDown;
//	PlannerHNS::WayPoint m_GoNormal;
	bool m_bStartSlow;

	pthread_mutex_t planning_mutex;
	pthread_mutex_t control_mutex;
	pthread_mutex_t simulation_mutex;

	pthread_t planning_thread_tid;
	pthread_t control_thread_tid;
	pthread_t simulation_thread_tid;
	bool m_bCancelThread;
	PlannerHNS::ControllerParams m_ControlParams;
	PlannerHNS::CAR_BASIC_INFO m_CarInfo;
	PlannerHNS::PlanningParams m_PlanningParams;
	double m_PlanningCycleTime;
	double m_ControlCycleTime;
	double m_SimulationCycleTime;

	PlannerHNS::VehicleState m_VehicleTargetState;
	PlannerHNS::VehicleState m_VehicleCurrentState;
	PlannerHNS::BehaviorState m_CurrentBehavior;

	PlannerHNS::LocalPlannerH 	m_LocalPlanner;
	PlannerHNS::GPSPoint 		m_FollowPoint;
	PlannerHNS::GPSPoint 		m_PerpPoint;
	double m_LateralError;
	std::vector&lt;DisplayDataObj&gt; m_DisplayList;

	GLMmodel* m_CarModel;
	std::vector&lt;PlannerHNS::WayPoint&gt; m_ActualPath;
	std::vector&lt;PlannerHNS::DetectedObject&gt; m_dummyObstacles;
	std::vector&lt;SimulationNS::SimulatedCarState&gt; m_SimulatedCars;
	std::vector&lt;PlannerHNS::BehaviorState&gt; m_SimulatedBehaviors;
	std::vector&lt;PlannerHNS::VehicleState&gt;  m_SimulatedVehicleState;
	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; m_SimulatedPrevTrajectory;
	std::vector&lt;SimulationNS::SimulatedTrajectoryFollower&gt; m_SimulatedPathFollower;

	std::vector&lt;PlannerHNS::WayPoint*&gt; m_all_cell_to_delete;



private:
	void PrepareVectorMapForDrawing();
	void DrawVectorMap();


	std::vector&lt;int&gt; m_LanesIds;
	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawLanes;
	std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt; m_ReadyToDrawCenterLines;


	void DetectSimulatedObstacles(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
	void TransToCarCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
	void TransToWorldCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);

	void SaveSimulationData();
	void LoadSimulationData();
	void AddSimulatedCar(const double&amp; x,const double&amp; y, const double&amp; a, const double&amp; v);


	/**
	 * Draw Infor Section
	 */
	Graph2dBase* m_pVelocityGraph;
	Graph2dBase* m_pSteeringGraph;
	Graph2dBase* m_pLateralErrGraph;

	double m_GlobalPlanningTime;
	double m_LocalPlanningTime;
	double m_ControllingTime;
	double m_ObjectTrakingTime;
	double m_SimulationTime;
	int m_iStepNumber;


	//Sub drawing functions
private:
	void DrawStartsAndGoals();
	void DrawTrafficInfo_StopLines_Lights();
	void DrawCarModels();
	void DrawPaths();
	void DrawAdditionalDebugInfo();


};

} /* namespace Graphics */

#endif /* PLANNERTESTDRAW_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/SimpleTracker.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/SimpleTracker.h">
				<diff>@@ -21,6 +21,7 @@ namespace SimulationNS
 #define DEBUG_TRACKER 0
 #define NEVER_GORGET_TIME -1000
 #define MIN_EVIDENCE_NUMBER 3
+#define TRACKING_HORIZON 150
 
 struct Kalman1dState
 {
@@ -133,12 +134,13 @@ public:
 		cv::setIdentity(m_filter.processNoiseCov, cv::Scalar::all(0.0001));
 		cv::setIdentity(m_filter.errorCovPost, cv::Scalar::all(0.075));
 
+
 		m_filter.predict();
 
 		errorSmoother.Update(a);
 	}
 
-	void UpdateTracking(double _dt, const double&amp; x, const double&amp; y, const double&amp; a, double&amp; x_new, double &amp; y_new , double&amp; a_new, double&amp; v)
+	void UpdateTracking(double _dt, const PlannerHNS::DetectedObject&amp; oldObj, PlannerHNS::DetectedObject&amp; predObj)
 	{
 		dt = _dt;
 #if (CV_MAJOR_VERSION == 2)
@@ -152,50 +154,58 @@ public:
 				0	,0	,1	,0	,
 				0	,0	,0	,1	);
 #endif		
-		double a_old = a;
+		double a_old = oldObj.center.pos.a;
 
 		cv::Mat_&lt;float&gt; measurement(nMeasure,1);
 		cv::Mat_&lt;float&gt; prediction(nStates,1);
 
-		measurement(0) = x;
-		measurement(1) = y;
+		measurement(0) = oldObj.center.pos.x;
+		measurement(1) = oldObj.center.pos.y;
 
 		prediction = m_filter.correct(measurement);
 
-		x_new = prediction.at&lt;float&gt;(0);
-		y_new = prediction.at&lt;float&gt;(1);
+		predObj.center.pos.x = prediction.at&lt;float&gt;(0);
+		predObj.center.pos.y = prediction.at&lt;float&gt;(1);
 		double vx  = prediction.at&lt;float&gt;(2);
 		double vy  = prediction.at&lt;float&gt;(3);
 
-		if(m_iLife &gt; 2)
+		if(m_iLife &gt; 10)
 		{
-			v = sqrt(vx*vx+vy*vy);
-			double diff_y = y_new - prev_y;
-			double diff_x = x_new - prev_x;
-			if(hypot(diff_y, diff_x) &gt; 0.5)
+			predObj.center.v = sqrt(vx*vx+vy*vy);
+			double diff_y = predObj.center.pos.y - prev_y;
+			double diff_x = predObj.center.pos.x - prev_x;
+			if(hypot(diff_y, diff_x) &gt; 0.15)
 			{
-				prev_y = y;
-				prev_x = x;
-				a_new = atan2(diff_y, diff_x);
+				prev_y = oldObj.center.pos.y;
+				prev_x = oldObj.center.pos.x;
+				predObj.center.pos.a = atan2(diff_y, diff_x);
 			}
 			else
-				a_new = a;
+			{
+				predObj.center.pos.a = oldObj.center.pos.a;
+			}
+
+			//if(predObj.center.v &gt; 0.1)
+			{
+				predObj.bDirection = true;
+				predObj.bVelocity = true;
+			}
+			predObj.acceleration = UtilityHNS::UtilityH::GetSign(predObj.center.v - oldObj.center.v);
 
 		}
 		else
 		{
-			v = 0;
-			a_new = a;
+			predObj.center.v = 0;
+			//predObj.center.pos.a = oldObj.center.pos.a;
+			predObj.center.pos.a = predObj.actual_yaw;
 		}
 
-		circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(a_new));
-
-		circ_angle =  errorSmoother.Update(circ_angle).x;
-
-		a_new = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);
+		//circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(predObj.center.pos.a));
+		//circ_angle =  errorSmoother.Update(circ_angle).x;
+		//predObj.center.pos.a = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);
 
-		if(v &lt; 0.1)
-			v = 0;
+		if(predObj.center.v &lt; 0.1)
+			predObj.center.v = 0;
 
 		//std::cout &lt;&lt; &quot;Track: Old (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;), New (&quot; &lt;&lt; x_new &lt;&lt; &quot;, &quot; &lt;&lt; y_new &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
 		//std::cout &lt;&lt; &quot;Track: &quot; &lt;&lt; m_id &lt;&lt; &quot;, A: &quot; &lt;&lt; a &lt;&lt; &quot;, A_new:(&quot; &lt;&lt; circ_angle &lt;&lt; &quot;,&quot; &lt;&lt;  a_new &lt;&lt; &quot;) , V&quot; &lt;&lt; v &lt;&lt; &quot;, dt: &quot; &lt;&lt; dt &lt;&lt; &quot;, forget_time: &quot; &lt;&lt; forget_time &lt;&lt; std::endl;
@@ -217,16 +227,16 @@ public:
 	double radius;
 	double forget_time;
 	std::vector&lt;KFTrackV*&gt; pTrackers;
-	InterestCircle* pPrevCircle;
-	InterestCircle* pNextCircle;
+//	InterestCircle* pPrevCircle;
+//	InterestCircle* pNextCircle;
 
 	InterestCircle(int _id)
 	{
 		id = _id;
 		radius = 0;
 		forget_time = NEVER_GORGET_TIME; // never forget
-		pPrevCircle = 0;
-		pNextCircle = 0;
+//		pPrevCircle = 0;
+//		pNextCircle = 0;
 	}
 };
 
@@ -249,6 +259,7 @@ class SimpleTracker
 public:
 	std::vector&lt;InterestCircle*&gt; m_InterestRegions;
 	std::vector&lt;KFTrackV*&gt; m_Tracks;
+	std::vector&lt;KFTrackV&gt; m_TrackSimply;
 	timespec m_TrackTimer;
 	long iTracksNumber;
 	PlannerHNS::WayPoint m_PrevState;
@@ -265,13 +276,15 @@ public:
 	void AssociateObjects();
 	void InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions);
 	void AssociateAndTrack();
+	void AssociateSimply();
 	void AssociateToRegions(KFTrackV&amp; detectedObject);
 	void CleanOldTracks();
 
 	void DoOneStep(const PlannerHNS::WayPoint&amp; currPose, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);
 
-	SimpleTracker(double horizon = 100);
+	SimpleTracker();
 	virtual ~SimpleTracker();
+	void InitSimpleTracker();
 
 public:
 	double m_DT;
</diff>
				<old_file>/*
 * SimpleTracker.h
 *
 *  Created on: Aug 11, 2016
 *      Author: hatem
 */

#ifndef SimpleTracker_H_
#define SimpleTracker_H_

#include &quot;RoadNetwork.h&quot;
#include &quot;opencv2/video/tracking.hpp&quot;
#include &lt;vector&gt;
#include &quot;UtilityH.h&quot;
#include &lt;math.h&gt;
#include &lt;iostream&gt;

namespace SimulationNS
{

#define DEBUG_TRACKER 0
#define NEVER_GORGET_TIME -1000
#define MIN_EVIDENCE_NUMBER 3

struct Kalman1dState
{
    double MovCov; //double q; //moving noise covariance
    double MeasureCov; //double r; //measurement noise covariance
    double x; //value
    double p; //estimation error covariance
    double k; //kalman gain
};

class  kalmanFilter1D
{
public:

	Kalman1dState result;

    kalmanFilter1D()
	{

	}
    kalmanFilter1D(double MovCov, double MeasureCov, double p, double intial_value)
    {
        result.MovCov = MovCov;
        result.MeasureCov = MeasureCov;
        result.p = p;
        result.x = intial_value;
    }

    Kalman1dState Update(double measurement)
    {
    	//prediction update
		//omit x = x
		result.p = result.p + result.MovCov;

		//measurement update
		result.k = result.p / (result.p + result.MeasureCov);
		result.x = result.x + result.k * (measurement - result.x);
		result.p = (1 - result.k) * result.p;

		return result;
    }
};

class KFTrackV
{
private:
	cv::KalmanFilter m_filter;
	double prev_x, prev_y, prev_v, prev_a;
	long m_id;
	double dt;
	int nStates;
	int nMeasure;
	double circ_angle;

public:
	int region_id;
	double forget_time;
	int m_iLife;
	PlannerHNS::DetectedObject obj;
	kalmanFilter1D errorSmoother;

	long GetTrackID()
	{
		return m_id;
	}

	KFTrackV(double x, double y, double a, long id, double _dt)
	{
		circ_angle = 0;
		errorSmoother.result.MovCov = 0.125;
		errorSmoother.result.MeasureCov = 0.1;
		errorSmoother.result.p = 1;
		errorSmoother.result.x = 0;
		region_id = -1;
		forget_time = NEVER_GORGET_TIME; // this is very bad , dangerous
		m_iLife = 0;
		dt = _dt;
		prev_x = x;
		prev_y = y;
		prev_v = 0;
		prev_a = a;
		nStates = 4;
		nMeasure = 2;

		m_id = id;

		m_filter = cv::KalmanFilter(nStates,nMeasure);
#if (CV_MAJOR_VERSION == 2)
		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
				0	,1	,0	,dt	,
				0	,0	,1	,0	,
				0	,0	,0	,1	);
#elif (CV_MAJOR_VERSION == 3)
		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
				0	,1	,0	,dt	,
				0	,0	,1	,0	,
				0	,0	,0	,1	);
#endif		

		m_filter.statePre.at&lt;float&gt;(0) = x;
		m_filter.statePre.at&lt;float&gt;(1) = y;
		m_filter.statePre.at&lt;float&gt;(2) = 0;
		m_filter.statePre.at&lt;float&gt;(3) = 0;

		m_filter.statePost = m_filter.statePre;

		setIdentity(m_filter.measurementMatrix);

		cv::setIdentity(m_filter.measurementNoiseCov, cv::Scalar::all(0.0001));
		cv::setIdentity(m_filter.processNoiseCov, cv::Scalar::all(0.0001));
		cv::setIdentity(m_filter.errorCovPost, cv::Scalar::all(0.075));

		m_filter.predict();

		errorSmoother.Update(a);
	}

	void UpdateTracking(double _dt, const double&amp; x, const double&amp; y, const double&amp; a, double&amp; x_new, double &amp; y_new , double&amp; a_new, double&amp; v)
	{
		dt = _dt;
#if (CV_MAJOR_VERSION == 2)
		m_filter.transitionMatrix = *(cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
				0	,1	,0	,dt	,
				0	,0	,1	,0	,
				0	,0	,0	,1	);
#elif (CV_MAJOR_VERSION == 3)
		m_filter.transitionMatrix = (cv::Mat_&lt;float&gt;(nStates, nStates) &lt;&lt; 1	,0	,dt	,0  ,
				0	,1	,0	,dt	,
				0	,0	,1	,0	,
				0	,0	,0	,1	);
#endif		
		double a_old = a;

		cv::Mat_&lt;float&gt; measurement(nMeasure,1);
		cv::Mat_&lt;float&gt; prediction(nStates,1);

		measurement(0) = x;
		measurement(1) = y;

		prediction = m_filter.correct(measurement);

		x_new = prediction.at&lt;float&gt;(0);
		y_new = prediction.at&lt;float&gt;(1);
		double vx  = prediction.at&lt;float&gt;(2);
		double vy  = prediction.at&lt;float&gt;(3);

		if(m_iLife &gt; 2)
		{
			v = sqrt(vx*vx+vy*vy);
			double diff_y = y_new - prev_y;
			double diff_x = x_new - prev_x;
			if(hypot(diff_y, diff_x) &gt; 0.5)
			{
				prev_y = y;
				prev_x = x;
				a_new = atan2(diff_y, diff_x);
			}
			else
				a_new = a;

		}
		else
		{
			v = 0;
			a_new = a;
		}

		circ_angle = UtilityHNS::UtilityH::GetCircularAngle(circ_angle, UtilityHNS::UtilityH::FixNegativeAngle(a_old), UtilityHNS::UtilityH::FixNegativeAngle(a_new));

		circ_angle =  errorSmoother.Update(circ_angle).x;

		a_new = UtilityHNS::UtilityH::SplitPositiveAngle(circ_angle);

		if(v &lt; 0.1)
			v = 0;

		//std::cout &lt;&lt; &quot;Track: Old (&quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; &quot;), New (&quot; &lt;&lt; x_new &lt;&lt; &quot;, &quot; &lt;&lt; y_new &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
		//std::cout &lt;&lt; &quot;Track: &quot; &lt;&lt; m_id &lt;&lt; &quot;, A: &quot; &lt;&lt; a &lt;&lt; &quot;, A_new:(&quot; &lt;&lt; circ_angle &lt;&lt; &quot;,&quot; &lt;&lt;  a_new &lt;&lt; &quot;) , V&quot; &lt;&lt; v &lt;&lt; &quot;, dt: &quot; &lt;&lt; dt &lt;&lt; &quot;, forget_time: &quot; &lt;&lt; forget_time &lt;&lt; std::endl;

		m_filter.predict();
		m_filter.statePre.copyTo(m_filter.statePost);
		m_filter.errorCovPre.copyTo(m_filter.errorCovPost);

		forget_time -= dt;
		m_iLife++;
	}
	virtual ~KFTrackV(){}
};

class InterestCircle
{
public:
	int id;
	double radius;
	double forget_time;
	std::vector&lt;KFTrackV*&gt; pTrackers;
	InterestCircle* pPrevCircle;
	InterestCircle* pNextCircle;

	InterestCircle(int _id)
	{
		id = _id;
		radius = 0;
		forget_time = NEVER_GORGET_TIME; // never forget
		pPrevCircle = 0;
		pNextCircle = 0;
	}
};

class CostRecordSet
{
public:
	int currobj;
	int prevObj;
	double cost;
	CostRecordSet(int curr_id, int prev_id, double _cost)
	{
		currobj = curr_id;
		prevObj = prev_id;
		cost = _cost;
	}
};

class SimpleTracker
{
public:
	std::vector&lt;InterestCircle*&gt; m_InterestRegions;
	std::vector&lt;KFTrackV*&gt; m_Tracks;
	timespec m_TrackTimer;
	long iTracksNumber;
	PlannerHNS::WayPoint m_PrevState;
	std::vector&lt;PlannerHNS::DetectedObject&gt; m_PrevDetectedObjects;
	std::vector&lt;PlannerHNS::DetectedObject&gt; m_DetectedObjects;

	void CreateTrack(PlannerHNS::DetectedObject&amp; o);
	void CreateTrackV2(PlannerHNS::DetectedObject&amp; o);
	KFTrackV* FindTrack(long index);
	void Track(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; objects_list);
	void TrackV2();
	void CoordinateTransform(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::DetectedObject&amp; obj);
	void CoordinateTransformPoint(const PlannerHNS::WayPoint&amp; refCoordinate, PlannerHNS::GPSPoint&amp; obj);
	void AssociateObjects();
	void InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions);
	void AssociateAndTrack();
	void AssociateToRegions(KFTrackV&amp; detectedObject);
	void CleanOldTracks();

	void DoOneStep(const PlannerHNS::WayPoint&amp; currPose, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list);

	SimpleTracker(double horizon = 100);
	virtual ~SimpleTracker();

public:
	double m_DT;
	double m_MAX_ASSOCIATION_DISTANCE;
	int m_MAX_TRACKS_AFTER_LOSING;
	bool m_bUseCenterOnly;
	double m_MaxKeepTime;
	bool m_bFirstCall;
};

} /* namespace BehaviorsNS */

#endif /* SimpleTracker_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/TrajectoryFollower.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/include/TrajectoryFollower.h">
				<diff>@@ -12,7 +12,7 @@
 #include &quot;PlannerCommonDef.h&quot;
 
 
-#define MAX_ACCELERATION_2G 20 // meter /sec/sec
+#define MAX_ACCELERATION_2G 5 // meter /sec/sec
 namespace SimulationNS
 {
 
</diff>
				<old_file>/*
 * TrajectoryFollower.h
 *
 *  Created on: Jun 18, 2016
 *      Author: hatem
 */

#ifndef TRAJECTORYFOLLOWER_H_
#define TRAJECTORYFOLLOWER_H_
#include &quot;RoadNetwork.h&quot;
#include &quot;UtilityH.h&quot;
#include &quot;PlannerCommonDef.h&quot;


#define MAX_ACCELERATION_2G 20 // meter /sec/sec
namespace SimulationNS
{

class TrajectoryFollower
{
public:
	TrajectoryFollower();
	virtual ~TrajectoryFollower();

	void PrepareNextWaypoint(const PlannerHNS::WayPoint&amp; CurPos, const double&amp; currVelocity, const double&amp; currSteering);

	void UpdateCurrentPath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path);

	int SteerControllerUpdate(const PlannerHNS::VehicleState&amp; CurrStatus,
			const PlannerHNS::BehaviorState&amp; CurrBehavior, double&amp; desiredSteerAngle);
	int VeclocityControllerUpdate(const double&amp; dt, const PlannerHNS::VehicleState&amp; CurrStatus,
			const PlannerHNS::BehaviorState&amp; CurrBehavior, double&amp; desiredVelocity, PlannerHNS::SHIFT_POS&amp; desiredShift);

	void Init(const PlannerHNS::ControllerParams&amp; params, const PlannerHNS::CAR_BASIC_INFO&amp; vehicleInfo, bool bEnableLogs = false, bool bCalibration = false);

	PlannerHNS::VehicleState DoOneStep(const double&amp; dt, const PlannerHNS::BehaviorState&amp; behavior,
				const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; currPose,
				const PlannerHNS::VehicleState&amp; vehicleState, const bool&amp; bNewTrajectory);

	//Testing Points
	PlannerHNS::WayPoint 	m_ForwardSimulation;
	PlannerHNS::WayPoint 	m_PerpendicularPoint;
	PlannerHNS::WayPoint 	m_FollowMePoint;
	double 					m_LateralError;
	double 					m_FollowingDistance;
	PlannerHNS::WayPoint 	m_CurrPos;
	int 					m_iCalculatedIndex;
	bool					m_bEndPath;
	double 					m_WayPointsDensity;


private:
	double 						m_StartFollowDistance;
	double 						m_FollowAcc;
	PlannerHNS::ControllerParams 			m_Params;
	PlannerHNS::CAR_BASIC_INFO 				m_VehicleInfo;
	std::vector&lt;PlannerHNS::WayPoint&gt; 	m_Path;
	PlannerHNS::WayPoint 		m_DesPos;
	double						m_PrevDesiredSteer; // control output
	double 						m_FollowAcceleration;
	int 						m_iPrevWayPoint;
	UtilityHNS::PIDController 	m_pidSteer;
	UtilityHNS::LowpassFilter 	m_lowpassSteer;

	UtilityHNS::PIDController 	m_pidVelocity;
	UtilityHNS::LowpassFilter 	m_lowpassVelocity;

	bool						m_bEnableLog;
	std::vector&lt;std::string&gt;    m_LogData;
	std::vector&lt;std::string&gt;    m_LogSteerPIDData;
	std::vector&lt;std::string&gt;    m_LogVelocityPIDData;

	//Steering and Velocity Calibration Global Variables
	bool						m_bCalibrationMode;
	int							m_iNextTest;
	std::vector&lt;std::string&gt;    m_SteerCalibrationData;
	std::vector&lt;std::string&gt;    m_VelocityCalibrationData;
	PlannerHNS::VehicleState 	m_prevCurrState_steer;
	PlannerHNS::VehicleState 	m_prevDesiredState_steer;
	PlannerHNS::VehicleState 	m_prevCurrState_vel;
	PlannerHNS::VehicleState 	m_prevDesiredState_vel;
	struct timespec 			m_SteerDelayTimer;
	struct timespec 			m_VelocityDelayTimer;
	std::vector&lt;std::pair&lt;double, double&gt; &gt; m_CalibrationRunList;


	bool FindNextWayPoint(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; state,
			const double&amp; velocity, PlannerHNS::WayPoint&amp; pursuite_point, PlannerHNS::WayPoint&amp; prep,
			double&amp; lateral_err, double&amp; follow_distance);

	int SteerControllerPart(const PlannerHNS::WayPoint&amp; state, const PlannerHNS::WayPoint&amp; way_point,
			const double&amp; lateral_error, double&amp; steerd);

	void PredictMotion(double&amp; x, double &amp;y, double&amp; heading, double steering, double velocity,
			double wheelbase, double time_elapsed);

	double GetPID_LinearChange(double minVal, double maxVal, double speedMax, double currSpeed);

	void AdjustPID(const double&amp; v, const double&amp; maxV,  PlannerHNS::PID_CONST&amp; steerPID);

	int CalculateVelocityDesired(const double&amp; dt, const double&amp; currVel,const PlannerHNS::STATE_TYPE&amp; CurrBehavior,
			double&amp; desiredVel);

	void LogCalibrationData(const PlannerHNS::VehicleState&amp; currState,const PlannerHNS::VehicleState&amp; desiredState);
	void InitCalibration();
	void CalibrationStep(const double&amp; dt, const PlannerHNS::VehicleState&amp; CurrStatus, double&amp; desiredSteer, double&amp; desiredVelocity);
};

} /* namespace SimulationNS */

#endif /* TRAJECTORYFOLLOWER_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/AlternativeVisualizer.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/AlternativeVisualizer.cpp">
				<diff>@@ -49,11 +49,6 @@ void AlternativeVisualizer::LoadMaterials()
 
 AlternativeVisualizer::~AlternativeVisualizer()
 {
-	if(m_pMap)
-	{
-		delete m_pMap;
-		m_pMap = 0;
-	}
 }
 
 bool AlternativeVisualizer::IsInitState()
@@ -192,21 +187,21 @@ void AlternativeVisualizer::DrawGPSData()
 	}
 
 	// 4- Convert to Cartesian and scale Up
-	MappingHelpers::llaToxyz(origin, GPSPoint());
-	GPSPoint prevP = origin;
-	vector&lt;double&gt; x_signal;
-	vector&lt;double&gt; y_signal;
-	for(unsigned int i = 0 ; i &lt; gpsDataPath.size(); i++)
-	{
-		MappingHelpers::llaToxyz(gpsDataPath.at(i).pos, origin);
-		gpsDataPath.at(i).pos.x = gpsDataPath.at(i).pos.x * 100000;
-		gpsDataPath.at(i).pos.y = gpsDataPath.at(i).pos.y * 100000;
-
-		x_signal.push_back(gpsDataPath.at(i).pos.x);
-		y_signal.push_back(gpsDataPath.at(i).pos.y);
-
-		prevP = gpsDataPath.at(i).pos;
-	}
+//	MappingHelpers::llaToxyz(origin, GPSPoint());
+//	GPSPoint prevP = origin;
+//	vector&lt;double&gt; x_signal;
+//	vector&lt;double&gt; y_signal;
+//	for(unsigned int i = 0 ; i &lt; gpsDataPath.size(); i++)
+//	{
+//		MappingHelpers::llaToxyz(gpsDataPath.at(i).pos, origin);
+//		gpsDataPath.at(i).pos.x = gpsDataPath.at(i).pos.x * 100000;
+//		gpsDataPath.at(i).pos.y = gpsDataPath.at(i).pos.y * 100000;
+//
+//		x_signal.push_back(gpsDataPath.at(i).pos.x);
+//		y_signal.push_back(gpsDataPath.at(i).pos.y);
+//
+//		prevP = gpsDataPath.at(i).pos;
+//	}
 
 
 	// 5- using cojugate grandient
@@ -219,21 +214,21 @@ void AlternativeVisualizer::DrawGPSData()
 
 	// 6- using kalman filter
 	vector&lt;WayPoint&gt; gpsDataPathSmoothedKalman = gpsDataPath;
-	KFTrackV kf(origin.x, origin.y, origin.a, 0, 1);
+/*	KFTrackV kf(origin.x, origin.y, origin.a, 0, 1);
 	for(unsigned int i = 0 ; i &lt; gpsDataPathSmoothedKalman.size(); i++)
 	{
 		GPSPoint p = gpsDataPathSmoothedKalman.at(i).pos;
 		kf.UpdateTracking(0.1, p.x, p.y, p.a, p.x, p.y, p.a, gpsDataPathSmoothedKalman.at(i).v);
 		gpsDataPathSmoothedKalman.at(i).pos = p;
 	}
-
+*/
 	// 7- using median filter with order n
 	vector&lt;double&gt; x_signal_res;
 	vector&lt;double&gt; y_signal_res;
 	vector&lt;WayPoint&gt; gpsDataPathSmoothedMedian;
 
-	medianfilter(x_signal, x_signal_res, 3);
-	medianfilter(y_signal, y_signal_res, 3);
+	//medianfilter(x_signal, x_signal_res, 3);
+	//medianfilter(y_signal, y_signal_res, 3);
 
 	for(unsigned int i =0 ; i &lt; x_signal_res.size(); i++)
 	{
@@ -274,9 +269,6 @@ void AlternativeVisualizer::DrawGPSData()
 
 	glEnable(GL_LIGHTING);
 
-
-
-
 }
 
 void AlternativeVisualizer::DrawVectorMap()
@@ -336,8 +328,10 @@ void AlternativeVisualizer::DrawVectorMap()
 
 void AlternativeVisualizer::DrawSimu()
 {
+
+
 	//DrawGPSData();
-	DrawVectorMap();
+	//DrawVectorMap();
 	float color[] = {0, 1, 0};
 	DrawingHelpers::DrawWidePath(m_GeneratedPath, 0.5, 0.5, color);
 }
</diff>
				<old_file>/*
 * AlternativeVisualizer.cpp
 *
 *  Created on: Jun 17, 2016
 *      Author: hatem
 */

#include &quot;AlternativeVisualizer.h&quot;
#include &quot;PlannerH.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &quot;MappingHelpers.h&quot;
#include &lt;sstream&gt;
#include &quot;MatrixOperations.h&quot;
#include &quot;SimpleTracker.h&quot;
#include &quot;DataRW.h&quot;
#include &lt;algorithm&gt;


using namespace std;
using namespace SimulationNS;
using namespace UtilityHNS;
using namespace PlannerHNS;


namespace Graphics
{

AlternativeVisualizer::AlternativeVisualizer()
{
	/**
	 * Writing the kml file for the RoadNetwork Map
	 */
//	std::vector&lt;TrafficLight&gt; trafficLights;
//	std::vector&lt;GPSPoint&gt; stopLines;
//	PlannerHNS::MappingHelpers::CreateKmlFromLocalizationPathFile(&quot;/home/user/Downloads/pose.csv&quot;, 50, 0.5, trafficLights, stopLines);
//	string kml_templateFilePath = UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmlTemplateFile;
//	string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmltargetFile;
//	PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
//	PlannerHNS::MappingHelpers::LoadKML(&quot;/home/user/SimuLogs/road_network_test.kml&quot;, m_RoadMap);

	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(&quot;/media/hatem/8ac0c5d5-8793-4b98-8728-55f8d67ec0f4/data/ToyotaCity2/map/vector_map/&quot;, m_RoadMap);
	m_start =  PlannerHNS::MappingHelpers::GetFirstWaypoint(m_RoadMap);
	PrepareVectorMapForDrawing();
}

void AlternativeVisualizer::LoadMaterials()
{
}

AlternativeVisualizer::~AlternativeVisualizer()
{
	if(m_pMap)
	{
		delete m_pMap;
		m_pMap = 0;
	}
}

bool AlternativeVisualizer::IsInitState()
{
	return false;
}

void AlternativeVisualizer::UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2)
{
	m_start.pos.x = x1;
	m_start.pos.y = y1;
	m_start.pos.a = a1;

	m_goal.pos.x = x2;
	m_goal.pos.y = y2;
	m_goal.pos.a = a2;

	PlannerHNS::PlannerH planner;
	m_GeneratedPath.clear();
	planner.PlanUsingReedShepp(m_start, m_goal, m_GeneratedPath, 0.5, 20);
	cout &lt;&lt; &quot;Path is Generated: &quot; &lt;&lt; m_GeneratedPath.size() &lt;&lt; endl;
}

void AlternativeVisualizer::AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a)
{
}

void AlternativeVisualizer::Reset()
{
}

void AlternativeVisualizer::PrepareVectorMapForDrawing()
{
	double distance_to_nearest_lane = 1;
	int j=0;
	int max_number_of_lanes = 500;
	double width_ratio = 2.0;

	vector&lt;PlannerHNS::Lane*&gt; currLane;
	vector&lt;PlannerHNS::Lane*&gt; lanes_list;
	vector&lt;PlannerHNS::Lane*&gt; traversed_lanes;

	while(distance_to_nearest_lane &lt; 100 &amp;&amp; currLane.size() == 0)
	{
		PlannerHNS::Lane* pL = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(m_start, m_RoadMap, distance_to_nearest_lane);
		if(pL)
			currLane.push_back(pL);
		distance_to_nearest_lane += 2;
	}

	if(currLane.size()==0)
	{
		if(m_RoadMap.roadSegments.size() &gt; 0)
			if(m_RoadMap.roadSegments.at(0).Lanes.size()&gt;0)
				currLane.push_back(&amp;m_RoadMap.roadSegments.at(0).Lanes.at(0));
	}

	for(unsigned int i=0; i&lt; currLane.size(); i++)
		lanes_list.push_back(currLane[i]);

	m_ReadyToDrawLanes.clear();
	m_ReadyToDrawCenterLines.clear();

	if(currLane.size() &gt; 0)
	{
		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; ready_to_draw;

		while(lanes_list.size()&gt;0 &amp;&amp; j &lt;max_number_of_lanes)
		{
			ready_to_draw.clear();
			PlannerHNS::Lane* l = lanes_list.at(0);
			lanes_list.erase(lanes_list.begin()+0);
			traversed_lanes.push_back(l);


			vector&lt;PlannerHNS::WayPoint&gt; path_local = l-&gt;points;

			DrawingHelpers::PreparePathForDrawing(path_local,ready_to_draw, 2.8 / width_ratio, 0.5);
			m_ReadyToDrawLanes.push_back(ready_to_draw);

			ready_to_draw.clear();
			DrawingHelpers::PreparePathForDrawing(path_local,ready_to_draw, 0.1, 0.5);
			m_ReadyToDrawCenterLines.push_back(ready_to_draw);


			j++;

			PlannerHNS::MappingHelpers::GetUniqueNextLanes(l, traversed_lanes, lanes_list);
		}
	}
}

void AlternativeVisualizer::medianfilter(std::vector&lt;double&gt; signal, std::vector&lt;double&gt;&amp; result, int nOrder)
{
	int nNewSize = signal.size()/nOrder;

	for(int i=0; i &lt; nNewSize; i++)
	{
		int index = i*nOrder;
		vector&lt;double&gt; temp;
		temp.insert(temp.begin(), signal.begin()+index, signal.begin()+index+nOrder);
		std::sort(temp.begin(), temp.end());
		result.push_back(temp.at(nOrder/2));
	}

}

void AlternativeVisualizer::DrawGPSData()
{

	// 1- Load Data From file
	vector&lt;UtilityHNS::GPSDataReader::GPSBasicData&gt; gps_data;
	GPSDataReader gps_reader(&quot;/home/user/Temp_folder/GPSRawData-noisy.csv&quot;);
	gps_reader.ReadAllData(gps_data);
	vector&lt;WayPoint&gt; gpsDataPath;

	// 2- Convert to OpenPlanner data structure
	for(int i = gps_data.size()-1; i &gt;=0 ; i--)
	{
		WayPoint p ;
		p.pos.lat = p.pos.x = gps_data.at(i).lat;
		p.pos.lon = p.pos.y = gps_data.at(i).lon;
		p.pos.alt = p.pos.z = gps_data.at(i).alt;
		gpsDataPath.push_back(p);
	}

	// 3- Specify Origini for transformation
	GPSPoint origin;
	if(gpsDataPath.size() &gt; 0)
	{
		origin = gpsDataPath.at(0).pos;
		m_followX = gpsDataPath.at(0).pos.x;
		m_followY = gpsDataPath.at(0).pos.y;
		m_followZ = gpsDataPath.at(0).pos.z;
		m_followA = gpsDataPath.at(0).pos.a;
	}

	// 4- Convert to Cartesian and scale Up
	MappingHelpers::llaToxyz(origin, GPSPoint());
	GPSPoint prevP = origin;
	vector&lt;double&gt; x_signal;
	vector&lt;double&gt; y_signal;
	for(unsigned int i = 0 ; i &lt; gpsDataPath.size(); i++)
	{
		MappingHelpers::llaToxyz(gpsDataPath.at(i).pos, origin);
		gpsDataPath.at(i).pos.x = gpsDataPath.at(i).pos.x * 100000;
		gpsDataPath.at(i).pos.y = gpsDataPath.at(i).pos.y * 100000;

		x_signal.push_back(gpsDataPath.at(i).pos.x);
		y_signal.push_back(gpsDataPath.at(i).pos.y);

		prevP = gpsDataPath.at(i).pos;
	}


	// 5- using cojugate grandient
	vector&lt;WayPoint&gt; gpsDataPathSmoothed;
	gpsDataPathSmoothed = gpsDataPath;
	PlanningHelpers::CalcAngleAndCost(gpsDataPathSmoothed);

	PlanningHelpers::SmoothPath(gpsDataPathSmoothed, 0.3, 0.46, 1.5);


	// 6- using kalman filter
	vector&lt;WayPoint&gt; gpsDataPathSmoothedKalman = gpsDataPath;
	KFTrackV kf(origin.x, origin.y, origin.a, 0, 1);
	for(unsigned int i = 0 ; i &lt; gpsDataPathSmoothedKalman.size(); i++)
	{
		GPSPoint p = gpsDataPathSmoothedKalman.at(i).pos;
		kf.UpdateTracking(0.1, p.x, p.y, p.a, p.x, p.y, p.a, gpsDataPathSmoothedKalman.at(i).v);
		gpsDataPathSmoothedKalman.at(i).pos = p;
	}

	// 7- using median filter with order n
	vector&lt;double&gt; x_signal_res;
	vector&lt;double&gt; y_signal_res;
	vector&lt;WayPoint&gt; gpsDataPathSmoothedMedian;

	medianfilter(x_signal, x_signal_res, 3);
	medianfilter(y_signal, y_signal_res, 3);

	for(unsigned int i =0 ; i &lt; x_signal_res.size(); i++)
	{
		WayPoint p ;
		p.pos.x = x_signal_res.at(i);
		p.pos.y = y_signal_res.at(i);

		gpsDataPathSmoothedMedian.push_back(p);
	}


	// 8- Visualizing results
	float PathColor[3] = {1.0, 0.0, 0.0};
	float SmoothPathColor[3] = {0.0, 1.0, 0.0};
	float kalmanPathColor[3] = {0.0, 0.0, 1.0};
	float medianPathColor[3] = {1.0, 1.0, 0.0};

	glDisable(GL_LIGHTING);
	glPushMatrix();
	glTranslated(3,10,0);
	DrawingHelpers::DrawWidePath(gpsDataPath, 0.2, 0.05, PathColor , false);
	glPopMatrix();

	glPushMatrix();
	glTranslated(6,10,0);
	DrawingHelpers::DrawWidePath(gpsDataPathSmoothed, 0.1, 0.05, SmoothPathColor , false);
	glPopMatrix();

	glPushMatrix();
	glTranslated(9,10,0);
	DrawingHelpers::DrawWidePath(gpsDataPathSmoothedKalman, 0.3, 0.05, kalmanPathColor , false);
	glPopMatrix();

	glPushMatrix();
	glTranslated(12,10,0);
	DrawingHelpers::DrawWidePath(gpsDataPathSmoothedMedian, 0.4, 0.05, medianPathColor , false);
	glPopMatrix();

	glEnable(GL_LIGHTING);




}

void AlternativeVisualizer::DrawVectorMap()
{
	glDisable(GL_LIGHTING);
	float PathColor[3];
	float Color1[3]; Color1[0] = 1.0; Color1[1] = 204.0/256.0; Color1[2] = 51.0/256.0;
	float Color2[3]; Color2[0] = 1.0; Color2[1] = 102.0/256.0; Color2[2] = 51.0/256.0;
	float Color3[3]; Color3[0] = 1.0; Color3[1] = 51.0/256.0;  Color3[2] = 102.0/256.0;
	float Color4[3]; Color4[0] = 204.0/256.0; Color4[1] = 51.0/256.0; Color4[2] = 1.0;

	const float mapdata_z = 0.005;

	for(unsigned int i=0; i&lt;m_ReadyToDrawLanes.size(); i++)
	{
		//PathColor[0]=0.5;PathColor[1] = j/20.0; PathColor[2] = j;
		if(i==0)
		{
			PathColor[0]=0.25 ;PathColor[1] = 0.25; PathColor[2] = 0.25;
		}
		else
		{
			double inc_color = (double)i/25.0;
			PathColor[0]=0.25 + inc_color; ;PathColor[1] = 0.25+inc_color; PathColor[2] = 0.25 + inc_color;
		}

		//PathColor[0]=0.25 ;PathColor[1] = 0.25; PathColor[2] = 0.25;
		if(i%4 == 0)
		{
			PathColor[0] = Color1[0]; PathColor[1] = Color1[1]; PathColor[2] = Color1[2];
		}
		else if(i%4 == 1)
		{
			PathColor[0] = Color2[0]; PathColor[1] = Color2[1]; PathColor[2] = Color2[2];
		}
		else if(i%4 == 2)
		{
			PathColor[0] = Color3[0]; PathColor[1] = Color3[1]; PathColor[2] = Color3[2];
		}
		else if(i%4 == 3)
		{
			PathColor[0] = Color4[0]; PathColor[1] = Color4[1]; PathColor[2] = Color4[2];
		}

		PathColor[0] = PathColor[0]*0.15;
		PathColor[1] = PathColor[1]*0.95;
		PathColor[2] = PathColor[2]*0.95;
		PathColor[0]=0.4;PathColor[1] = 0.4; PathColor[2] = 0.4;
		DrawingHelpers::DrawPrePreparedPolygons(m_ReadyToDrawLanes[i], mapdata_z, PathColor);

		PathColor[0]=0.97;PathColor[1] = 0.97; PathColor[2] = 0.97;
		DrawingHelpers::DrawPrePreparedPolygons(m_ReadyToDrawCenterLines[i], mapdata_z+0.015, PathColor, 1);
	}

	glEnable(GL_LIGHTING);
}

void AlternativeVisualizer::DrawSimu()
{
	//DrawGPSData();
	DrawVectorMap();
	float color[] = {0, 1, 0};
	DrawingHelpers::DrawWidePath(m_GeneratedPath, 0.5, 0.5, color);
}

void AlternativeVisualizer::DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY)
{
}

void AlternativeVisualizer::OnLeftClick(const double&amp; x, const double&amp; y)
{}

void AlternativeVisualizer::OnRightClick(const double&amp; x, const double&amp; y)
{}

void AlternativeVisualizer::OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key)
{
	//std::cout &lt;&lt; &quot;key&quot; &lt;&lt; std::endl;

	switch(key)
	{
	case 's':
		break;
	case 'v':
	{
	}
	break;
	case 'l':
	{
	}
	break;
	case 'n':
	{
	}
	break;
	case 'g':
	{
	}
	break;
	default:
		break;

	}
}

void AlternativeVisualizer::TransToCarCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
{
	PlannerHNS::Mat3 rotationMat(-currPose.pos.a);
	PlannerHNS::Mat3 translationMat(-currPose.pos.x, -currPose.pos.y);
	for(unsigned int i=0; i &lt; obj_list.size(); i++)
	{
		obj_list.at(i).center.pos = translationMat*obj_list.at(i).center.pos;
		obj_list.at(i).center.pos = rotationMat*obj_list.at(i).center.pos;
		for(unsigned int j = 0 ; j &lt; obj_list.at(i).contour.size(); j++)
		{
			obj_list.at(i).contour.at(j) = translationMat*obj_list.at(i).contour.at(j);
			obj_list.at(i).contour.at(j) = rotationMat*obj_list.at(i).contour.at(j);
		}
	}
}

void AlternativeVisualizer::TransToWorldCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
{
	PlannerHNS::Mat3 rotationMat(currPose.pos.a);
	PlannerHNS::Mat3 translationMat(currPose.pos.x, currPose.pos.y);
	for(unsigned int i=0; i &lt; obj_list.size(); i++)
	{
		obj_list.at(i).center.pos = rotationMat*obj_list.at(i).center.pos;
		obj_list.at(i).center.pos = translationMat*obj_list.at(i).center.pos;

		for(unsigned int j = 0 ; j &lt; obj_list.at(i).contour.size(); j++)
		{
			obj_list.at(i).contour.at(j) = translationMat*obj_list.at(i).contour.at(j);
			obj_list.at(i).contour.at(j) = rotationMat*obj_list.at(i).contour.at(j);
		}
	}
}

} /* namespace Graphics */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/CarState.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/CarState.cpp">
				<diff>@@ -367,7 +367,7 @@ double CarState::PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp;
 		path.at(i).timeCost = -1;
 	}
 
-	int startIndex = PlanningHelpers::GetClosestNextPointIndex(path, state);
+	int startIndex = PlanningHelpers::GetClosestNextPointIndexFast(path, state);
 	double total_distance = 0;
 	path.at(startIndex).timeCost = 0;
 	for(unsigned int i=startIndex+1; i&lt;path.size(); i++)
@@ -737,7 +737,7 @@ void CarState::FindNextBestSafeTrajectory(int&amp; safe_index)
 	bool bNewTrajectory = false;
 //	if(m_TotalPath.size()&gt;0)
 //	{
-//		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
+//		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(m_Path, state);
 //		int index_limit = 0;//m_Path.size() - 20;
 //		if(index_limit&lt;=0)
 //			index_limit =  m_Path.size()/2.0;
@@ -825,7 +825,8 @@ void CarState::FindNextBestSafeTrajectory(int&amp; safe_index)
 		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
 	else
 		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
-	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
+	//currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
+	currentBehavior.maxVelocity = 0;
 	currentBehavior.minVelocity		= 0;
 	currentBehavior.stopDistance 	= preCalcPrams-&gt;distanceToStop();
 	currentBehavior.followVelocity 	= preCalcPrams-&gt;velocityOfNext;
@@ -1028,7 +1029,8 @@ PlannerHNS::BehaviorState SimulatedCarState::GenerateBehaviorState(const Planner
 	//    	else
 	//    		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
 
-	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
+	//currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
+	currentBehavior.maxVelocity  = 0;
 	currentBehavior.minVelocity		= 0;
 	currentBehavior.stopDistance 	= 0;
 	currentBehavior.followVelocity 	= 0;
@@ -1041,7 +1043,7 @@ bool SimulatedCarState::SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::Ve
 	PlannerHNS::PlanningParams planningDefaultParams;
 	planningDefaultParams.rollOutNumber = 0;
 
-	int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
+	int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(m_Path, state);
 	int index_limit = 0;//m_Path.size() - 15;
 	if(index_limit&lt;=0)
 		index_limit =  m_Path.size()/2.0;
</diff>
				<old_file>/*
 * CarState.cpp
 *
 *  Created on: Jun 20, 2016
 *      Author: hatem
 */

#include &quot;CarState.h&quot;
#include &quot;UtilityH.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &quot;MappingHelpers.h&quot;
#include &quot;MatrixOperations.h&quot;
#include &quot;PlannerH.h&quot;
#include &quot;SimulatedTrajectoryFollower.h&quot;


using namespace PlannerHNS;
using namespace UtilityHNS;

namespace SimulationNS
{

CarState::CarState()
{
	pLane = 0;
	m_CurrentVelocity =  m_CurrentVelocityD =0;
	m_CurrentSteering = m_CurrentSteeringD =0;
	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
	m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
	m_pCurrentBehaviorState = 0;
	m_pGoToGoalState = 0;
	m_pStopState= 0;
	m_pWaitState= 0;
	m_pMissionCompleteState= 0;
	m_pAvoidObstacleState = 0;
	m_pTrafficLightStopState = 0;
	m_pTrafficLightWaitState = 0;
	m_pFollowState = 0;
	m_SimulationSteeringDelayFactor = 0.1;
	UtilityH::GetTickCount(m_SteerDelayTimer);
	m_PredictionTime = 0;

	InitBehaviorStates();
}

CarState::~CarState()
{

}

void CarState::Init(const ControllerParams ctrlParams, const PlannerHNS::PlanningParams&amp; params,const CAR_BASIC_INFO&amp; carInfo)
 	{
 		m_CarInfo = carInfo;
 		m_ControlParams = ctrlParams;
 		m_CurrentVelocity =  m_CurrentVelocityD =0;
 		m_CurrentSteering = m_CurrentSteeringD =0;
 		m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
 		m_CurrentAccSteerAngle = m_CurrentAccVelocity = 0;
 		m_Params = params;

 		if(m_pCurrentBehaviorState)
 			m_pCurrentBehaviorState-&gt;SetBehaviorsParams(&amp;m_Params);
 	}

void CarState::InitBehaviorStates()
{

	m_pStopState 				= new StopState(0, 0, 0);
	m_pMissionCompleteState 	= new MissionAccomplishedState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), 0);
	m_pGoToGoalState 			= new ForwardState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pMissionCompleteState);
	m_pWaitState 				= new WaitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pInitState 				= new InitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pFollowState				= new FollowState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pAvoidObstacleState		= new SwerveState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pTrafficLightStopState	= new TrafficLightStopState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);
	m_pTrafficLightWaitState	= new TrafficLightWaitState(m_pStopState-&gt;m_pParams, m_pStopState-&gt;GetCalcParams(), m_pGoToGoalState);


	m_pGoToGoalState-&gt;InsertNextState(m_pStopState);
	m_pGoToGoalState-&gt;InsertNextState(m_pWaitState);
	m_pGoToGoalState-&gt;InsertNextState(m_pFollowState);
	m_pGoToGoalState-&gt;InsertNextState(m_pAvoidObstacleState);
	m_pGoToGoalState-&gt;InsertNextState(m_pTrafficLightStopState);

	m_pAvoidObstacleState-&gt;InsertNextState(m_pStopState);
	m_pAvoidObstacleState-&gt;InsertNextState(m_pWaitState);
	m_pAvoidObstacleState-&gt;InsertNextState(m_pFollowState);
	m_pAvoidObstacleState-&gt;decisionMakingTime = 0.0;
	m_pAvoidObstacleState-&gt;InsertNextState(m_pTrafficLightStopState);

	m_pFollowState-&gt;InsertNextState(m_pStopState);
	m_pFollowState-&gt;InsertNextState(m_pWaitState);
	m_pFollowState-&gt;InsertNextState(m_pAvoidObstacleState);
	m_pFollowState-&gt;InsertNextState(m_pTrafficLightStopState);

	m_pStopState-&gt;InsertNextState(m_pGoToGoalState);

	m_pTrafficLightStopState-&gt;InsertNextState(m_pTrafficLightWaitState);

	m_pTrafficLightWaitState-&gt;InsertNextState(m_pTrafficLightStopState);


	m_pCurrentBehaviorState = m_pInitState;

}

void CarState::InitPolygons()
{
	double l2 = m_CarInfo.length/2.0;
	double w2 = m_CarInfo.width/2.0;

	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 0,0));
	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 0,0));
	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 0,0));
	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 0,0));

//	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 1,0));
//	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 1,0));
//	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 1,0));
//	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 1,0));
}

 void CarState::FirstLocalizeMe(const WayPoint&amp; initCarPos)
 {
	pLane = initCarPos.pLane;
	state = initCarPos;
	m_OdometryState.pos.a = initCarPos.pos.a;
	m_OdometryState.pos.x = initCarPos.pos.x + (m_CarInfo.wheel_base/2.0 * cos(initCarPos.pos.a));
	m_OdometryState.pos.y = initCarPos.pos.y + (m_CarInfo.wheel_base/2.0 * sin(initCarPos.pos.a));
 }

 void CarState::LocalizeMe(const double&amp; dt)
{
	//calculate the new x, y ,
	 WayPoint currPose = state;

	if(m_CurrentShift == SHIFT_POS_DD)
	{
		m_OdometryState.pos.x	 +=  m_CurrentVelocity * dt * cos(currPose.pos.a);
		m_OdometryState.pos.y	 +=  m_CurrentVelocity * dt * sin(currPose.pos.a);
		m_OdometryState.pos.a	 +=  m_CurrentVelocity * dt * tan(m_CurrentSteering)  / m_CarInfo.wheel_base;

	}
	else if(m_CurrentShift == SHIFT_POS_RR )
	{
		m_OdometryState.pos.x	 +=  -m_CurrentVelocity * dt * cos(currPose.pos.a);
		m_OdometryState.pos.y	 +=  -m_CurrentVelocity * dt * sin(currPose.pos.a);
		m_OdometryState.pos.a	 +=  -m_CurrentVelocity * dt * tan(m_CurrentSteering);
	}

	m_OdometryState.pos.a = atan2(sin(m_OdometryState.pos.a), cos(m_OdometryState.pos.a));
	m_OdometryState.pos.a = UtilityH::FixNegativeAngle(m_OdometryState.pos.a);

	state.pos.a = m_OdometryState.pos.a;
	state.pos.x = m_OdometryState.pos.x	 - (m_CurrentVelocity*dt* (m_CarInfo.wheel_base) * cos (m_OdometryState.pos.a));
	state.pos.y = m_OdometryState.pos.y	 - (m_CurrentVelocity*dt* (m_CarInfo.wheel_base/2.0) * sin (m_OdometryState.pos.a));
}

 void CarState::UpdateState(const PlannerHNS::VehicleState&amp; state, const bool&amp; bUseDelay)
  {
	 if(!bUseDelay)
	 {
		 m_CurrentSteering 	= m_CurrentSteeringD;
		 std::cout &lt;&lt; &quot; No Delay &quot; &lt;&lt; std::endl;
	 }
	 else
	 {
		 double currSteerDeg = RAD2DEG * m_CurrentSteering;
		 double desiredSteerDeg = RAD2DEG * m_CurrentSteeringD;

		 double mFact = UtilityH::GetMomentumScaleFactor(state.speed);
		 double diff = desiredSteerDeg - currSteerDeg;
		 double diffSign = UtilityH::GetSign(diff);
		 double inc = 1.0*diffSign;
		 if(abs(diff) &lt; 1.0 )
			 inc = diff;

		 std::cout &lt;&lt; &quot;Delay: &quot; &lt;&lt; m_SimulationSteeringDelayFactor
				 &lt;&lt; &quot;, Fact: &quot; &lt;&lt; mFact
				 &lt;&lt; &quot;, Diff: &quot; &lt;&lt; diff
				 &lt;&lt; &quot;, inc: &quot; &lt;&lt; inc &lt;&lt; std::endl;
		 if(UtilityH::GetTimeDiffNow(m_SteerDelayTimer) &gt; m_SimulationSteeringDelayFactor*mFact)
		 {
			 UtilityH::GetTickCount(m_SteerDelayTimer);
			 currSteerDeg += inc;
		 }

		 m_CurrentSteering = DEG2RAD * currSteerDeg;
	 }

	 m_CurrentShift 	= m_CurrentShiftD;
	 m_CurrentVelocity = m_CurrentVelocityD;
  }

 void CarState::AddAndTransformContourPoints(const PlannerHNS::DetectedObject&amp; obj, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; contourPoints)
 {
	 contourPoints.clear();
	 WayPoint  p, p_center = obj.center;
	 p_center.pos.a += M_PI_2;
	 for(unsigned int i=0; i&lt; obj.contour.size(); i++)
	 {
		 p.pos = obj.contour.at(i);
		 //TransformPoint(p_center, p.pos);
		 contourPoints.push_back(p);
	 }

	 contourPoints.push_back(obj.center);
 }

 void CarState::TransformPoint(const PlannerHNS::WayPoint&amp; refPose, PlannerHNS::GPSPoint&amp; p)
 {
 	PlannerHNS::Mat3 rotationMat(refPose.pos.a);
 	PlannerHNS::Mat3 translationMat(refPose.pos.x, refPose.pos.y);
	p = rotationMat*p;
	p = translationMat*p;
 }

 bool CarState::GetNextTrafficLight(const int&amp; prevTrafficLightId, const std::vector&lt;PlannerHNS::TrafficLight&gt;&amp; trafficLights, PlannerHNS::TrafficLight&amp; trafficL)
 {
	 for(unsigned int i = 0; i &lt; trafficLights.size(); i++)
	 {
		 double d = hypot(trafficLights.at(i).pos.y - state.pos.y, trafficLights.at(i).pos.x - state.pos.x);
		 if(d &lt;= trafficLights.at(i).stoppingDistance)
		 {
			 //double a = UtilityH::FixNegativeAngle(atan2(trafficLights.at(i).pos.y - state.pos.y, trafficLights.at(i).pos.x - state.pos.x));
			 double a_diff = UtilityH::AngleBetweenTwoAnglesPositive(UtilityH::FixNegativeAngle(trafficLights.at(i).pos.a) , UtilityH::FixNegativeAngle(state.pos.a));

			 if(a_diff &lt; M_PI_2 &amp;&amp; trafficLights.at(i).id != prevTrafficLightId)
			 {
				 std::cout &lt;&lt; &quot;Detected Light, ID = &quot; &lt;&lt; trafficLights.at(i).id &lt;&lt; &quot;, Distance = &quot; &lt;&lt; d &lt;&lt; &quot;, Angle = &quot; &lt;&lt; trafficLights.at(i).pos.a*RAD2DEG &lt;&lt; &quot;, Car Heading = &quot; &lt;&lt; state.pos.a*RAD2DEG &lt;&lt; &quot;, Diff = &quot; &lt;&lt; a_diff*RAD2DEG &lt;&lt; std::endl;
				 trafficL = trafficLights.at(i);
				 return true;
			 }
		 }
	 }

	 return false;
 }

 void CarState::CalculateImportantParameterForDecisionMaking(const PlannerHNS::VehicleState&amp; car_state,
		 const PlannerHNS::GPSPoint&amp; goal,
			const bool&amp; bEmergencyStop,
			const bool&amp; bGreenTrafficLight)
 {
 	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();

 	//Mission Complete
 	//pValues-&gt;bGoalReached = IsGoalAchieved(goal);
 	pValues-&gt;minStoppingDistance	= car_state.speed * 3.6 * 1.5;
 	if(pValues-&gt;distanceToNext &gt; 0 || pValues-&gt;distanceToStop()&gt;0)
 		pValues-&gt;minStoppingDistance += 1.0;
 	pValues-&gt;iCentralTrajectory		= m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber/2;
 	pValues-&gt;stoppingDistances.clear();
 	pValues-&gt;currentVelocity 		= car_state.speed;
 	pValues-&gt;bTrafficIsRed 			= false;
 	pValues-&gt;currentTrafficLightID 	= -1;
 	pValues-&gt;bRePlan 				= false;
 	pValues-&gt;bFullyBlock 			= false;

 	FindSafeTrajectory(pValues-&gt;iCurrSafeTrajectory, pValues-&gt;distanceToNext, pValues-&gt;velocityOfNext);
 	if((pValues-&gt;iCurrSafeTrajectory == -1 &amp;&amp; pValues-&gt;distanceToNext &lt; m_pCurrentBehaviorState-&gt;m_pParams-&gt;minFollowingDistance) || bEmergencyStop )
 		pValues-&gt;bFullyBlock = true;


 	TrafficLight tl;

 	if(GetNextTrafficLight(pValues-&gt;prevTrafficLightID, m_TrafficLights, tl))
 	{
 		pValues-&gt;currentTrafficLightID = tl.id;

 	}

 	pValues-&gt;bTrafficIsRed = !bGreenTrafficLight;

 	//cout &lt;&lt; &quot;Distances: &quot; &lt;&lt; pValues-&gt;stoppingDistances.size() &lt;&lt; &quot;, Distance To Stop : &quot; &lt;&lt; pValues-&gt;distanceToStop &lt;&lt; endl;
 }

void CarState::InitializeTrajectoryCosts()
{
	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;
	int centralIndex = pParams-&gt;rollOutNumber/2;
	std::vector&lt;double&gt; end_distance_list;

	m_TrajectoryCosts.clear();

	//double totalCost = 1.0 / (double)pParams-&gt;rollOutNumber;
	double totalDistance = 0;
	for(int i=0; i&lt; pParams-&gt;rollOutNumber+1; i++)
	{
		PlannerHNS::TrajectoryCost tc;
		tc.index = i;
		tc.relative_index = i - centralIndex;
		tc.distance_from_center = pParams-&gt;rollOutDensity*tc.relative_index;
		tc.priority_cost = fabs(tc.distance_from_center);
		totalDistance += tc.priority_cost;
		m_TrajectoryCosts.push_back(tc);
	}

	if(totalDistance==0) return ;

	//Normalize cost
	for(unsigned int i = 0; i&lt; m_TrajectoryCosts.size(); i++)
	{
		m_TrajectoryCosts.at(i).priority_cost = m_TrajectoryCosts.at(i).priority_cost/totalDistance;
	}
}

void CarState::CalculateTransitionCosts()
{
	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();
	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;

	double totalDistance = 0;
	//pValues-&gt;iCurrSafeTrajectory = 4;
	if(pValues-&gt;iCentralTrajectory &lt; 0)
		pValues-&gt;iCentralTrajectory = pParams-&gt;rollOutNumber / 2;

	if(pValues-&gt;iCurrSafeTrajectory &lt; 0)
		pValues-&gt;iCurrSafeTrajectory = pValues-&gt;iCentralTrajectory;

	if(pValues-&gt;iPrevSafeTrajectory &lt; 0)
		pValues-&gt;iPrevSafeTrajectory = pValues-&gt;iCentralTrajectory;

	for(unsigned int i = 0; i&lt; m_TrajectoryCosts.size(); i++)
	{
		m_TrajectoryCosts.at(i).transition_cost = fabs(pParams-&gt;rollOutDensity* (m_TrajectoryCosts.at(i).index - pValues-&gt;iCurrSafeTrajectory));
		totalDistance += m_TrajectoryCosts.at(i).transition_cost;
	}

	if(totalDistance==0) return ;

	//Normalize cost
	for(unsigned int i = 0; i&lt; m_TrajectoryCosts.size(); i++)
	{
		m_TrajectoryCosts.at(i).transition_cost = m_TrajectoryCosts.at(i).transition_cost/totalDistance;
	}
}

double CarState::PredictTimeCostForTrajectory(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::VehicleState&amp; vstatus, const PlannerHNS::WayPoint&amp; currState)
{
	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;

		//1- Calculate time prediction for each trajectory
	if(path.size() == 0) return 0;

	SimulationNS::SimulatedTrajectoryFollower predControl;
	ControllerParams params;
	params.Steering_Gain = PID_CONST(1.5, 0.0, 0.0);
	params.Velocity_Gain = PID_CONST(0.2, 0.01, 0.1);
	params.minPursuiteDistance = 3.0;

	predControl.Init(params, m_CarInfo);
	//double totalDistance = 0;
	VehicleState CurrentState = vstatus;
	VehicleState CurrentSteeringD;
	bool bNewPath = true;
	WayPoint localState = currState;
	WayPoint prevState = currState;
	int iPrevIndex = 0;
	double accum_time = 0;
	double pred_max_time = 10.0;
	double endDistance = pParams-&gt;microPlanDistance/2.0;

	for(unsigned int i = 0 ; i &lt; path.size(); i++)
	{
		path.at(i).collisionCost = 0;
		path.at(i).timeCost = -1;
	}

	int startIndex = PlanningHelpers::GetClosestNextPointIndex(path, state);
	double total_distance = 0;
	path.at(startIndex).timeCost = 0;
	for(unsigned int i=startIndex+1; i&lt;path.size(); i++)
	{
		total_distance += hypot(path.at(i).pos.x- path.at(i-1).pos.x,path.at(i).pos.y- path.at(i-1).pos.y);
		if(m_CurrentVelocity &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
			accum_time = total_distance/m_CurrentVelocity;
		path.at(i).timeCost = accum_time;
		if(total_distance &gt; endDistance)
			break;
	}

//	while(totalDistance &lt; pParams-&gt;microPlanDistance/2.0 &amp;&amp; accum_time &lt; pred_max_time)
//	{
//		double dt = 0.05;
//		PlannerHNS::BehaviorState currMessage;
//		currMessage.state = FORWARD_STATE;
//		currMessage.maxVelocity = PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*CurrentState.speed*3.6);
//
//		SimulationNS::ControllerParams c_params = m_ControlParams;
//		c_params.SteeringDelay = m_ControlParams.SteeringDelay / (1.0-UtilityH::GetMomentumScaleFactor(CurrentState.speed));
//		predControl.Init(c_params, m_CarInfo);
//		CurrentSteeringD = predControl.DoOneStep(dt, currMessage, path, localState, CurrentState, bNewPath);
//
//		if(bNewPath) // first call
//		{
//			if(predControl.m_iCalculatedIndex &gt; 0)
//			{
//				for(unsigned int j=0; j &lt; predControl.m_iCalculatedIndex; j++)
//					path.at(j).timeCost = -1;
//			}
//		}
//		else
//		{
//			if(predControl.m_iCalculatedIndex != iPrevIndex)
//				path.at(iPrevIndex).timeCost = accum_time;
//		}
//
//		accum_time+=dt;
//		bNewPath = false;
//
//		//Update State
//		CurrentState = CurrentSteeringD;
//
//		//Localize Me
//		localState.pos.x	 +=  CurrentState.speed * dt * cos(localState.pos.a);
//		localState.pos.y	 +=  CurrentState.speed * dt * sin(localState.pos.a);
//		localState.pos.a	 +=  CurrentState.speed * dt * tan(CurrentState.steer)  / m_CarInfo.wheel_base;
//
//		totalDistance += distance2points(prevState.pos, localState.pos);
//
//		prevState = localState;
//		iPrevIndex = predControl.m_iCalculatedIndex;
//	}

	return accum_time;
}

void CarState::PredictObstacleTrajectory(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::WayPoint&amp; pos, const double&amp; predTime, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths)
{
	PlannerHNS::PlanningParams planningDefaultParams;
	planningDefaultParams.rollOutNumber = 0;
	planningDefaultParams.microPlanDistance = predTime*pos.v;

	planningDefaultParams.pathDensity = 0.5;
	//PlannerHNS::Lane* pMapLane  = MappingHelpers::GetClosestLaneFromMapDirectionBased(pos, map, 3.0);
	std::vector&lt;PlannerHNS::Lane*&gt; pMapLanes = MappingHelpers::GetClosestMultipleLanesFromMap(pos, map, 1.5);

	PlannerHNS::PlannerH planner;
	std::vector&lt;int&gt; LanesIds;
	std::vector&lt; std::vector&lt;PlannerHNS::WayPoint&gt; &gt;  rollOuts;
	std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedPath;

	if(planningDefaultParams.microPlanDistance &gt; 0)
	{
		for(unsigned int i = 0; i &lt; pMapLanes.size(); i++)
		{
			std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; loca_generatedPath;
			planner.PredictPlanUsingDP(pMapLanes.at(i), pos, planningDefaultParams.microPlanDistance, loca_generatedPath);
			if(loca_generatedPath.size() &gt; 0)
				generatedPath.insert(generatedPath.begin(),loca_generatedPath.begin(), loca_generatedPath.end());
		}
	}

//	planner.GenerateRunoffTrajectory(generatedPath, pos,
//			planningDefaultParams.enableLaneChange,
//			pos.v,
//			planningDefaultParams.microPlanDistance,
//			m_CarInfo.max_speed_forward,
//			planningDefaultParams.minSpeed,
//			planningDefaultParams.carTipMargin,
//			planningDefaultParams.rollInMargin,
//			planningDefaultParams.rollInSpeedFactor,
//			planningDefaultParams.pathDensity,
//			planningDefaultParams.rollOutDensity,
//			planningDefaultParams.rollOutNumber,
//			planningDefaultParams.smoothingDataWeight,
//			planningDefaultParams.smoothingSmoothWeight,
//			planningDefaultParams.smoothingToleranceError,
//			planningDefaultParams.speedProfileFactor,
//			planningDefaultParams.enableHeadingSmoothing,
//			rollOuts);

	if(generatedPath.size() &gt; 0)
	{
		//path = rollOuts.at(0);
		paths = generatedPath;

//		PlanningHelpers::GenerateRecommendedSpeed(path,
//				m_CarInfo.max_speed_forward,
//				planningDefaultParams.speedProfileFactor);
//		PlanningHelpers::SmoothSpeedProfiles(path, 0.15,0.35, 0.1);
	}

	if(pMapLanes.size() ==0 || paths.size() == 0)
	{
		paths.clear();
		generatedPath.clear();
	}
	else
	{
		//std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
		//std::cout &lt;&lt; &quot;Predicted Trajectories for Distance : &quot; &lt;&lt;  planningDefaultParams.microPlanDistance &lt;&lt; std::endl;
		for(unsigned int j=0; j &lt; paths.size(); j++)
		{
			if(paths.at(j).size()==0)
				continue;

			double timeDelay = 0;
			double total_distance = 0;
			paths.at(j).at(0).timeCost = 0;
			paths.at(j).at(0).v = pos.v;
			for(unsigned int i=1; i&lt;paths.at(j).size(); i++)
			{
				paths.at(j).at(i).v = pos.v;
				paths.at(j).at(i).pos.a = atan2(paths.at(j).at(i).pos.y - paths.at(j).at(i-1).pos.y, paths.at(j).at(i).pos.x - paths.at(j).at(i-1).pos.x);
				total_distance += distance2points(paths.at(j).at(i).pos, paths.at(j).at(i-1).pos);
				if(pos.v &gt; 0.1 &amp;&amp; total_distance &gt; 0.1)
					timeDelay = total_distance/pos.v;
				paths.at(j).at(i).timeCost = timeDelay;
			}

			//std::cout &lt;&lt; &quot;ID : &quot; &lt;&lt;  j &lt;&lt; &quot;, timeDelay : &quot; &lt;&lt; timeDelay &lt;&lt; &quot;, Distance : &quot; &lt;&lt; total_distance &lt;&lt; std::endl;
		}

		//std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
	}
}

bool CarState::CalculateIntersectionVelocities(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; ego_path, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; predctedPath, const PlannerHNS::DetectedObject&amp; obj)
{
	bool bCollisionDetected = false;
	for(unsigned int k = 0; k &lt; predctedPath.size(); k++)
	{
		for(unsigned int j = 0; j &lt; predctedPath.at(k).size(); j++)
		{
			bool bCollisionFound =false;
			for(unsigned int i = 0; i &lt; ego_path.size(); i++)
			{
				if(ego_path.at(i).timeCost &gt; 0.0)
				{
					double collision_distance = hypot(ego_path.at(i).pos.x-predctedPath.at(k).at(j).pos.x, ego_path.at(i).pos.y-predctedPath.at(k).at(j).pos.y);
					double contact_distance = hypot(state.pos.x - ego_path.at(i).pos.x,state.pos.y - ego_path.at(i).pos.y);
					if(collision_distance &lt;= m_CarInfo.width  &amp;&amp; abs(ego_path.at(i).timeCost - predctedPath.at(k).at(j).timeCost)&lt;4.0)
					{
						ego_path.at(i).collisionCost = 1;
						double a = UtilityH::AngleBetweenTwoAnglesPositive(ego_path.at(i).pos.a, predctedPath.at(k).at(j).pos.a);
						if(a &lt; M_PI_4/2.0)
							ego_path.at(i).v = obj.center.v;
						else
							ego_path.at(i).v = 0;
						predctedPath.at(k).at(j).collisionCost = 1;
						bCollisionFound = true;
						bCollisionDetected = true;
						break;
					}
				}
			}

			if(bCollisionFound)
				break;
		}
	}

	return bCollisionDetected;
}

bool CarState::CalculateObstacleCosts(PlannerHNS::RoadNetwork&amp; map, const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
{
	double predTime = PredictTimeCostForTrajectory(m_Path, vstatus, state);
	m_PredictedPath.clear();
	bool bObstacleDetected = false;
	for(unsigned int i = 0; i &lt; obj_list.size(); i++)
	{
		//std::vector&lt;WayPoint&gt; predPath;
		PredictObstacleTrajectory(map, obj_list.at(i).center, 10.0, m_PredictedPath);
		bool bObstacle = CalculateIntersectionVelocities(m_Path, m_PredictedPath, obj_list.at(i));
		if(bObstacle)
			bObstacleDetected = true;
	}

	return bObstacleDetected;
}

//void CarState::CalculateDistanceCosts(const PlannerHNS::VehicleState&amp; vstatus, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
//{
//	PlanningParams* pParams = &amp;m_pCurrentBehaviorState-&gt;m_PlanningParams;
//	double critical_lateral_distance = pParams-&gt;rollOutDensity + m_CarInfo.width/2.0;
//
//	if(m_TotalPath.size()==0) return;
//
//	//First Filtering
//	int iEgoIndex = PlanningHelpers::GetClosestPointIndex(m_TotalPath, state);
//	for(unsigned int i = 0 ; i &lt; obj_list.size(); i++)
//	{
//		std::vector&lt;WayPoint&gt; contourPoints;
//		AddAndTransformContourPoints(obj_list.at(i), contourPoints);
//
//		double distance_direct_smallest = 9999999;
//		double distance_on_trajectory_smallest = 9999999;
//		for(unsigned int j = 0; j &lt; contourPoints.size(); j++)
//		{
//			double distance_direct = distance2points(state.pos, contourPoints.at(j).pos);
//			if(distance_direct &lt; distance_direct_smallest)
//				distance_direct_smallest = distance_direct;
//
//			double distance_on_trajectory  = PlanningHelpers::GetDistanceOnTrajectory(m_TotalPath, iEgoIndex, contourPoints.at(j)) - m_CarInfo.length/2.0;
//			if(distance_on_trajectory &gt; 0 &amp;&amp; distance_on_trajectory &lt; distance_on_trajectory_smallest)
//				distance_on_trajectory_smallest = distance_on_trajectory;
//		}
//
//		for(unsigned int j = 0; j &lt; contourPoints.size(); j++)
//		{
//			PlannerHNS::WayPoint wp;
//			wp = contourPoints.at(j);
//
//			double distance_lateral = PlanningHelpers::GetPerpDistanceToTrajectorySimple(m_TotalPath, wp, iEgoIndex);
//
////			if(distance_direct &gt; pParams-&gt;horizonDistance)
////				continue;
//
//			for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
//			{
//				double normalized_cost = 1.0 - (distance_on_trajectory_smallest / pParams-&gt;minFollowingDistance);
//				double d_diff = fabs(distance_lateral - m_TrajectoryCosts.at(c).distance_from_center);
//				m_TrajectoryCosts.at(c).lateral_costs.push_back(std::make_pair(j,d_diff));
//
//				if(d_diff &lt; critical_lateral_distance &amp;&amp; (distance_on_trajectory_smallest &lt; m_TrajectoryCosts.at(c).closest_obj_distance || m_TrajectoryCosts.at(c).closest_obj_distance &lt;= 0))
//				{
//					//if(normalized_cost &gt; m_TrajectoryCosts.at(c).closest_obj_cost)
//					{
//						m_TrajectoryCosts.at(c).closest_obj_cost = normalized_cost;
//						m_TrajectoryCosts.at(c).closest_obj_distance = distance_on_trajectory_smallest;
//						m_TrajectoryCosts.at(c).closest_obj_velocity = obj_list.at(i).center.v;
//
//					}
//				}
//			}
//		}
//	}
//}

void  CarState::FindSafeTrajectory(int&amp; safe_index, double&amp; closest_distance, double&amp; closest_velocity)
{
	PlanningParams* pParams = m_pCurrentBehaviorState-&gt;m_pParams;

	//if the  closest_obj_cost is less than 0.9 (12 meter) consider this trajectory blocked
	closest_distance = pParams-&gt;horizonDistance;
//	std::cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; std::endl;
//	std::cout &lt;&lt; &quot;&gt;&gt; Costs: &quot; &lt;&lt; std::endl;
	for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
	{
//		std::cout &lt;&lt; m_TrajectoryCosts.at(c).ToString() &lt;&lt; std::endl;

		if(m_TrajectoryCosts.at(c).closest_obj_cost &gt;= 0.6)
			m_TrajectoryCosts.at(c).cost = 1;
		else
			m_TrajectoryCosts.at(c).cost =
					(m_TrajectoryCosts.at(c).closest_obj_cost +
					m_TrajectoryCosts.at(c).priority_cost +
					m_TrajectoryCosts.at(c).transition_cost)/3.0;

		if(m_TrajectoryCosts.at(c).closest_obj_distance &gt; 0 &amp;&amp; m_TrajectoryCosts.at(c).closest_obj_distance &lt; closest_distance)
		{
			closest_distance = m_TrajectoryCosts.at(c).closest_obj_distance;
			closest_velocity = m_TrajectoryCosts.at(c).closest_obj_velocity;
		}
	}

	int smallestIndex = -1;
	double smallestCost = 1;
	for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
	{
		if(m_TrajectoryCosts.at(c).cost &lt; smallestCost)
		{
			smallestCost = m_TrajectoryCosts.at(c).cost;
			smallestIndex = c;
		}
	}

	safe_index = smallestIndex;

//	std::cout &lt;&lt; &quot;Selected Trajectory: &quot; &lt;&lt; safe_index &lt;&lt; &quot;, Closest Distance: &quot; &lt;&lt; closest_distance &lt;&lt; std::endl;
//	std::cout &lt;&lt; &quot;----------------------------------------------------&quot; &lt;&lt; std::endl;
}

void CarState::FindNextBestSafeTrajectory(int&amp; safe_index)
{
	PreCalculatedConditions* pValues = m_pCurrentBehaviorState-&gt;GetCalcParams();
	for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
	{
		m_TrajectoryCosts.at(c).cost =
				(m_TrajectoryCosts.at(c).priority_cost +
				m_TrajectoryCosts.at(c).transition_cost)/2.0;
	}

	int smallestIndex = pValues-&gt;iCentralTrajectory;
	double smallestCost = 1;
	for(unsigned int c = 0; c &lt; m_TrajectoryCosts.size(); c++)
	{
		if(m_TrajectoryCosts.at(c).cost &lt; smallestCost)
		{
			smallestCost = m_TrajectoryCosts.at(c).cost;
			smallestIndex = c;
		}
	}

	safe_index = smallestIndex;
}

 void CarState::UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance)
 {
	 PlannerHNS::Lane* pMapLane = 0;
	PlannerHNS::Lane* pPathLane = 0;
	pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
	if(!pPathLane)
		pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, search_distance);

	if(pPathLane)
		pLane = pPathLane;
	else if(pMapLane)
		pLane = pMapLane;
	else
		pLane = 0;
 }

 void CarState::SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState)
 {
	SetSimulatedTargetOdometryReadings(vehicleState.speed, vehicleState.steer, vehicleState.shift);
	UpdateState(vehicleState, true);
	LocalizeMe(dt);
 }

 bool CarState::IsGoalAchieved(const PlannerHNS::GPSPoint&amp; goal)
 {
	double distance_to_goal = distance2points(state.pos , goal);
	if(distance_to_goal &lt; 1.5)
		return true;
	else
		return false;
 }

 bool CarState::SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState)
 {
	 PlannerHNS::PreCalculatedConditions *preCalcPrams = m_pCurrentBehaviorState-&gt;GetCalcParams();

	bool bNewTrajectory = false;
//	if(m_TotalPath.size()&gt;0)
//	{
//		int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
//		int index_limit = 0;//m_Path.size() - 20;
//		if(index_limit&lt;=0)
//			index_limit =  m_Path.size()/2.0;
//		if(m_RollOuts.size() == 0
//				|| currIndex &gt; index_limit
//				|| m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan
//				|| m_pCurrentBehaviorState-&gt;m_Behavior == OBSTACLE_AVOIDANCE_STATE)
//		{
//			PlannerHNS::PlannerH planner;
//			std::vector&lt;PlannerHNS::WayPoint&gt; tempSec, tempSampledPoints;
//
//			planner.GenerateRunoffTrajectory(m_TotalPath, state,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableLaneChange,
//					vehicleState.speed,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;microPlanDistance,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;minSpeed,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;carTipMargin,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollInMargin,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollInSpeedFactor,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;pathDensity,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutDensity,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingDataWeight,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingSmoothWeight,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;smoothingToleranceError,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;enableHeadingSmoothing,
//					m_RollOuts,tempSec, tempSampledPoints);
//
//			m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = false;
//
//			//FindNextBestSafeTrajectory(pValues-&gt;iCurrSafeTrajectory);
//			if(preCalcPrams-&gt;iCurrSafeTrajectory &gt;= 0
//					&amp;&amp; preCalcPrams-&gt;iCurrSafeTrajectory &lt; m_RollOuts.size()
//					&amp;&amp; m_pCurrentBehaviorState-&gt;m_Behavior == OBSTACLE_AVOIDANCE_STATE)
//			{
//				preCalcPrams-&gt;iPrevSafeTrajectory = preCalcPrams-&gt;iCurrSafeTrajectory;
//				m_Path = m_RollOuts.at(preCalcPrams-&gt;iCurrSafeTrajectory);
//				bNewTrajectory = true;
//			}
//			else
//			{
//				preCalcPrams-&gt;iPrevSafeTrajectory = preCalcPrams-&gt;iCentralTrajectory;
//				m_Path = m_RollOuts.at(preCalcPrams-&gt;iCentralTrajectory);
//				bNewTrajectory = true;
//			}
//
//			PlanningHelpers::GenerateRecommendedSpeed(m_Path,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;maxSpeed,
//					m_pCurrentBehaviorState-&gt;m_pParams-&gt;speedProfileFactor);
//			PlanningHelpers::SmoothSpeedProfiles(m_Path, 0.15,0.35, 0.1);
//			std::ostringstream str_out;
//			str_out &lt;&lt; UtilityH::GetHomeDirectory();
//			str_out &lt;&lt; DataRW::LoggingMainfolderName;
//			str_out &lt;&lt; DataRW::PathLogFolderName;
//			str_out &lt;&lt; &quot;_&quot;;
//			PlanningHelpers::WritePathToFile(str_out.str(), m_Path);
////			}
////			else if(m_RollOuts.size() &gt; 0)
////				std::cout &lt;&lt; &quot;Error .. Error .. Slected Trajectory is out of range !! ( &quot; &lt;&lt; preCalcPrams-&gt;iCurrSafeTrajectory &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
//
//		}
//	}

	return bNewTrajectory;
 }

 PlannerHNS::BehaviorState CarState::GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState)
 {
	PlannerHNS::PreCalculatedConditions *preCalcPrams = m_pCurrentBehaviorState-&gt;GetCalcParams();

	m_pCurrentBehaviorState = m_pCurrentBehaviorState-&gt;GetNextState();
	PlannerHNS::BehaviorState currentBehavior;

	currentBehavior.state = m_pCurrentBehaviorState-&gt;m_Behavior;
	if(currentBehavior.state == PlannerHNS::FOLLOW_STATE)
		currentBehavior.followDistance = preCalcPrams-&gt;distanceToNext;
	else
		currentBehavior.followDistance = 0;

	if(preCalcPrams-&gt;bUpcomingRight)
		currentBehavior.indicator = PlannerHNS::INDICATOR_RIGHT;
	else if(preCalcPrams-&gt;bUpcomingLeft)
		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
	else
		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;
	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, vehicleState.speed*3.6);
	currentBehavior.minVelocity		= 0;
	currentBehavior.stopDistance 	= preCalcPrams-&gt;distanceToStop();
	currentBehavior.followVelocity 	= preCalcPrams-&gt;velocityOfNext;

	return currentBehavior;
 }

// PlannerHNS::BehaviorState CarState::DoOneStep(const double&amp; dt,
//		 const PlannerHNS::VehicleState&amp; vehicleState,
//		 const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
//		 const PlannerHNS::GPSPoint&amp; goal, PlannerHNS::RoadNetwork&amp; map	,
//		const bool&amp; bEmergencyStop,
//		const bool&amp; bGreenTrafficLight,
//		const bool&amp; bLive)
//{
//	 if(!bLive)
//		 SimulateOdoPosition(dt, vehicleState);
//
//	UpdateCurrentLane(map, 3.0);
//
//	InitializeTrajectoryCosts();
//
//	CalculateTransitionCosts();
//
//	CalculateDistanceCosts(vehicleState, obj_list);
//
//	CalculateImportantParameterForDecisionMaking(vehicleState, goal, bEmergencyStop, bGreenTrafficLight);
//
//	PlannerHNS::BehaviorState beh = GenerateBehaviorState(vehicleState);
//
//	beh.bNewPlan = SelectSafeTrajectoryAndSpeedProfile(vehicleState);
//
//
////	timespec predictionTime;
////	UtilityH::GetTickCount(predictionTime);
//	//if(UtilityH::GetTimeDiffNow(m_PredictionTimer) &gt; 0.5 || beh.bNewPlan)
//	{
//		//CalculateObstacleCosts(map, vehicleState, obj_list);
//		//m_PredictionTime = UtilityH::GetTimeDiffNow(predictionTime);
//	}
//
//
////	bool bCollision = false;
////	int wp_id = -1;
////	for(unsigned int i=0; i &lt; m_Path.size(); i++)
////	{
////		if(m_Path.at(i).collisionCost &gt; 0)
////		{
////			bCollision = true;
////			wp_id = i;
////			beh.maxVelocity = m_Path.at(i).v;//PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
////			break;
////		}
////	}
//
////	std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
////	std::cout &lt;&lt; &quot;Max Velocity = &quot; &lt;&lt; beh.maxVelocity &lt;&lt; &quot;, New Plan : &quot; &lt;&lt; beh.bNewPlan &lt;&lt;  std::endl;
////	std::cout &lt;&lt; &quot;Collision = &quot; &lt;&lt; bCollision &lt;&lt; &quot;, @ WayPoint : &quot; &lt;&lt; wp_id &lt;&lt;  std::endl;
////	std::cout &lt;&lt; &quot;------------------------------------------------&quot; &lt;&lt;  std::endl;
//
//	return beh;
// }


 SimulatedCarState::SimulatedCarState()
 {
 	pLane = 0;
 	m_CurrentVelocity =  m_CurrentVelocityD =0;
 	m_CurrentSteering = m_CurrentSteeringD =0;
 	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
 	bDetected = false;
 }

 SimulatedCarState::~SimulatedCarState()
 {
 }

 void SimulatedCarState::Init(const CAR_BASIC_INFO&amp; carInfo)
{
	m_CarInfo = carInfo;
	m_CurrentVelocity =  m_CurrentVelocityD =0;
	m_CurrentSteering = m_CurrentSteeringD =0;
	m_CurrentShift 		=  m_CurrentShiftD = SHIFT_POS_NN;
}


 void SimulatedCarState::InitPolygons()
 {
 	double l2 = m_CarInfo.length/2.0;
 	double w2 = m_CarInfo.width/2.0;

 	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 0,0));
 	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 0,0));
 	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 0,0));
 	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 0,0));

// 	m_CarShapePolygon.push_back(GPSPoint(-w2, -l2, 1,0));
// 	m_CarShapePolygon.push_back(GPSPoint(w2, -l2, 1,0));
// 	m_CarShapePolygon.push_back(GPSPoint(w2, l2, 1,0));
// 	m_CarShapePolygon.push_back(GPSPoint(-w2, l2, 1,0));
 }

  void SimulatedCarState::FirstLocalizeMe(const WayPoint&amp; initCarPos)
  {
 	pLane = initCarPos.pLane;
 	state = initCarPos;
 	m_OdometryState.pos.a = initCarPos.pos.a;
 	m_OdometryState.pos.x = initCarPos.pos.x;
 	m_OdometryState.pos.y = initCarPos.pos.y;
  }

  void SimulatedCarState::LocalizeMe(const double&amp; dt)
 {
 	//calculate the new x, y ,
 	 WayPoint currPose = state;

 	if(m_CurrentShift == SHIFT_POS_DD)
 	{
 		m_OdometryState.pos.x	 +=  m_CurrentVelocity * dt * cos(currPose.pos.a);
 		m_OdometryState.pos.y	 +=  m_CurrentVelocity * dt * sin(currPose.pos.a);
 		m_OdometryState.pos.a	 +=  m_CurrentVelocity * dt * tan(m_CurrentSteering)  / m_CarInfo.wheel_base;

 	}
 	else if(m_CurrentShift == SHIFT_POS_RR )
 	{
 		m_OdometryState.pos.x	 +=  -m_CurrentVelocity * dt * cos(currPose.pos.a);
 		m_OdometryState.pos.y	 +=  -m_CurrentVelocity * dt * sin(currPose.pos.a);
 		m_OdometryState.pos.a	 +=  -m_CurrentVelocity * dt * tan(m_CurrentSteering);
 	}

 	m_OdometryState.pos.a = atan2(sin(m_OdometryState.pos.a), cos(m_OdometryState.pos.a));
 	m_OdometryState.pos.a = UtilityH::FixNegativeAngle(m_OdometryState.pos.a);

 	state.pos.a = m_OdometryState.pos.a;
 	state.pos.x = m_OdometryState.pos.x;
 	state.pos.y = m_OdometryState.pos.y;
 	state.v = m_CurrentVelocity;

 }

  void SimulatedCarState::UpdateState(const bool&amp; bUseDelay)
   {
 	 m_CurrentSteering 	= m_CurrentSteeringD;
 	 m_CurrentShift 	= m_CurrentShiftD;
 	 m_CurrentVelocity = m_CurrentVelocityD;
   }

  void SimulatedCarState::CalculateImportantParameterForDecisionMaking(const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list,
 		 const PlannerHNS::VehicleState&amp; car_state, const PlannerHNS::GPSPoint&amp; goal, PlannerHNS::RoadNetwork&amp; map)
  {

  	PlannerHNS::Lane* pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
  	PlannerHNS::Lane* pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, 3.0);

  	if(pPathLane)
  		pLane = pPathLane;
  	else if(pMapLane)
  		pLane = pMapLane;
  	else
  		pLane = 0;

  	//cout &lt;&lt; &quot;Distances: &quot; &lt;&lt; pValues-&gt;stoppingDistances.size() &lt;&lt; &quot;, Distance To Stop : &quot; &lt;&lt; pValues-&gt;distanceToStop &lt;&lt; endl;

  }

  void SimulatedCarState::SimulateOdoPosition(const double&amp; dt, const PlannerHNS::VehicleState&amp; vehicleState)
  {
 	SetSimulatedTargetOdometryReadings(vehicleState.speed, vehicleState.steer, vehicleState.shift);
 	UpdateState(false);
 	LocalizeMe(dt);
  }

  void SimulatedCarState::UpdateCurrentLane(PlannerHNS::RoadNetwork&amp; map, const double&amp; search_distance)
  {
	  PlannerHNS::Lane* pMapLane = 0;
 	PlannerHNS::Lane* pPathLane = MappingHelpers::GetLaneFromPath(state, m_Path);
 	if(!pPathLane)
 		pMapLane  = MappingHelpers::GetClosestLaneFromMap(state, map, search_distance);

 	if(pPathLane)
 		pLane = pPathLane;
 	else if(pMapLane)
 		pLane = pMapLane;
 	else
 		pLane = 0;
  }

PlannerHNS::BehaviorState SimulatedCarState::GenerateBehaviorState(const PlannerHNS::VehicleState&amp; vehicleState)
{
	PlannerHNS::BehaviorState currentBehavior;
	currentBehavior.state = PlannerHNS::FORWARD_STATE;

	/**
	 * Use for future simulation of other detecing other cars indicator and act accordingly
	 */
	//    	if(preCalcPrams-&gt;bUpcomingRight)
	//    		currentBehavior.indicator = PlannerHNS::INDICATOR_RIGHT;
	//    	else if(preCalcPrams-&gt;bUpcomingLeft)
	//    		currentBehavior.indicator = PlannerHNS::INDICATOR_LEFT;
	//    	else
	//    		currentBehavior.indicator = PlannerHNS::INDICATOR_NONE;

	currentBehavior.maxVelocity 	= PlannerHNS::PlanningHelpers::GetVelocityAhead(m_Path, state, 1.5*vehicleState.speed*3.6);
	currentBehavior.minVelocity		= 0;
	currentBehavior.stopDistance 	= 0;
	currentBehavior.followVelocity 	= 0;

	return currentBehavior;
}

bool SimulatedCarState::SelectSafeTrajectoryAndSpeedProfile(const PlannerHNS::VehicleState&amp; vehicleState)
{
	PlannerHNS::PlanningParams planningDefaultParams;
	planningDefaultParams.rollOutNumber = 0;

	int currIndex = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_Path, state);
	int index_limit = 0;//m_Path.size() - 15;
	if(index_limit&lt;=0)
		index_limit =  m_Path.size()/2.0;
	if(m_RollOuts.size() == 0 || currIndex &gt; index_limit)
	{
		PlannerHNS::PlannerH planner;
		std::vector&lt;int&gt; LanesIds;

		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedPath;
//		planner.PlanUsingDP(state, PlannerHNS::WayPoint(),
//				150, LanesIds, m_ generatedPath);
//		m_RollOuts.clear();
//		if(generatedPath.size()&gt;0)
//			m_TotalPath = generatedPath.at(0);

		std::vector&lt;PlannerHNS::WayPoint&gt; tempSec, tempSampledPoints;


//		planner.GenerateRunoffTrajectory(generatedPath, state,
//				planningDefaultParams.enableLaneChange,
//				vehicleState.speed,
//				planningDefaultParams.microPlanDistance,
//				m_CarInfo.max_speed_forward,
//				planningDefaultParams.minSpeed,
//				planningDefaultParams.carTipMargin,
//				planningDefaultParams.rollInMargin,
//				planningDefaultParams.rollInSpeedFactor,
//				planningDefaultParams.pathDensity,
//				planningDefaultParams.rollOutDensity,
//				planningDefaultParams.rollOutNumber,
//				planningDefaultParams.smoothingDataWeight,
//				planningDefaultParams.smoothingSmoothWeight,
//				planningDefaultParams.smoothingToleranceError,
//				planningDefaultParams.speedProfileFactor,
//				planningDefaultParams.enableHeadingSmoothing,
//				m_RollOuts, tempSec, tempSampledPoints);

		if(m_RollOuts.size() &gt; 0)
		{
			m_Path = m_RollOuts.at(0);
			PlanningHelpers::GenerateRecommendedSpeed(m_Path,
					m_CarInfo.max_speed_forward,
								planningDefaultParams.speedProfileFactor);
			PlanningHelpers::SmoothSpeedProfiles(m_Path, 0.15,0.35, 0.1);
		}
	}

	if(!pLane || m_TotalPath.size() &lt; 3 || m_Path.size() &lt; 3)
	{
		m_Path.clear();
		m_TotalPath.clear();
		return false;
	}

	return m_Path.size() &gt; 0;
}

  PlannerHNS::BehaviorState SimulatedCarState::DoOneStep(
		  const double&amp; dt,
		  const PlannerHNS::VehicleState&amp; vehicleState,
		  const PlannerHNS::WayPoint&amp; currPose,
		  const PlannerHNS::GPSPoint&amp; goal,
		  PlannerHNS::RoadNetwork&amp; map)
{


	SimulateOdoPosition(dt, vehicleState);

	UpdateCurrentLane(map, 3.0);

	PlannerHNS::BehaviorState beh = GenerateBehaviorState(vehicleState);

	beh.bNewPlan = SelectSafeTrajectoryAndSpeedProfile(vehicleState);

	return beh;
}

} /* namespace SimulationNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/DrawingHelpers.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/DrawingHelpers.cpp">
				<diff>@@ -356,7 +356,7 @@ void DrawingHelpers::DrawWidePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path_
 
 void DrawingHelpers::DrawLinePoygonline(const PlannerHNS::GPSPoint&amp; p1, const PlannerHNS::GPSPoint&amp; p2, const double&amp; w)
 {
-	POINT2D center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
+	GPSPoint center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
 	double a = 0;
 
 	center.x = p1.x + (p2.x-p1.x)/2.0;
@@ -390,7 +390,7 @@ void DrawingHelpers::DrawLinePoygonFromCenterX(const PlannerHNS::WayPoint&amp; p1, c
 		const PlannerHNS::WayPoint&amp; p2, const double&amp; z2, const double&amp; w, const double&amp; h,
 		PlannerHNS::WayPoint&amp; prev_point)
 {
-	POINT2D center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
+	GPSPoint center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
 	double a = 0;
 	double prev_angle = 0;
 
@@ -615,7 +615,7 @@ void DrawingHelpers::DrawSimpleEllipse(float x, float y, float z, float outer_wi
 
 void DrawingHelpers::DrawPedal(float x, float y, float z, float width, float height, float inner_height, float color[3])
 {
-	POINT2D pa, pb, pc, pd;
+	GPSPoint pa, pb, pc, pd;
 	double w2 = width/2.0;
 	double h2 = height/2.0;
 
</diff>
				<old_file>/*
 * DrawingHelpers.cpp
 *
 *  Created on: May 31, 2016
 *      Author: hatem
 */

#include &quot;DrawingHelpers.h&quot;
#include &lt;stdarg.h&gt;
#include &lt;stdio.h&gt;
#include &lt;cmath&gt;
#include &quot;UtilityH.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &lt;GL/freeglut.h&gt;

using namespace std;
using namespace PlannerHNS;
using namespace UtilityHNS;

namespace Graphics
{

DrawingHelpers::DrawingHelpers() {
	// TODO Auto-generated constructor stub

}

DrawingHelpers::~DrawingHelpers() {
	// TODO Auto-generated destructor stub
}

void DrawingHelpers::DrawString(float x, float y, GLvoid* font_style, char* format, ...)
{
	glDisable(GL_LIGHTING);

	va_list args;
	char buffer[1000], *s;

	va_start(args, format);
	vsprintf(buffer, format, args);
	va_end(args);
	//GLuint ox = x;
	GLuint oy = y;

	glRasterPos2f(x, y);
	for (s = buffer; *s; s++)
	{
		if(*s == ',')
		{
			x += 220;
			y = oy;
			glRasterPos2f(x, y);
			continue;
		}
		else if(*s == '\n')
		{
			y+=12;
			glRasterPos2f(x, y);
			continue;
		}

		glutBitmapCharacter(font_style, *s);
	}
	glEnable(GL_LIGHTING);
}

void DrawingHelpers::DrawGrid(const double&amp; x, const double&amp; y, const double&amp; w, const double&amp; h, const double&amp; cell_l)
{
	glPushMatrix();
	int nVerticalLisne   = floor(w/cell_l);
	int nHorizontalLines = floor(h/cell_l);

	glBegin(GL_LINES);
	glColor3ub(210,210,210);
	double incr = y;
	for(int r=0; r&lt;= nHorizontalLines; r++)
	{
		glNormal3f(1.0, 1.0, 1.0);
		glVertex3f(x, incr, 0);
		glVertex3f(x+w, incr, 0);
		incr+=cell_l;
	}

	double incc = x;
	for(int r=0; r&lt;= nVerticalLisne; r++)
	{
		glNormal3f(1.0, 1.0, 1.0);
		glVertex3f(incc, y,  0);
		glVertex3f(incc, y + h, 0);
		incc+=cell_l;
	}
	glEnd();

	glPopMatrix();
}

void DrawingHelpers::DrawArrow(const double&amp; x, const double&amp; y, const double&amp; a)
{
	const int nSlicesStacks = 50;
	const double percent = 20.0;
	const double innerPercent = 15.0;
	double half_length = 10/2.0;

	glPushMatrix();
	//Draw one cylender and cone
	glTranslated(x, y, 0.5);
	glRotated(a*RAD2DEG, 0,0,1);

	//X Axis
	glPushMatrix();
	glColor3ub(200,200,200);
	glRotated(90, 0,1,0);
	glutSolidCylinder(half_length/percent, half_length,nSlicesStacks,nSlicesStacks);
	glTranslated(0,0,half_length);
	glColor3f(1,1,0);
	glutSolidCone(half_length/innerPercent, half_length/innerPercent,nSlicesStacks,nSlicesStacks);
	glPopMatrix();

	glPopMatrix();
}

void DrawingHelpers::DrawCustomOrigin(const double&amp; x, const double&amp; y, const double&amp; z, const int&amp; yaw, const int&amp; roll, const int&amp; pitch, const double&amp; length)
{
	const int nSlicesStacks = 50;
	const double percent = 20.0;
	const double innerPercent = 15.0;
	double half_length = length/2.0;

	glPushMatrix();
	//Draw one cylender and cone
	glTranslated(x, y, z);
	glRotated(yaw, 0,0,1);
	glRotated(roll, 1,0,0);
	glRotated(pitch, 0,1,0);

	//Z Axis
	glPushMatrix();
	glColor3f(0.65,0.65,0.65);
	glutSolidCylinder(half_length/percent, half_length,nSlicesStacks,nSlicesStacks);
	glTranslated(0,0,half_length);
	glColor3f(0,0,1);
	glutSolidCone(half_length/innerPercent, half_length/innerPercent,nSlicesStacks,nSlicesStacks);
	glPopMatrix();

	//X Axis
	glPushMatrix();
	glColor3f(0.65,0.65,0.65);
	glRotated(90, 0,1,0);
	glutSolidCylinder(half_length/percent, half_length,nSlicesStacks,nSlicesStacks);
	glTranslated(0,0,half_length);
	glColor3f(1,1,0);
	glutSolidCone(half_length/innerPercent, half_length/innerPercent,nSlicesStacks,nSlicesStacks);
	glPopMatrix();

//	//Y Axis
	glPushMatrix();
	glColor3f(0.65,0.65,0.65);
	glRotated(90, 1,0,0);
	glutSolidCylinder(half_length/percent, half_length, nSlicesStacks, nSlicesStacks);
	glTranslated(0,0,half_length);
	glColor3f(1,0,0);
	glutSolidCone(half_length/innerPercent, half_length/innerPercent, nSlicesStacks,nSlicesStacks);
	glPopMatrix();

	//glDisable(GL_LIGHTING);
	glPopMatrix();

}

vector&lt;vector&lt;float&gt; &gt; DrawingHelpers::PreparePathForDrawing(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; redyForDraw, double w, double resolution)
{
	vector&lt;vector&lt;float&gt; &gt; colorProfiles;
	if(path.size() &lt; 2) return colorProfiles;
	int size = path.size();
	WayPoint p1 = path[0];
	WayPoint p2 =p1;
	WayPoint prev_point = p1;
	WayPoint center, prev_center ,pa, pb, pc, pd;
	double a = 0;
	double prev_angle = 0;
	vector&lt;WayPoint&gt; four_temp;
	vector&lt;float&gt; color_vector;

	for(int i=0; i &lt; size ; i++)
	{

		color_vector.clear();
		four_temp.clear();

		pa = p2 = path[i];

		color_vector.push_back(p1.v/12.0);
		color_vector.push_back(p1.v/12.0);
		color_vector.push_back(p1.v/12.0);
		colorProfiles.push_back(color_vector);

		if(distance2points(p1.pos, p2.pos) &lt; resolution)
		  continue;

		center.pos.x = p1.pos.x + (p2.pos.x-p1.pos.x)/2.0;
		center.pos.y = p1.pos.y + (p2.pos.y-p1.pos.y)/2.0;

		a = atan2(p2.pos.y- p1.pos.y, p2.pos.x- p1.pos.x);

		pa.pos.x = p1.pos.x - w * cos(a - M_PI/2.0);
		pa.pos.y = p1.pos.y - w * sin(a - M_PI/2.0);
		pa.pos.z = p1.pos.z;

		pb.pos.x = p1.pos.x + w * cos(a - M_PI/2.0);
		pb.pos.y = p1.pos.y + w * sin(a - M_PI/2.0);
		pb.pos.z = p1.pos.z;


		pc.pos.x = p2.pos.x + w * cos(a - M_PI/2.0);
		pc.pos.y = p2.pos.y + w * sin(a - M_PI/2.0);
		pc.pos.z = p2.pos.z;

		pd.pos.x = p2.pos.x - w * cos(a - M_PI/2.0);
		pd.pos.y = p2.pos.y - w * sin(a - M_PI/2.0);
		pd.pos.z = p2.pos.z;

		if(!(prev_point.pos.x == p1.pos.x &amp;&amp;  prev_point.pos.y == p1.pos.y))
		{
			prev_angle = atan2(p1.pos.y- prev_point.pos.y, p1.pos.x- prev_point.pos.x);

			pa.pos.x = p1.pos.x - w * cos(prev_angle - M_PI/2.0);
			pa.pos.y = p1.pos.y - w * sin(prev_angle - M_PI/2.0);

			pb.pos.x = p1.pos.x + w * cos(prev_angle - M_PI/2.0);
			pb.pos.y = p1.pos.y + w * sin(prev_angle - M_PI/2.0);
		}

	  	four_temp.push_back(pa);
	  	four_temp.push_back(pb);
	  	four_temp.push_back(pc);
	  	four_temp.push_back(pd);

	  	redyForDraw.push_back(four_temp);

		prev_point = p1;
		p1 = p2;
	}
	  return colorProfiles;
}

void DrawingHelpers::DrawPrePreparedPolygons(std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; path,
		double z, float color[3],int nSkipPoints, const std::vector&lt;std::vector&lt;float&gt; &gt;* colorProfile)
{


	if(!colorProfile)
		glColor3f(color[0], color[1], color[2]);

	for(unsigned int i=0; i&lt; path.size(); i+=nSkipPoints)
	{
		if(path[i].size() == 4)
		{
			if(path[i][0].pLane &amp;&amp; (path[i][0].pLane-&gt;pRightLane || path[i][0].pLane-&gt;pLeftLane))
				glColor3f(1, 0, 0);
			else if(colorProfile)
			{
				glColor3f(color[0]*(*colorProfile)[i][0], color[1] * (*colorProfile)[i][1], color[2] * (*colorProfile)[i][2]);
			}

			 glBegin(GL_POLYGON);
				  glNormal3f(0.0, 0.0, 0.1);
//				  glVertex3f(path[i][0].p.x, path[i][0].p.y,path[i][0].p.z+z);
//				  glVertex3f(path[i][1].p.x, path[i][1].p.y,path[i][1].p.z+z);
//				  glVertex3f(path[i][2].p.x, path[i][2].p.y,path[i][2].p.z+z);
//				  glVertex3f(path[i][3].p.x, path[i][3].p.y,path[i][3].p.z+z);
				  glVertex3f(path[i][0].pos.x, path[i][0].pos.y,z);
				  glVertex3f(path[i][1].pos.x, path[i][1].pos.y,z);
				  glVertex3f(path[i][2].pos.x, path[i][2].pos.y,z);
				  //glVertex3f((path[i][2].p.x+path[i][1].p.x)/2.0, (path[i][2].p.y+path[i][1].p.y)/2.0,z);
				  glVertex3f(path[i][3].pos.x, path[i][3].pos.y,z);
			  glEnd();
		}
	}


}

void DrawingHelpers::DrawCostPath(const std::vector&lt;PlannerHNS::WayPoint*&gt;&amp; path_points, const double&amp; z, const double&amp; width)
{
	if(path_points.size()==0) return;

	WayPoint p1 = *path_points[0];
	float color[3] = {0,0,0};

	double max_cost = 0;
	for(unsigned int i=0; i &lt; path_points.size(); i++)
	{
		if(path_points.at(i)-&gt;cost &gt; max_cost)
			max_cost = path_points.at(i)-&gt;cost;
	}

	int size = path_points.size();

	for(int i=0; i &lt; size; i++)
	{
		p1 = *path_points[i];
		double norm_cost = path_points.at(i)-&gt;cost / max_cost * 2.0;
		if(norm_cost &lt;= 1.0)
		{
			color[0] = norm_cost;
			color[1] = 1.0;
		}
		else if(norm_cost &gt; 1.0)
		{
			color[0] = 1.0;
			color[1] = 2.0 - norm_cost;
		}

		glColor3f(color[0], color[1], color[2]);

		//DrawLinePoygonFromCenterX(p1, z, p2, z, width, 0, prev_point);
		DrawWideEllipse(p1.pos.x, p1.pos.y, z, 0.5, 0.5, 0.25, color);
	}
}

void DrawingHelpers::DrawWidePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path_points, const double&amp; z, const double&amp; width, float color[3], bool bGadient)
{
	if(path_points.size()==0) return;

	WayPoint p1 = path_points[0];
	WayPoint p2 = p1;

	float localColor[3] = {color[0],color[1],color[2]};

	int size = path_points.size();
	WayPoint prev_point = p1;

	for(int i=1; i &lt; size; i+=2)
	{
		p2 = path_points[i];
		if(bGadient)
		{
			localColor[0] = color[0] * (float)(i+20)*3/(float)size;
			localColor[1] = color[1] * (float)(i+20)*3/(float)size;
			localColor[2] = color[2] * (float)(i+20)*3/(float)size;
		}

		if(p2.bDir == BACKWARD_DIR)
			glColor3f(1,0, 0);
		else
			glColor3f(localColor[0],localColor[1],localColor[2]);

		DrawLinePoygonFromCenterX(p1, z, p2, z, width, 0, prev_point);

		prev_point = p1;

		p1 = p2;
	}
}

void DrawingHelpers::DrawLinePoygonline(const PlannerHNS::GPSPoint&amp; p1, const PlannerHNS::GPSPoint&amp; p2, const double&amp; w)
{
	POINT2D center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
	double a = 0;

	center.x = p1.x + (p2.x-p1.x)/2.0;
	center.y = p1.y + (p2.y-p1.y)/2.0;

	 a = atan2(p2.y- p1.y, p2.x- p1.x);

	pa.x = p1.x - w * cos(a - M_PI/2.0);
	pa.y = p1.y - w * sin(a - M_PI/2.0);

	pb.x = p1.x + w * cos(a - M_PI/2.0);
	pb.y = p1.y + w * sin(a - M_PI/2.0);


	pc.x = p2.x + w * cos(a - M_PI/2.0);
	pc.y = p2.y + w * sin(a - M_PI/2.0);

	pd.x = p2.x - w * cos(a - M_PI/2.0);
	pd.y = p2.y - w * sin(a - M_PI/2.0);

	glBegin(GL_POLYGON);
	  glNormal3f(0.1, 0.1, 0.1);
	  glVertex3f(pa.x, pa.y, p1.z);
	  glVertex3f(pb.x, pb.y, p1.z);
	  glVertex3f(pc.x, pc.y, p2.z);
	  glVertex3f(pd.x, pd.y, p2.z);
	glEnd();
}

void DrawingHelpers::DrawLinePoygonFromCenterX(const PlannerHNS::WayPoint&amp; p1, const double&amp; z,
		const PlannerHNS::WayPoint&amp; p2, const double&amp; z2, const double&amp; w, const double&amp; h,
		PlannerHNS::WayPoint&amp; prev_point)
{
	POINT2D center, prev_center ,pa, pb, pc, pd, prev_pa,prev_pb;
	double a = 0;
	double prev_angle = 0;

	center.x = p1.pos.x + (p2.pos.x-p1.pos.x)/2.0;
	center.y = p1.pos.y + (p2.pos.y-p1.pos.y)/2.0;

	 a = atan2(p2.pos.y- p1.pos.y, p2.pos.x- p1.pos.x);

	pa.x = p1.pos.x - w * cos(a - M_PI/2.0);
	pa.y = p1.pos.y - w * sin(a - M_PI/2.0);

	pb.x = p1.pos.x + w * cos(a - M_PI/2.0);
	pb.y = p1.pos.y + w * sin(a - M_PI/2.0);


	pc.x = p2.pos.x + w * cos(a - M_PI/2.0);
	pc.y = p2.pos.y + w * sin(a - M_PI/2.0);

	pd.x = p2.pos.x - w * cos(a - M_PI/2.0);
	pd.y = p2.pos.y - w * sin(a - M_PI/2.0);

	if(!(prev_point.pos.x == p1.pos.x &amp;&amp;  prev_point.pos.y == p1.pos.y))
	{
		prev_angle = atan2(p1.pos.y- prev_point.pos.y, p1.pos.x- prev_point.pos.x);

		pa.x = p1.pos.x - w * cos(prev_angle - M_PI/2.0);
		pa.y = p1.pos.y - w * sin(prev_angle - M_PI/2.0);

		pb.x = p1.pos.x + w * cos(prev_angle - M_PI/2.0);
		pb.y = p1.pos.y + w * sin(prev_angle - M_PI/2.0);

	}

	  glBegin(GL_POLYGON);
		  glNormal3f(0.1, 0.1, 0.1);
		  glVertex3f(pa.x, pa.y,z);
		  glVertex3f(pb.x, pb.y, z);
		  glVertex3f(pc.x, pc.y,z);
		  glVertex3f(pd.x, pd.y, z);
	  glEnd();

}

void DrawingHelpers::DrawCustomCarModel(const PlannerHNS::WayPoint&amp; pose,const double&amp; steeringAngle, const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; carPoints,float color[3], const double&amp; angleFix)
{
	if(carPoints.size() == 4)
	{
		double z_margin = 0.05;

		glPushMatrix();
		glTranslated(pose.pos.x, pose.pos.y, pose.pos.z);
		glRotated(pose.pos.a*RAD2DEG + angleFix, 0,0,1);
		for(unsigned  int i = 0; i &lt; 4; i++)
		{
			glBegin(GL_LINE_STRIP);
			//glColor3f(0,1,1);
			glColor3f(color[0],color[1],color[2]);
			glVertex3f(carPoints[i].x, carPoints[i].y, carPoints[i].z);
			glVertex3f(carPoints[i].x, carPoints[i].y, carPoints[i].z+1);

			glEnd();
		}

		glBegin(GL_POLYGON);
		//glColor3f(0,0,1);
		glColor3f(color[0],color[0],color[2]);
			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+z_margin);
			glVertex3f(carPoints[1].x, carPoints[1].y, carPoints[1].z+z_margin);
			glVertex3f(carPoints[2].x, carPoints[2].y, carPoints[2].z+z_margin);
			glVertex3f(carPoints[3].x, carPoints[3].y, carPoints[3].z+z_margin);
			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+z_margin);

			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+z_margin);
			glVertex3f(carPoints[2].x, carPoints[2].y, carPoints[2].z+z_margin);

			glVertex3f(carPoints[1].x, carPoints[1].y, carPoints[1].z+z_margin);
			glVertex3f(carPoints[3].x, carPoints[3].y, carPoints[3].z+z_margin);

		glEnd();

		glBegin(GL_LINE_LOOP);
		glColor3f(color[0],color[0],color[2]);
			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+1);
			glVertex3f(carPoints[1].x, carPoints[1].y, carPoints[1].z+1);
			glVertex3f(carPoints[2].x, carPoints[2].y, carPoints[2].z+1);
			glVertex3f(carPoints[3].x, carPoints[3].y, carPoints[3].z+1);
			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+1);

			glVertex3f(carPoints[0].x, carPoints[0].y, carPoints[0].z+1);
			glVertex3f(carPoints[2].x, carPoints[2].y, carPoints[2].z+1);

			glVertex3f(carPoints[1].x, carPoints[1].y, carPoints[1].z+1);
			glVertex3f(carPoints[3].x, carPoints[3].y, carPoints[3].z+1);

		glEnd();


		double width = fabs(carPoints[0].x - carPoints[2].x);
		double length = fabs(carPoints[0].y - carPoints[2].y);
		double innerRad = 1.0;
		double scale_factor = 0.1;
		glColor3f(0.05,0.05,0.05);

		glPushMatrix();
		glTranslated(width/2.0,length/2.0 - 0.5,0);
		glScaled(scale_factor, scale_factor, scale_factor);
		glRotated(90, 0,0,1);
		glRotated(90, 1,0,0);
		glutSolidTorus(innerRad, 3.0, 20, 20);
		glPopMatrix();

		glPushMatrix();
		glTranslated(-width/2.0,length/2.0 - 0.5,0);
		glScaled(scale_factor, scale_factor, scale_factor);
		glRotated(90, 0,0,1);
		glRotated(90, 1,0,0);
		glutSolidTorus(innerRad, 3.0, 20, 20);
		glPopMatrix();

		glPushMatrix();
		glTranslated(width/2.0,-length/2.0 + 0.5,0);
		glScaled(scale_factor, scale_factor, scale_factor);
		glRotated(90+steeringAngle*RAD2DEG, 0,0,1);
		glRotated(90, 1,0,0);
		glutSolidTorus(innerRad, 3.0, 20, 20);
		glPopMatrix();

		glPushMatrix();
		glTranslated(-width/2.0,-length/2.0 + 0.5,0);
		glScaled(scale_factor, scale_factor, scale_factor);
		glRotated(90+steeringAngle*RAD2DEG, 0,0,1);
		glRotated(90, 1,0,0);
		glutSolidTorus(innerRad, 3.0, 20, 20);
		glPopMatrix();




		glPopMatrix();
	}

	DrawCustomOrigin(pose.pos.x, pose.pos.y, pose.pos.z, pose.pos.a*RAD2DEG, 0,0, 2);
}

GLMmodel* DrawingHelpers::LoadModel(const char* fileName)
{
	GLMmodel* pmodel = glmReadOBJ((char*)fileName);
	if (!pmodel) exit(0);
	glmUnitize(pmodel);
	glmFacetNormals(pmodel);
	glmVertexNormals(pmodel, 90.0);

	return pmodel;
}

void DrawingHelpers::DrawModel(GLMmodel* pmod,double length, double width, double height, double x, double y,double z, double heading, double pitch , double roll )
{
	if (pmod)
	{
		if(!glIsEnabled(GL_LIGHTING))
			  glEnable(GL_LIGHTING);

		glPushMatrix();
		glTranslated(x,y,z);
		glRotated(heading*RAD2DEG,0.0, 0.0, 1.0);
		glRotated(pitch*RAD2DEG,0.0, 1.0, 0.0);
		glRotated(roll*RAD2DEG,1.0, 0.0, 0.0);

		glScaled(length, width, height);
		glmDraw(pmod, GLM_FLAT | GLM_MATERIAL );
		glPopMatrix();

		glDisable(GL_LIGHTING);
	}
}

void DrawingHelpers::DrawFilledEllipse(float x, float y, float z, float width, float height)
{
	glDisable(GL_LIGHTING);
	glBegin(GL_TRIANGLE_FAN);
		//All triangles fan out starting with this point
		glVertex3f (x,y,z);
		for (float i = 0; i &lt;=M_PI*2*RAD2DEG; i+=0.1)
		{
			glVertex3f(x + width*cos(i), y+height*sin(i), z);
		}
	glEnd();
	glEnable(GL_LIGHTING);
}

void DrawingHelpers::DrawWideEllipse(float x, float y, float z, float outer_width, float outer_height,
		float inner_width,float color[3])
{
	//std::vector&lt;WayPoint&gt; ellipse_points;
	glColor3f(color[0], color[1], color[2]);
	GPSPoint p1 = GPSPoint(x + outer_width*cos(0),y + outer_height*sin(0),z,0);
	GPSPoint p2 = p1;
	for (float i = 0.1; i &lt;= M_PI*2 + 0.1; i+=0.1)
	{
		//ellipse_points.push_back(WayPoint(x + outer_width*cos(i), y+outer_height*sin(i), z, 0));
		p2.x = x + outer_width*cos(i);
		p2.y = y + outer_height*sin(i);
		p2.z = z;

		DrawLinePoygonline(p1,p2, outer_width - inner_width);
		p1 = p2;

	}

	//DrawWidePath(ellipse_points, z, outer_width - inner_width,color);
}

void DrawingHelpers::DrawSimpleEllipse(float x, float y, float z, float outer_width, float outer_height)
{
	glBegin(GL_LINE_STRIP);
	for (float jj = 0; jj &lt;=M_PI*2.0; jj+=0.1)
	{
		glVertex3f(x + outer_width*cos(jj), y+ outer_height*sin(jj),z);
	}
	glEnd();
}

void DrawingHelpers::DrawPedal(float x, float y, float z, float width, float height, float inner_height, float color[3])
{
	POINT2D pa, pb, pc, pd;
	double w2 = width/2.0;
	double h2 = height/2.0;

	pa.x = x - w2;
	pa.y = y - h2;

	pb.x = x + w2;
	pb.y = y - h2;

	pc.x = x + w2;
	pc.y = y + h2;

	pd.x = x - w2;
	pd.y = y + h2;

	glBegin(GL_LINE_LOOP);
	  glVertex3f(pa.x, pa.y, z);
	  glVertex3f(pb.x, pb.y, z);
	  glVertex3f(pc.x, pc.y, z);
	  glVertex3f(pd.x, pd.y, z);
	glEnd();

	GPSPoint p1(x, y + h2, z, 0);
	GPSPoint p2(x, y + h2 - inner_height, z, 0);

	glColor3f(color[0], color[1], color[2]);
	DrawLinePoygonline(p1,p2,w2);

}

} /* namespace Graphics */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/Graph2dBase.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/Graph2dBase.cpp">
				<diff>@@ -121,7 +121,7 @@ double Graph2dBase::DrawGraph()
 
 void Graph2dBase::InsertPointTimeStamp(const timespec&amp; tStamp, const double&amp; y)
 {
-	POINT2D p(0,y,0);
+	GPSPoint p(0,y,0,0);
 	if(xy_arr_original.size() == 0)
 	{
 		xy_arr_original.push_back(p);
@@ -188,7 +188,7 @@ void Graph2dBase::InsertPoint(const double&amp; x, const double&amp; y)
 
 }
 
-void Graph2dBase::InsertPointsList(const std::vector&lt;PlannerHNS::POINT2D&gt;&amp; points)
+void Graph2dBase::InsertPointsList(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; points)
 {
 
 }
</diff>
				<old_file>/*
 * Graph2dBase.cpp
 *
 *  Created on: Oct 8, 2016
 *      Author: hatem
 */

#include &quot;Graph2dBase.h&quot;
#include &quot;UtilityH.h&quot;

using namespace PlannerHNS;


namespace Graphics
{

#define BORDER_MARGIN 20
#define AXE_WIDTH 2

Graph2dBase::Graph2dBase(double width, double height, int nMaxPoints, double max_y, double min_y, std::string str_title, std::string str_x, std::string str_y, double a_color[], double g_color[]) {

	w = width;
	h = height;
	nPoints = nMaxPoints;
	graph_title = str_title;
	x_name = str_x;
	y_name = str_y;


	axes_color[0] = a_color[0];
	axes_color[1] = a_color[1];
	axes_color[2] = a_color[2];

	graph_color[0] = g_color[0];
	graph_color[1] = g_color[1];
	graph_color[2] = g_color[2];

	m_PrevTimeStamp.tv_nsec = 0;
	m_PrevTimeStamp.tv_sec = 0;
	max_point.y = max_y;
	min_point.y = min_y;


}

void Graph2dBase::ReInitGraphResolution(double width, double height, int nMaxPoints, double a_color[], double g_color[])
{
	w = width;
	h = height;
	nPoints = nMaxPoints;
	axes_color[0] = a_color[0];
	axes_color[1] = a_color[1];
	axes_color[2] = a_color[2];

	graph_color[0] = g_color[0];
	graph_color[1] = g_color[1];
	graph_color[2] = g_color[2];
}

Graph2dBase::~Graph2dBase()
{

}


double Graph2dBase::DrawGraph()
{

	glDisable(GL_LIGHTING);

	glBegin(GL_POLYGON);
		glColor3f(0.9,0.9,0.9);
		glNormal3f(0.1, 0.1, 0.1);
		glVertex3f(0, 0, 0);
		glVertex3f(0, h, 0);
		glVertex3f(w, h, 0);
		glVertex3f(w, 0, 0);
	glEnd();


	GPSPoint p_origin, x_end, y_end;
	p_origin.x = BORDER_MARGIN;
	p_origin.y = h - BORDER_MARGIN*2;

	x_end.x = w - BORDER_MARGIN*2;
	x_end.y = h - BORDER_MARGIN*2;

	y_end.x = BORDER_MARGIN;
	y_end.y = BORDER_MARGIN;


	glColor3f(axes_color[0],axes_color[1],axes_color[2]);
	DrawingHelpers::DrawLinePoygonline(p_origin, x_end, AXE_WIDTH);
	DrawingHelpers::DrawLinePoygonline(p_origin, y_end, AXE_WIDTH);

	glColor3f(graph_color[0],graph_color[1],graph_color[2]);
	DrawingHelpers::DrawString(x_end.x, x_end.y, GLUT_BITMAP_HELVETICA_18, (char*)x_name.c_str());
	DrawingHelpers::DrawString(y_end.x, y_end.y, GLUT_BITMAP_HELVETICA_18, (char*)y_name.c_str());
	DrawingHelpers::DrawString(BORDER_MARGIN, p_origin.y+BORDER_MARGIN, GLUT_BITMAP_HELVETICA_18, (char*)graph_title.c_str());


	glPointSize(4);
	glBegin(GL_POINTS);
		for(unsigned int i = 1 ; i &lt; xy_arr.size(); i++)
		{
			//glVertex3f(xy_arr.at(i-1).x, xy_arr.at(i-1).y, 0);
			glVertex3f(xy_arr.at(i).x, xy_arr.at(i).y, 0);
		}
	glEnd();
	glBegin(GL_LINES);
		for(unsigned int i = 1 ; i &lt; xy_arr.size(); i++)
		{
			glVertex3f(xy_arr.at(i-1).x, xy_arr.at(i-1).y, 0);
			glVertex3f(xy_arr.at(i).x, xy_arr.at(i).y, 0);
		}
	glEnd();


	glEnable(GL_LIGHTING);
}

void Graph2dBase::InsertPointTimeStamp(const timespec&amp; tStamp, const double&amp; y)
{
	POINT2D p(0,y,0);
	if(xy_arr_original.size() == 0)
	{
		xy_arr_original.push_back(p);
	}
	else
	{
		if(tStamp.tv_nsec == 0 &amp;&amp; tStamp.tv_sec == 0)
		{
			p.x = xy_arr_original.at(xy_arr_original.size()-1).x+1;
		}
		else
		{
			double t = UtilityHNS::UtilityH::GetTimeDiff(m_PrevTimeStamp, tStamp);
			p.x = xy_arr_original.at(xy_arr_original.size()-1).x+t;
		}
	}



	double initial_x = xy_arr_original.at(0).x;

//	if(xy_arr_original.size() &gt; nPoints)
//	{
//		initial_x = xy_arr_original.at(0).x;
//		xy_arr_original.erase(xy_arr_original.begin()+0);
//	}



	xy_arr_original.push_back(p);

	xy_arr.clear();


	for(unsigned int i=0; i&lt;xy_arr_original.size(); i++ )
	{
		//p.x = BORDER_MARGIN + ((xy_arr_original.at(i).x - avg_x) / (max_point.x - min_point.x) * 10.0);
		//p.y = h - BORDER_MARGIN*2 - ((xy_arr_original.at(i).y - avg_y) / (max_point.y - min_point.y) * 10.0);
		double y_val = (h - BORDER_MARGIN*3) * ((xy_arr_original.at(i).y - min_point.y) / (max_point.y - min_point.y));
		double x_val = (xy_arr_original.at(i).x - initial_x)*10.0;

		p.x = BORDER_MARGIN + x_val;
		p.y = (h - BORDER_MARGIN*2) - y_val;
		xy_arr.push_back(p);
	}

	double total_x = 0;

	for(int i=xy_arr.size()-1; i&gt;0; i-- )
	{
		total_x += (xy_arr.at(i).x - xy_arr.at(i-1).x);
		if(total_x &gt; (w - BORDER_MARGIN*3))
		{
			xy_arr_original.erase(xy_arr_original.begin(), xy_arr_original.begin()+i);
			break;
		}
	}

	m_PrevTimeStamp = tStamp;
}

void Graph2dBase::InsertPoint(const double&amp; x, const double&amp; y)
{

}

void Graph2dBase::InsertPointsList(const std::vector&lt;PlannerHNS::POINT2D&gt;&amp; points)
{

}

void Graph2dBase::UpdateComment(const std::string&amp; str_com)
{
	str_comment = str_com;
}

} /* namespace Graphics */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/PlannerTestDraw.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/PlannerTestDraw.cpp">
				<diff>@@ -14,6 +14,7 @@
 #include &quot;SimpleTracker.h&quot;
 #include &quot;DataRW.h&quot;
 #include &quot;PlannerCommonDef.h&quot;
+//#include &lt;plib/js.h&gt;
 
 
 using namespace std;
@@ -44,6 +45,7 @@ PlannerTestDraw::PlannerTestDraw()
 	m_pVelocityGraph = 0;
 	planning_thread_tid = 0;
 	control_thread_tid = 0;
+	game_wheel_thread_tid = 0;
 	simulation_thread_tid = 0;
 	m_bCancelThread = false;
 	m_PlanningCycleTime = 0.01;
@@ -242,8 +244,6 @@ PlannerTestDraw::PlannerTestDraw()
 //	PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
 
 
-	m_pMap = new PlannerHNS::GridMap(0,0,60,60,5.0, true);
-
 	m_CarInfo.width = 2.0;
 	m_CarInfo.length = 4.2;
 	m_CarInfo.wheel_base = 2.5;
@@ -309,7 +309,8 @@ PlannerTestDraw::PlannerTestDraw()
 	m_pLateralErrGraph  = new Graph2dBase(20, 200,1000, 1.0, -1.0, &quot;Lateral Error&quot;, &quot;T s&quot;, &quot;D meter&quot;, axes_color, graph_color );
 
 	pthread_create(&amp;planning_thread_tid, NULL, &amp;PlannerTestDraw::PlanningThreadStaticEntryPoint, this);
-	pthread_create(&amp;control_thread_tid, NULL, &amp;PlannerTestDraw::ControlThreadStaticEntryPoint, this);
+	//pthread_create(&amp;control_thread_tid, NULL, &amp;PlannerTestDraw::ControlThreadStaticEntryPoint, this);
+	//pthread_create(&amp;game_wheel_thread_tid, NULL, &amp;PlannerTestDraw::GameWheelThreadStaticEntryPoint, this);
 	//pthread_create(&amp;simulation_thread_tid, NULL, &amp;PlannerTestDraw::SimulationThreadStaticEntryPoint, this);
 	//InitStartAndGoal(2, -50, M_PI, 100, 100, M_PI_2);
 
@@ -476,11 +477,8 @@ PlannerTestDraw::~PlannerTestDraw()
 	if(simulation_thread_tid&gt;0)
 		pthread_join(simulation_thread_tid, (void**)&amp;pRet);
 
-	if(m_pMap)
-	{
-		delete m_pMap;
-		m_pMap = 0;
-	}
+	if(game_wheel_thread_tid&gt;0)
+		pthread_join(game_wheel_thread_tid, (void**)&amp;pRet);
 
 }
 
@@ -754,8 +752,6 @@ void PlannerTestDraw::DrawSimu()
 
 	DrawVectorMap();
 
-	//	if(m_pMap)
-	//		DrawingHelpers::DrawGrid(m_pMap-&gt;origin_x, m_pMap-&gt;origin_y, m_pMap-&gt;w, m_pMap-&gt;h, m_pMap-&gt;cell_l);
 
 	DrawPaths();
 	DrawStartsAndGoals();
@@ -941,7 +937,7 @@ void PlannerTestDraw::DrawPaths()
 
 	if(m_iStepNumber%4 == 0)
 	{
-		DrawingHelpers::DrawWidePath(m_LocalPlanner.m_PathSection, 0.08, 0.25, TotalPathColor);
+		//DrawingHelpers::DrawWidePath(m_LocalPlanner.m_PathSection, 0.08, 0.25, TotalPathColor);
 
 		//DrawingHelpers::DrawCostPath(m_all_cell_to_delete, 0.5, 0.5);
 
@@ -1445,7 +1441,7 @@ void* PlannerTestDraw::PlanningThreadStaticEntryPoint(void* pThis)
 			 */
 			int currIndexToGoal = 0;
 			if(pR-&gt;m_LocalPlanner.m_TotalPath.size()&gt;0)
-				currIndexToGoal = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(pR-&gt;m_LocalPlanner.m_TotalPath.at(0), pR-&gt;m_LocalPlanner.state);
+				currIndexToGoal = PlannerHNS::PlanningHelpers::GetClosestNextPointIndexFast(pR-&gt;m_LocalPlanner.m_TotalPath.at(0), pR-&gt;m_LocalPlanner.state);
 //			int index_limit_total = pR-&gt;m_LocalPlanner.m_TotalPath.size() - 25;
 //			if(index_limit_total&lt;=0)
 //				index_limit_total =  pR-&gt;m_LocalPlanner.m_TotalPath.size()/2.0;
@@ -1527,7 +1523,16 @@ void* PlannerTestDraw::PlanningThreadStaticEntryPoint(void* pThis)
 			if(pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl == 1 &amp;&amp; pR-&gt;m_CurrentBehavior.state != PlannerHNS::INITIAL_STATE)
 				bEmergencyStop = true;
 
-			pR-&gt;m_CurrentBehavior = pR-&gt;m_LocalPlanner.DoOneStep(dt, currTargetState, obj_list, 1, pR-&gt;m_RoadMap, bEmergencyStop, pR-&gt;m_bGreenTrafficLight);
+			PlannerHNS::TrafficLight tl;
+			vector&lt;PlannerHNS::TrafficLight&gt; tls;
+			if(pR-&gt;m_bGreenTrafficLight)
+				tl.lightState = PlannerHNS::GREEN_LIGHT;
+			else
+				tl.lightState = PlannerHNS::RED_LIGHT;
+
+			tls.push_back(tl);
+
+			pR-&gt;m_CurrentBehavior = pR-&gt;m_LocalPlanner.DoOneStep(dt, currTargetState, obj_list, 1, pR-&gt;m_RoadMap, bEmergencyStop, tls);
 
 			PlannerHNS::PlanningHelpers::WritePathToFile(&quot;/home/hatem/SimuLogs/Test&quot;, pR-&gt;m_LocalPlanner.m_Path);
 
@@ -1813,4 +1818,58 @@ void* PlannerTestDraw::SimulationThreadStaticEntryPoint(void* pThis)
 	return 0;
 }
 
+
+void* PlannerTestDraw::GameWheelThreadStaticEntryPoint(void* pThis)
+{
+
+	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
+	/*jsJoystick* pWheel = new jsJoystick(0);
+	int nAxis = pWheel-&gt;getNumAxes();
+	float* pAxis = new float[nAxis];
+	int nButtons = pWheel-&gt;getNumButtons();
+	int* pButtons = new int[nButtons];
+
+	cout &lt;&lt; &quot;Axis Number: &quot; &lt;&lt; nAxis &lt;&lt; endl;
+
+	while(!pR-&gt;m_bCancelThread)
+	{
+		pWheel-&gt;read(pButtons, pAxis);
+
+		if(pButtons[BUTTON_INDEX] == START_BUTTON_VALUE)
+			cout &lt;&lt; &quot;Start Button Value: &quot; &lt;&lt; 1 &lt;&lt; endl;
+		else
+			cout &lt;&lt; &quot;Start Button Value: &quot; &lt;&lt; 0 &lt;&lt; endl;
+
+		cout &lt;&lt; &quot;Steering Axis Value: &quot; &lt;&lt; -pAxis[STEERING_AXIS] &lt;&lt; endl;
+		cout &lt;&lt; &quot;Acceleration Axis Value: &quot; &lt;&lt; 1 - pAxis[ACCELERATION_AXIS] &lt;&lt; endl;
+		cout &lt;&lt; &quot;Braking Axis Value: &quot; &lt;&lt; 1 - pAxis[BRAKE_AXIS] &lt;&lt; endl;
+
+		pR-&gt;m_SteeringAngle = -pAxis[STEERING_AXIS];
+		pR-&gt;m_Acceleration = 1 - pAxis[ACCELERATION_AXIS];
+		pR-&gt;m_Braking = 1 - pAxis[BRAKE_AXIS];
+
+		pthread_mutex_lock(&amp;pR-&gt;control_mutex);
+		if(pR-&gt;m_Acceleration &gt; 0)
+			pR-&gt;m_VehicleTargetState.shift = PlannerHNS::SHIFT_POS_DD;
+		pR-&gt;m_VehicleTargetState.speed = pR-&gt;m_LocalPlanner.m_CarInfo.max_speed_forward * pR-&gt;m_Acceleration;
+
+		if(pR-&gt;m_Braking &gt; 0)
+			pR-&gt;m_VehicleTargetState.speed = 0;
+
+		pR-&gt;m_VehicleTargetState.steer = pR-&gt;m_SteeringAngle*pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle;
+
+		pthread_mutex_unlock(&amp;pR-&gt;control_mutex);
+
+		usleep(10000);
+	}
+
+	delete [] pAxis;
+	delete [] pButtons;
+	delete pWheel;
+
+	cout &lt;&lt; &quot;Exit Game Wheel Loop.&quot; &lt;&lt; endl;
+	*/
+	return pR;
+}
+
 } /* namespace Graphics */
</diff>
				<old_file>/*
 * PlannerTestDraw.cpp
 *
 *  Created on: Jun 17, 2016
 *      Author: hatem
 */

#include &quot;PlannerTestDraw.h&quot;
#include &quot;PlannerH.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &quot;MappingHelpers.h&quot;
#include &lt;sstream&gt;
#include &quot;MatrixOperations.h&quot;
#include &quot;SimpleTracker.h&quot;
#include &quot;DataRW.h&quot;
#include &quot;PlannerCommonDef.h&quot;


using namespace std;
using namespace SimulationNS;
using namespace UtilityHNS;

#define VectorMap &quot;/media/hatem/8ac0c5d5-8793-4b98-8728-55f8d67ec0f4/data/ToyotaCity2/map/vector_map/&quot;
//#define kmlMap	&quot;tsukuba_multy_2_11.kml&quot;

#define kmlMapPath	&quot;/media/user/8ac0c5d5-8793-4b98-8728-55f8d67ec0f4/data/ToyotaCity2/map/kml/ToyotaCityCustomInfo.kml&quot;

#define kmlTemplateFile &quot;PlannerX_MapTemplate.kml&quot;
#define kmltargetFile &quot;ToyotaKML.kml&quot;
#define PreDefinedPath  &quot;11,333,1090,1704,147, 1791,801, 431, 1522, 372, 791, 1875, 1872,171,108,21,&quot;

namespace Graphics
{

#define EnableThreadBody

PlannerTestDraw::PlannerTestDraw()
{
	planning_mutex =  PTHREAD_MUTEX_INITIALIZER;
	control_mutex = PTHREAD_MUTEX_INITIALIZER;
	simulation_mutex = PTHREAD_MUTEX_INITIALIZER;

	m_LateralError = 0;
	m_pVelocityGraph = 0;
	planning_thread_tid = 0;
	control_thread_tid = 0;
	simulation_thread_tid = 0;
	m_bCancelThread = false;
	m_PlanningCycleTime = 0.01;
	m_ControlCycleTime  = 0.01;
	m_SimulationCycleTime = 0.02;
	m_bResetForSimulation = false;
	m_GlobalPlanningTime = 0;
	m_LocalPlanningTime = 0;
	m_ControllingTime = 0;
	m_ObjectTrakingTime = 0;
	m_SimulationTime = 0;
	m_iCurrentGoal = 0;
	m_CarModel = 0;
	m_iStepNumber = 0;


	std::vector&lt;PlannerHNS::TrafficLight&gt; trafficLights;
	std::vector&lt;PlannerHNS::GPSPoint&gt; stopLines;
	PlannerHNS::RoadNetwork roadMap;

//	PlannerHNS::MappingHelpers::CreateKmlFromLocalizationPathFile(&quot;/home/user/Downloads/path1016_3.csv&quot;, 105, 1.5, trafficLights, stopLines);

	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(VectorMap, m_RoadMap);
//	string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+&quot;PlannerX_MapTemplate.kml&quot;;
//	PlannerHNS::MappingHelpers::WriteKML(&quot;/home/user/data/Moriyama2/map/kml/Moriyama_Test.kml&quot;,kml_templateFilePath , roadMap);

	//string kml_templateFilePath = UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmlTemplateFile;
	//string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+ &quot;ToyotaCityCustomInfo.kml&quot;;
	//PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);

	//PlannerHNS::MappingHelpers::LoadKML(kmlMapPath, m_RoadMap);

	//stop line : 554.318849669619908,183.992441420792119,31.8523999999999994
	//Traffic Light : 552.116878887182907,187.472750477604876,27.5702239999999996
	//Stop Line : 552.116878887182907,187.472750477604876,27.5702239999999996
	//TGraffic Light: 549.620514013766524,153.862837466717821,29.4425120000000007

	/**
	 * Writing the kml file for the RoadNetwork Map
	 */
//	ostringstream fileName;
//	fileName &lt;&lt; UtilityH::GetFilePrefixHourMinuteSeconds();
//	fileName &lt;&lt; &quot;_RoadNetwork.kml&quot;;
//	PlannerHNS::MappingHelpers::WriteKML(fileName.str(),UtilityH::GetHomeDirectory()+
//			DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmlTemplateFile, m_RoadMap);
//
//	PlannerHNS::StopLine st1, st2, st3, st4,st5,st6,st7;
//	st1.id = 1;
//	st1.stopSignID = 1;
//	st1.trafficLightID = -1;
//	st1.points.push_back(PlannerHNS::GPSPoint(102,-27.9,1.59,0));
//	st1.points.push_back(PlannerHNS::GPSPoint(105,-25.9,1.59,0));
//	PlannerHNS::WayPoint wp;
//	wp.pos = PlannerHNS::GPSPoint(102,-27.9,1.59,0);
//	st1.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap, 30);
//	if(st1.pLane)
//		st1.laneId = st1.pLane-&gt;id;
//
//	st2.id = 2;
//	st2.stopSignID = -1;
//	st2.trafficLightID = 1;
//	st2.points.push_back(PlannerHNS::GPSPoint(172,2.06,6,0));
//	st2.points.push_back(PlannerHNS::GPSPoint(174,-2.97,6,0));
//	wp.pos = PlannerHNS::GPSPoint(172,2.06,6,0);
//	st2.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
//	if(st2.pLane)
//		st2.laneId = st2.pLane-&gt;id;
//
//	st3.id = 3;
//	st3.stopSignID = -1;
//	st3.trafficLightID = 2;
//	st3.points.push_back(PlannerHNS::GPSPoint(257,46.7,20.5,0));
//	st3.points.push_back(PlannerHNS::GPSPoint(260,40,20.5,0));
//	wp.pos = PlannerHNS::GPSPoint(257,46.7,20.5,0);
//	st3.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
//	if(st3.pLane)
//		st3.laneId = st3.pLane-&gt;id;
//
//	st4.id = 4;
//	st4.stopSignID = 2;
//	st4.trafficLightID = -1;
//	st4.points.push_back(PlannerHNS::GPSPoint(311,69.3,34.4,0));
//	st4.points.push_back(PlannerHNS::GPSPoint(313,67,34.4,0));
//	wp.pos = PlannerHNS::GPSPoint(311,69.3,34.4,0);
//	st4.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
//	if(st4.pLane)
//		st4.laneId = st4.pLane-&gt;id;
//
//	st5.id = 5;
//	st5.stopSignID = 3;
//	st5.trafficLightID = -1;
//	st5.points.push_back(PlannerHNS::GPSPoint(250,31,18,0));
//	st5.points.push_back(PlannerHNS::GPSPoint(247,35,18,0));
//	wp.pos = PlannerHNS::GPSPoint(250,31,18,0);
//	st5.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
//	if(st5.pLane)
//		st5.laneId = st5.pLane-&gt;id;
//
//	st6.id = 6;
//	st6.stopSignID = -1;
//	st6.trafficLightID = 3;
//	st6.points.push_back(PlannerHNS::GPSPoint(127,-24.5,3,0));
//	st6.points.push_back(PlannerHNS::GPSPoint(125,-21.5,3,0));
//	wp.pos = PlannerHNS::GPSPoint(127,-24.5,3,0);
//	st6.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
//	if(st6.pLane)
//		st6.laneId = st6.pLane-&gt;id;
//
//	st7.id = 7;
//	st7.stopSignID = -1;
//	st7.trafficLightID = 4;
//	st7.points.push_back(PlannerHNS::GPSPoint(89.8,47.8,-2.0,0));
//	st7.points.push_back(PlannerHNS::GPSPoint(91.7,49.1,-2.0,0));
//	wp.pos = PlannerHNS::GPSPoint(89.8,47.8,-2.0,0);
//	st7.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
//	if(st7.pLane)
//		st7.laneId = st7.pLane-&gt;id;
//
//
//	PlannerHNS::TrafficLight t1, t2, t3, t4;
//	t1.id = 1;
//	t1.laneIds.push_back(st2.laneId);
//	t1.pLanes.push_back(st2.pLane);
//	t1.pos = PlannerHNS::GPSPoint(189,14.1,8.9,0);
//
//	t2.id = 2;
//	t2.laneIds.push_back(st3.laneId);
//	t2.pLanes.push_back(st3.pLane);
//	t2.pos = PlannerHNS::GPSPoint(268,50.8,21.9,0);
//
//	t3.id = 3;
//	t3.laneIds.push_back(st6.laneId);
//	t3.pLanes.push_back(st6.pLane);
//	t3.pos = PlannerHNS::GPSPoint(122,-29.6,-7.0,0);
//
//	t4.id = 4;
//	t4.laneIds.push_back(st7.laneId);
//	t4.pLanes.push_back(st7.pLane);
//	t4.pos = PlannerHNS::GPSPoint(88,56.7,-1.5,0);
//
//
//	m_RoadMap.trafficLights.push_back(t1);
//	m_RoadMap.trafficLights.push_back(t2);
//	m_RoadMap.trafficLights.push_back(t3);
//	m_RoadMap.trafficLights.push_back(t4);
//
//	m_RoadMap.stopLines.push_back(st1);
//	m_RoadMap.stopLines.push_back(st2);
//	m_RoadMap.stopLines.push_back(st3);
//	m_RoadMap.stopLines.push_back(st4);
//	m_RoadMap.stopLines.push_back(st5);
//	m_RoadMap.stopLines.push_back(st6);
//	m_RoadMap.stopLines.push_back(st7);


//	PlannerHNS::StopLine st_tsu_1, st_tsu2;
//	st_tsu_1.id = 1;
//	st_tsu_1.stopSignID = -1;
//	st_tsu_1.trafficLightID = 1;
//	st_tsu_1.points.push_back(PlannerHNS::GPSPoint(555.0,178.1,31.8,0));
//	st_tsu_1.points.push_back(PlannerHNS::GPSPoint(556.3,179.9,31.8,0));
//	PlannerHNS::WayPoint wp;
//	wp.pos = PlannerHNS::GPSPoint(555.0,178.1,31.8,0);
//	st_tsu_1.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap, 30);
//	if(st_tsu_1.pLane)
//		st_tsu_1.laneId = st_tsu_1.pLane-&gt;id;
//
//	st_tsu2.id = 2;
//	st_tsu2.stopSignID = -1;
//	st_tsu2.trafficLightID = 2;
//	st_tsu2.points.push_back(PlannerHNS::GPSPoint(551.2,197.6,26.6,0));
//	st_tsu2.points.push_back(PlannerHNS::GPSPoint(550.6,196.2,26.6,0));
//	wp.pos = PlannerHNS::GPSPoint(551.2,197.6,26.6,0);
//	st_tsu2.pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(wp,m_RoadMap);
//	if(st_tsu2.pLane)
//		st_tsu2.laneId = st_tsu2.pLane-&gt;id;
//
//	PlannerHNS::TrafficLight t1, t2, t3, t4;
//	t1.id = 1;
//	t1.laneIds.push_back(st_tsu_1.laneId);
//	t1.pLanes.push_back(st_tsu_1.pLane);
//	t1.pos = PlannerHNS::GPSPoint(553.5,214.6,26.6,0);
//
//	t2.id = 2;
//	t2.laneIds.push_back(st_tsu2.laneId);
//	t2.pLanes.push_back(st_tsu2.pLane);
//	t2.pos = PlannerHNS::GPSPoint(554.4,168.2,29.3,0);
//	m_RoadMap.trafficLights.push_back(t1);
//	m_RoadMap.trafficLights.push_back(t2);
//
//	m_RoadMap.stopLines.push_back(st_tsu_1);
//	m_RoadMap.stopLines.push_back(st_tsu2);
//
//	string kml_templateFilePath = UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmlTemplateFile;
//	string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+ &quot;TsukubaMapWithStopLines.kml&quot;;
//	PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);


	m_pMap = new PlannerHNS::GridMap(0,0,60,60,5.0, true);

	m_CarInfo.width = 2.0;
	m_CarInfo.length = 4.2;
	m_CarInfo.wheel_base = 2.5;
	m_CarInfo.turning_radius = 5.2;
	m_CarInfo.max_steer_angle = 0.5;

	// 6 -&gt; 8.3, 5 -&gt; 6.8 , 4 -&gt; 5.4 , 3 -&gt; 3.9, 2 -&gt; 2.6
	//1.3, 1.3, 1.35, 1.36, 1.38

	m_CarInfo.max_speed_forward = 3.0;

	m_CarInfo.min_speed_forward = 0.2;
	m_ControlParams.SteeringDelay = 1.2;
	m_ControlParams.minPursuiteDistance = 3.0;
	m_ControlParams.Steering_Gain = PlannerHNS::PID_CONST(0.07, 0.02, 0.001);
	m_ControlParams.maxAccel = 0.6;
	m_ControlParams.maxDecel = -1.0;

	m_PlanningParams.maxSpeed = 3.0;

	m_PlanningParams.minSpeed = 0.2;
	m_PlanningParams.microPlanDistance = 50;

	m_LocalPlanner.m_SimulationSteeringDelayFactor = m_ControlParams.SimulationSteeringDelay = 0;
	m_PlanningParams.smoothingDataWeight = 0.45;
	m_PlanningParams.smoothingSmoothWeight = 0.35;
	m_PlanningParams.smoothingToleranceError = 0.01;
	//m_PlanningParams.carTipMargin = 3.0;
	//m_PlanningParams.rollInMargin = 12.0;
	//m_PlanningParams.rollInSpeedFactor = 0.25;
	m_PlanningParams.pathDensity = 0.5;
	m_PlanningParams.rollOutDensity = 0.25;
	m_PlanningParams.rollOutNumber = 8;
	m_PlanningParams.horizonDistance = 200;
	m_PlanningParams.minFollowingDistance = 8.0;
	m_PlanningParams.minDistanceToAvoid = 16.0;
	m_PlanningParams.maxDistanceToAvoid = 6.0;
	m_PlanningParams.speedProfileFactor = 2.0;
	m_PlanningParams.horizonDistance = 0.2;
	m_PlanningParams.verticalSafetyDistance = 0.4;

	m_PlanningParams.enableSwerving = true;
	m_PlanningParams.enableFollowing = true;
	m_PlanningParams.enableTrafficLightBehavior = true;
	m_PlanningParams.enableStopSignBehavior = true;
	m_PlanningParams.enableLaneChange = false;

	m_LocalPlanner.Init(m_ControlParams, m_PlanningParams, m_CarInfo);
	m_LocalPlanner.InitPolygons();

	m_start =  PlannerHNS::MappingHelpers::GetFirstWaypoint(m_RoadMap);
	m_followX = m_start.pos.x;
	m_followY = m_start.pos.y;
	m_followZ = m_start.pos.z;
	m_followA = m_start.pos.a;

	m_bMakeNewPlan = false;

	double axes_color[3] = {0.1, 0.1, 0.8};
	double graph_color[3] = {0.9, 0.2, 0.1};
	m_pVelocityGraph = new Graph2dBase(20, 200,1000, 12, 0, &quot;Car Velocity&quot;, &quot;T s&quot;, &quot;V km/h&quot;, axes_color, graph_color );
	m_pSteeringGraph = new Graph2dBase(20, 200,1000, m_CarInfo.max_steer_angle*RAD2DEG, -m_CarInfo.max_steer_angle*RAD2DEG, &quot;Car Steering&quot;, &quot;T s&quot;, &quot;A deg&quot;, axes_color, graph_color );
	m_pLateralErrGraph  = new Graph2dBase(20, 200,1000, 1.0, -1.0, &quot;Lateral Error&quot;, &quot;T s&quot;, &quot;D meter&quot;, axes_color, graph_color );

	pthread_create(&amp;planning_thread_tid, NULL, &amp;PlannerTestDraw::PlanningThreadStaticEntryPoint, this);
	pthread_create(&amp;control_thread_tid, NULL, &amp;PlannerTestDraw::ControlThreadStaticEntryPoint, this);
	//pthread_create(&amp;simulation_thread_tid, NULL, &amp;PlannerTestDraw::SimulationThreadStaticEntryPoint, this);
	//InitStartAndGoal(2, -50, M_PI, 100, 100, M_PI_2);

	PrepareVectorMapForDrawing();


}

void PlannerTestDraw::InitStartAndGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2)
{
	m_start = PlannerHNS::WayPoint(x1, y1, 0, a1);
	//m_start = PlannerHNS::MappingHelpers::GetFirstWaypoint(m_RoadMap);
	PlannerHNS::WayPoint* pWS = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(m_start, m_RoadMap);
	if(pWS)
		m_start = *pWS;
	else
		cout &lt;&lt; &quot;#Planning Error: Start Position is too far from the road network map!&quot; &lt;&lt; endl;

	m_start.pos.z = 0;
	m_start.bDir = PlannerHNS::FORWARD_DIR;

	m_LocalPlanner.FirstLocalizeMe(m_start);

	/**
	 * Planning using goad point
	 */


	PlannerHNS::WayPoint gp(x2, y2, 0, a2);
	PlannerHNS::WayPoint* pW = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(gp, m_RoadMap);
	if(pW)
	{
		pW-&gt;bDir = PlannerHNS::FORWARD_DIR;
		m_goals.push_back(*pW);
	}
	else
		cout &lt;&lt; &quot;#Planning Error: Goal Position is too far from the road network map!&quot; &lt;&lt; endl;

	//try fixed goal positions :

//	PlannerHNS::WayPoint g1(557.1, 177.43, 0, 0);
//	PlannerHNS::WayPoint g2(553.03, 195.59, 0, 0);
//	PlannerHNS::WayPoint g3(-57.23, 60.67, 0, 0);
//
//	PlannerHNS::WayPoint* pW = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(g1, m_RoadMap);
//	if(pW)
//	{
//		//pW-&gt;pos = g1.pos;
//		pW-&gt;bDir = PlannerHNS::FORWARD_DIR;
//		m_goals.push_back(*pW);
//	}
//	else
//		cout &lt;&lt; &quot;#Planning Error: Goal Position is too far from the road network map!&quot; &lt;&lt; endl;
//
//	 pW = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(g2, m_RoadMap);
//	if(pW)
//	{
//		pW-&gt;bDir = PlannerHNS::FORWARD_DIR;
//		//pW-&gt;pos = g2.pos;
//		m_goals.push_back(*pW);
//	}
//	else
//		cout &lt;&lt; &quot;#Planning Error: Goal Position is too far from the road network map!&quot; &lt;&lt; endl;
//
//	pW = PlannerHNS::MappingHelpers::GetLastWaypoint(m_RoadMap);
//	if(pW)
//	{
//		//pW-&gt;pos = g3.pos;
//		pW-&gt;bDir = PlannerHNS::FORWARD_DIR;
//		m_goals.push_back(*pW);
//	}
//	else
//		cout &lt;&lt; &quot;#Planning Error: Goal Position is too far from the road network map!&quot; &lt;&lt; endl;


	m_bMakeNewPlan = true;

}

void PlannerTestDraw::SaveSimulationData()
{
	std::vector&lt;std::string&gt; simulationDataPoints;
	std::ostringstream startStr;
	startStr &lt;&lt; m_start.pos.x &lt;&lt; &quot;,&quot; &lt;&lt; m_start.pos.y &lt;&lt; &quot;,&quot; &lt;&lt; m_start.pos.z &lt;&lt; &quot;,&quot;
			&lt;&lt; m_start.pos.a &lt;&lt; &quot;,&quot; &lt;&lt; m_start.cost &lt;&lt; &quot;,&quot; &lt;&lt; m_start.v &lt;&lt; &quot;,&quot; ;
	simulationDataPoints.push_back(startStr.str());

	std::ostringstream goalStr;
	if(m_goals.size()&gt;0)
		goalStr &lt;&lt; m_goals.at(0).pos.x &lt;&lt; &quot;,&quot; &lt;&lt; m_goals.at(0).pos.y &lt;&lt; &quot;,&quot; &lt;&lt; m_goals.at(0).pos.z &lt;&lt; &quot;,&quot;
				&lt;&lt; m_goals.at(0).pos.a &lt;&lt; &quot;,&quot; &lt;&lt; m_goals.at(0).cost &lt;&lt; &quot;,&quot; &lt;&lt; m_goals.at(0).v &lt;&lt; &quot;,&quot; ;
	simulationDataPoints.push_back(goalStr.str());

	for(unsigned int i = 0; i &lt; m_SimulatedCars.size(); i++)
	{
		std::ostringstream carStr;
		carStr &lt;&lt; m_SimulatedCars.at(i).state.pos.x &lt;&lt; &quot;,&quot;
				&lt;&lt; m_SimulatedCars.at(i).state.pos.y &lt;&lt; &quot;,&quot;
				&lt;&lt; m_SimulatedCars.at(i).state.pos.z &lt;&lt; &quot;,&quot;
				&lt;&lt; m_SimulatedCars.at(i).state.pos.a &lt;&lt; &quot;,&quot;
				&lt;&lt; m_SimulatedCars.at(i).state.cost &lt;&lt; &quot;,&quot;
				&lt;&lt; m_SimulatedCars.at(i).m_CarInfo.max_speed_forward &lt;&lt; &quot;,&quot; ;
		simulationDataPoints.push_back(carStr.str());
	}

	DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::SimulationFolderName, &quot;SimulationFile&quot;,
				&quot;X,Y,Z,A,C,V,&quot;,	simulationDataPoints);
}

void PlannerTestDraw::LoadSimulationData()
{
	m_bCancelThread = true;
	PlannerTestDraw* pRet = 0;
	if(planning_thread_tid&gt;0)
		pthread_join(planning_thread_tid, (void**)&amp;pRet);
	if(control_thread_tid&gt;0)
		pthread_join(control_thread_tid, (void**)&amp;pRet);
	if(simulation_thread_tid&gt;0)
		pthread_join(simulation_thread_tid, (void**)&amp;pRet);

	m_LocalPlanner = PlannerHNS::LocalPlannerH();

	m_LocalPlanner.m_SimulationSteeringDelayFactor = m_ControlParams.SimulationSteeringDelay;
	m_LocalPlanner.Init(m_ControlParams, m_PlanningParams, m_CarInfo);
	m_LocalPlanner.InitPolygons();
	m_ActualPath.clear();

	string simuDataFileName = UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::SimulationFolderName + &quot;s1.csv&quot;;
	SimulationFileReader sfr(simuDataFileName);
	SimulationFileReader::SimulationData data;

	sfr.ReadAllData(data);
	InitStartAndGoal(data.startPoint.x, data.startPoint.y, data.startPoint.a,
			data.goalPoint.x, data.goalPoint.y, data.goalPoint.a);

	for(unsigned  int i=0; i &lt; data.simuCars.size(); i++)
	{
		AddSimulatedCar(data.simuCars.at(i).x, data.simuCars.at(i).y,
				data.simuCars.at(i).a, (6.0 + rand()%6)/3.6);
	}

	//m_bResetForSimulation = true;

	m_bCancelThread = false;
	pthread_create(&amp;planning_thread_tid, NULL, &amp;PlannerTestDraw::PlanningThreadStaticEntryPoint, this);
	pthread_create(&amp;control_thread_tid, NULL, &amp;PlannerTestDraw::ControlThreadStaticEntryPoint, this);
	pthread_create(&amp;simulation_thread_tid, NULL, &amp;PlannerTestDraw::SimulationThreadStaticEntryPoint, this);
}

void PlannerTestDraw::LoadMaterials()
{
	if(!m_CarModel)
		m_CarModel = DrawingHelpers::LoadModel(&quot;libs/data/porsche.obj&quot;);
}

PlannerTestDraw::~PlannerTestDraw()
{
	m_bCancelThread = true;
	PlannerTestDraw* pRet = 0;
	if(planning_thread_tid&gt;0)
		pthread_join(planning_thread_tid, (void**)&amp;pRet);
	if(control_thread_tid&gt;0)
		pthread_join(control_thread_tid, (void**)&amp;pRet);
	if(simulation_thread_tid&gt;0)
		pthread_join(simulation_thread_tid, (void**)&amp;pRet);

	if(m_pMap)
	{
		delete m_pMap;
		m_pMap = 0;
	}

}

bool PlannerTestDraw::IsInitState()
{
	if(m_LocalPlanner.m_TotalPath.size() &gt; 0)
		return false;
	else
		return true;
}

void PlannerTestDraw::UpdatePlaneStartGoal(const double&amp; x1,const double&amp; y1, const double&amp; a1, const double&amp; x2,const double&amp; y2, const double&amp; a2)
{
	InitStartAndGoal(x1, y1, a1, x2, y2, a2);
}

void PlannerTestDraw::DetectSimulatedObstacles(std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
{
	obj_list.clear();
	for(unsigned int i =0; i &lt; m_SimulatedCars.size(); i++)
	{
		PlannerHNS::DetectedObject ob;
		ob.id = 0;
		ob.l = m_SimulatedCars.at(i).m_CarInfo.length;
		ob.w = m_SimulatedCars.at(i).m_CarInfo.width;
		ob.center.pos = m_SimulatedCars.at(i).state.pos;
		ob.center.v = m_SimulatedCars.at(i).state.v;
		ob.contour = m_SimulatedCars.at(i).m_CarShapePolygon;
		ob.center.pLane = m_SimulatedCars.at(i).state.pLane;
		obj_list.push_back(ob);
	}
}

void PlannerTestDraw::AddSimulatedCarPos(const double&amp; x,const double&amp; y, const double&amp; a)
{
	double v  = 4.0;//(6.0 + rand()%6)/3.6;
	AddSimulatedCar(x,y,a,v);
}

void PlannerTestDraw::AddSimulatedCar(const double&amp; x,const double&amp; y, const double&amp; a, const double&amp; v)
{
	SimulatedCarState car;
	PlannerHNS::CAR_BASIC_INFO carInfo;
	PlannerHNS::ControllerParams params;


	carInfo.width  = 1.8;
	carInfo.length = 4.1;
	carInfo.max_speed_forward = v;
	carInfo.max_steer_angle = 0.42;
	carInfo.min_steer_angle = -0.42;
	carInfo.turning_radius = 4.0;
	carInfo.wheel_base = 2.0;

	params.Steering_Gain = PlannerHNS::PID_CONST(1.5, 0.0, 0.0);
	params.Velocity_Gain = PlannerHNS::PID_CONST(0.2, 0.05, 0.1);
	params.minPursuiteDistance = 3.0;


	car.Init(carInfo);
	car.InitPolygons();
	car.state.pos = PlannerHNS::GPSPoint(x,y,0,a);

	PlannerHNS::WayPoint* pWS = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(car.state, m_RoadMap);
	if(pWS)
	{
		car.pLane = pWS-&gt;pLane;
	}
	else
		cout &lt;&lt; &quot;#Planning Error: Start Position is too far from the road network map!&quot; &lt;&lt; endl;


	car.state.bDir = PlannerHNS::FORWARD_DIR;
	car.FirstLocalizeMe(car.state);

	pthread_mutex_lock(&amp;simulation_mutex);
	m_SimulatedCars.push_back(car);
	m_SimulatedBehaviors.push_back(PlannerHNS::BehaviorState());
	m_SimulatedVehicleState.push_back(PlannerHNS::VehicleState());
	m_SimulatedPrevTrajectory.push_back(vector&lt;PlannerHNS::WayPoint&gt;());
	SimulatedTrajectoryFollower pf;
	pf.Init(params, carInfo);
	m_SimulatedPathFollower.push_back(pf);
	pthread_mutex_unlock(&amp;simulation_mutex);
}

void PlannerTestDraw::Reset()
{
//	pthread_mutex_lock(&amp;planning_mutex);
//	m_LocalPlanner.m_Path.clear();
//	m_LocalPlanner.m_RollOuts.clear();
//	pthread_mutex_unlock(&amp;planning_mutex);
//
//	m_followX = m_start.pos.x;
//	m_followY = m_start.pos.y;
//	m_followZ = m_start.pos.z;
//	m_followA = m_start.pos.a;
//
//	m_bNewPath = false;
//
//	m_LocalPlanner.state = m_start;
//
//	pthread_mutex_lock(&amp;behaviors_mutex);
//	m_CurrentBehavior.state = INITIAL_STATE ;
//	pthread_mutex_unlock(&amp;behaviors_mutex);
}

void PlannerTestDraw::PrepareVectorMapForDrawing()
{
	double distance_to_nearest_lane = 1;
	int j=0;
	int max_number_of_lanes = 500;
	double width_ratio = 2.0;

	vector&lt;PlannerHNS::Lane*&gt; currLane;
	vector&lt;PlannerHNS::Lane*&gt; lanes_list;
	vector&lt;PlannerHNS::Lane*&gt; traversed_lanes;

	while(distance_to_nearest_lane &lt; 100 &amp;&amp; currLane.size() == 0)
	{
		PlannerHNS::Lane* pL = PlannerHNS::MappingHelpers::GetClosestLaneFromMap(m_start, m_RoadMap, distance_to_nearest_lane);
		if(pL)
			currLane.push_back(pL);
		distance_to_nearest_lane += 2;
	}

	if(currLane.size()==0)
	{
		if(m_RoadMap.roadSegments.size() &gt; 0)
			if(m_RoadMap.roadSegments.at(0).Lanes.size()&gt;0)
				currLane.push_back(&amp;m_RoadMap.roadSegments.at(0).Lanes.at(0));
	}

	for(unsigned int i=0; i&lt; currLane.size(); i++)
		lanes_list.push_back(currLane[i]);

	m_ReadyToDrawLanes.clear();
	m_ReadyToDrawCenterLines.clear();
//	m_TrafficLights.clear();
//	m_StopSigns.clear();
//	m_OtherSigns.clear();

	if(currLane.size() &gt; 0)
	{
		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; ready_to_draw;

		while(lanes_list.size()&gt;0 &amp;&amp; j &lt;max_number_of_lanes)
		{
			ready_to_draw.clear();
			PlannerHNS::Lane* l = lanes_list.at(0);
			lanes_list.erase(lanes_list.begin()+0);
			traversed_lanes.push_back(l);


			vector&lt;PlannerHNS::WayPoint&gt; path_local = l-&gt;points;

			DrawingHelpers::PreparePathForDrawing(path_local,ready_to_draw, 2.8 / width_ratio);
			m_ReadyToDrawLanes.push_back(ready_to_draw);

			ready_to_draw.clear();
			DrawingHelpers::PreparePathForDrawing(path_local,ready_to_draw, 0.1);
			m_ReadyToDrawCenterLines.push_back(ready_to_draw);

			j++;

			PlannerHNS::MappingHelpers::GetUniqueNextLanes(l, traversed_lanes, lanes_list);

			//Get the traffic lights pos
//			for(unsigned int itl = 0; itl &lt; l-&gt;trafficLights.size(); itl++)
//			{
//
//				Vector2D p(l-&gt;trafficLights[itl]-&gt;position.x, l-&gt;trafficLights[itl]-&gt;position.y, l-&gt;trafficLights[itl]-&gt;position.z,0);
//				int iNextIndex = MappingHelpers::GetClosestNextPointIndex(path_local, p);
//				if(iNextIndex &gt; 0)
//					p.a = MathUtil::AngleBetweenVectorsPositive(path_local.at(iNextIndex), path_local.at(iNextIndex-1));
//				else
//					p.a = MathUtil::AngleBetweenVectorsPositive(path_local.at(iNextIndex+1), path_local.at(iNextIndex));
//
//				m_TrafficLights.push_back(p);
//			}
//
//			for(unsigned int itl = 0; itl &lt; l-&gt;roadSigns.size(); itl++)
//			{
//				Vector2D p(l-&gt;roadSigns[itl]-&gt;position.x, l-&gt;roadSigns[itl]-&gt;position.y, l-&gt;roadSigns[itl]-&gt;position.z,0);
//				int iNextIndex = MappingHelpers::GetClosestNextPointIndex(path_local, p);
//				if(iNextIndex &gt; 0)
//					p.a = MathUtil::AngleBetweenVectorsPositive(path_local.at(iNextIndex), path_local.at(iNextIndex-1));
//				else
//					p.a = MathUtil::AngleBetweenVectorsPositive(path_local.at(iNextIndex+1), path_local.at(iNextIndex));
//
//				if(l-&gt;roadSigns[itl]-&gt;signtype == STOP_SIGN)
//					m_StopSigns.push_back(p);
//				else if(l-&gt;roadSigns[itl]-&gt;signtype == STOP_LINE)
//				{
//					vector&lt;Vector2D&gt; path_temp;
//					for(unsigned int k=0; k&lt; l-&gt;roadSigns[itl]-&gt;points.size(); k++)
//					{
//						path_temp.push_back(Vector2D(l-&gt;roadSigns[itl]-&gt;points.at(k).x, l-&gt;roadSigns[itl]-&gt;points.at(k).y, l-&gt;roadSigns[itl]-&gt;points.at(k).z,p.a));
//					}
//					m_StopLines.push_back(path_temp);
//				}
//				else
//					m_OtherSigns.push_back(p);
//			}
		}
	}
}

void PlannerTestDraw::DrawVectorMap()
{
	glDisable(GL_LIGHTING);
	float PathColor[3];
	float Color1[3]; Color1[0] = 1.0; Color1[1] = 204.0/256.0; Color1[2] = 51.0/256.0;
	float Color2[3]; Color2[0] = 1.0; Color2[1] = 102.0/256.0; Color2[2] = 51.0/256.0;
	float Color3[3]; Color3[0] = 1.0; Color3[1] = 51.0/256.0;  Color3[2] = 102.0/256.0;
	float Color4[3]; Color4[0] = 204.0/256.0; Color4[1] = 51.0/256.0; Color4[2] = 1.0;

	const float mapdata_z = 0.005;

	for(unsigned int i=0; i&lt;m_ReadyToDrawLanes.size(); i++)
	{
		//PathColor[0]=0.5;PathColor[1] = j/20.0; PathColor[2] = j;
		if(i==0)
		{
			PathColor[0]=0.25 ;PathColor[1] = 0.25; PathColor[2] = 0.25;
		}
		else
		{
			double inc_color = (double)i/25.0;
			PathColor[0]=0.25 + inc_color; ;PathColor[1] = 0.25+inc_color; PathColor[2] = 0.25 + inc_color;
		}

		//PathColor[0]=0.25 ;PathColor[1] = 0.25; PathColor[2] = 0.25;
		if(i%4 == 0)
		{
			PathColor[0] = Color1[0]; PathColor[1] = Color1[1]; PathColor[2] = Color1[2];
		}
		else if(i%4 == 1)
		{
			PathColor[0] = Color2[0]; PathColor[1] = Color2[1]; PathColor[2] = Color2[2];
		}
		else if(i%4 == 2)
		{
			PathColor[0] = Color3[0]; PathColor[1] = Color3[1]; PathColor[2] = Color3[2];
		}
		else if(i%4 == 3)
		{
			PathColor[0] = Color4[0]; PathColor[1] = Color4[1]; PathColor[2] = Color4[2];
		}

		PathColor[0] = PathColor[0]*0.15;
		PathColor[1] = PathColor[1]*0.95;
		PathColor[2] = PathColor[2]*0.95;
		PathColor[0]=0.4;PathColor[1] = 0.4; PathColor[2] = 0.4;
		//DrawingHelpers::DrawPrePreparedPolygons(m_ReadyToDrawLanes[i], mapdata_z, PathColor);

		PathColor[0]=0.1;PathColor[1] = 0.1; PathColor[2] = 0.1;
		DrawingHelpers::DrawPrePreparedPolygons(m_ReadyToDrawCenterLines[i], mapdata_z+0.015, PathColor, 1);
	}

	glEnable(GL_LIGHTING);
}

void PlannerTestDraw::DrawSimu()
{

	m_followX = m_LocalPlanner.state.pos.x;
	m_followY = m_LocalPlanner.state.pos.y;
	m_followZ = m_LocalPlanner.state.pos.z;
	m_followA = m_LocalPlanner.state.pos.a;

	DrawVectorMap();

	//	if(m_pMap)
	//		DrawingHelpers::DrawGrid(m_pMap-&gt;origin_x, m_pMap-&gt;origin_y, m_pMap-&gt;w, m_pMap-&gt;h, m_pMap-&gt;cell_l);

	DrawPaths();
	DrawStartsAndGoals();
	DrawCarModels();
	DrawAdditionalDebugInfo();
	DrawTrafficInfo_StopLines_Lights();
}

void PlannerTestDraw::DrawAdditionalDebugInfo()
{
	glColor3f(1,0,0);
	DrawingHelpers::DrawFilledEllipse(m_FollowPoint.x, m_FollowPoint.y, 0.2, 0.2, 0.2);

	glColor3f(0,0,1);
	DrawingHelpers::DrawFilledEllipse(m_PerpPoint.x, m_PerpPoint.y, 0.2, 0.2, 0.2);
}

void PlannerTestDraw::DrawStartsAndGoals()
{
	for(unsigned int i=0 ; i &lt; m_goals.size(); i++)
	{
		glColor3f(1,0,1);
		DrawingHelpers::DrawFilledEllipse(m_goals.at(i).pos.x, m_goals.at(i).pos.y, 1.2, 0.2,0.2);
		DrawingHelpers::DrawArrow(m_goals.at(i).pos.x+2.5, m_goals.at(i).pos.y, m_goals.at(i).pos.a);
	}
}

void PlannerTestDraw::DrawTrafficInfo_StopLines_Lights()
{
	//Draw Traffic Light :
	glDisable(GL_LIGHTING);
	for(unsigned int i=0 ; i &lt; m_RoadMap.trafficLights.size(); i++)
	{
		glPushMatrix();
		if(m_bGreenTrafficLight)
			glColor3f(0.3,0,0);
		else
			glColor3f(1,0,0);
		glTranslated(m_RoadMap.trafficLights.at(i).pos.x, m_RoadMap.trafficLights.at(i).pos.y, 1);
		glRotated(m_RoadMap.trafficLights.at(i).pos.a*RAD2DEG, 0,0,1);
		glRotated(90, 1,0,0);
		glTranslated(-m_RoadMap.trafficLights.at(i).pos.x, -m_RoadMap.trafficLights.at(i).pos.y, -1);
		DrawingHelpers::DrawFilledEllipse(m_RoadMap.trafficLights.at(i).pos.x, m_RoadMap.trafficLights.at(i).pos.y, 1, 0.5,0.5);
		if(m_bGreenTrafficLight)
			glColor3f(0,1,0);
		else
			glColor3f(0,0.3,0);
		DrawingHelpers::DrawFilledEllipse(m_RoadMap.trafficLights.at(i).pos.x+1.2, m_RoadMap.trafficLights.at(i).pos.y, 1, 0.5,0.5);
		glPopMatrix();

//		glPushMatrix();
//		glTranslated(m_RoadMap.trafficLights.at(i).pos.x, m_RoadMap.trafficLights.at(i).pos.y, 1.5);
//		std::ostringstream str_out ;
//		str_out.precision(4);
//		str_out &lt;&lt; &quot;TFID: &quot;&lt;&lt; m_RoadMap.trafficLights.at(i).id;
//		DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
//		glPopMatrix();
	}

	for(unsigned int i=0 ; i &lt; m_RoadMap.stopLines.size(); i++)
	{
		float stop_line_Color[3] = {0.8, 0.99, 0.99};
		vector&lt;PlannerHNS::WayPoint&gt; line_points;
		for(unsigned int islp = 0; islp &lt; m_RoadMap.stopLines.at(i).points.size(); islp++)
		{
			PlannerHNS::WayPoint wp;
			wp.pos = m_RoadMap.stopLines.at(i).points.at(islp);
			line_points.push_back(wp);
		}
		DrawingHelpers::DrawWidePath(line_points, 0.2, 0.15, stop_line_Color);
		PlannerHNS::GPSPoint p;
		if(m_RoadMap.stopLines.at(i).points.size() &gt; 1)
		{
			p.x = (m_RoadMap.stopLines.at(i).points.at(0).x + m_RoadMap.stopLines.at(i).points.at(1).x)/2.0;
			p.y = (m_RoadMap.stopLines.at(i).points.at(0).y + m_RoadMap.stopLines.at(i).points.at(1).y)/2.0;
		}

//		glPushMatrix();
//		glTranslated(p.x, p.y, 1.5);
//		std::ostringstream str_out ;
//		str_out.precision(4);
//		str_out &lt;&lt; &quot;SLID: &quot;&lt;&lt; m_RoadMap.stopLines.at(i).id;
//		glColor3f(0,1,0);
//		DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
//		glPopMatrix();
	}

//	if(m_RoadMap.roadSegments.size()&gt;0)
//	{
//		for(unsigned int i=0 ; i &lt; m_RoadMap.roadSegments.at(0).Lanes.size(); i++)
//		{
//			if(m_RoadMap.roadSegments.at(0).Lanes.at(i).points.size() &gt; 0)
//			{
//				PlannerHNS::GPSPoint p = m_RoadMap.roadSegments.at(0).Lanes.at(i).points.at(m_RoadMap.roadSegments.at(0).Lanes.at(i).points.size()/2).pos;
//				glPushMatrix();
//				glTranslated(p.x, p.y, 1.5);
//				std::ostringstream str_out ;
//				str_out.precision(4);
//				str_out &lt;&lt; &quot;LID: &quot;&lt;&lt; m_RoadMap.roadSegments.at(0).Lanes.at(i).id;
//				glColor3f(1,0,0);
//				DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
//				glPopMatrix();
//			}
//		}
//	}

	glEnable(GL_LIGHTING);
}

void PlannerTestDraw::DrawCarModels()
{
	glDisable(GL_LIGHTING);
	for(unsigned int i =0; i &lt;m_dummyObstacles.size(); i++)
	{
		float CarColor[3] = {0.9, 0.1, 0.9};
		DrawingHelpers::DrawCustomCarModel(m_dummyObstacles.at(i).center, 0,m_LocalPlanner.m_CarShapePolygon, CarColor, 90);
		//std::cout &lt;&lt; &quot; &gt;&gt;&gt; Calculated Angle : &quot; &lt;&lt; (m_dummyObstacles.at(i).center.pos.a*RAD2DEG + 90)*DEG2RAD &lt;&lt; std::endl;
		glPushMatrix();
		glTranslated(m_dummyObstacles.at(i).center.pos.x, m_dummyObstacles.at(i).center.pos.y, 1.3);
		std::ostringstream str_out ;
		str_out.precision(4);
		str_out &lt;&lt;  m_dummyObstacles.at(i).center.v *3.6;
		DrawingHelpers::DrawString(0, 0,
				GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
		glPopMatrix();
	}

	float CarColor[3] = {0.1, 0.9, 0.9};

	pthread_mutex_lock(&amp;simulation_mutex);
	for(unsigned int i =0; i &lt;m_SimulatedCars.size(); i++)
	{
		DrawingHelpers::DrawCustomCarModel(m_SimulatedCars.at(i).state, m_SimulatedVehicleState.at(i).steer, m_LocalPlanner.m_CarShapePolygon, CarColor, 90);
//
//		glPushMatrix();
//		glTranslated(m_SimulatedCars.at(i).state.pos.x, m_SimulatedCars.at(i).state.pos.y, 1.3);
//		std::ostringstream str_out ;
//		str_out.precision(2);
//		str_out &lt;&lt;  m_SimulatedVehicleState.at(i).speed *3.6;
//		DrawingHelpers::DrawString(0, 1,
//				GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
//		glPopMatrix();

		float TotalPathColor[3] = {0.5, 0.0, 0.99};
		DrawingHelpers::DrawWidePath(m_SimulatedCars.at(i).m_TotalPath, 0.08, 0.15, TotalPathColor);

//		for(unsigned int ii = 0; ii &lt; m_SimulatedCars.at(i).m_TotalPath.size(); ii++ )
//		{
//			if(m_SimulatedCars.at(i).m_TotalPath.at(ii).collisionCost &gt;= 1)
//				glColor3f(1, 0, 0);
//			else
//				glColor3f(TotalPathColor[0], TotalPathColor[1], TotalPathColor[2]);
//			DrawingHelpers::DrawSimpleEllipse(m_SimulatedCars.at(i).m_TotalPath.at(ii).pos.x,
//					m_SimulatedCars.at(i).m_TotalPath.at(ii).pos.y, 0.25, 1.0, 1.0);
//
//
//		}
	}
	pthread_mutex_unlock(&amp;simulation_mutex);

	if(m_CarModel)
	{
//		DrawingHelpers::DrawModel(m_CarModel, m_LocalPlanner.m_CarInfo.wheel_base *0.9,
//				m_LocalPlanner.m_CarInfo.wheel_base*0.9, m_LocalPlanner.m_CarInfo.wheel_base*0.9,
//				m_LocalPlanner.state.pos.x,m_LocalPlanner.state.pos.y,
//				m_LocalPlanner.state.pos.z+0.275, m_LocalPlanner.state.pos.a, 0,0);
	}

	DrawingHelpers::DrawCustomCarModel(m_LocalPlanner.state, m_LocalPlanner.m_CurrentSteering , m_LocalPlanner.m_CarShapePolygon, CarColor, 90);

	glEnable(GL_LIGHTING);
}

void PlannerTestDraw::DrawPaths()
{
	float TotalPathColor[3] = {0.99, 0.2, 0.2};
	float PlannedPathColor[3] = {0.9, 0.1, 0.9};
	float ActualPathColor[3] = {0.1, 0.1, 0.9};
	float RollOutsColor[3] = {0.1, 0.9, 0.1};

	glDisable(GL_LIGHTING);
	pthread_mutex_lock(&amp;planning_mutex);

	if(m_iStepNumber%4 == 0)
	{
		DrawingHelpers::DrawWidePath(m_LocalPlanner.m_PathSection, 0.08, 0.25, TotalPathColor);

		//DrawingHelpers::DrawCostPath(m_all_cell_to_delete, 0.5, 0.5);

	}
	else if(m_iStepNumber%4 == 1)
	{
		for(unsigned int i = 0; i &lt; m_LocalPlanner.m_SampledPoints.size(); i++)
			{
				glPointSize(8);
				glBegin(GL_POINTS);
					glColor3f(0.1,0.9,0.1);
					glVertex3f(m_LocalPlanner.m_SampledPoints.at(i).pos.x, m_LocalPlanner.m_SampledPoints.at(i).pos.y, 0.21);
				glEnd();
				glPointSize(1);
			}
	}
	else if(m_iStepNumber%4 == 2)
	{

	for(unsigned int i=0; i&lt; m_LocalPlanner.m_TotalPath.size(); i++)
		DrawingHelpers::DrawWidePath(m_LocalPlanner.m_TotalPath.at(i), 0.08, 0.1, TotalPathColor);

	DrawingHelpers::DrawWidePath(m_LocalPlanner.m_Path, 0.16, 0.06, PlannedPathColor);
	DrawingHelpers::DrawWidePath(m_ActualPath, 0.1, 0.15, ActualPathColor);

	for(unsigned int i = 0; i &lt; m_LocalPlanner.m_Path.size(); i+=2 )
	{
//		if(m_LocalPlanner.m_Path.at(i).collisionCost &gt;= 1)
//		{
//			glColor3f(1, 0, 0);
//			float collisionColor[3] = {1, 0, 0};
//			DrawingHelpers::DrawWideEllipse(m_LocalPlanner.m_Path.at(i).pos.x,
//					m_LocalPlanner.m_Path.at(i).pos.y, 0.2, 1.0, 1.0, 0.8, collisionColor);
//		}
//		else
//		{
//			glColor3f(PlannedPathColor[0], PlannedPathColor[1], PlannedPathColor[2]);
//			DrawingHelpers::DrawSimpleEllipse(m_LocalPlanner.m_Path.at(i).pos.x,
//					m_LocalPlanner.m_Path.at(i).pos.y, 0.2, 1.0, 1.0);
//		}

//		glPointSize(10);
//		glBegin(GL_POINTS);
//			glColor3f(0,0,1);
//			glVertex3f(m_LocalPlanner.m_Path.at(i).pos.x, m_LocalPlanner.m_Path.at(i).pos.y, 0.21);
//		glEnd();
//		glPointSize(1);

//		glPushMatrix();
//		glTranslated(m_LocalPlanner.m_Path.at(i).pos.x, m_LocalPlanner.m_Path.at(i).pos.y, 0.25);
//		std::ostringstream str_out ;
//		str_out.precision(4);
//		str_out &lt;&lt;  m_LocalPlanner.m_Path.at(i).timeCost;
//		glColor3f(1,0.9,1);
//		DrawingHelpers::DrawString(0, 0,
//				GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
//		glPopMatrix();
	}


	for(unsigned int li=0; li &lt; m_LocalPlanner.m_RollOuts.size();li++)
	{
		for(unsigned int ti=0; ti &lt; m_LocalPlanner.m_RollOuts.at(li).size(); ti++)
		{
			DrawingHelpers::DrawWidePath(m_LocalPlanner.m_RollOuts.at(li).at(ti), 0.14, 0.06, RollOutsColor);

			for(unsigned int i = 0; i &lt; m_LocalPlanner.m_RollOuts.at(li).at(ti).size(); i+=2 )
			{
//				if(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).collisionCost &gt;= 1)
//				{
//					glColor3f(1, 0, 0);
//					float collisionColor[3] = {1, 0, 0};
//					DrawingHelpers::DrawWideEllipse(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.x,
//							m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.y, 0.2, 1.0, 1.0, 0.8, collisionColor);
//				}
//				else
//				{
//					glColor3f(PlannedPathColor[0], PlannedPathColor[1], PlannedPathColor[2]);
//					DrawingHelpers::DrawSimpleEllipse(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.x,
//							m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.y, 0.2, 1.0, 1.0);
//				}

//				glDisable(GL_LIGHTING);
//				glPointSize(10);
//				glBegin(GL_POINTS);
//				int j_dec = 0;
//				int r_inc = i*8;
//				if(r_inc &gt; 255)
//				{
//					//j_dec = i*5 - 255;
//					r_inc = 255;
//				}
//					//glColor3ub(r_inc,255-j_dec,0);
//					glVertex3f(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.x, m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.y, 0.21);
//				glEnd();
//				glPointSize(1);

//				glPushMatrix();
//				glTranslated(m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.x, m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).pos.y, 0.25);
//				std::ostringstream str_out ;
//				str_out.precision(4);
//				str_out &lt;&lt;  m_LocalPlanner.m_RollOuts.at(li).at(ti).at(i).timeCost;
//				glColor3f(1,0.9,1);
//				DrawingHelpers::DrawString(0, 0,
//						GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
//				glPopMatrix();
			}
		}
	}



//	for(unsigned int ii = 0; ii &lt; m_LocalPlanner.m_PredictedPath.size(); ii++ )
//	{
//		DrawingHelpers::DrawWidePath(m_LocalPlanner.m_PredictedPath.at(ii), 0.08, 0.25, TotalPathColor);
//
//		for(unsigned int k = 0; k &lt; m_LocalPlanner.m_PredictedPath.at(ii).size(); k++ )
//		{
//			if(m_LocalPlanner.m_PredictedPath.at(ii).at(k).collisionCost &gt;= 1)
//				glColor3f(1, 0, 0);
//			else
//				glColor3f(TotalPathColor[0], TotalPathColor[1], TotalPathColor[2]);
//			DrawingHelpers::DrawSimpleEllipse(m_LocalPlanner.m_PredictedPath.at(ii).at(k).pos.x,
//					m_LocalPlanner.m_PredictedPath.at(ii).at(k).pos.y, 0.25, 1.0, 1.0);
//
//			glPushMatrix();
//			glTranslated(m_LocalPlanner.m_PredictedPath.at(ii).at(k).pos.x, m_LocalPlanner.m_PredictedPath.at(ii).at(k).pos.y, 0.25);
//			std::ostringstream str_out ;
//			str_out.precision(4);
//			str_out &lt;&lt;  m_LocalPlanner.m_PredictedPath.at(ii).at(k).timeCost;
//			glColor3f(1,0.9,1);
//			DrawingHelpers::DrawString(0, 0,
//					GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
//			glPopMatrix();
//		}
//
//	}

	}
	pthread_mutex_unlock(&amp;planning_mutex);
	glEnable(GL_LIGHTING);
}

void PlannerTestDraw::DrawInfo(const int&amp; centerX, const int&amp; centerY, const int&amp; maxX, const int&amp; maxY)
{
	double left_shift = 25;
	glDisable(GL_LIGHTING);
	glPushMatrix();
	glTranslated(centerX-left_shift, 70, 0);
	glRotated(-1*m_VehicleCurrentState.steer*RAD2DEG*16, 0,0,1);
	glTranslated(-(centerX-left_shift), -70, 0);

	float wheel_color[3] = {0.6, 0.7, 0.8};
	DrawingHelpers::DrawWideEllipse(centerX-left_shift, 70, 0.5, 60, 55, 54, wheel_color);

	glColor3f(0.5,0.4, 0.3);
	PlannerHNS::GPSPoint p1(centerX-left_shift, 70, 0.52, 0), p2(centerX-left_shift+38, 70-38, 0.52, 0);
	DrawingHelpers::DrawLinePoygonline(p1, p2, 5);

	PlannerHNS::GPSPoint p11(centerX-left_shift, 70, 0.52, 0), p22(centerX-left_shift-38, 70-38, 0.52, 0);
	DrawingHelpers::DrawLinePoygonline(p11, p22, 5);

	PlannerHNS::GPSPoint p111(centerX-left_shift, 70, 0.52, 0), p222(centerX-left_shift, 70+52, 0.52, 0);
	DrawingHelpers::DrawLinePoygonline(p111, p222, 5);
	glPopMatrix();

	double speed = m_VehicleCurrentState.speed*3.6;
	float pedal_color[3] = {0.5,0.4, 0.3};
	glColor3f(wheel_color[0],wheel_color[1],wheel_color[2]);
	DrawingHelpers::DrawPedal(centerX + 70, 70, 0, 30.0, 100.0, speed*5.5,pedal_color );

	glPushMatrix();
	glTranslated(centerX-left_shift-15, 70+85, 0);
	glColor3f(0.8, 0.1, 0.7);
	std::ostringstream str_out ;
	str_out.precision(2);
	str_out &lt;&lt;  m_VehicleCurrentState.steer*RAD2DEG;
	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)str_out.str().c_str());
	glPopMatrix();

	glPushMatrix();
	glTranslated(centerX+60, 70+85, 0);
	glColor3f(0.8, 0.1, 0.7);
	std::ostringstream v_out ;
	v_out.precision(2);
	v_out &lt;&lt;  speed;
	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)v_out.str().c_str());
	glPopMatrix();

	glEnable(GL_LIGHTING);
//
//	INITIAL_STATE, WAITING_STATE, FORWARD_STATE, STOPPING_STATE, EMERGENCY_STATE,
//		TRAFFIC_LIGHT_STOP_STATE, STOP_SIGN_STOP_STATE, FOLLOW_STATE, LANE_CHANGE_STATE, OBSTACLE_AVOIDANCE_STATE, FINISH_STATE

	std::ostringstream state_out ;
	state_out.precision(4);
	state_out &lt;&lt; &quot;State-&gt; &quot;;
	string str = &quot;Unknown&quot;;
	switch(m_CurrentBehavior.state)
	{
	case PlannerHNS::INITIAL_STATE:
		str = &quot;Init&quot;;
		break;
	case PlannerHNS::WAITING_STATE:
		str = &quot;Waiting&quot;;
		break;
	case PlannerHNS::FORWARD_STATE:
		str = &quot;Forward&quot;;
		break;
	case PlannerHNS::STOPPING_STATE:
		str = &quot;Stop&quot;;
		break;
	case PlannerHNS::FINISH_STATE:
		str = &quot;End&quot;;
		break;
	case PlannerHNS::FOLLOW_STATE:
		str = &quot;Follow&quot;;
		break;
	case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
		str = &quot;Swerving&quot;;
		break;
	case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
		str = &quot;Light Stop&quot;;
		break;
	case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
		str = &quot;Light Wait&quot;;
		break;
	case PlannerHNS::STOP_SIGN_STOP_STATE:
		str = &quot;Sign Stop&quot;;
		break;
	case PlannerHNS::STOP_SIGN_WAIT_STATE:
		str = &quot;Sign Wait&quot;;
		break;
	default:
		str = &quot;Unknown&quot;;
		break;
	}
	state_out &lt;&lt; str;
	state_out &lt;&lt; &quot; (&quot; &lt;&lt; m_CurrentBehavior.followDistance &lt;&lt; &quot;;&quot;
			&lt;&lt; m_CurrentBehavior.followVelocity*3.6 &lt;&lt; &quot;;&quot;
			&lt;&lt; m_CurrentBehavior.stopDistance &lt;&lt; &quot;;&quot;
			&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &lt;&lt; &quot;;&quot;
			&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iPrevSafeTrajectory &lt;&lt; &quot;)&quot;;

	double verticalTranslation = 200;
	glPushMatrix();
	glColor3f(0.8, 0.5, 0.7);
	glTranslated(10, verticalTranslation, 0);
	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)state_out.str().c_str());

	double y = 30;
	for(unsigned int i = 0; i &lt; m_dummyObstacles.size(); i++)
	{
		std::ostringstream sim_n_out ;
		sim_n_out &lt;&lt; &quot;Simu Car (:&quot; &lt;&lt; m_dummyObstacles.at(i).id &lt;&lt; &quot;) -&gt; &quot;;
		sim_n_out &lt;&lt; m_dummyObstacles.at(i).center.v;
		glColor3f(0.6, 0.6, 0.9);
		DrawingHelpers::DrawString(0, y, GLUT_BITMAP_TIMES_ROMAN_24, (char*)sim_n_out.str().c_str());
		y+=30;
	}

	glPopMatrix();

//	glPushMatrix();
//	verticalTranslation += 300;
//	glTranslated(10, verticalTranslation, 0);
//	if(m_pVelocityGraph)
//	{
//		double axes_color[3] = {0.1, 0.1, 0.8};
//		double graph_color[3] = {0.9, 0.2, 0.1};
//		m_pVelocityGraph-&gt;ReInitGraphResolution(maxX-20, 200,1000, axes_color, graph_color );
//		//if(m_VehicleCurrentState.speed&gt;0)
//		{
//			m_pVelocityGraph-&gt;InsertPointTimeStamp(m_VehicleCurrentState.tStamp, m_VehicleCurrentState.speed*3.6);
//		}
//		m_pVelocityGraph-&gt;DrawGraph();
//	}
//	glPopMatrix();
//
//	glPushMatrix();
//	verticalTranslation+=250;
//	glTranslated(10, verticalTranslation, 0);
//	if(m_pSteeringGraph)
//	{
//		double axes_color[3] = {0.1, 0.1, 0.8};
//		double graph_color[3] = {0.9, 0.2, 0.1};
//		m_pSteeringGraph-&gt;ReInitGraphResolution(maxX-20, 200,1000, axes_color, graph_color );
//		//if(m_VehicleCurrentState.steer&gt;0)
//		{
//			m_pSteeringGraph-&gt;InsertPointTimeStamp(m_VehicleCurrentState.tStamp, m_VehicleCurrentState.steer*RAD2DEG);
//		}
//		m_pSteeringGraph-&gt;DrawGraph();
//	}
//	glPopMatrix();
//
//	glPushMatrix();
//	verticalTranslation+=250;
//	glTranslated(10, verticalTranslation, 0);
//	if(m_pLateralErrGraph)
//	{
//		double axes_color[3] = {0.1, 0.1, 0.8};
//		double graph_color[3] = {0.9, 0.2, 0.1};
//		m_pLateralErrGraph-&gt;ReInitGraphResolution(maxX-20, 200,1000, axes_color, graph_color );
//		//if(m_VehicleCurrentState.steer&gt;0)
//		{
//			m_pLateralErrGraph-&gt;InsertPointTimeStamp(m_VehicleCurrentState.tStamp, m_LateralError);
//		}
//		m_pLateralErrGraph-&gt;DrawGraph();
//	}
//	glPopMatrix();

	glPushMatrix();
	std::ostringstream performance_str ;
	performance_str.precision(6);
	glColor3f(0.8, 0.5, 0.7);
	verticalTranslation+=250;
	glTranslated(10, verticalTranslation, 0);
	performance_str &lt;&lt; 				&quot;DP Time 		= &quot;;
	performance_str &lt;&lt; m_GlobalPlanningTime;
	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)performance_str.str().c_str());
	glPopMatrix();
	glPushMatrix();
	std::ostringstream local_performance_str ;
	local_performance_str.precision(6);
	glColor3f(0.8, 0.5, 0.7);
	verticalTranslation+=30;
	glTranslated(10, verticalTranslation, 0);
	local_performance_str &lt;&lt; 		&quot;Local Planner 	= &quot;;
	local_performance_str &lt;&lt; m_LocalPlanningTime;
	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)local_performance_str.str().c_str());
	glPopMatrix();
	glPushMatrix();
	std::ostringstream track_performance_str ;
	track_performance_str.precision(6);
	glColor3f(0.8, 0.5, 0.7);
	verticalTranslation+=30;
	glTranslated(10, verticalTranslation, 0);
	track_performance_str &lt;&lt; 		&quot;Tracking Timer	= &quot;;
	track_performance_str &lt;&lt; m_ObjectTrakingTime;
	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)track_performance_str.str().c_str());
	glPopMatrix();
	glPushMatrix();
	std::ostringstream control_performance_str ;
	control_performance_str.precision(6);
	glColor3f(0.8, 0.5, 0.7);
	verticalTranslation+=30;
	glTranslated(10, verticalTranslation, 0);
	control_performance_str &lt;&lt; 		&quot;Control Time	= &quot;;
	control_performance_str &lt;&lt; m_ControllingTime;
	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)control_performance_str.str().c_str());
	glPopMatrix();
	glPushMatrix();
	std::ostringstream simu_performance_str ;
	simu_performance_str.precision(6);
	glColor3f(0.8, 0.5, 0.7);
	verticalTranslation+=30;
	glTranslated(10, verticalTranslation, 0);
	simu_performance_str &lt;&lt; 		&quot;Simu Time 		= &quot;;
	simu_performance_str &lt;&lt; m_SimulationTime;
	DrawingHelpers::DrawString(0, 0, GLUT_BITMAP_TIMES_ROMAN_24, (char*)simu_performance_str.str().c_str());
	glPopMatrix();

}

void PlannerTestDraw::OnLeftClick(const double&amp; x, const double&amp; y)
{
//	if(m_LocalPlanner.m_TotalPath.size() &gt; 0)
//	{
//		PlannerHNS::WayPoint wp1(x,y,0,0);
//		int index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_LocalPlanner.m_TotalPath.at(0), wp1);
//		PlannerHNS::WayPoint wp2 = m_LocalPlanner.m_TotalPath.at(0).at(index);
//		vector&lt;PlannerHNS::WayPoint&gt; line;
//		line.push_back(wp1);
//		line.push_back(wp2);
//		float color[3] = {0.99, 0.0, 0.0};
//		DrawingHelpers::DrawWidePath(line,0.1,1, color);
//	}

}

void PlannerTestDraw::OnRightClick(const double&amp; x, const double&amp; y)
{}

void PlannerTestDraw::OnKeyboardPress(const SPECIAL_KEYS_TYPE&amp; sKey, const unsigned char&amp; key)
{
	//std::cout &lt;&lt; &quot;key&quot; &lt;&lt; std::endl;

	switch(key)
	{
	case 's':
		if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl == 0)
			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
		else if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl == 1)
			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 0;
		break;
	case 'v':
	{
		SaveSimulationData();
	}
	break;
	case 'l':
	{
		LoadSimulationData();
	}
	break;
	case 'n':
	{
		pthread_mutex_lock(&amp;simulation_mutex);
		m_SimulatedCars.clear();
		m_SimulatedBehaviors.clear();
		m_SimulatedVehicleState.clear();
		m_SimulatedPrevTrajectory.clear();
		m_SimulatedPathFollower.clear();
		pthread_mutex_unlock(&amp;simulation_mutex);
	}
	break;
	case 'g':
	{
		if(m_bGreenTrafficLight)
			m_bGreenTrafficLight = false;
		else
			m_bGreenTrafficLight = true;
	}
	break;
	case '1':
	{
		m_iStepNumber++;
	}
	break;
	default:
		break;

	}
}

void PlannerTestDraw::TransToCarCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
{
	PlannerHNS::Mat3 rotationMat(-currPose.pos.a);
	PlannerHNS::Mat3 translationMat(-currPose.pos.x, -currPose.pos.y);
	for(unsigned int i=0; i &lt; obj_list.size(); i++)
	{
		obj_list.at(i).center.pos = translationMat*obj_list.at(i).center.pos;
		obj_list.at(i).center.pos = rotationMat*obj_list.at(i).center.pos;
		for(unsigned int j = 0 ; j &lt; obj_list.at(i).contour.size(); j++)
		{
			obj_list.at(i).contour.at(j) = translationMat*obj_list.at(i).contour.at(j);
			obj_list.at(i).contour.at(j) = rotationMat*obj_list.at(i).contour.at(j);
		}
	}
}

void PlannerTestDraw::TransToWorldCoordinates(const PlannerHNS::WayPoint&amp; currPose, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obj_list)
{
	PlannerHNS::Mat3 rotationMat(currPose.pos.a);
	PlannerHNS::Mat3 translationMat(currPose.pos.x, currPose.pos.y);
	for(unsigned int i=0; i &lt; obj_list.size(); i++)
	{
		obj_list.at(i).center.pos = rotationMat*obj_list.at(i).center.pos;
		obj_list.at(i).center.pos = translationMat*obj_list.at(i).center.pos;

		for(unsigned int j = 0 ; j &lt; obj_list.at(i).contour.size(); j++)
		{
			obj_list.at(i).contour.at(j) = translationMat*obj_list.at(i).contour.at(j);
			obj_list.at(i).contour.at(j) = rotationMat*obj_list.at(i).contour.at(j);
		}
	}
}

void* PlannerTestDraw::PlanningThreadStaticEntryPoint(void* pThis)
{
	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
	struct timespec moveTimer;
	UtilityH::GetTickCount(moveTimer);
	vector&lt;string&gt; logData;
	PlannerHNS::PlannerH planner;
	SimpleTracker obstacleTracking;
	obstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 1;
	obstacleTracking.m_MAX_TRACKS_AFTER_LOSING = 5;
	obstacleTracking.m_bUseCenterOnly = true;

	vector&lt;string&gt; behaviorsLogData;

	while(!pR-&gt;m_bCancelThread)
	{
		double time_elapsed  = UtilityH::GetTimeDiffNow(moveTimer);

		if(time_elapsed &gt;= pR-&gt;m_PlanningCycleTime)
		{
			double dt = time_elapsed;
			UtilityH::GetTickCount(moveTimer);
#ifdef EnableThreadBody
			vector&lt;vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedTotalPath;// = pR-&gt;m_LocalPlanner.m_TotalPath;
			bool bNewPlan = false;
			PlannerHNS::VehicleState currTargetState;
			pthread_mutex_lock(&amp;pR-&gt;control_mutex);
			currTargetState = pR-&gt;m_VehicleTargetState;
			pthread_mutex_unlock(&amp;pR-&gt;control_mutex);

			/**
			 * Path Planning Step (Global Planning)
			 */
			int currIndexToGoal = 0;
			if(pR-&gt;m_LocalPlanner.m_TotalPath.size()&gt;0)
				currIndexToGoal = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(pR-&gt;m_LocalPlanner.m_TotalPath.at(0), pR-&gt;m_LocalPlanner.state);
//			int index_limit_total = pR-&gt;m_LocalPlanner.m_TotalPath.size() - 25;
//			if(index_limit_total&lt;=0)
//				index_limit_total =  pR-&gt;m_LocalPlanner.m_TotalPath.size()/2.0;
//
//			if(currIndexToal &gt; index_limit_total)
//			{
//				pR-&gt;m_bMakeNewPlan = true;
//				PlannerHNS::WayPoint g_p = pR-&gt;m_goals.at(m_iCurrentGoal);
//				pR-&gt;m_goal = pR-&gt;m_start;
//				pR-&gt;m_start = g_p;
//			}


			if(pR-&gt;m_bMakeNewPlan == false &amp;&amp; pR-&gt;m_CurrentBehavior.state == PlannerHNS::STOPPING_STATE &amp;&amp; (pR-&gt;m_iCurrentGoal+1) &lt; pR-&gt;m_goals.size())
			{
				if(pR-&gt;m_LocalPlanner.m_TotalPath.size() &gt; 0 &amp;&amp; currIndexToGoal &gt; pR-&gt;m_LocalPlanner.m_TotalPath.size() - 8)
				{
					pR-&gt;m_iCurrentGoal = pR-&gt;m_iCurrentGoal + 1;
					pR-&gt;m_bMakeNewPlan = true;
					pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = true;
				}
			}

			if((pR-&gt;m_CurrentBehavior.state == PlannerHNS::INITIAL_STATE &amp;&amp; pR-&gt;m_LocalPlanner.m_Path.size() == 0 &amp;&amp; pR-&gt;m_bMakeNewPlan) || pR-&gt;m_bMakeNewPlan )
			{
				//planner.PlanUsingReedShepp(pR-&gt;m_LocalPlanner.state, pR-&gt;m_goal, generatedPath);
				timespec planTime;
				UtilityH::GetTickCount(planTime);
				planner.PlanUsingDP(pR-&gt;m_LocalPlanner.state,
						pR-&gt;m_goals.at(pR-&gt;m_iCurrentGoal),
						1000000,
						false,
						pR-&gt;m_LanesIds,
						pR-&gt;m_RoadMap,
						generatedTotalPath, &amp;pR-&gt;m_all_cell_to_delete);
				pR-&gt;m_GlobalPlanningTime = UtilityH::GetTimeDiffNow(planTime);

				if(generatedTotalPath.size()&gt;0 &amp;&amp; generatedTotalPath.at(0).size()&gt;0)
				{
					pR-&gt;m_goals.at(pR-&gt;m_iCurrentGoal) = generatedTotalPath.at(0).at(generatedTotalPath.at(0).size()-1);
					pR-&gt;m_bMakeNewPlan = false;
					bNewPlan = true;
				}

			}

			/**
			 * Behavior Generator , State Machine , Decision making Step
			 */
			pthread_mutex_lock(&amp;pR-&gt;planning_mutex);
			if(bNewPlan)
				pR-&gt;m_LocalPlanner.m_TotalPath = generatedTotalPath;



			timespec trackingTimer;
			UtilityH::GetTickCount(trackingTimer);
			std::vector&lt;PlannerHNS::DetectedObject&gt; obj_list;
			pthread_mutex_lock(&amp;pR-&gt;simulation_mutex);
			pR-&gt;DetectSimulatedObstacles(obj_list);
			pthread_mutex_unlock(&amp;pR-&gt;simulation_mutex);

			obstacleTracking.DoOneStep(pR-&gt;m_LocalPlanner.state, obj_list);
			obj_list = obstacleTracking.m_DetectedObjects;


			pR-&gt;m_ObjectTrakingTime = UtilityH::GetTimeDiffNow(trackingTimer);

			timespec localPlannerTimer;
			UtilityH::GetTickCount(localPlannerTimer);
			PlannerHNS::WayPoint goal_wp;
			if(pR-&gt;m_goals.size() &gt; 0)
				goal_wp = pR-&gt;m_goals.at(0);
//			if(pR-&gt;m_iCurrentGoal+1 &lt; pR-&gt;m_goals.size())
//				goal_wp = pR-&gt;m_goals.at(pR-&gt;m_iCurrentGoal);

			bool bEmergencyStop = false;

			if(pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl == 1 &amp;&amp; pR-&gt;m_CurrentBehavior.state != PlannerHNS::INITIAL_STATE)
				bEmergencyStop = true;

			pR-&gt;m_CurrentBehavior = pR-&gt;m_LocalPlanner.DoOneStep(dt, currTargetState, obj_list, 1, pR-&gt;m_RoadMap, bEmergencyStop, pR-&gt;m_bGreenTrafficLight);

			PlannerHNS::PlanningHelpers::WritePathToFile(&quot;/home/hatem/SimuLogs/Test&quot;, pR-&gt;m_LocalPlanner.m_Path);

//			double d_slowDown = hypot(pR-&gt;m_SlowDown.pos.y - pR-&gt;m_LocalPlanner.state.pos.y, pR-&gt;m_SlowDown.pos.x - pR-&gt;m_LocalPlanner.state.pos.x);
//			if(d_slowDown &lt; 3)
//				pR-&gt;m_bStartSlow = true;
//
//			if(pR-&gt;m_bStartSlow)
//				pR-&gt;m_CurrentBehavior.maxVelocity = 1;
//
//			double d_goNormal = hypot(pR-&gt;m_GoNormal.pos.y - pR-&gt;m_LocalPlanner.state.pos.y, pR-&gt;m_GoNormal.pos.x - pR-&gt;m_LocalPlanner.state.pos.x);
//			if(d_slowDown &lt; 3)
//				pR-&gt;m_bStartSlow = false;


			pR-&gt;m_LocalPlanningTime = UtilityH::GetTimeDiffNow(localPlannerTimer);
			pR-&gt;m_VehicleCurrentState.steer = pR-&gt;m_LocalPlanner.m_CurrentSteering;
			pR-&gt;m_VehicleCurrentState.speed = pR-&gt;m_LocalPlanner.m_CurrentVelocity;
			pR-&gt;m_VehicleCurrentState.shift = pR-&gt;m_LocalPlanner.m_CurrentShift;
			UtilityH::GetTickCount(pR-&gt;m_VehicleCurrentState.tStamp);

			if(pR-&gt;m_CurrentBehavior.state != PlannerHNS::INITIAL_STATE)
				behaviorsLogData.push_back(pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;ToString(pR-&gt;m_CurrentBehavior.state));

			pR-&gt;m_dummyObstacles = obj_list;

			pthread_mutex_unlock(&amp;pR-&gt;planning_mutex);

			double d = 0;
			if(pR-&gt;m_ActualPath.size()&gt;0)
				d = distance2points(pR-&gt;m_ActualPath.at(pR-&gt;m_ActualPath.size()-1).pos, pR-&gt;m_LocalPlanner.state.pos);


			if(pR-&gt;m_ActualPath.size() &gt; 0 &amp;&amp; d &gt; 0.5 )
			{
				pR-&gt;m_ActualPath.push_back(pR-&gt;m_LocalPlanner.state);
			}
			else if(pR-&gt;m_ActualPath.size()==0 &amp;&amp; pR-&gt;m_LocalPlanner.m_Path.size() &gt; 0)
			{
				pR-&gt;m_ActualPath.push_back(pR-&gt;m_LocalPlanner.state);
			}
#endif
		}
	}

	DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::StatesLogFolderName, &quot;BehaviorsLog&quot;,
			pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;ToStringHeader(), behaviorsLogData );

	return 0;
}

void* PlannerTestDraw::ControlThreadStaticEntryPoint(void* pThis)
{
	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
	struct timespec moveTimer;
	TrajectoryFollower predControl;
	double timeOfHalf = 0;
	double timeTotal = 0;
	int counter = 0;
	PlannerHNS::VehicleState calibrationTargetState;

	bool bCalibrationMode = false;
	bool bStartCalibration = false;
	timespec delayTimer;
	double timeDelay = 0;
	double totalLateralError = 0;


	predControl.Init(pR-&gt;m_ControlParams, pR-&gt;m_CarInfo);

	UtilityH::GetTickCount(moveTimer);
	vector&lt;string&gt; logData;
	vector&lt;PlannerHNS::WayPoint&gt; generatedPath;
	vector&lt;vector&lt;PlannerHNS::WayPoint&gt; &gt; simulationGeneratedPaths;

	while(!pR-&gt;m_bCancelThread)
	{
		double time_elapsed  = UtilityH::GetTimeDiffNow(moveTimer);

		if(time_elapsed &gt;= pR-&gt;m_ControlCycleTime)
		{
			double dt = time_elapsed;
			UtilityH::GetTickCount(moveTimer);

#ifdef EnableThreadBody
			pthread_mutex_lock(&amp;pR-&gt;planning_mutex);

			PlannerHNS::BehaviorState currMessage = pR-&gt;m_CurrentBehavior;
			PlannerHNS::VehicleState currState, targetState;
			if(pR-&gt;m_bResetForSimulation)
			{
				predControl.Init(pR-&gt;m_ControlParams, pR-&gt;m_CarInfo);
				generatedPath.clear();
				pR-&gt;m_bResetForSimulation = false;
			}

			currState.steer = pR-&gt;m_LocalPlanner.m_CurrentSteering;
			currState.speed = pR-&gt;m_LocalPlanner.m_CurrentVelocity;
			currState.shift = pR-&gt;m_LocalPlanner.m_CurrentShift;

			pthread_mutex_unlock(&amp;pR-&gt;planning_mutex);

//			if(bCalibrationMode)
//			{
//				if(!bStartCalibration)
//				{
//					calibrationTargetState.speed = 0;
//					if(counter == 0)
//						calibrationTargetState.steer = pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle/2.0;
//					else if(counter == 1)
//						calibrationTargetState.steer = 0;
//					else if(counter == 2)
//						calibrationTargetState.steer = -pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle/2.0;
//					else if(counter == 3)
//						calibrationTargetState.steer = 0;
//
//					UtilityH::GetTickCount(delayTimer);
//					timeOfHalf = 0;
//					bStartCalibration = true;
//				}
//				else
//				{
//					if(abs(abs(currState.steer*RAD2DEG) - abs(calibrationTargetState.steer*RAD2DEG)) &lt; 0.5)
//					{
//						timeOfHalf = UtilityH::GetTimeDiffNow(delayTimer);
//						counter++;
//						timeTotal += timeOfHalf;
//						bStartCalibration = false;
//						if(counter==4)
//						{
//							bCalibrationMode = false;
//							timeDelay = (timeTotal / (double)counter) / (pR-&gt;m_LocalPlanner.m_CarInfo.max_steer_angle*RAD2DEG/2.0);
//							timeDelay = timeDelay*17.5;
//
//						}
//					}
//				}
//
//				targetState = calibrationTargetState;
//			}
//			else if(!bCalibrationMode)
//			{
//				timespec controlTimer;
//				UtilityH::GetTickCount(controlTimer);
//				bool bNewPath = false;
//				if(PlannerHNS::PlanningHelpers::CompareTrajectories(generatedPath, pR-&gt;m_LocalPlanner.m_Path) == false &amp;&amp; pR-&gt;m_LocalPlanner.m_Path.size()&gt;0)
//				{
//					generatedPath = pR-&gt;m_LocalPlanner.m_Path;
//					bNewPath = true;
//					cout &lt;&lt; &quot;Path is Updated in the controller .. &quot; &lt;&lt; pR-&gt;m_LocalPlanner.m_Path.size() &lt;&lt; endl;
//				}
//
//				PlannerHNS::ControllerParams c_params = pR-&gt;m_ControlParams;
//				c_params.SteeringDelay = pR-&gt;m_ControlParams.SteeringDelay / (1.0-UtilityH::GetMomentumScaleFactor(currState.speed));
//				predControl.Init(c_params, pR-&gt;m_CarInfo);
//				targetState = predControl.DoOneStep(dt, currMessage, generatedPath, pR-&gt;m_LocalPlanner.state, currState, bNewPath);
//				pR-&gt;m_ControllingTime = UtilityH::GetTimeDiffNow(controlTimer);
//			}

			timespec controlTimer;
			UtilityH::GetTickCount(controlTimer);
			bool bNewPath = false;
			if(PlannerHNS::PlanningHelpers::CompareTrajectories(generatedPath, pR-&gt;m_LocalPlanner.m_Path) == false &amp;&amp; pR-&gt;m_LocalPlanner.m_Path.size()&gt;0)
			{
				generatedPath = pR-&gt;m_LocalPlanner.m_Path;
				bNewPath = true;
				cout &lt;&lt; &quot;Path is Updated in the controller .. &quot; &lt;&lt; pR-&gt;m_LocalPlanner.m_Path.size() &lt;&lt; endl;
			}

			targetState = predControl.DoOneStep(dt, currMessage, generatedPath, pR-&gt;m_LocalPlanner.state, currState, bNewPath);
			pR-&gt;m_ControllingTime = UtilityH::GetTimeDiffNow(controlTimer);

			//cout &lt;&lt; pR-&gt;m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;ToString(currMessage.state) &lt;&lt; endl;

			pR-&gt;m_FollowPoint  = predControl.m_FollowMePoint.pos;
			pR-&gt;m_PerpPoint    = predControl.m_PerpendicularPoint.pos;
			pR-&gt;m_LateralError = predControl.m_LateralError;

			//if(abs(pR-&gt;m_LateralError) &gt; 0.5)
				totalLateralError = abs(pR-&gt;m_LateralError);

//			cout &lt;&lt; &quot;S D P  = &quot; &lt;&lt; pR-&gt;m_ControlParams.SteeringDelayPercent
//				 &lt;&lt; &quot;, S D  = &quot; &lt;&lt; pR-&gt;m_ControlParams.SteeringDelay
//				 &lt;&lt; &quot;, T D  = &quot; &lt;&lt; timeDelay
//				 &lt;&lt; &quot;, L E  = &quot; &lt;&lt; pR-&gt;m_LateralError
//				 &lt;&lt; &quot;, T E  = &quot; &lt;&lt; totalLateralError
//				 &lt;&lt; &quot;, K P &quot; &lt;&lt; pR-&gt;m_ControlParams.Steering_Gain.kP
//				 &lt;&lt; &quot;, K I &quot; &lt;&lt; pR-&gt;m_ControlParams.Steering_Gain.kI &lt;&lt; endl;


//			if(totalLateralError &gt;= 3.0)
//			{
//				break;
//			}

			pthread_mutex_lock(&amp;pR-&gt;control_mutex);
			pR-&gt;m_VehicleTargetState = targetState;
			pthread_mutex_unlock(&amp;pR-&gt;control_mutex);
#endif
		}
	}

//	if(totalLateralError &gt;= 3.0)
//	{
//		pR-&gt;LoadSimulationData();
//		totalLateralError = 0;
//		//pR-&gt;m_ControlParams.Steering_Gain.kP += 0.5;
//		//pR-&gt;m_ControlParams.Steering_Gain.kD-=0.001;
//		//pR-&gt;m_ControlParams.SteeringDelayPercent+=1.0;
//	}

	return 0;
}

void* PlannerTestDraw::SimulationThreadStaticEntryPoint(void* pThis)
{
	PlannerTestDraw* pR = (PlannerTestDraw*)pThis;
	struct timespec moveTimer;
	UtilityH::GetTickCount(moveTimer);
	vector&lt;string&gt; logData;
	PlannerHNS::PlannerH planner;
	std::vector&lt;PlannerHNS::DetectedObject&gt; dummyObstacles;


	while(!pR-&gt;m_bCancelThread)
	{
		double time_elapsed  = UtilityH::GetTimeDiffNow(moveTimer);

		if(time_elapsed &gt;= 0.05)
		{
			double dt = 0.05;
			UtilityH::GetTickCount(moveTimer);

#ifdef EnableThreadBody
			PlannerHNS::BehaviorState currMessage = pR-&gt;m_CurrentBehavior;

			if(currMessage.state != PlannerHNS::INITIAL_STATE &amp;&amp; currMessage.state != PlannerHNS::WAITING_STATE)
			{
				pthread_mutex_lock(&amp;pR-&gt;simulation_mutex);
				for(unsigned int i = 0 ; i &lt; pR-&gt;m_SimulatedCars.size(); i++)
				{
					pR-&gt;m_SimulatedBehaviors.at(i) = pR-&gt;m_SimulatedCars.at(i).DoOneStep(
							dt, pR-&gt;m_SimulatedVehicleState.at(i),
							pR-&gt;m_SimulatedCars.at(i).state,
							PlannerHNS::GPSPoint(), pR-&gt;m_RoadMap);

					if(pR-&gt;m_SimulatedCars.at(i).m_Path.size() == 0)
					{
						pR-&gt;m_SimulatedCars.erase(pR-&gt;m_SimulatedCars.begin()+i);
						pR-&gt;m_SimulatedBehaviors.erase(pR-&gt;m_SimulatedBehaviors.begin()+i);
						pR-&gt;m_SimulatedVehicleState.erase(pR-&gt;m_SimulatedVehicleState.begin()+i);
						pR-&gt;m_SimulatedPrevTrajectory.erase(pR-&gt;m_SimulatedPrevTrajectory.begin()+i);
						pR-&gt;m_SimulatedPathFollower.erase(pR-&gt;m_SimulatedPathFollower.begin()+i);
						i--;
						continue;
					}

					bool bNewPath = false;
					if(PlannerHNS::PlanningHelpers::CompareTrajectories(pR-&gt;m_SimulatedPrevTrajectory.at(i), pR-&gt;m_SimulatedCars.at(i).m_Path) == false &amp;&amp; pR-&gt;m_SimulatedCars.at(i).m_Path.size()&gt;0)
					{
						pR-&gt;m_SimulatedPrevTrajectory.at(i) = pR-&gt;m_SimulatedCars.at(i).m_Path;

						bNewPath = true;
						cout &lt;&lt; &quot;Path is Updated in the controller .. &quot; &lt;&lt; pR-&gt;m_SimulatedCars.at(i).m_Path.size() &lt;&lt; endl;
					}

					PlannerHNS::VehicleState currState;
					currState.steer = pR-&gt;m_SimulatedCars.at(i).m_CurrentSteering;
					currState.speed = pR-&gt;m_SimulatedCars.at(i).m_CurrentVelocity;
					currState.shift = PlannerHNS::SHIFT_POS_DD;

					pR-&gt;m_SimulatedVehicleState.at(i) = pR-&gt;m_SimulatedPathFollower.at(i).DoOneStep(dt, pR-&gt;m_SimulatedBehaviors.at(i), pR-&gt;m_SimulatedPrevTrajectory.at(i),
							pR-&gt;m_SimulatedCars.at(i).state, currState, bNewPath);
					//pR-&gt;m_SimulatedCars.at(i).state.v = pR-&gt;m_SimulatedVehicleState.at(i).speed;
				}
				pthread_mutex_unlock(&amp;pR-&gt;simulation_mutex);
			}
			pR-&gt;m_SimulationTime = UtilityH::GetTimeDiffNow(moveTimer);
#endif
		}
	}

	return 0;
}

} /* namespace Graphics */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/SimpleTracker.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/SimpleTracker.cpp">
				<diff>@@ -23,18 +23,22 @@ namespace SimulationNS
 
 using namespace PlannerHNS;
 
-SimpleTracker::SimpleTracker(double horizon)
+SimpleTracker::SimpleTracker()
 {
 	iTracksNumber = 1;
 	m_DT = 0.1;
 	m_MAX_ASSOCIATION_DISTANCE = 3.0;
 	m_MAX_TRACKS_AFTER_LOSING = 10;
-	m_MaxKeepTime = 15; // seconds
+	m_MaxKeepTime = 2; // seconds
 	m_bUseCenterOnly = true;
 	m_bFirstCall = true;
 	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
+}
 
-	InitializeInterestRegions(horizon, 5, 5, m_InterestRegions);
+void SimpleTracker::InitSimpleTracker()
+{
+	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
+	InitializeInterestRegions(TRACKING_HORIZON, 5, 5, m_InterestRegions);
 }
 
 SimpleTracker::~SimpleTracker()
@@ -63,9 +67,10 @@ void SimpleTracker::InitializeInterestRegions(double horizon, double init_raduis
 		if(regions.size() == 0)
 		{
 			pCir-&gt;radius = 5;
-			pCir-&gt;pPrevCircle = 0;
-			//pCir-&gt;forget_time = NEVER_GORGET_TIME;
+			//pCir-&gt;pPrevCircle = 0;
+			pCir-&gt;forget_time = NEVER_GORGET_TIME;
 			pCir-&gt;forget_time = m_MaxKeepTime*2.0;
+			pCir-&gt;forget_time = m_MaxKeepTime;
 			regions.push_back(pCir);
 			std::cout &lt;&lt; &quot;Region No: &quot; &lt;&lt; regions.size() &lt;&lt; &quot;, Radius: &quot; &lt;&lt; pCir-&gt;radius &lt;&lt; &quot;, F time: &quot; &lt;&lt; pCir-&gt;forget_time &lt;&lt; std::endl;
 		}
@@ -77,9 +82,10 @@ void SimpleTracker::InitializeInterestRegions(double horizon, double init_raduis
 			else
 				pCir-&gt;radius = regions.at(iPrev)-&gt;radius + regions.at(iPrev)-&gt;radius;
 
-			regions.at(iPrev)-&gt;pNextCircle = pCir;
-			pCir-&gt;pPrevCircle = regions.at(iPrev);
+//			regions.at(iPrev)-&gt;pNextCircle = pCir;
+//			pCir-&gt;pPrevCircle = regions.at(iPrev);
 			pCir-&gt;forget_time = m_MaxKeepTime-iPrev-2;
+			pCir-&gt;forget_time = m_MaxKeepTime;
 			if(pCir-&gt;forget_time &lt;= 0 )
 				pCir-&gt;forget_time = 0.2;
 			regions.push_back(pCir);
@@ -205,6 +211,50 @@ void SimpleTracker::AssociateAndTrack()
 	}
 }
 
+void SimpleTracker::AssociateSimply()
+{
+	std::vector&lt;KFTrackV&gt; newObjects;
+	for(unsigned int j = 0; j &lt; m_DetectedObjects.size(); j++)
+	{
+		double iCloseset = 0;
+		double dCloseset = 9999999;
+		for(unsigned int i = 0; i &lt; m_TrackSimply.size(); i++)
+		{
+			double d = hypot(m_DetectedObjects.at(j).center.pos.y-m_TrackSimply.at(i).obj.center.pos.y, m_DetectedObjects.at(j).center.pos.x-m_TrackSimply.at(i).obj.center.pos.x);
+			if(d &lt; dCloseset)
+			{
+				dCloseset = d;
+				iCloseset = i;
+			}
+		}
+
+		if(dCloseset &lt;= m_MAX_ASSOCIATION_DISTANCE)
+		{
+			m_DetectedObjects.at(j).id = m_TrackSimply.at(iCloseset).obj.id;
+			m_DetectedObjects.at(j).center.pos.a = m_TrackSimply.at(iCloseset).obj.center.pos.a;
+			m_TrackSimply.at(iCloseset).obj = m_DetectedObjects.at(j);
+			newObjects.push_back(m_TrackSimply.at(iCloseset));
+		}
+		else
+		{
+			iTracksNumber = iTracksNumber + 1;
+			m_DetectedObjects.at(j).id = iTracksNumber;
+			KFTrackV track(m_DetectedObjects.at(j).center.pos.x, m_DetectedObjects.at(j).center.pos.y,m_DetectedObjects.at(j).center.pos.a, m_DetectedObjects.at(j).id, m_DT);
+			track.obj = m_DetectedObjects.at(j);
+			newObjects.push_back(track);
+		}
+	}
+
+	m_TrackSimply = newObjects;
+
+	for(unsigned int i =0; i&lt; m_TrackSimply.size(); i++)
+		m_TrackSimply.at(i).UpdateTracking(m_DT, m_TrackSimply.at(i).obj, m_TrackSimply.at(i).obj);
+
+	m_DetectedObjects.clear();
+	for(unsigned int i = 0; i&lt; m_TrackSimply.size(); i++)
+		m_DetectedObjects.push_back(m_TrackSimply.at(i).obj);
+}
+
 void SimpleTracker::CreateTrackV2(DetectedObject&amp; o)
 {
 	iTracksNumber = iTracksNumber + 1;
@@ -219,9 +269,7 @@ void SimpleTracker::TrackV2()
 {
 	for(unsigned int i =0; i&lt; m_Tracks.size(); i++)
 	{
-		m_Tracks.at(i)-&gt;UpdateTracking(m_DT, m_Tracks.at(i)-&gt;obj.center.pos.x, m_Tracks.at(i)-&gt;obj.center.pos.y, m_Tracks.at(i)-&gt;obj.center.pos.a,
-				m_Tracks.at(i)-&gt;obj.center.pos.x, m_Tracks.at(i)-&gt;obj.center.pos.y, m_Tracks.at(i)-&gt;obj.center.pos.a,
-				m_Tracks.at(i)-&gt;obj.center.v);
+		m_Tracks.at(i)-&gt;UpdateTracking(m_DT, m_Tracks.at(i)-&gt;obj, m_Tracks.at(i)-&gt;obj);
 
 		//std::cout&lt;&lt; &quot;Obj ID: &quot; &lt;&lt; m_Tracks.at(i)-&gt;GetTrackID() &lt;&lt; &quot;, Remaining Time: &quot; &lt;&lt;  m_Tracks.at(i)-&gt;forget_time  &lt;&lt; std::endl;
 	}
@@ -230,7 +278,7 @@ void SimpleTracker::TrackV2()
 void SimpleTracker::CleanOldTracks()
 {
 	m_DetectedObjects.clear();
-	for(int i = 0; i&lt; m_Tracks.size(); i++)
+	for(int i = 0; i&lt; (int)m_Tracks.size(); i++)
 	{
 		if(m_Tracks.at(i)-&gt;forget_time &lt; 0 &amp;&amp; m_Tracks.at(i)-&gt;forget_time &gt; NEVER_GORGET_TIME)
 		{
@@ -255,25 +303,20 @@ void SimpleTracker::DoOneStep(const WayPoint&amp; currPose, const std::vector&lt;Detect
 	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);
 
 	//std::cout &lt;&lt; &quot; Tracking Time : &quot; &lt;&lt; m_DT &lt;&lt; std::endl;
-
 	m_DetectedObjects = obj_list;
 
-	AssociateAndTrack();
-
-	TrackV2();
+	AssociateSimply();
 
-	CleanOldTracks();
+//	AssociateAndTrack();
+//	TrackV2();
+//	CleanOldTracks();
 
 
 
 //	AssociateObjects();
-//
 //	Track(m_DetectedObjects);
-//
 //	m_PrevDetectedObjects = m_DetectedObjects;
-//
 //	m_PrevState = currPose;
-
 }
 
 void SimpleTracker::AssociateObjects()
@@ -361,8 +404,7 @@ void SimpleTracker::CreateTrack(DetectedObject&amp; o)
 {
 	KFTrackV* pT = new KFTrackV(o.center.pos.x, o.center.pos.y,o.center.pos.a, o.id, m_DT);
 	o.id = pT-&gt;GetTrackID();
-	pT-&gt;UpdateTracking(m_DT, o.center.pos.x, o.center.pos.y, o.center.pos.a,
-			o.center.pos.x, o.center.pos.y,o.center.pos.a, o.center.v);
+	pT-&gt;UpdateTracking(m_DT, o, o);
 	m_Tracks.push_back(pT);
 }
 
@@ -386,9 +428,9 @@ void SimpleTracker::Track(std::vector&lt;DetectedObject&gt;&amp; objects_list)
 			KFTrackV* pT = FindTrack(objects_list[i].id);
 			if(pT)
 			{
-				pT-&gt;UpdateTracking(m_DT, objects_list[i].center.pos.x, objects_list[i].center.pos.y, objects_list[i].center.pos.a,
-						objects_list[i].center.pos.x, objects_list[i].center.pos.y, objects_list[i].center.pos.a,
-						objects_list[i].center.v);
+//				pT-&gt;UpdateTracking(m_DT, objects_list[i].center.pos.x, objects_list//[i].center.pos.y, objects_list[i].center.pos.a,
+						//objects_list[i].center.pos.x, objects_list[i].center.pos.y, //objects_list[i].center.pos.a,
+//						objects_list[i].center.v);
 				//std::cout &lt;&lt; &quot;Update Current Track &quot; &lt;&lt; objects_list[i].id &lt;&lt; std::endl;
 			}
 			else
</diff>
				<old_file>/*
 * SimpleTracker.cpp
 *
 *  Created on: Aug 11, 2016
 *      Author: hatem
 */

#include &quot;SimpleTracker.h&quot;
#include &quot;MatrixOperations.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &quot;UtilityH.h&quot;

#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdio&gt;

#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;opencv2/video/tracking.hpp&gt;

namespace SimulationNS
{

using namespace PlannerHNS;

SimpleTracker::SimpleTracker(double horizon)
{
	iTracksNumber = 1;
	m_DT = 0.1;
	m_MAX_ASSOCIATION_DISTANCE = 3.0;
	m_MAX_TRACKS_AFTER_LOSING = 10;
	m_MaxKeepTime = 15; // seconds
	m_bUseCenterOnly = true;
	m_bFirstCall = true;
	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);

	InitializeInterestRegions(horizon, 5, 5, m_InterestRegions);
}

SimpleTracker::~SimpleTracker()
{
	for(unsigned int i = 0; i &lt; m_InterestRegions.size(); i++)
	{
		delete m_InterestRegions.at(i);
	}
	m_InterestRegions.clear();

	for(unsigned int i = 0; i &lt; m_Tracks.size(); i++)
	{
		delete m_Tracks.at(i);
	}
	m_Tracks.clear();

}

void SimpleTracker::InitializeInterestRegions(double horizon, double init_raduis, double init_time, std::vector&lt;InterestCircle*&gt;&amp; regions)
{
	//initialize interest regions
	double distance = 0;
	while(distance &lt;= horizon)
	{
		InterestCircle* pCir = new InterestCircle(regions.size()+1);
		if(regions.size() == 0)
		{
			pCir-&gt;radius = 5;
			pCir-&gt;pPrevCircle = 0;
			//pCir-&gt;forget_time = NEVER_GORGET_TIME;
			pCir-&gt;forget_time = m_MaxKeepTime*2.0;
			regions.push_back(pCir);
			std::cout &lt;&lt; &quot;Region No: &quot; &lt;&lt; regions.size() &lt;&lt; &quot;, Radius: &quot; &lt;&lt; pCir-&gt;radius &lt;&lt; &quot;, F time: &quot; &lt;&lt; pCir-&gt;forget_time &lt;&lt; std::endl;
		}
		else
		{
			int iPrev = regions.size()-1;
			if(regions.size() &gt; 1)
				pCir-&gt;radius = regions.at(iPrev)-&gt;radius + regions.at(iPrev-1)-&gt;radius;
			else
				pCir-&gt;radius = regions.at(iPrev)-&gt;radius + regions.at(iPrev)-&gt;radius;

			regions.at(iPrev)-&gt;pNextCircle = pCir;
			pCir-&gt;pPrevCircle = regions.at(iPrev);
			pCir-&gt;forget_time = m_MaxKeepTime-iPrev-2;
			if(pCir-&gt;forget_time &lt;= 0 )
				pCir-&gt;forget_time = 0.2;
			regions.push_back(pCir);

			std::cout &lt;&lt; &quot;Region No: &quot; &lt;&lt; regions.size() &lt;&lt; &quot;, Radius: &quot; &lt;&lt; pCir-&gt;radius &lt;&lt; &quot;, F time: &quot; &lt;&lt; pCir-&gt;forget_time &lt;&lt; std::endl;
		}

		distance = pCir-&gt;radius;
	}
}

void SimpleTracker::AssociateToRegions(KFTrackV&amp; detectedObject)
{
	for(unsigned int i = 0; i &lt; m_InterestRegions.size(); i++)
	{
		m_InterestRegions.at(i)-&gt;pTrackers.clear();
		if(detectedObject.obj.distance_to_center &lt;= m_InterestRegions.at(i)-&gt;radius)
		{
			detectedObject.region_id = m_InterestRegions.at(i)-&gt;id;
			detectedObject.forget_time = m_InterestRegions.at(i)-&gt;forget_time;
			//std::cout &lt;&lt; &quot;Associate Object: &quot; &lt;&lt; detectedObject.obj.id &lt;&lt; &quot;, With Region: &quot; &lt;&lt; detectedObject.region_id &lt;&lt; &quot;, And Time: &quot; &lt;&lt; detectedObject.forget_time &lt;&lt; std::endl;
			return;
		}
	}

	if(m_InterestRegions.size() &gt; 0)
	{
		detectedObject.region_id = m_InterestRegions.at(m_InterestRegions.size()-1)-&gt;id;
		detectedObject.forget_time = m_InterestRegions.at(m_InterestRegions.size()-1)-&gt;forget_time;
		//std::cout &lt;&lt; &quot;Associate Object: &quot; &lt;&lt; detectedObject.obj.id &lt;&lt; &quot;, With Region: &quot; &lt;&lt; detectedObject.region_id &lt;&lt; &quot;, And Time: &quot; &lt;&lt; detectedObject.forget_time &lt;&lt; std::endl;
	}
}

void SimpleTracker::AssociateAndTrack()
{
	DetectedObject* prev_obj;
	DetectedObject* curr_obj;

	std::vector&lt;CostRecordSet&gt; matching_matrix;

	for(unsigned int i = 0 ; i &lt; m_DetectedObjects.size(); i++)
	{
		double minCost = 99999999;
		double minID = -1;

		curr_obj = &amp;m_DetectedObjects.at(i);
		curr_obj-&gt;center.cost = 0;

		matching_matrix.push_back(CostRecordSet(i, -1, 0));

		for(unsigned int j = 0; j &lt; m_Tracks.size(); j++)
		{
			prev_obj = &amp;m_Tracks.at(j)-&gt;obj;
			double expected_d = prev_obj-&gt;center.v * m_DT;

			if(m_bUseCenterOnly)
			{
				curr_obj-&gt;center.cost = fabs(hypot(curr_obj-&gt;center.pos.y- prev_obj-&gt;center.pos.y, curr_obj-&gt;center.pos.x- prev_obj-&gt;center.pos.x) - expected_d);
			}
			else
			{
				for(unsigned int k = 0; k &lt; curr_obj-&gt;contour.size(); k++)
					for(unsigned int pk = 0; pk &lt; prev_obj-&gt;contour.size(); pk++)
						curr_obj-&gt;center.cost += fabs(hypot(curr_obj-&gt;contour.at(k).y -prev_obj-&gt;contour.at(pk).y, curr_obj-&gt;contour.at(k).x -prev_obj-&gt;contour.at(pk).x) - expected_d);

				curr_obj-&gt;center.cost = curr_obj-&gt;center.cost/(double)(curr_obj-&gt;contour.size()*prev_obj-&gt;contour.size());
			}

			if(DEBUG_TRACKER)
				std::cout &lt;&lt; &quot;Cost Cost (&quot; &lt;&lt; i &lt;&lt; &quot;), &quot; &lt;&lt; prev_obj-&gt;center.pos.ToString() &lt;&lt; &quot;,&quot;
						&lt;&lt; curr_obj-&gt;center.cost &lt;&lt;  &quot;, contour: &quot; &lt;&lt; curr_obj-&gt;contour.size()
						&lt;&lt; &quot;, &quot; &lt;&lt; curr_obj-&gt;center.pos.ToString() &lt;&lt; std::endl;

			if(curr_obj-&gt;center.cost &lt; minCost)
			{
				minCost = curr_obj-&gt;center.cost;
				minID = j;
			}
		}

		bool bSkip = false;

		for(unsigned int k = 0; k &lt; matching_matrix.size(); k++)
		{
			if(matching_matrix.at(k).prevObj == minID)
			{
				if(minCost &lt; matching_matrix.at(k).cost)
				{
					matching_matrix.at(k).prevObj = minID;
					matching_matrix.at(k).cost = minCost;
				}
				bSkip = true;
				break;
			}
		}

		if(!bSkip &amp;&amp; minID &gt;= 0 &amp;&amp; minCost &lt;= m_MAX_ASSOCIATION_DISTANCE)
		{
			matching_matrix.at(i).prevObj = minID;
			matching_matrix.at(i).cost = minCost;
		}
	}

	for(unsigned int i = 0 ; i &lt; matching_matrix.size(); i ++)
	{
		curr_obj =  &amp;m_DetectedObjects.at(matching_matrix.at(i).currobj);

		if(matching_matrix.at(i).prevObj == -1)
		{
			 CreateTrackV2(*curr_obj);
			if(DEBUG_TRACKER)
				std::cout &lt;&lt; &quot;New Matching Index: &quot; &lt;&lt; matching_matrix.at(i).currobj &lt;&lt; &quot;, &quot;&lt;&lt; matching_matrix.at(i).cost&lt;&lt; &quot;, &quot; &lt;&lt; iTracksNumber &lt;&lt; std::endl;
		}
		else
		{
			curr_obj-&gt;id = m_Tracks.at(matching_matrix.at(i).prevObj)-&gt;obj.id;
			curr_obj-&gt;center.pos.a = m_Tracks.at(matching_matrix.at(i).prevObj)-&gt;obj.center.pos.a;
			m_Tracks.at(matching_matrix.at(i).prevObj)-&gt;obj = *curr_obj;
			AssociateToRegions(*m_Tracks.at(matching_matrix.at(i).prevObj));
			if(DEBUG_TRACKER)
				std::cout &lt;&lt; &quot;ObjIndex: &quot; &lt;&lt;  matching_matrix.at(i).currobj &lt;&lt;  &quot;, Matched with ID  &quot; &lt;&lt; prev_obj-&gt;id &lt;&lt; &quot;, &quot;&lt;&lt; matching_matrix.at(i).cost &lt;&lt; std::endl;
		}
	}
}

void SimpleTracker::CreateTrackV2(DetectedObject&amp; o)
{
	iTracksNumber = iTracksNumber + 1;
	o.id = iTracksNumber;
	KFTrackV* pT = new KFTrackV(o.center.pos.x, o.center.pos.y,o.center.pos.a, o.id, m_DT);
	pT-&gt;obj = o;
	AssociateToRegions(*pT);
	m_Tracks.push_back(pT);
}

void SimpleTracker::TrackV2()
{
	for(unsigned int i =0; i&lt; m_Tracks.size(); i++)
	{
		m_Tracks.at(i)-&gt;UpdateTracking(m_DT, m_Tracks.at(i)-&gt;obj.center.pos.x, m_Tracks.at(i)-&gt;obj.center.pos.y, m_Tracks.at(i)-&gt;obj.center.pos.a,
				m_Tracks.at(i)-&gt;obj.center.pos.x, m_Tracks.at(i)-&gt;obj.center.pos.y, m_Tracks.at(i)-&gt;obj.center.pos.a,
				m_Tracks.at(i)-&gt;obj.center.v);

		//std::cout&lt;&lt; &quot;Obj ID: &quot; &lt;&lt; m_Tracks.at(i)-&gt;GetTrackID() &lt;&lt; &quot;, Remaining Time: &quot; &lt;&lt;  m_Tracks.at(i)-&gt;forget_time  &lt;&lt; std::endl;
	}
}

void SimpleTracker::CleanOldTracks()
{
	m_DetectedObjects.clear();
	for(int i = 0; i&lt; m_Tracks.size(); i++)
	{
		if(m_Tracks.at(i)-&gt;forget_time &lt; 0 &amp;&amp; m_Tracks.at(i)-&gt;forget_time &gt; NEVER_GORGET_TIME)
		{
			delete m_Tracks.at(i);
			m_Tracks.erase(m_Tracks.begin()+i);
			i--;
		}
		else if(m_Tracks.at(i)-&gt;m_iLife &gt; MIN_EVIDENCE_NUMBER)
		{
			m_DetectedObjects.push_back(m_Tracks.at(i)-&gt;obj);
		}
	}
}

void SimpleTracker::DoOneStep(const WayPoint&amp; currPose, const std::vector&lt;DetectedObject&gt;&amp; obj_list)
{
	if(!m_bFirstCall)
		m_DT = UtilityHNS::UtilityH::GetTimeDiffNow(m_TrackTimer);
	else
		m_bFirstCall = false;

	UtilityHNS::UtilityH::GetTickCount(m_TrackTimer);

	//std::cout &lt;&lt; &quot; Tracking Time : &quot; &lt;&lt; m_DT &lt;&lt; std::endl;

	m_DetectedObjects = obj_list;

	AssociateAndTrack();

	TrackV2();

	CleanOldTracks();



//	AssociateObjects();
//
//	Track(m_DetectedObjects);
//
//	m_PrevDetectedObjects = m_DetectedObjects;
//
//	m_PrevState = currPose;

}

void SimpleTracker::AssociateObjects()
{
	std::vector&lt;DetectedObject&gt; hidden_list;
	DetectedObject* prev_obj;
	DetectedObject* curr_obj;

	for(unsigned int i = 0 ; i &lt; m_DetectedObjects.size(); i++)
	{
		double minCost = 99999999;
		double minID = -1;

		curr_obj = &amp;m_DetectedObjects.at(i);
		curr_obj-&gt;center.cost = 0;

		for(unsigned int j = 0; j &lt; m_PrevDetectedObjects.size(); j++)
		{
			prev_obj = &amp;m_PrevDetectedObjects.at(j);

			if(m_bUseCenterOnly)
			{
				curr_obj-&gt;center.cost = hypot(curr_obj-&gt;center.pos.y- prev_obj-&gt;center.pos.y, curr_obj-&gt;center.pos.x- prev_obj-&gt;center.pos.x);
			}
			else
			{
				for(unsigned int k = 0; k &lt; curr_obj-&gt;contour.size(); k++)
					for(unsigned int pk = 0; pk &lt; prev_obj-&gt;contour.size(); pk++)
						curr_obj-&gt;center.cost += hypot(curr_obj-&gt;contour.at(k).y -prev_obj-&gt;contour.at(pk).y, curr_obj-&gt;contour.at(k).x -prev_obj-&gt;contour.at(pk).x);

				curr_obj-&gt;center.cost = curr_obj-&gt;center.cost/(double)(curr_obj-&gt;contour.size()*prev_obj-&gt;contour.size());
			}

//			if(DEBUG_TRACKER)
//				std::cout &lt;&lt; &quot;Cost (&quot; &lt;&lt; i &lt;&lt; &quot;), &quot; &lt;&lt; prev_obj-&gt;center.pos.ToString() &lt;&lt; &quot;, Cost: &quot;
//						&lt;&lt; curr_obj-&gt;center.cost &lt;&lt;  &quot;, contour: &quot; &lt;&lt; curr_obj-&gt;contour.size()
//						&lt;&lt; &quot;, &quot; &lt;&lt; curr_obj-&gt;center.pos.ToString() &lt;&lt; std::endl;

			if(curr_obj-&gt;center.cost &lt; minCost)
			{
				minCost = curr_obj-&gt;center.cost;
				minID = prev_obj-&gt;id;
			}
		}

		if(minID &lt;= 0 || minCost &gt; m_MAX_ASSOCIATION_DISTANCE) // new Object enter the scene
		{
			iTracksNumber = iTracksNumber + 1;
			 curr_obj-&gt;id = iTracksNumber;
			if(DEBUG_TRACKER)
				std::cout &lt;&lt; &quot;New Matching &quot; &lt;&lt; curr_obj-&gt;id &lt;&lt; &quot;, &quot;&lt;&lt; minCost&lt;&lt; &quot;, &quot; &lt;&lt; iTracksNumber &lt;&lt; std::endl;
		}
		else
		{
			 curr_obj-&gt;id = minID;
			if(DEBUG_TRACKER)
				std::cout &lt;&lt; &quot;Matched with ID  &quot; &lt;&lt; curr_obj-&gt;id &lt;&lt; &quot;, &quot;&lt;&lt; minCost&lt;&lt; std::endl;
		}
	}

	for(unsigned int i = 0 ; i &lt; m_PrevDetectedObjects.size(); i++)
	{
		prev_obj = &amp;m_PrevDetectedObjects.at(i);
		bool bFound = false;
		for(unsigned int j = 0; j &lt; m_DetectedObjects.size(); j++)
		{
			if(prev_obj-&gt;id == m_DetectedObjects.at(j).id)
			{
				bFound = true;
				break;
			}
		}

		if(!bFound &amp;&amp; prev_obj-&gt;predicted_center.cost &lt; m_MAX_TRACKS_AFTER_LOSING)
		{
			prev_obj-&gt;predicted_center.cost++;
			hidden_list.push_back(*prev_obj);
		}
	}

	m_DetectedObjects.insert(m_DetectedObjects.begin(), hidden_list.begin(), hidden_list.end());
}

void SimpleTracker::CreateTrack(DetectedObject&amp; o)
{
	KFTrackV* pT = new KFTrackV(o.center.pos.x, o.center.pos.y,o.center.pos.a, o.id, m_DT);
	o.id = pT-&gt;GetTrackID();
	pT-&gt;UpdateTracking(m_DT, o.center.pos.x, o.center.pos.y, o.center.pos.a,
			o.center.pos.x, o.center.pos.y,o.center.pos.a, o.center.v);
	m_Tracks.push_back(pT);
}

KFTrackV* SimpleTracker::FindTrack(long index)
{
	for(unsigned int i=0; i&lt; m_Tracks.size(); i++)
	{
		if(m_Tracks[i]-&gt;GetTrackID() == index)
			return m_Tracks[i];
	}

	return 0;
}

void SimpleTracker::Track(std::vector&lt;DetectedObject&gt;&amp; objects_list)
{
	for(unsigned int i =0; i&lt;objects_list.size(); i++)
	{
		if(objects_list[i].id &gt;= 0)
		{
			KFTrackV* pT = FindTrack(objects_list[i].id);
			if(pT)
			{
				pT-&gt;UpdateTracking(m_DT, objects_list[i].center.pos.x, objects_list[i].center.pos.y, objects_list[i].center.pos.a,
						objects_list[i].center.pos.x, objects_list[i].center.pos.y, objects_list[i].center.pos.a,
						objects_list[i].center.v);
				//std::cout &lt;&lt; &quot;Update Current Track &quot; &lt;&lt; objects_list[i].id &lt;&lt; std::endl;
			}
			else
			{
				CreateTrack(objects_list[i]);
				//std::cout &lt;&lt; &quot;Create New Track &quot; &lt;&lt; objects_list[i].id &lt;&lt; std::endl;
			}
		}
	}
}

void SimpleTracker::CoordinateTransform(const WayPoint&amp; refCoordinate, DetectedObject&amp; obj)
{
	Mat3 rotationMat(-refCoordinate.pos.a);
	Mat3 translationMat(-refCoordinate.pos.x, -refCoordinate.pos.y);
	obj.center.pos = translationMat*obj.center.pos;
	obj.center.pos = rotationMat*obj.center.pos;
	for(unsigned int j = 0 ; j &lt; obj.contour.size(); j++)
	{
		obj.contour.at(j) = translationMat*obj.contour.at(j);
		obj.contour.at(j) = rotationMat*obj.contour.at(j);
	}
}

void SimpleTracker::CoordinateTransformPoint(const WayPoint&amp; refCoordinate, GPSPoint&amp; obj)
{
	Mat3 rotationMat(-refCoordinate.pos.a);
	Mat3 translationMat(-refCoordinate.pos.x, -refCoordinate.pos.y);
	obj = translationMat*obj;
	obj = rotationMat*obj;
}

} /* namespace BehaviorsNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/TrajectoryFollower.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_simu/src/TrajectoryFollower.cpp">
				<diff>@@ -134,7 +134,7 @@ bool TrajectoryFollower::FindNextWayPoint(const std::vector&lt;PlannerHNS::WayPoint
 	if(totalD &lt;= 1 || totalD &lt;= d_critical)
 	{
 		m_bEndPath = true;
-		cout &lt;&lt; &quot;Critical Distance: &quot; &lt;&lt; d_critical &lt;&lt; endl;
+		//cout &lt;&lt; &quot;Critical Distance: &quot; &lt;&lt; d_critical &lt;&lt; endl;
 	}
 	else
 		m_bEndPath = false;
@@ -276,7 +276,7 @@ int TrajectoryFollower::VeclocityControllerUpdate(const double&amp; dt, const Planne
 		if((desiredVelocity &lt; 0.1 &amp;&amp; desiredVelocity &gt; -0.1) || CurrBehavior.followDistance &lt;= 0) //use only effective velocities
 			desiredVelocity = 0;
 
-		cout &lt;&lt; &quot;Follow State:  acceleration = &quot; &lt;&lt; deceleration_critical &lt;&lt; &quot;, speed = &quot; &lt;&lt; desiredVelocity &lt;&lt;  &quot;, Distance = &quot; &lt;&lt; CurrBehavior.followDistance&lt;&lt; endl;
+		//cout &lt;&lt; &quot;Follow State:  acceleration = &quot; &lt;&lt; deceleration_critical &lt;&lt; &quot;, speed = &quot; &lt;&lt; CurrStatus.speed &lt;&lt;  &quot;, Distance = &quot; &lt;&lt; CurrBehavior.followDistance&lt;&lt; endl;
 	}
 	else
 	{
</diff>
				<old_file>/*
 * TrajectoryFollower.cpp
 *
 *  Created on: Jun 18, 2016
 *      Author: hatem
 */

#include &quot;TrajectoryFollower.h&quot;
#include &quot;PlanningHelpers.h&quot;
#include &lt;cmath&gt;
#include &lt;stdlib.h&gt;
#include &lt;iostream&gt;

using namespace PlannerHNS;
using namespace UtilityHNS;
using namespace std;


namespace SimulationNS
{

TrajectoryFollower::TrajectoryFollower()
{
	m_iNextTest = 0;
	m_bCalibrationMode = false;
	m_bEnableLog = false;
	m_WayPointsDensity = 1;
	m_bEndPath = false;
	m_FollowingDistance = 0;
	m_LateralError 		= 0;
	m_PrevDesiredSteer	= 0;
	m_FollowAcceleration= 0;
	m_iPrevWayPoint 	= -1;
	m_StartFollowDistance = 0;
	m_FollowAcc = 0.5;
	m_iCalculatedIndex = 0;
	UtilityH::GetTickCount(m_SteerDelayTimer);
	UtilityH::GetTickCount(m_VelocityDelayTimer);
}

void TrajectoryFollower::Init(const ControllerParams&amp; params, const CAR_BASIC_INFO&amp; vehicleInfo, bool bEnableLogs, bool bCalibration)
{
	m_bEnableLog = bEnableLogs;
	m_bCalibrationMode = bCalibration;
	if(m_bCalibrationMode)
		InitCalibration();

	m_Params = params;
	m_VehicleInfo = vehicleInfo;

	//m_pidSteer.Init(0.1, 0.005, 0.001); // for 5 m/s
	//m_pidSteer.Init(0.07, 0.02, 0.01); // for 3 m/s
	//m_pidSteer.Init(0.9, 0.1, 0.2); //for lateral error
	//m_pidVelocity.Init(0.1, 0.005, 0.1);
	m_lowpassSteer.Init(2, 100, 4);

	m_pidSteer.Init(params.Steering_Gain.kP, params.Steering_Gain.kI, params.Steering_Gain.kD); // for 3 m/s
	m_pidSteer.Setlimit(m_VehicleInfo.max_steer_angle, -m_VehicleInfo.max_steer_angle);
	m_pidVelocity.Init(params.Velocity_Gain.kP, params.Velocity_Gain.kI, params.Velocity_Gain.kD);
}

TrajectoryFollower::~TrajectoryFollower()
{
	if(m_bEnableLog)
	{
		DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::ControlLogFolderName, &quot;ControlLog&quot;,
				&quot;time,X,Y,heading, Target, error,LateralError,SteerBeforLowPass,Steer,iIndex, pathSize&quot;,
				m_LogData);

		DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::ControlLogFolderName, &quot;SteeringCalibrationLog&quot;,
				&quot;time, reset, start A, end A, desired A, dt, vel&quot;, m_SteerCalibrationData);

		DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::ControlLogFolderName, &quot;VelocityCalibrationLog&quot;,
				&quot;time, reset, start V, end V, desired V, dt, steering&quot;, m_VelocityCalibrationData);

		DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::ControlLogFolderName, &quot;SteeringPIDLog&quot;,m_pidSteer.ToStringHeader(), m_LogSteerPIDData );
		DataRW::WriteLogData(UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName+DataRW::ControlLogFolderName, &quot;VelocityPIDLog&quot;,m_pidVelocity.ToStringHeader(), m_LogVelocityPIDData );
	}
}

void TrajectoryFollower::PrepareNextWaypoint(const PlannerHNS::WayPoint&amp; CurPos, const double&amp; currVelocity, const double&amp; currSteering)
{
	WayPoint pred_point = CurPos;
	m_ForwardSimulation = pred_point;

	double nIterations = m_Params.SteeringDelay/0.01; //angle error
	//double nIterations = 0.5/0.01; //lateral  error
	for(unsigned int i=0; i&lt; nIterations; i++)
	{
		PredictMotion(m_ForwardSimulation.pos.x, m_ForwardSimulation.pos.y, m_ForwardSimulation.pos.a, currSteering,currVelocity, m_VehicleInfo.wheel_base, 0.01);
	}

	m_CurrPos = m_ForwardSimulation;

	bool ret = FindNextWayPoint(m_Path, pred_point, currVelocity, m_FollowMePoint, m_PerpendicularPoint, m_LateralError, m_FollowingDistance);
	if(ret)
	{
		m_DesPos = m_FollowMePoint;
	//	m_DesPos.a = m_pDesAngCir-&gt;CalcAngle(m_DesPos.a);
	}
}

void TrajectoryFollower::UpdateCurrentPath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
{
	//BehaviorsNS::MappingHelpers::ConvertFromWaypointsToVectorPath(path, m_Path);
	if(path.size()&gt;0)
		m_WayPointsDensity = hypot(path.at(1).pos.y - path.at(0).pos.y, path.at(1).pos.x - path.at(0).pos.x);

	m_Path = path;
}

bool TrajectoryFollower::FindNextWayPoint(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; state,
		const double&amp; velocity, PlannerHNS::WayPoint&amp; pursuite_point, PlannerHNS::WayPoint&amp; prep,
		double&amp; lateral_err, double&amp; follow_distance)
{
	if(path.size()==0) return false;

	follow_distance = fabs(velocity) * (m_Params.SteeringDelay+0.5);
	if(follow_distance &lt; m_Params.minPursuiteDistance)
		follow_distance = m_Params.minPursuiteDistance;

	RelativeInfo info;
	PlanningHelpers::GetRelativeInfo(path, state, info);
	unsigned int point_index = 0;
	pursuite_point = PlanningHelpers::GetFollowPointOnTrajectory(path, info, follow_distance, point_index);
	prep = info.perp_point;
	lateral_err = info.perp_distance;
	m_iPrevWayPoint = info.iFront;

	double d_critical = (-velocity*velocity)/2.0*m_VehicleInfo.max_deceleration;
	int nPointToEnd = path.size() - m_iPrevWayPoint;
	double totalD = m_WayPointsDensity*nPointToEnd;

	if(totalD &lt;= 1 || totalD &lt;= d_critical)
	{
		m_bEndPath = true;
		cout &lt;&lt; &quot;Critical Distance: &quot; &lt;&lt; d_critical &lt;&lt; endl;
	}
	else
		m_bEndPath = false;

	return true;
}

int TrajectoryFollower::SteerControllerUpdate(const PlannerHNS::VehicleState&amp; CurrStatus,
		const PlannerHNS::BehaviorState&amp; CurrBehavior, double&amp; desiredSteerAngle)
{
	if(m_Path.size()==0) return -1;
	int ret = -1;
	//AdjustPID(CurrStatus.velocity, 18.0, m_Params.Gain);
	if(CurrBehavior.state == FORWARD_STATE || CurrBehavior.state == TRAFFIC_LIGHT_STOP_STATE || CurrBehavior.state == STOP_SIGN_STOP_STATE || CurrBehavior.state  == FOLLOW_STATE)
		ret = SteerControllerPart(m_CurrPos, m_DesPos, m_LateralError, desiredSteerAngle);

	if(ret &lt; 0)
		desiredSteerAngle = m_PrevDesiredSteer;
	else
		m_PrevDesiredSteer = desiredSteerAngle;

	return ret;
}

int TrajectoryFollower::SteerControllerPart(const PlannerHNS::WayPoint&amp; state, const PlannerHNS::WayPoint&amp; way_point,
		const double&amp; lateral_error, double&amp; steerd)
{
	double current_a = UtilityH::SplitPositiveAngle(state.pos.a);
	double target_a = atan2(way_point.pos.y - state.pos.y, way_point.pos.x - state.pos.x);

	double e =  UtilityH::SplitPositiveAngle(target_a - current_a);

//	if(e &gt; M_PI_2 || e &lt; -M_PI_2)
//		return -1;


	double before_lowpass = m_pidSteer.getPID(e);
	//cout &lt;&lt; m_pidSteer.ToString() &lt;&lt; endl;

	if(m_bEnableLog)
		m_LogSteerPIDData.push_back(m_pidSteer.ToString());

	//TODO use lateral error instead of angle error
	//double future_lateral_error = PlanningHelpers::GetPerpDistanceToTrajectorySimple(m_Path, m_ForwardSimulation,0);


	//steerd = m_pidSteer.getPID( future_lateral_error*-1, 0);

//	if(m_LateralError &lt; 0)
//		steerd = m_pidSteer.getPID(current_a+sqrt(abs(m_LateralError)), target_a);
//	else
//		steerd = m_pidSteer.getPID(current_a-sqrt(m_LateralError), target_a);


	//cout &lt;&lt; &quot;Error : &quot; &lt;&lt; e &lt;&lt; &quot;, Current A: &quot; &lt;&lt; current_a &lt;&lt; &quot;, Target A: &quot; &lt;&lt; target_a &lt;&lt;  &quot; Steeting Angle = &quot; &lt;&lt; steerd*RAD2DEG &lt;&lt; endl;
//	if(abs(before_lowpass) &lt; m_Params.MaxSteerAngle*0.5)
//		steerd = m_lowpassSteer.getFilter(before_lowpass);
//	else
		steerd = before_lowpass;

//	timespec t;
//	UtilityH::GetTickCount(t);
//	std::ostringstream dataLine;
//	dataLine &lt;&lt; UtilityH::GetLongTime(t) &lt;&lt; &quot;,&quot; &lt;&lt; state.pos.x &lt;&lt; &quot;,&quot; &lt;&lt; state.pos.y &lt;&lt; &quot;,&quot; &lt;&lt;  current_a &lt;&lt; &quot;,&quot; &lt;&lt;
//			target_a &lt;&lt; &quot;,&quot; &lt;&lt;  e &lt;&lt; &quot;,&quot; &lt;&lt;m_LateralError &lt;&lt; &quot;,&quot; &lt;&lt;  before_lowpass &lt;&lt; &quot;,&quot; &lt;&lt;  steerd &lt;&lt;  &quot;,&quot; &lt;&lt;
//			m_iPrevWayPoint &lt;&lt; &quot;,&quot; &lt;&lt; m_Path.size() &lt;&lt; &quot;,&quot;;
//	m_LogData.push_back(dataLine.str());

	return 1;
}

void TrajectoryFollower::PredictMotion(double&amp; x, double &amp;y, double&amp; heading, double steering, double velocity, double wheelbase, double time_elapsed)
{
	x += velocity * time_elapsed *  cos(heading);
	y += velocity * time_elapsed *  sin(heading);
	heading = heading + ((velocity*time_elapsed*tan(steering))  / (wheelbase) );
}

int TrajectoryFollower::VeclocityControllerUpdate(const double&amp; dt, const PlannerHNS::VehicleState&amp; CurrStatus,
		const PlannerHNS::BehaviorState&amp; CurrBehavior, double&amp; desiredVelocity, PlannerHNS::SHIFT_POS&amp; desiredShift)
{
	double critical_long_front_distance =  2.0;

	if(CurrBehavior.state == TRAFFIC_LIGHT_STOP_STATE || CurrBehavior.state == STOP_SIGN_STOP_STATE || m_bEndPath)
	{
		double deceleration_critical = m_VehicleInfo.max_deceleration;
		if(CurrBehavior.stopDistance != 0)
			deceleration_critical = (-CurrStatus.speed*CurrStatus.speed)/(2.0*CurrBehavior.stopDistance);

		desiredVelocity = (deceleration_critical * dt) + CurrStatus.speed;

		//desiredVelocity = m_PerpendicularPoint.v;
	}
	else if(CurrBehavior.state == FORWARD_STATE || CurrBehavior.state == OBSTACLE_AVOIDANCE_STATE )
	{

		double e = CurrBehavior.maxVelocity - CurrStatus.speed;

		//Using PID for velocity
		//m_pidVelocity.Setlimit(CurrBehavior.maxVelocity, 0);
		//desiredVelocity = m_pidVelocity.getPID(e);

		//Using constant acceleration for velocity
		if(e &gt;= 0)
			desiredVelocity = (m_VehicleInfo.max_acceleration * dt) + CurrStatus.speed;
		else
			desiredVelocity = (m_VehicleInfo.max_deceleration * dt) + CurrStatus.speed;

		if(desiredVelocity &gt; CurrBehavior.maxVelocity)
			desiredVelocity = CurrBehavior.maxVelocity;
		else if(desiredVelocity&lt;m_VehicleInfo.min_speed_forward)
			desiredVelocity = m_VehicleInfo.min_speed_forward;

		//std::cout &lt;&lt; &quot;Velocity from follower : dt=&quot; &lt;&lt; dt &lt;&lt; &quot;, e= &quot; &lt;&lt; e &lt;&lt; &quot;, acc_const=&quot; &lt;&lt; acc_const &lt;&lt; &quot;, desiredVelocity = &quot;&lt;&lt;desiredVelocity&lt;&lt;  std::endl;

		m_StartFollowDistance = 0;
	}
	else if(CurrBehavior.state == STOPPING_STATE || CurrBehavior.state == FINISH_STATE)
	{
		desiredVelocity = 0;
	}
	else if(CurrBehavior.state == FOLLOW_STATE)
	{
		double deceleration_critical = 0;
		double inv_time = 2.0*((CurrBehavior.followDistance-critical_long_front_distance)-CurrStatus.speed);
		if(inv_time == 0)
			deceleration_critical = MAX_ACCELERATION_2G;
		else
			deceleration_critical = CurrStatus.speed*CurrStatus.speed/inv_time;

		if(deceleration_critical &gt; 0) deceleration_critical = -deceleration_critical;
		if(deceleration_critical &lt; -MAX_ACCELERATION_2G) deceleration_critical = -MAX_ACCELERATION_2G;

		desiredVelocity = (deceleration_critical * dt) + CurrStatus.speed;

		if(desiredVelocity &gt; CurrBehavior.maxVelocity)
			desiredVelocity = CurrBehavior.maxVelocity;

		if((desiredVelocity &lt; 0.1 &amp;&amp; desiredVelocity &gt; -0.1) || CurrBehavior.followDistance &lt;= 0) //use only effective velocities
			desiredVelocity = 0;

		cout &lt;&lt; &quot;Follow State:  acceleration = &quot; &lt;&lt; deceleration_critical &lt;&lt; &quot;, speed = &quot; &lt;&lt; desiredVelocity &lt;&lt;  &quot;, Distance = &quot; &lt;&lt; CurrBehavior.followDistance&lt;&lt; endl;
	}
	else
	{
		desiredVelocity = 0;
	}

	if(desiredVelocity &gt; m_VehicleInfo.max_speed_forward)
		desiredVelocity = m_VehicleInfo.max_speed_forward;
	else if (desiredVelocity &lt; 0)
		desiredVelocity = 0;
	//desiredVelocity = 2.0;



	desiredShift = PlannerHNS::SHIFT_POS_DD;
	if(m_bEnableLog)
		m_LogVelocityPIDData.push_back(m_pidVelocity.ToString());
	return 1;
}

PlannerHNS::VehicleState TrajectoryFollower::DoOneStep(const double&amp; dt, const PlannerHNS::BehaviorState&amp; behavior,
		const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const PlannerHNS::WayPoint&amp; currPose,
		const PlannerHNS::VehicleState&amp; vehicleState, const bool&amp; bNewTrajectory)
{
	if(bNewTrajectory &amp;&amp; path.size() &gt; 0)
	{
		UpdateCurrentPath(path);
		m_iPrevWayPoint = -1;
	}

	PlannerHNS::VehicleState desiredState;

	if(m_bCalibrationMode)
	{
		CalibrationStep(dt, vehicleState, desiredState.steer, desiredState.speed);
		desiredState.shift = PlannerHNS::SHIFT_POS_DD;
	}
	else if(m_Path.size()&gt;0 &amp;&amp; behavior.state != INITIAL_STATE )
	{
		PrepareNextWaypoint(currPose, vehicleState.speed, vehicleState.steer);
		VeclocityControllerUpdate(dt, vehicleState, behavior, desiredState.speed, desiredState.shift);
		SteerControllerUpdate(vehicleState, behavior, desiredState.steer);
	}
	else
	{
		desiredState.steer = 0;
		desiredState.speed = 0;
		desiredState.shift = PlannerHNS::SHIFT_POS_DD;
		//cout &lt;&lt; &quot;&gt;&gt;&gt; Error, Very Dangerous, Following No Path !!.&quot; &lt;&lt; endl;
	}

	if(m_bEnableLog)
		LogCalibrationData(vehicleState, desiredState);

	return desiredState;
}

void TrajectoryFollower::CalibrationStep(const double&amp; dt, const PlannerHNS::VehicleState&amp; CurrStatus, double&amp; desiredSteer, double&amp; desiredVelocity)
{
	if(m_iNextTest &gt;= (int)m_CalibrationRunList.size()-1)
	{
		desiredSteer = 0;
		desiredVelocity = 0;
		return;
	}

	if(fabs(CurrStatus.speed - m_CalibrationRunList.at(m_iNextTest).first)*3.6 &lt;= 1
			&amp;&amp; fabs(CurrStatus.steer - m_CalibrationRunList.at(m_iNextTest).second)*RAD2DEG &lt;=0.5)
		m_iNextTest++;

	desiredVelocity = m_CalibrationRunList.at(m_iNextTest).first;
	desiredSteer = m_CalibrationRunList.at(m_iNextTest).second;

	cout &lt;&lt; &quot;i:&quot; &lt;&lt; m_iNextTest &lt;&lt; &quot;, desVel:&quot; &lt;&lt; desiredVelocity &lt;&lt; &quot;, CurVel:&quot; &lt;&lt; CurrStatus.speed
			&lt;&lt; &quot;, desStr:&quot; &lt;&lt; desiredSteer &lt;&lt; &quot;, CurrStr:&quot; &lt;&lt; CurrStatus.steer &lt;&lt; endl;

//	double e = targetSpeed - CurrStatus.speed;
//	if(e &gt;= 0)
//		desiredVelocity = (m_VehicleInfo.max_acceleration * dt) + CurrStatus.speed;
//	else
//		desiredVelocity = (m_VehicleInfo.max_deceleration * dt) + CurrStatus.speed;
}

void TrajectoryFollower::LogCalibrationData(const PlannerHNS::VehicleState&amp; currState,const PlannerHNS::VehicleState&amp; desiredState)
{
	int startAngle=0, finishAngle=0, originalTargetAngle=0, currVelocity = 0;
	double t_FromStartToFinish_a = 0;
	bool bAngleReset = false;
	int startV=0, finishV=0, originalTargetV=0, currSteering = 0;
	double t_FromStartToFinish_v = 0;
	bool bVelocityReset = false;

	//1- decide reset
	if((int)(m_prevDesiredState_steer.steer*RAD2DEG) != (int)(desiredState.steer*RAD2DEG))
		bAngleReset = true;

	if((int)(m_prevDesiredState_vel.speed*3.6) != (int)(desiredState.speed*3.6))
		bVelocityReset = true;

	//2- calculate time and log
	if(bAngleReset)
	{
		startAngle = m_prevCurrState_steer.steer*RAD2DEG;
		finishAngle = currState.steer*RAD2DEG;
		originalTargetAngle = m_prevDesiredState_steer.steer*RAD2DEG;
		t_FromStartToFinish_a = UtilityH::GetTimeDiffNow(m_SteerDelayTimer);
		currVelocity = currState.speed*3.6;
		UtilityH::GetTickCount(m_SteerDelayTimer);

		std::ostringstream dataLine;
		dataLine &lt;&lt; UtilityH::GetLongTime(m_SteerDelayTimer) &lt;&lt; &quot;,&quot;
				&lt;&lt; bAngleReset &lt;&lt; &quot;,&quot;
				&lt;&lt; startAngle &lt;&lt; &quot;,&quot;
				&lt;&lt; finishAngle &lt;&lt; &quot;,&quot;
				&lt;&lt; originalTargetAngle &lt;&lt; &quot;,&quot;
				&lt;&lt; t_FromStartToFinish_a &lt;&lt; &quot;,&quot;
				&lt;&lt; currVelocity &lt;&lt; &quot;,&quot;;

		m_SteerCalibrationData.push_back(dataLine.str());

		if(bAngleReset)
		{
			bAngleReset = false;
			m_prevCurrState_steer = currState;
			m_prevDesiredState_steer = desiredState;
		}
	}

	if(bVelocityReset)
	{
		startV = m_prevCurrState_vel.speed*3.6;
		finishV = currState.speed*3.6;
		originalTargetV = m_prevDesiredState_vel.speed*3.6;
		t_FromStartToFinish_v = UtilityH::GetTimeDiffNow(m_VelocityDelayTimer);
		currSteering = currState.steer*RAD2DEG;
		UtilityH::GetTickCount(m_VelocityDelayTimer);

		std::ostringstream dataLine;
		dataLine &lt;&lt; UtilityH::GetLongTime(m_VelocityDelayTimer) &lt;&lt; &quot;,&quot;
				&lt;&lt; bVelocityReset &lt;&lt; &quot;,&quot;
				&lt;&lt; startV &lt;&lt; &quot;,&quot;
				&lt;&lt; finishV &lt;&lt; &quot;,&quot;
				&lt;&lt; originalTargetV &lt;&lt; &quot;,&quot;
				&lt;&lt; t_FromStartToFinish_v &lt;&lt; &quot;,&quot;
				&lt;&lt; currSteering &lt;&lt; &quot;,&quot;;

		m_VelocityCalibrationData.push_back(dataLine.str());

		if(bVelocityReset)
		{
			bVelocityReset = false;
			m_prevCurrState_vel = currState;
			m_prevDesiredState_vel = desiredState;
		}
	}
}

void TrajectoryFollower::InitCalibration()
{
	m_CalibrationRunList.push_back(make_pair(0,0));
	m_CalibrationRunList.push_back(make_pair(0,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(0,0.0));
	m_CalibrationRunList.push_back(make_pair(0,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(0,m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(0,0.0));
	m_CalibrationRunList.push_back(make_pair(0,-m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(0,m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(0,0.0));
	m_CalibrationRunList.push_back(make_pair(0,-m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(0,m_VehicleInfo.max_steer_angle/1.0));
	m_CalibrationRunList.push_back(make_pair(0,0.0));
	m_CalibrationRunList.push_back(make_pair(0,-m_VehicleInfo.max_steer_angle/1.0));

	m_CalibrationRunList.push_back(make_pair(1,0));
	m_CalibrationRunList.push_back(make_pair(1,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(1,0.0));
	m_CalibrationRunList.push_back(make_pair(1,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(1,m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(1,0.0));
	m_CalibrationRunList.push_back(make_pair(1,-m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(1,m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(1,0.0));
	m_CalibrationRunList.push_back(make_pair(1,-m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(1,m_VehicleInfo.max_steer_angle/1.0));
	m_CalibrationRunList.push_back(make_pair(1,0.0));
	m_CalibrationRunList.push_back(make_pair(1,-m_VehicleInfo.max_steer_angle/1.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(2,0));
	m_CalibrationRunList.push_back(make_pair(2,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(2,0.0));
	m_CalibrationRunList.push_back(make_pair(2,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(2,m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(2,0.0));
	m_CalibrationRunList.push_back(make_pair(2,-m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(2,m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(2,0.0));
	m_CalibrationRunList.push_back(make_pair(2,-m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(2,m_VehicleInfo.max_steer_angle/1.0));
	m_CalibrationRunList.push_back(make_pair(2,0.0));
	m_CalibrationRunList.push_back(make_pair(2,-m_VehicleInfo.max_steer_angle/1.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(3,0));
	m_CalibrationRunList.push_back(make_pair(3,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(3,0.0));
	m_CalibrationRunList.push_back(make_pair(3,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(3,m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(3,0.0));
	m_CalibrationRunList.push_back(make_pair(3,-m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(3,m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(3,0.0));
	m_CalibrationRunList.push_back(make_pair(3,-m_VehicleInfo.max_steer_angle/1.5));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(4,0));
	m_CalibrationRunList.push_back(make_pair(4,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(4,0.0));
	m_CalibrationRunList.push_back(make_pair(4,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(4,m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(4,0.0));
	m_CalibrationRunList.push_back(make_pair(4,-m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(4,m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(4,0.0));
	m_CalibrationRunList.push_back(make_pair(4,-m_VehicleInfo.max_steer_angle/1.5));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(5,0));
	m_CalibrationRunList.push_back(make_pair(5,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(5,0.0));
	m_CalibrationRunList.push_back(make_pair(5,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(5,m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(5,0.0));
	m_CalibrationRunList.push_back(make_pair(5,-m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(5,m_VehicleInfo.max_steer_angle/1.5));
	m_CalibrationRunList.push_back(make_pair(5,0.0));
	m_CalibrationRunList.push_back(make_pair(5,-m_VehicleInfo.max_steer_angle/1.5));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(6,0));
	m_CalibrationRunList.push_back(make_pair(6,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(6,0.0));
	m_CalibrationRunList.push_back(make_pair(6,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(6,m_VehicleInfo.max_steer_angle/3.0));
	m_CalibrationRunList.push_back(make_pair(6,0.0));
	m_CalibrationRunList.push_back(make_pair(6,-m_VehicleInfo.max_steer_angle/3.0));
	m_CalibrationRunList.push_back(make_pair(6,m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(6,0.0));
	m_CalibrationRunList.push_back(make_pair(6,-m_VehicleInfo.max_steer_angle/2.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(7,0));
	m_CalibrationRunList.push_back(make_pair(7,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(7,0.0));
	m_CalibrationRunList.push_back(make_pair(7,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(7,m_VehicleInfo.max_steer_angle/3.0));
	m_CalibrationRunList.push_back(make_pair(7,0.0));
	m_CalibrationRunList.push_back(make_pair(7,-m_VehicleInfo.max_steer_angle/3.0));
	m_CalibrationRunList.push_back(make_pair(7,m_VehicleInfo.max_steer_angle/2.0));
	m_CalibrationRunList.push_back(make_pair(7,0.0));
	m_CalibrationRunList.push_back(make_pair(7,-m_VehicleInfo.max_steer_angle/2.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(8,0));
	m_CalibrationRunList.push_back(make_pair(8,m_VehicleInfo.max_steer_angle/6.0));
	m_CalibrationRunList.push_back(make_pair(8,0.0));
	m_CalibrationRunList.push_back(make_pair(8,-m_VehicleInfo.max_steer_angle/6.0));
	m_CalibrationRunList.push_back(make_pair(8,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(8,0.0));
	m_CalibrationRunList.push_back(make_pair(8,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(8,m_VehicleInfo.max_steer_angle/3.0));
	m_CalibrationRunList.push_back(make_pair(8,0.0));
	m_CalibrationRunList.push_back(make_pair(8,-m_VehicleInfo.max_steer_angle/3.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(9,0));
	m_CalibrationRunList.push_back(make_pair(9,m_VehicleInfo.max_steer_angle/6.0));
	m_CalibrationRunList.push_back(make_pair(9,0.0));
	m_CalibrationRunList.push_back(make_pair(9,-m_VehicleInfo.max_steer_angle/6.0));
	m_CalibrationRunList.push_back(make_pair(9,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(9,0.0));
	m_CalibrationRunList.push_back(make_pair(9,-m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(9,m_VehicleInfo.max_steer_angle/3.0));
	m_CalibrationRunList.push_back(make_pair(9,0.0));
	m_CalibrationRunList.push_back(make_pair(9,-m_VehicleInfo.max_steer_angle/3.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(10,0));
	m_CalibrationRunList.push_back(make_pair(10,m_VehicleInfo.max_steer_angle/6.0));
	m_CalibrationRunList.push_back(make_pair(10,0.0));
	m_CalibrationRunList.push_back(make_pair(10,-m_VehicleInfo.max_steer_angle/6.0));
	m_CalibrationRunList.push_back(make_pair(10,m_VehicleInfo.max_steer_angle/5.0));
	m_CalibrationRunList.push_back(make_pair(10,0.0));
	m_CalibrationRunList.push_back(make_pair(10,-m_VehicleInfo.max_steer_angle/5.0));
	m_CalibrationRunList.push_back(make_pair(10,m_VehicleInfo.max_steer_angle/4.0));
	m_CalibrationRunList.push_back(make_pair(10,0.0));
	m_CalibrationRunList.push_back(make_pair(10,-m_VehicleInfo.max_steer_angle/4.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(11,0));
	m_CalibrationRunList.push_back(make_pair(11,m_VehicleInfo.max_steer_angle/8.0));
	m_CalibrationRunList.push_back(make_pair(11,0.0));
	m_CalibrationRunList.push_back(make_pair(11,-m_VehicleInfo.max_steer_angle/8.0));
	m_CalibrationRunList.push_back(make_pair(11,m_VehicleInfo.max_steer_angle/6.0));
	m_CalibrationRunList.push_back(make_pair(11,0.0));
	m_CalibrationRunList.push_back(make_pair(11,-m_VehicleInfo.max_steer_angle/6.0));
	m_CalibrationRunList.push_back(make_pair(11,m_VehicleInfo.max_steer_angle/5.0));
	m_CalibrationRunList.push_back(make_pair(11,0.0));
	m_CalibrationRunList.push_back(make_pair(11,-m_VehicleInfo.max_steer_angle/5.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(13,0));
	m_CalibrationRunList.push_back(make_pair(13,m_VehicleInfo.max_steer_angle/10.0));
	m_CalibrationRunList.push_back(make_pair(13,0.0));
	m_CalibrationRunList.push_back(make_pair(13,-m_VehicleInfo.max_steer_angle/10.0));
	m_CalibrationRunList.push_back(make_pair(13,m_VehicleInfo.max_steer_angle/9.0));
	m_CalibrationRunList.push_back(make_pair(13,0.0));
	m_CalibrationRunList.push_back(make_pair(13,-m_VehicleInfo.max_steer_angle/9.0));
	m_CalibrationRunList.push_back(make_pair(13,m_VehicleInfo.max_steer_angle/8.0));
	m_CalibrationRunList.push_back(make_pair(13,0.0));
	m_CalibrationRunList.push_back(make_pair(13,-m_VehicleInfo.max_steer_angle/8.0));

	m_CalibrationRunList.push_back(make_pair(0,0));

	m_CalibrationRunList.push_back(make_pair(15,0));
	m_CalibrationRunList.push_back(make_pair(15,m_VehicleInfo.max_steer_angle/15.0));
	m_CalibrationRunList.push_back(make_pair(15,0.0));
	m_CalibrationRunList.push_back(make_pair(15,-m_VehicleInfo.max_steer_angle/15.0));
	m_CalibrationRunList.push_back(make_pair(15,m_VehicleInfo.max_steer_angle/12.0));
	m_CalibrationRunList.push_back(make_pair(15,0.0));
	m_CalibrationRunList.push_back(make_pair(15,-m_VehicleInfo.max_steer_angle/12.0));
	m_CalibrationRunList.push_back(make_pair(15,m_VehicleInfo.max_steer_angle/10.0));
	m_CalibrationRunList.push_back(make_pair(15,0.0));
	m_CalibrationRunList.push_back(make_pair(15,-m_VehicleInfo.max_steer_angle/10.0));
	m_CalibrationRunList.push_back(make_pair(0,0));
}

} /* namespace SimulationNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_utility/include/DataRW.h" new_path="ros/src/computing/planning/common/lib/openplanner/op_utility/include/DataRW.h">
				<diff>@@ -25,6 +25,7 @@ public:
 	static std::string LoggingMainfolderName;
 	static std::string ControlLogFolderName;
 	static std::string PathLogFolderName;
+	static std::string GlobalPathLogFolderName;
 	static std::string StatesLogFolderName;
 	static std::string SimulationFolderName;
 	static std::string KmlMapsFolderName;
@@ -134,6 +135,7 @@ public:
 		double a;
 		double c;
 		double v;
+		std::string name;
 	};
 
 	struct SimulationData
@@ -413,6 +415,45 @@ public:
 	int ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
 };
 
+class AisanCurbFileReader : public SimpleReaderBase
+{
+public:
+
+	struct AisanCurb
+	{
+		int 	ID;
+		int 	LID;
+		double 	Height;
+		double 	Width;
+		int 	dir;
+		int 	LinkID;
+	};
+
+	AisanCurbFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	~AisanCurbFileReader(){}
+
+	bool ReadNextLine(AisanCurb&amp; data);
+	int ReadAllData(std::vector&lt;AisanCurb&gt;&amp; data_list);
+};
+
+class AisanRoadEdgeFileReader : public SimpleReaderBase
+{
+public:
+
+	struct AisanRoadEdge
+	{
+		int 	ID;
+		int 	LID;
+		int 	LinkID;
+	};
+
+	AisanRoadEdgeFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
+	~AisanRoadEdgeFileReader(){}
+
+	bool ReadNextLine(AisanRoadEdge&amp; data);
+	int ReadAllData(std::vector&lt;AisanRoadEdge&gt;&amp; data_list);
+};
+
 class AisanDataConnFileReader : public SimpleReaderBase
 {
 public:
</diff>
				<old_file>/*
 * DataRW.h
 *
 *  Created on: Jun 23, 2016
 *      Author: hatem
 */

#ifndef DATARW_H_
#define DATARW_H_

#include &lt;string&gt;
#include &lt;fstream&gt;
#include &lt;sstream&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;

namespace UtilityHNS {

class DataRW
{
public:
	DataRW();
	virtual ~DataRW();

	static std::string LoggingMainfolderName;
	static std::string ControlLogFolderName;
	static std::string PathLogFolderName;
	static std::string StatesLogFolderName;
	static std::string SimulationFolderName;
	static std::string KmlMapsFolderName;


	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::string&gt;&amp; gps_list);
	static void WriteKMLFile(const std::string&amp; fileName, const std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; gps_list);
	static void WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData);
};

class SimpleReaderBase
{
private:
	std::ifstream* m_pFile;
	std::vector&lt;std::string&gt; m_RawHeaders;
	std::vector&lt;std::string&gt; m_DataTitlesHeader;
	std::vector&lt;std::vector&lt;std::vector&lt;std::string&gt; &gt; &gt; m_AllData;
	int m_nHeders;
	int m_iDataTitles;
	int m_nVarPerObj;
	int m_nLineHeaders;
	std::string m_HeaderRepeatKey;
	char m_Separator;

	void ReadHeaders();
	void ParseDataTitles(const std::string&amp; header);

public:
	/**
	 *
	 * @param fileName log file name
	 * @param nHeaders number of data headers
	 * @param iDataTitles which row contains the data titles
	 * @param nVariablesForOneObject 0 means each row represents one object
	 */
	SimpleReaderBase(const std::string&amp; fileName, const int&amp; nHeaders = 2, const char&amp; separator = ',',
			const int&amp; iDataTitles = 1, const int&amp; nVariablesForOneObject = 0,
			const int&amp; nLineHeaders = 0, const std::string&amp; headerRepeatKey = &quot;...&quot;);
	~SimpleReaderBase();

protected:
	int ReadAllData();
	bool ReadSingleLine(std::vector&lt;std::vector&lt;std::string&gt; &gt;&amp; line);

};

//class GPSLocalizerReader : public SimpleReaderBase
//{
//	public:
//		GPSLocalizerReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
//		~GPSLocalizerReader(){}
//
//		bool ReadNextLine( MsgEstPose&amp; pos, double&amp; logTime);
//		int ReadAllData(vector&lt;pair&lt;double,  MsgEstPose&gt; &gt;&amp; pos_list);
//};
//
class GPSDataReader : public SimpleReaderBase
{
public:
	struct GPSBasicData
	{
		double lat;
		double lon;
		double alt;
		double dir;
		double distance;

	};

	public:
	GPSDataReader(const std::string&amp; fileName) : SimpleReaderBase(fileName){}
	~GPSDataReader(){}

	bool ReadNextLine(GPSBasicData&amp; data);
	int ReadAllData(std::vector&lt;GPSBasicData&gt;&amp; data_list);
};

//
//class VehicleStateReader : public SimpleReaderBase
//{
//	public:
//	VehicleStateReader(const string&amp; fileName) : SimpleReaderBase(fileName){}
//	~VehicleStateReader(){}
//
//	bool ReadNextLine( MsgVehicleStatus&amp; state, double&amp; logTime);
//	int ReadAllData(vector&lt;pair&lt;double,  MsgVehicleStatus&gt; &gt;&amp; state_list);
//};
//
//class MovingObjectsReader : public SimpleReaderBase
//{
//	public:
//	MovingObjectsReader(const string&amp; fileName) : SimpleReaderBase(fileName, 2, 1, 28, 4){}
//	~MovingObjectsReader(){}
//
//	bool ReadNextLine( MsgMovingObject&amp; state, double&amp; logTime);
//	int ReadAllData(vector&lt;pair&lt;double,  MsgMovingObject&gt; &gt;&amp; state_list);
//};

class SimulationFileReader : public SimpleReaderBase
{
public:
	struct SimulationPoint
	{
		double x;
		double y;
		double z;
		double a;
		double c;
		double v;
	};

	struct SimulationData
	{
		SimulationPoint startPoint;
		SimulationPoint goalPoint;
		std::vector&lt;SimulationPoint&gt; simuCars;
	};

	SimulationFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~SimulationFileReader(){}

	bool ReadNextLine(SimulationPoint&amp; data);
	int ReadAllData(SimulationData&amp; data_list);
};

class LocalizationPathReader : public SimpleReaderBase
{
public:
	struct LocalizationWayPoint
	{
		double t;
		double x;
		double y;
		double z;
		double a;
		double v;
	};

	LocalizationPathReader(const std::string&amp; fileName, const char&amp; separator) : SimpleReaderBase(fileName, 1, separator){}
	~LocalizationPathReader(){}

	bool ReadNextLine(LocalizationWayPoint&amp; data);
	int ReadAllData(std::vector&lt;LocalizationWayPoint&gt;&amp; data_list);
};

class AisanPointsFileReader : public SimpleReaderBase
{
public:
	struct AisanPoints
	{
		int PID;
		double B;
		double L;
		double H;
		double Bx;
		double Ly;
		int Ref;
		int MCODE1;
		int MCODE2;
		int MCODE3;
	};

	AisanPointsFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanPointsFileReader(){}

	bool ReadNextLine(AisanPoints&amp; data);
	int ReadAllData(std::vector&lt;AisanPoints&gt;&amp; data_list);
};

class AisanNodesFileReader : public SimpleReaderBase
{
public:

	struct AisanNode
	{
		int NID;
		int PID;
	};

	AisanNodesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanNodesFileReader(){}

	bool ReadNextLine(AisanNode&amp; data);
	int ReadAllData(std::vector&lt;AisanNode&gt;&amp; data_list);
};

class AisanLinesFileReader : public SimpleReaderBase
{
public:

	struct AisanLine
	{
		int LID;
		int BPID;
		int FPID;
		int BLID;
		int FLID;
	};

	AisanLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanLinesFileReader(){}

	bool ReadNextLine(AisanLine&amp; data);
	int ReadAllData(std::vector&lt;AisanLine&gt;&amp; data_list);
};

class AisanCenterLinesFileReader : public SimpleReaderBase
{
public:

	struct AisanCenterLine
	{
		int 	DID;
		int 	Dist;
		int 	PID;
		double 	Dir;
		double 	Apara;
		double 	r;
		double 	slope;
		double 	cant;
		double 	LW;
		double 	RW;
	};

	AisanCenterLinesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanCenterLinesFileReader(){}

	bool ReadNextLine(AisanCenterLine&amp; data);
	int ReadAllData(std::vector&lt;AisanCenterLine&gt;&amp; data_list);
};

class AisanAreasFileReader : public SimpleReaderBase
{
public:

	struct AisanArea
	{
		int 	AID;
		int 	SLID;
		int 	ELID;
	};

	AisanAreasFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanAreasFileReader(){}

	bool ReadNextLine(AisanArea&amp; data);
	int ReadAllData(std::vector&lt;AisanArea&gt;&amp; data_list);
};

class AisanIntersectionFileReader : public SimpleReaderBase
{
public:

	struct AisanIntersection
	{
		int 	ID;
		int 	AID;
		int 	LinkID;
	};

	AisanIntersectionFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanIntersectionFileReader(){}

	bool ReadNextLine(AisanIntersection&amp; data);
	int ReadAllData(std::vector&lt;AisanIntersection&gt;&amp; data_list);
};

class AisanLanesFileReader : public SimpleReaderBase
{
public:

	struct AisanLane
	{
		int LnID	;
		int DID		;
		int BLID	;
		int FLID	;
		int BNID	;
		int FNID	;
		int JCT		;
		int BLID2	;
		int BLID3	;
		int BLID4	;
		int FLID2	;
		int FLID3	;
		int FLID4	;
		int ClossID	;
		double Span	;
		int LCnt	;
		int Lno		;
		int LaneType;
		int LimitVel;
		int RefVel	;
		int RoadSecID;
		int LaneChgFG;
		int LinkWAID;
		char LaneDir;
		int  LeftLaneId;
		int RightLaneId;

	};

	AisanLanesFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanLanesFileReader(){}

	bool ReadNextLine(AisanLane&amp; data);
	int ReadAllData(std::vector&lt;AisanLane&gt;&amp; data_list);
};

class AisanStopLineFileReader : public SimpleReaderBase
{
public:

	struct AisanStopLine
	{
		int 	ID;
		int 	LID;
		int 	TLID;
		int 	SignID;
		int 	LinkID;
	};

	AisanStopLineFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanStopLineFileReader(){}

	bool ReadNextLine(AisanStopLine&amp; data);
	int ReadAllData(std::vector&lt;AisanStopLine&gt;&amp; data_list);
};

class AisanRoadSignFileReader : public SimpleReaderBase
{
public:

	struct AisanRoadSign
	{
		int 	ID;
		int 	VID;
		int 	PLID;
		int 	Type;
		int 	LinkID;
	};

	AisanRoadSignFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanRoadSignFileReader(){}

	bool ReadNextLine(AisanRoadSign&amp; data);
	int ReadAllData(std::vector&lt;AisanRoadSign&gt;&amp; data_list);
};

class AisanSignalFileReader : public SimpleReaderBase
{
public:

	struct AisanSignal
	{
		int 	ID;
		int 	VID;
		int 	PLID;
		int 	Type;
		int 	LinkID;
	};

	AisanSignalFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanSignalFileReader(){}

	bool ReadNextLine(AisanSignal&amp; data);
	int ReadAllData(std::vector&lt;AisanSignal&gt;&amp; data_list);
};

class AisanVectorFileReader : public SimpleReaderBase
{
public:

	struct AisanVector
	{
		int 	VID;
		int 	PID;
		double 	Hang;
		double 	Vang;
	};

	AisanVectorFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanVectorFileReader(){}

	bool ReadNextLine(AisanVector&amp; data);
	int ReadAllData(std::vector&lt;AisanVector&gt;&amp; data_list);
};

class AisanDataConnFileReader : public SimpleReaderBase
{
public:

	struct DataConn
	{
		int 	LID; // lane id
		int 	SLID; // stop line id
		int 	SID; // signal id
		int 	SSID; // stop sign id
	};

	AisanDataConnFileReader(const std::string&amp; fileName) : SimpleReaderBase(fileName, 1){}
	~AisanDataConnFileReader(){}

	bool ReadNextLine(DataConn&amp; data);
	int ReadAllData(std::vector&lt;DataConn&gt;&amp; data_list);
};


} /* namespace UtilityHNS */

#endif /* DATARW_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/common/lib/openplanner/op_utility/src/DataRW.cpp" new_path="ros/src/computing/planning/common/lib/openplanner/op_utility/src/DataRW.cpp">
				<diff>@@ -17,6 +17,7 @@ namespace UtilityHNS
 
 std::string DataRW::LoggingMainfolderName 	= &quot;/SimuLogs/&quot;;
 std::string DataRW::ControlLogFolderName 	= &quot;ControlLogs/&quot;;
+std::string DataRW::GlobalPathLogFolderName = &quot;GlobalPathLogs/&quot;;
 std::string DataRW::PathLogFolderName 		= &quot;TrajectoriesLogs/&quot;;
 std::string DataRW::StatesLogFolderName 	= &quot;BehaviorsLogs/&quot;;
 std::string DataRW::SimulationFolderName 	= &quot;SimulationData/&quot;;
@@ -329,7 +330,7 @@ bool SimulationFileReader::ReadNextLine(SimulationPoint&amp; data)
 	if(ReadSingleLine(lineData))
 	{
 		if(lineData.size()==0) return false;
-		if(lineData.at(0).size() &lt; 5) return false;
+		if(lineData.at(0).size() &lt; 6) return false;
 
 		data.x = strtod(lineData.at(0).at(0).c_str(), NULL);
 		data.y = strtod(lineData.at(0).at(1).c_str(), NULL);
@@ -337,6 +338,7 @@ bool SimulationFileReader::ReadNextLine(SimulationPoint&amp; data)
 		data.a = strtod(lineData.at(0).at(3).c_str(), NULL);
 		data.c = strtod(lineData.at(0).at(4).c_str(), NULL);
 		data.v = strtod(lineData.at(0).at(5).c_str(), NULL);
+		data.name = lineData.at(0).at(6);
 
 		return true;
 
@@ -827,6 +829,75 @@ int AisanVectorFileReader::ReadAllData(vector&lt;AisanVector&gt;&amp; data_list)
 	return count;
 }
 
+bool AisanCurbFileReader::ReadNextLine(AisanCurb&amp; data)
+{
+	vector&lt;vector&lt;string&gt; &gt; lineData;
+	if(ReadSingleLine(lineData))
+	{
+		if(lineData.size()==0) return false;
+		if(lineData.at(0).size() &lt; 6) return false;
+
+		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.LID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.Height = strtod(lineData.at(0).at(2).c_str(), NULL);
+		data.Width 	= strtod(lineData.at(0).at(3).c_str(), NULL);
+		data.dir 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.LinkID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+
+		return true;
+
+	}
+	else
+		return false;
+}
+
+int AisanCurbFileReader::ReadAllData(vector&lt;AisanCurb&gt;&amp; data_list)
+{
+	data_list.clear();
+	AisanCurb data;
+	//double logTime = 0;
+	int count = 0;
+	while(ReadNextLine(data))
+	{
+		data_list.push_back(data);
+		count++;
+	}
+	return count;
+}
+
+bool AisanRoadEdgeFileReader::ReadNextLine(AisanRoadEdge&amp; data)
+{
+	vector&lt;vector&lt;string&gt; &gt; lineData;
+	if(ReadSingleLine(lineData))
+	{
+		if(lineData.size()==0) return false;
+		if(lineData.at(0).size() &lt; 3) return false;
+
+		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
+		data.LID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+		data.LinkID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
+
+		return true;
+
+	}
+	else
+		return false;
+}
+
+int AisanRoadEdgeFileReader::ReadAllData(vector&lt;AisanRoadEdge&gt;&amp; data_list)
+{
+	data_list.clear();
+	AisanRoadEdge data;
+	//double logTime = 0;
+	int count = 0;
+	while(ReadNextLine(data))
+	{
+		data_list.push_back(data);
+		count++;
+	}
+	return count;
+}
+
 bool AisanDataConnFileReader::ReadNextLine(DataConn&amp; data)
 {
 	vector&lt;vector&lt;string&gt; &gt; lineData;
</diff>
				<old_file>/*
 * DataRW.cpp
 *
 *  Created on: Jun 23, 2016
 *      Author: hatem
 */

#include &quot;DataRW.h&quot;
#include &lt;stdlib.h&gt;
#include &lt;tinyxml.h&gt;
#include &quot;UtilityH.h&quot;

using namespace std;

namespace UtilityHNS
{

std::string DataRW::LoggingMainfolderName 	= &quot;/SimuLogs/&quot;;
std::string DataRW::ControlLogFolderName 	= &quot;ControlLogs/&quot;;
std::string DataRW::PathLogFolderName 		= &quot;TrajectoriesLogs/&quot;;
std::string DataRW::StatesLogFolderName 	= &quot;BehaviorsLogs/&quot;;
std::string DataRW::SimulationFolderName 	= &quot;SimulationData/&quot;;
std::string DataRW::KmlMapsFolderName 		= &quot;KmlMaps/&quot;;


DataRW::DataRW()
{
}

DataRW::~DataRW()
{
}

void DataRW::WriteLogData(const std::string&amp; logFolder, const std::string&amp; logTitle, const std::string&amp; header, const std::vector&lt;std::string&gt;&amp; logData)
{
	if(logData.size() &lt; 2)
		return;

	ostringstream fileName;
	fileName &lt;&lt; logFolder;
	fileName &lt;&lt; logTitle;
	fileName &lt;&lt; UtilityH::GetFilePrefixHourMinuteSeconds();
	fileName &lt;&lt; &quot;.csv&quot;;

	std::ofstream f(fileName.str().c_str());

	if(f.is_open())
	{
		if(header.size() &gt; 0)
			f &lt;&lt; header &lt;&lt; &quot;\r\n&quot;;
		for(unsigned int i = 0 ; i &lt; logData.size(); i++)
			f &lt;&lt; logData.at(i) &lt;&lt; &quot;\r\n&quot;;
	}

	f.close();
}

void DataRW::WriteKMLFile(const string&amp; fileName, const vector&lt;string&gt;&amp; gps_list)
{
	TiXmlDocument kmldoc(UtilityH::GetHomeDirectory()+DataRW::KmlMapsFolderName + &quot;KmlTemplate.kml&quot;);

	bool bkmlFileLoaded =  kmldoc.LoadFile();

	assert(bkmlFileLoaded== true);

	TiXmlElement* pElem = kmldoc.FirstChildElement();

	if(!pElem)
	{
		printf(&quot;\n Empty KML File !&quot;);
		return;
	}

	TiXmlElement* pV=0;
	TiXmlHandle hKmlFile(pElem);

	//pV = hKmlFile.FirstChild(&quot;Folder&quot;).FirstChild(&quot;Folder&quot;).FirstChild(&quot;Document&quot;).FirstChild(&quot;Placemark&quot;).FirstChild(&quot;LineString&quot;).FirstChild(&quot;coordinates&quot;).Element();
	pV = hKmlFile.FirstChild(&quot;Folder&quot;).FirstChild(&quot;Document&quot;).FirstChild(&quot;Placemark&quot;).FirstChild(&quot;LineString&quot;).FirstChild(&quot;coordinates&quot;).Element();
	if(!pV)
		pV = hKmlFile.FirstChild( &quot;Placemark&quot; ).FirstChild(&quot;LineString&quot;).FirstChild(&quot;coordinates&quot;).Element();

	if(pV)
	{
			ostringstream val;
			val.precision(18);

			for(unsigned int i =0; i &lt; gps_list.size(); i++)
			{
				val &lt;&lt; gps_list[i] &lt;&lt;  &quot; &quot;;
			}

			TiXmlText * text = new TiXmlText( val.str() );
			pV-&gt;LinkEndChild(text);
	}

	kmldoc.SaveFile(fileName);
}

void DataRW::WriteKMLFile(const string&amp; fileName, const vector&lt;vector&lt;string&gt; &gt;&amp; gps_list)
  {
	  TiXmlDocument kmldoc(UtilityH::GetHomeDirectory()+DataRW::KmlMapsFolderName + &quot;KmlTemplate.kml&quot;);

	  	bool bkmlFileLoaded =  kmldoc.LoadFile();

	  	assert(bkmlFileLoaded== true);

	  	TiXmlElement* pElem = kmldoc.FirstChildElement();

	  	if(!pElem)
	  	{
	  		printf(&quot;\n Empty KML File !&quot;);
	  		return;
	  	}

	  	TiXmlNode* pV=0;
	  	TiXmlNode* pPlaceMarkNode=0;
	  	TiXmlElement* pDocument=0;
	  	TiXmlHandle hKmlFile(pElem);

	  	//pV = hKmlFile.FirstChild(&quot;Folder&quot;).FirstChild(&quot;Folder&quot;).FirstChild(&quot;Document&quot;).FirstChild(&quot;Placemark&quot;).FirstChild(&quot;LineString&quot;).FirstChild(&quot;coordinates&quot;).Element();

	  	pDocument = hKmlFile.FirstChild(&quot;Folder&quot;).FirstChild(&quot;Document&quot;).Element();
	  	pPlaceMarkNode = hKmlFile.FirstChild(&quot;Folder&quot;).FirstChild(&quot;Document&quot;).FirstChild(&quot;Placemark&quot;).Node();

	  	if(!pDocument)
	  	{
	  		pDocument = hKmlFile.Element();
	  		pPlaceMarkNode = hKmlFile.FirstChild( &quot;Placemark&quot; ).Node();
	  	}



//	  	pV = hKmlFile.FirstChild(&quot;Folder&quot;).FirstChild(&quot;Document&quot;).FirstChild(&quot;Placemark&quot;).FirstChild(&quot;LineString&quot;).FirstChild(&quot;coordinates&quot;).Element();
//	  	if(!pV)
//	  		pV = hKmlFile.FirstChild( &quot;Placemark&quot; ).FirstChild(&quot;LineString&quot;).FirstChild(&quot;coordinates&quot;).Element();


	  	if(pDocument)
	  	{
	  		for(unsigned int l = 0; l &lt; gps_list.size(); l++)
	  		{

	  			pV = pPlaceMarkNode-&gt;Clone();
	  			TiXmlElement* pElement = pV-&gt;FirstChild(&quot;LineString&quot;)-&gt;FirstChild(&quot;coordinates&quot;)-&gt;ToElement();

	  			ostringstream val;
				val.precision(18);

				for(unsigned int i =0; i &lt; gps_list[l].size(); i++)
				{
					val &lt;&lt; gps_list[l][i] &lt;&lt;  &quot; &quot;;
				}

				TiXmlText * text = new TiXmlText( val.str() );
				pElement-&gt;LinkEndChild(text);

				pDocument-&gt;InsertEndChild(*pV);

	  		}

	  	}

	  	kmldoc.SaveFile(fileName);
  }

SimpleReaderBase::SimpleReaderBase(const string&amp; fileName, const int&amp; nHeaders,const char&amp; separator,
		  const int&amp; iDataTitles, const int&amp; nVariablesForOneObject ,
		  const int&amp; nLineHeaders, const string&amp; headerRepeatKey)
{
	  m_pFile = new ifstream(fileName.c_str(), ios::in);
	  if(!m_pFile-&gt;is_open())
	  {
		  printf(&quot;\n Can't Open Map File !, %s&quot;, fileName.c_str());
		  return;
	  }

	m_nHeders = nHeaders;
	m_iDataTitles = iDataTitles;
	m_nVarPerObj = nVariablesForOneObject;
	m_HeaderRepeatKey = headerRepeatKey;
	m_nLineHeaders = nLineHeaders;
	m_Separator = separator;
	m_pFile-&gt;precision(16);

	ReadHeaders();
}

SimpleReaderBase::~SimpleReaderBase()
{
	if(m_pFile-&gt;is_open())
		m_pFile-&gt;close();
}

bool SimpleReaderBase::ReadSingleLine(vector&lt;vector&lt;string&gt; &gt;&amp; line)
{
	if(!m_pFile-&gt;is_open() || m_pFile-&gt;eof()) return false;

	string strLine, innerToken;
	line.clear();
	getline(*m_pFile, strLine);
	istringstream str_stream(strLine);

	vector&lt;string&gt; header;
	vector&lt;string&gt; obj_part;

	if(m_nVarPerObj == 0)
	{
		while(getline(str_stream, innerToken, m_Separator))
		{
			obj_part.push_back(innerToken);
		}

		line.push_back(obj_part);
		return true;
	}
	else
	{
		int iCounter = 0;
		while(iCounter &lt; m_nLineHeaders &amp;&amp; getline(str_stream, innerToken, m_Separator))
		{
			header.push_back(innerToken);
			iCounter++;
		}
		obj_part.insert(obj_part.begin(), header.begin(), header.end());

		iCounter = 1;

		while(getline(str_stream, innerToken, m_Separator))
		{
			obj_part.push_back(innerToken);
			if(iCounter == m_nVarPerObj)
			{
				line.push_back(obj_part);
				obj_part.clear();

				iCounter = 0;
				obj_part.insert(obj_part.begin(), header.begin(), header.end());

			}
			iCounter++;
		}
	}

	return true;
}

int SimpleReaderBase::ReadAllData()
{
	if(!m_pFile-&gt;is_open()) return 0;

	m_AllData.clear();
	vector&lt;vector&lt;string&gt; &gt; singleLine;
	while(!m_pFile-&gt;eof())
	{
		ReadSingleLine(singleLine);
		m_AllData.push_back(singleLine);
	}

	return m_AllData.size();
}

void SimpleReaderBase::ReadHeaders()
{
	if(!m_pFile-&gt;is_open()) return;

	string strLine;
	int iCounter = 0;
	m_RawHeaders.clear();
	while(!m_pFile-&gt;eof() &amp;&amp; iCounter &lt; m_nHeders)
	{
		getline(*m_pFile, strLine);
		m_RawHeaders.push_back(strLine);
		if(iCounter == m_iDataTitles)
			ParseDataTitles(strLine);
		iCounter++;
	}
}

void SimpleReaderBase::ParseDataTitles(const string&amp; header)
{
	if(header.size()==0) return;

	string innerToken;
	istringstream str_stream(header);
	m_DataTitlesHeader.clear();
	while(getline(str_stream, innerToken, m_Separator))
	{
		if(innerToken.compare(m_HeaderRepeatKey)!=0)
			m_DataTitlesHeader.push_back(innerToken);
	}
}

bool GPSDataReader::ReadNextLine(GPSBasicData&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 5) return false;

		data.lat = strtod(lineData.at(0).at(2).c_str(), NULL);
		data.lon = strtod(lineData.at(0).at(3).c_str(), NULL);
		data.alt = strtod(lineData.at(0).at(4).c_str(), NULL);
		data.distance = strtod(lineData.at(0).at(5).c_str(), NULL);

		return true;

	}
	else
		return false;
}

int GPSDataReader::ReadAllData(vector&lt;GPSBasicData&gt;&amp; data_list)
{
	data_list.clear();
	GPSBasicData data;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool SimulationFileReader::ReadNextLine(SimulationPoint&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 5) return false;

		data.x = strtod(lineData.at(0).at(0).c_str(), NULL);
		data.y = strtod(lineData.at(0).at(1).c_str(), NULL);
		data.z = strtod(lineData.at(0).at(2).c_str(), NULL);
		data.a = strtod(lineData.at(0).at(3).c_str(), NULL);
		data.c = strtod(lineData.at(0).at(4).c_str(), NULL);
		data.v = strtod(lineData.at(0).at(5).c_str(), NULL);

		return true;

	}
	else
		return false;
}

int SimulationFileReader::ReadAllData(SimulationData&amp; data_list)
{
	data_list.simuCars.clear();
	SimulationPoint data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		if(count == 0)
			data_list.startPoint = data;
		else if(count == 1)
			data_list.goalPoint = data;
		else
			data_list.simuCars.push_back(data);

		count++;
	}

	return count;
}

bool LocalizationPathReader::ReadNextLine(LocalizationWayPoint&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 5) return false;

		//data.t = strtod(lineData.at(0).at(0).c_str(), NULL);
		data.x = strtod(lineData.at(0).at(0).c_str(), NULL);
		data.y = strtod(lineData.at(0).at(1).c_str(), NULL);
		data.z = strtod(lineData.at(0).at(2).c_str(), NULL);
		data.a = strtod(lineData.at(0).at(3).c_str(), NULL);
		data.v = strtod(lineData.at(0).at(4).c_str(), NULL);

		return true;

	}
	else
		return false;
}

int LocalizationPathReader::ReadAllData(vector&lt;LocalizationWayPoint&gt;&amp; data_list)
{
	data_list.clear();
	LocalizationWayPoint data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanNodesFileReader::ReadNextLine(AisanNode&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 10) return false;

		data.NID = strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.PID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);

		return true;

	}
	else
		return false;
}

int AisanNodesFileReader::ReadAllData(vector&lt;AisanNode&gt;&amp; data_list)
{
	data_list.clear();
	AisanNode data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanPointsFileReader::ReadNextLine(AisanPoints&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 10) return false;

		data.PID = strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.B = strtod(lineData.at(0)[1].c_str(), NULL);
		data.L = strtod(lineData.at(0)[2].c_str(), NULL);
		data.H = strtod(lineData.at(0)[3].c_str(), NULL);

		data.Bx = strtod(lineData.at(0)[4].c_str(), NULL);
		data.Ly = strtod(lineData.at(0)[5].c_str(), NULL);
		data.Ref = strtol(lineData.at(0).at(6).c_str(), NULL, 10);
		data.MCODE1 = strtol(lineData.at(0).at(7).c_str(), NULL, 10);
		data.MCODE2 = strtol(lineData.at(0).at(8).c_str(), NULL, 10);
		data.MCODE3 = strtol(lineData.at(0).at(9).c_str(), NULL, 10);

		return true;

	}
	else
		return false;
}

int AisanPointsFileReader::ReadAllData(vector&lt;AisanPoints&gt;&amp; data_list)
{
	data_list.clear();
	AisanPoints data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanLinesFileReader::ReadNextLine(AisanLine&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 5) return false;

		data.LID = strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.BPID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.FPID = strtol(lineData.at(0).at(2).c_str(), NULL, 10);
		data.BLID = strtol(lineData.at(0).at(3).c_str(), NULL, 10);
		data.FLID = strtol(lineData.at(0).at(4).c_str(), NULL, 10);

		return true;
	}
	else
		return false;
}

int AisanLinesFileReader::ReadAllData(vector&lt;AisanLine&gt;&amp; data_list)
{
	data_list.clear();
	AisanLine data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanCenterLinesFileReader::ReadNextLine(AisanCenterLine&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 5) return false;

		data.DID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.Dist 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.PID 	= strtol(lineData.at(0).at(2).c_str(), NULL, 10);

		data.Dir 	= strtod(lineData.at(0)[3].c_str(), NULL);
		data.Apara 	= strtod(lineData.at(0)[4].c_str(), NULL);
		data.r 		= strtod(lineData.at(0)[5].c_str(), NULL);
		data.slope 	= strtod(lineData.at(0)[6].c_str(), NULL);
		data.cant 	= strtod(lineData.at(0)[7].c_str(), NULL);
		data.LW 	= strtod(lineData.at(0)[8].c_str(), NULL);
		data.RW 	= strtod(lineData.at(0)[9].c_str(), NULL);

		return true;
	}
	else
		return false;
}

int AisanCenterLinesFileReader::ReadAllData(vector&lt;AisanCenterLine&gt;&amp; data_list)
{
	data_list.clear();
	AisanCenterLine data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanLanesFileReader::ReadNextLine(AisanLane&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size() == 0) return false;
		if(lineData.at(0).size() &lt; 17) return false;

		data.LnID		= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.DID		= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.BLID		= strtol(lineData.at(0).at(2).c_str(), NULL, 10);
		data.FLID		= strtol(lineData.at(0).at(3).c_str(), NULL, 10);
		data.BNID	 	= strtol(lineData.at(0).at(4).c_str(), NULL, 10);
		data.FNID		= strtol(lineData.at(0).at(5).c_str(), NULL, 10);
		data.JCT		= strtol(lineData.at(0).at(6).c_str(), NULL, 10);
		data.BLID2	 	= strtol(lineData.at(0).at(7).c_str(), NULL, 10);
		data.BLID3		= strtol(lineData.at(0).at(8).c_str(), NULL, 10);
		data.BLID4		= strtol(lineData.at(0).at(9).c_str(), NULL, 10);
		data.FLID2	 	= strtol(lineData.at(0).at(10).c_str(), NULL, 10);
		data.FLID3		= strtol(lineData.at(0).at(11).c_str(), NULL, 10);
		data.FLID4		= strtol(lineData.at(0).at(12).c_str(), NULL, 10);
		data.ClossID 	= strtol(lineData.at(0).at(13).c_str(), NULL, 10);
		data.Span 		= strtod(lineData.at(0).at(14).c_str(), NULL);
		data.LCnt	 	= strtol(lineData.at(0).at(15).c_str(), NULL, 10);
		data.Lno	  	= strtol(lineData.at(0).at(16).c_str(), NULL, 10);


		if(lineData.at(0).size() &lt; 23) return true;

		data.LaneType	= strtol(lineData.at(0).at(17).c_str(), NULL, 10);
		data.LimitVel	= strtol(lineData.at(0).at(18).c_str(), NULL, 10);
		data.RefVel	 	= strtol(lineData.at(0).at(19).c_str(), NULL, 10);
		data.RoadSecID	= strtol(lineData.at(0).at(20).c_str(), NULL, 10);
		data.LaneChgFG 	= strtol(lineData.at(0).at(21).c_str(), NULL, 10);
		data.LinkWAID	= strtol(lineData.at(0).at(22).c_str(), NULL, 10);


		if(lineData.at(0).size() &gt; 23)
		{
			string str_dir = lineData.at(0).at(23);
			if(str_dir.size() &gt; 0)
				data.LaneDir 	= str_dir.at(0);
			else
				data.LaneDir  	= 'F';
		}

//		data.LeftLaneId  = 0;
//		data.RightLaneId = 0;
//		data.LeftLaneId 	= strtol(lineData.at(0).at(24).c_str(), NULL, 10);
//		data.RightLaneId 	= strtol(lineData.at(0).at(25).c_str(), NULL, 10);


		return true;
	}
	else
		return false;
}

int AisanLanesFileReader::ReadAllData(vector&lt;AisanLane&gt;&amp; data_list)
{
	data_list.clear();
	AisanLane data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanAreasFileReader::ReadNextLine(AisanArea&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 3) return false;

		data.AID = strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.SLID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.ELID = strtol(lineData.at(0).at(2).c_str(), NULL, 10);

		return true;

	}
	else
		return false;
}

int AisanAreasFileReader::ReadAllData(vector&lt;AisanArea&gt;&amp; data_list)
{
	data_list.clear();
	AisanArea data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanIntersectionFileReader::ReadNextLine(AisanIntersection&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 3) return false;

		data.ID = strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.AID = strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.LinkID = strtol(lineData.at(0).at(2).c_str(), NULL, 10);

		return true;

	}
	else
		return false;
}

int AisanIntersectionFileReader::ReadAllData(vector&lt;AisanIntersection&gt;&amp; data_list)
{
	data_list.clear();
	AisanIntersection data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanStopLineFileReader::ReadNextLine(AisanStopLine&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 5) return false;

		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.LID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.TLID 	= strtol(lineData.at(0).at(2).c_str(), NULL, 10);
		data.SignID = strtol(lineData.at(0).at(3).c_str(), NULL, 10);
		data.LinkID = strtol(lineData.at(0).at(4).c_str(), NULL, 10);

		return true;

	}
	else
		return false;
}

int AisanStopLineFileReader::ReadAllData(vector&lt;AisanStopLine&gt;&amp; data_list)
{
	data_list.clear();
	AisanStopLine data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanRoadSignFileReader::ReadNextLine(AisanRoadSign&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 5) return false;

		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.VID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.PLID 	= strtol(lineData.at(0).at(2).c_str(), NULL, 10);
		data.Type 	= strtol(lineData.at(0).at(3).c_str(), NULL, 10);
		data.LinkID = strtol(lineData.at(0).at(4).c_str(), NULL, 10);

		return true;

	}
	else
		return false;
}

int AisanRoadSignFileReader::ReadAllData(vector&lt;AisanRoadSign&gt;&amp; data_list)
{
	data_list.clear();
	AisanRoadSign data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanSignalFileReader::ReadNextLine(AisanSignal&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 5) return false;

		data.ID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.VID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.PLID 	= strtol(lineData.at(0).at(2).c_str(), NULL, 10);
		data.Type 	= strtol(lineData.at(0).at(3).c_str(), NULL, 10);
		data.LinkID = strtol(lineData.at(0).at(4).c_str(), NULL, 10);

		return true;

	}
	else
		return false;
}

int AisanSignalFileReader::ReadAllData(vector&lt;AisanSignal&gt;&amp; data_list)
{
	data_list.clear();
	AisanSignal data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}

	return count;
}

bool AisanVectorFileReader::ReadNextLine(AisanVector&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 4) return false;

		data.VID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.PID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.Hang 	= strtod(lineData.at(0).at(2).c_str(), NULL);
		data.Vang 	= strtod(lineData.at(0).at(3).c_str(), NULL);

		return true;

	}
	else
		return false;
}

int AisanVectorFileReader::ReadAllData(vector&lt;AisanVector&gt;&amp; data_list)
{
	data_list.clear();
	AisanVector data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

bool AisanDataConnFileReader::ReadNextLine(DataConn&amp; data)
{
	vector&lt;vector&lt;string&gt; &gt; lineData;
	if(ReadSingleLine(lineData))
	{
		if(lineData.size()==0) return false;
		if(lineData.at(0).size() &lt; 4) return false;

		data.LID 	= strtol(lineData.at(0).at(0).c_str(), NULL, 10);
		data.SLID 	= strtol(lineData.at(0).at(1).c_str(), NULL, 10);
		data.SID 	= strtol(lineData.at(0).at(2).c_str(), NULL, 10);
		data.SSID 	= strtol(lineData.at(0).at(3).c_str(), NULL, 10);

		return true;

	}
	else
		return false;
}

int AisanDataConnFileReader::ReadAllData(vector&lt;DataConn&gt;&amp; data_list)
{
	data_list.clear();
	DataConn data;
	//double logTime = 0;
	int count = 0;
	while(ReadNextLine(data))
	{
		data_list.push_back(data);
		count++;
	}
	return count;
}

} /* namespace UtilityHNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/mission/packages/way_planner/nodes/RosHelpers.cpp" new_path="ros/src/computing/planning/mission/packages/way_planner/nodes/RosHelpers.cpp">
				<diff>@@ -491,7 +491,7 @@ void RosHelpers::FindIncommingBranches(const std::vector&lt;std::vector&lt;PlannerHNS:
 	static int detection_range = 30; // meter
 	if(globalPaths.size() &gt; 0)
 	{
-		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(globalPaths.at(0), currPose);
+		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex_obsolete(globalPaths.at(0), currPose);
 		PlannerHNS::WayPoint closest_wp = globalPaths.at(0).at(close_index);
 		double d = 0;
 		for(unsigned int i=close_index+1; i &lt; globalPaths.at(0).size(); i++)
</diff>
				<old_file>/*
 * RosHelpers.cpp
 *
 *  Created on: Jun 30, 2016
 *      Author: ai-driver
 */

#include &quot;RosHelpers.h&quot;

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;math.h&gt;
#include &quot;PlanningHelpers.h&quot;

namespace WayPlannerNS {

RosHelpers::RosHelpers() {

}

RosHelpers::~RosHelpers() {
}

void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
{
	static tf::TransformListener listener;

	while (1)
	{
		try
		{
			listener.lookupTransform(parent_frame, child_frame, ros::Time(0), transform);
			break;
		}
		catch (tf::TransformException&amp; ex)
		{
			ROS_ERROR(&quot;%s&quot;, ex.what());
			ros::Duration(1.0).sleep();
		}
	}
}

void RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; path,
		autoware_msgs::LaneArray&amp; laneArray)
{
	autoware_msgs::lane l;

	for(unsigned int i=0; i &lt; path.size(); i++)
	{
		autoware_msgs::waypoint wp;
		wp.pose.pose.position.x = path.at(i).x;
		wp.pose.pose.position.y = path.at(i).y;
		wp.pose.pose.position.z = path.at(i).z;
		//wp.pose.pose.position.z = 5;
		wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(path.at(i).a));

		l.waypoints.push_back(wp);
	}

	if(l.waypoints.size()&gt;0)
		laneArray.lanes.push_back(l);
}

void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path,
		autoware_msgs::LaneArray&amp; laneArray)
{
	autoware_msgs::lane l;

	for(unsigned int i=0; i &lt; path.size(); i++)
	{
		autoware_msgs::waypoint wp;
		wp.pose.pose.position.x = path.at(i).pos.x;
		wp.pose.pose.position.y = path.at(i).pos.y;
		wp.pose.pose.position.z = path.at(i).pos.z;
		//wp.pose.pose.position.z = 5;
		wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(path.at(i).pos.a));
		wp.twist.twist.linear.x = path.at(i).v;
		wp.twist.twist.linear.y = path.at(i).laneId;
		wp.twist.twist.linear.z = path.at(i).stopLineID;
		wp.twist.twist.angular.x = path.at(i).laneChangeCost;
		wp.twist.twist.angular.y = path.at(i).LeftLaneId;
		wp.twist.twist.angular.z = path.at(i).RightLaneId;
		//std::cout &lt;&lt; &quot;PathID: &quot; &lt;&lt; i &lt;&lt; &quot;, LID:&quot; &lt;&lt; path.at(i).laneId &lt;&lt; &quot;, LeftLaneID: &quot; &lt;&lt;  path.at(i).LeftLaneId &lt;&lt; &quot;, RightLaneID: &quot; &lt;&lt; path.at(i).RightLaneId &lt;&lt; std::endl;

		for(unsigned int iaction = 0; iaction &lt; path.at(i).actionCost.size(); iaction++)
		{
			if(path.at(i).actionCost.at(iaction).first == PlannerHNS::RIGHT_TURN_ACTION)
				wp.dtlane.dir = 1;
			else if(path.at(i).actionCost.at(iaction).first == PlannerHNS::LEFT_TURN_ACTION)
				wp.dtlane.dir = 2;
			else
				wp.dtlane.dir = 0;
		}


		//wp.dtlane.dir = path.at(i).pos.a;

		//PlannerHNS::GPSPoint p = path.at(i).pos;
		//std::cout &lt;&lt; p.ToString() &lt;&lt; std::endl;

		l.waypoints.push_back(wp);
	}

	if(l.waypoints.size()&gt;0)
		laneArray.lanes.push_back(l);
}

void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
{
	markerArray.markers.clear();
	autoware_msgs::LaneArray map_lane_array;
	for(unsigned int i = 0; i&lt; map.roadSegments.size(); i++)
		for(unsigned int j = 0; j &lt; map.roadSegments.at(i).Lanes.size(); j++)
			RosHelpers::ConvertFromPlannerHToAutowarePathFormat(map.roadSegments.at(i).Lanes.at(j).points, map_lane_array);

	std_msgs::ColorRGBA total_color;
	total_color.r = 1;
	total_color.g = 0.5;
	total_color.b = 0.3;
	total_color.a = 0.85;

	visualization_msgs::Marker lane_waypoint_marker;
	  lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	  lane_waypoint_marker.header.stamp = ros::Time();
	  lane_waypoint_marker.ns = &quot;vector_map_center_lines_rviz&quot;;
	  lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	  lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
	  lane_waypoint_marker.scale.x = 0.25;
	  lane_waypoint_marker.scale.y = 0.25;
	  lane_waypoint_marker.scale.z = 0.25;
	  lane_waypoint_marker.color = total_color;
	  //lane_waypoint_marker.frame_locked = false;

	  int count = 0;
	  for (unsigned int i=0; i&lt;  map_lane_array.lanes.size(); i++)
	  {
	    lane_waypoint_marker.points.clear();
	    lane_waypoint_marker.id = count;

	    for (unsigned int j=0; j &lt; map_lane_array.lanes.at(i).waypoints.size(); j++)
	    {
	      geometry_msgs::Point point;
	      point = map_lane_array.lanes.at(i).waypoints.at(j).pose.pose.position;
	      lane_waypoint_marker.points.push_back(point);
	    }
	    markerArray.markers.push_back(lane_waypoint_marker);
	    count++;
	  }

	  RosHelpers::createGlobalLaneArrayOrientationMarker(map_lane_array, markerArray);
		total_color.r = 0.99;
		total_color.g = 0.99;
		total_color.b = 0.99;
		total_color.a = 0.85;

		visualization_msgs::Marker stop_waypoint_marker;
		  stop_waypoint_marker.header.frame_id = &quot;map&quot;;
		  stop_waypoint_marker.header.stamp = ros::Time();
		  stop_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
		  stop_waypoint_marker.action = visualization_msgs::Marker::ADD;
		  stop_waypoint_marker.scale.x = 0.4;
		  stop_waypoint_marker.scale.y = 0.4;
		  stop_waypoint_marker.scale.z = 0.4;
		  stop_waypoint_marker.color = total_color;
		 // stop_waypoint_marker.frame_locked = false;


		  for (unsigned int i=0; i&lt;  map.stopLines.size(); i++)
		  {
			  std::ostringstream ns_id;
			  ns_id &lt;&lt; &quot;stop_lines_rviz_&quot; ;
			  ns_id &lt;&lt; map.stopLines.at(i).id;
			  stop_waypoint_marker.ns =ns_id.str();

			  autoware_msgs::LaneArray lane_array_2;
			  RosHelpers::ConvertFromPlannerHPointsToAutowarePathFormat(map.stopLines.at(i).points, lane_array_2);

			  stop_waypoint_marker.points.clear();
			  stop_waypoint_marker.id = count;
			  for (unsigned int j=0; j&lt;  lane_array_2.lanes.size(); j++)
			  {


				for (unsigned int k=0; k &lt; lane_array_2.lanes.at(j).waypoints.size(); k++)
				{
				  geometry_msgs::Point point;
				  point = lane_array_2.lanes.at(j).waypoints.at(k).pose.pose.position;
				  stop_waypoint_marker.points.push_back(point);
				}

				markerArray.markers.push_back(stop_waypoint_marker);
				count++;
			  }
		  }



	  //RosHelpers::createGlobalLaneArrayOrientationMarker(map_lane_array, markerArray);
}

void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
		const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; paths,
			visualization_msgs::MarkerArray&amp; markerArray)
{
	visualization_msgs::Marker lane_waypoint_marker;
	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	lane_waypoint_marker.header.stamp = ros::Time();
	lane_waypoint_marker.ns = &quot;global_lane_array_marker&quot;;
	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
	lane_waypoint_marker.scale.x = 0.1;
	lane_waypoint_marker.scale.y = 0.1;
	std_msgs::ColorRGBA roll_color, total_color, curr_color;
	roll_color.r = 0;
	roll_color.g = 1;
	roll_color.b = 0;
	roll_color.a = 0.5;

	lane_waypoint_marker.color = roll_color;
	lane_waypoint_marker.frame_locked = false;

	int count = 0;
	for (unsigned int i = 0; i &lt; paths.size(); i++)
	{
		lane_waypoint_marker.points.clear();
		lane_waypoint_marker.id = count;

		for (unsigned int j=0; j &lt; paths.at(i).size(); j++)
		{
		  geometry_msgs::Point point;

		  point.x = paths.at(i).at(j).pos.x;
		  point.y = paths.at(i).at(j).pos.y;
		  point.z = paths.at(i).at(j).pos.z;

		  lane_waypoint_marker.points.push_back(point);
		}

		markerArray.markers.push_back(lane_waypoint_marker);
		count++;
	}

	lane_waypoint_marker.points.clear();
	lane_waypoint_marker.id = count;
	lane_waypoint_marker.scale.x = 0.1;
	lane_waypoint_marker.scale.y = 0.1;
	curr_color.r = 1;
	curr_color.g = 0;
	curr_color.b = 1;
	curr_color.a = 0.9;
	lane_waypoint_marker.color = curr_color;

	for (unsigned int j=0; j &lt; curr_path.size(); j++)
	{
	  geometry_msgs::Point point;

	  point.x = curr_path.at(j).pos.x;
	  point.y = curr_path.at(j).pos.y;
	  point.z = curr_path.at(j).pos.z;

	  lane_waypoint_marker.points.push_back(point);
	}

	markerArray.markers.push_back(lane_waypoint_marker);
	count++;
}

void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths,
			visualization_msgs::MarkerArray&amp; markerArray)
{
	visualization_msgs::Marker lane_waypoint_marker;
	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	lane_waypoint_marker.header.stamp = ros::Time();
	lane_waypoint_marker.ns = &quot;global_lane_array_marker&quot;;
	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;


	std_msgs::ColorRGBA roll_color, total_color, curr_color;
	lane_waypoint_marker.points.clear();
	lane_waypoint_marker.id = 1;
	lane_waypoint_marker.scale.x = 0.35;
	lane_waypoint_marker.scale.y = 0.35;
	total_color.r = 1;
	total_color.g = 0;
	total_color.b = 0;
	total_color.a = 0.5;
	lane_waypoint_marker.color = total_color;
	lane_waypoint_marker.frame_locked = false;

	int count = 0;
	for (unsigned int i = 0; i &lt; globalPaths.size(); i++)
	{
		lane_waypoint_marker.points.clear();
		lane_waypoint_marker.id = count;

		for (unsigned int j=0; j &lt; globalPaths.at(i).size(); j++)
		{
		  geometry_msgs::Point point;

		  point.x = globalPaths.at(i).at(j).pos.x;
		  point.y = globalPaths.at(i).at(j).pos.y;
		  point.z = globalPaths.at(i).at(j).pos.z;

		  lane_waypoint_marker.points.push_back(point);
		}

		markerArray.markers.push_back(lane_waypoint_marker);
		count++;

//		visualization_msgs::MarkerArray tmp_marker_array;
//		visualization_msgs::Marker dir_marker;
//		  dir_marker.header.frame_id = &quot;map&quot;;
//		  dir_marker.header.stamp = ros::Time();
//		  dir_marker.type = visualization_msgs::Marker::ARROW;
//		  dir_marker.action = visualization_msgs::Marker::ADD;
//		  dir_marker.scale.x = 0.5;
//		  dir_marker.scale.y = 0.1;
//		  dir_marker.scale.z = 0.1;
//		  dir_marker.color.r = 1.0;
//		  dir_marker.color.a = 1.0;
//		  dir_marker.frame_locked = true;
//		  dir_marker.id = count;
//		  dir_marker.ns = &quot;direction_marker&quot;;
//
//		  for (unsigned int j=0; j &lt; globalPaths.at(i).size(); j++)
//			{
//			  geometry_msgs::Point point;
//
//			  point.x = globalPaths.at(i).at(j).pos.x;
//			  point.y = globalPaths.at(i).at(j).pos.y;
//			  point.z = globalPaths.at(i).at(j).pos.z;
//
//			  dir_marker.pose.position = point;
//			  dir_marker.pose.orientation = tf::createQuaternionMsgFromYaw(globalPaths.at(i).at(j).pos.a);
//			  tmp_marker_array.markers.push_back(dir_marker);
//			}
//
//		  markerArray.markers.insert(markerArray.markers.end(), tmp_marker_array.markers.begin(),
//		                                           tmp_marker_array.markers.end());
//			count++;


	}
}

void RosHelpers::createGlobalLaneArrayMarker(std_msgs::ColorRGBA color,
		const autoware_msgs::LaneArray &amp;lane_waypoints_array, visualization_msgs::MarkerArray&amp; markerArray)
{
  visualization_msgs::Marker lane_waypoint_marker;
  lane_waypoint_marker.header.frame_id = &quot;map&quot;;
  lane_waypoint_marker.header.stamp = ros::Time();
  lane_waypoint_marker.ns = &quot;global_lane_array_marker&quot;;
  lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
  lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
  lane_waypoint_marker.scale.x = 0.75;
  lane_waypoint_marker.scale.y = 0.75;
  lane_waypoint_marker.color = color;
  lane_waypoint_marker.frame_locked = false;

  int count = 0;
  for (unsigned int i=0; i&lt;  lane_waypoints_array.lanes.size(); i++)
  {
    lane_waypoint_marker.points.clear();
    lane_waypoint_marker.id = count;

    for (unsigned int j=0; j &lt; lane_waypoints_array.lanes.at(i).waypoints.size(); j++)
    {
      geometry_msgs::Point point;
      point = lane_waypoints_array.lanes.at(i).waypoints.at(j).pose.pose.position;
      lane_waypoint_marker.points.push_back(point);
    }
    markerArray.markers.push_back(lane_waypoint_marker);
    count++;
  }

}

void RosHelpers::createGlobalLaneArrayVelocityMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
		, visualization_msgs::MarkerArray&amp; markerArray)
{
  visualization_msgs::MarkerArray tmp_marker_array;
  // display by markers the velocity of each waypoint.
  visualization_msgs::Marker velocity_marker;
  velocity_marker.header.frame_id = &quot;map&quot;;
  velocity_marker.header.stamp = ros::Time();
  velocity_marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
  velocity_marker.action = visualization_msgs::Marker::ADD;
  //velocity_marker.scale.z = 0.4;
  velocity_marker.color.a = 0.9;
  velocity_marker.color.r = 1;
  velocity_marker.color.g = 1;
  velocity_marker.color.b = 1;
  velocity_marker.frame_locked = false;

  int count = 1;
  for (unsigned int i=0; i&lt;  lane_waypoints_array.lanes.size(); i++)
  {

	  std::ostringstream str_count;
	  str_count &lt;&lt; count;
    velocity_marker.ns = &quot;global_velocity_lane_&quot; + str_count.str();
    for (unsigned int j=0; j &lt; lane_waypoints_array.lanes.at(i).waypoints.size(); j++)
    {
      //std::cout &lt;&lt; _waypoints[i].GetX() &lt;&lt; &quot; &quot; &lt;&lt; _waypoints[i].GetY() &lt;&lt; &quot; &quot; &lt;&lt; _waypoints[i].GetZ() &lt;&lt; &quot; &quot; &lt;&lt; _waypoints[i].GetVelocity_kmh() &lt;&lt; std::endl;
      velocity_marker.id = j;
      geometry_msgs::Point relative_p;
      relative_p.y = 0.5;
      velocity_marker.pose.position = calcAbsoluteCoordinate(relative_p, lane_waypoints_array.lanes.at(i).waypoints.at(j).pose.pose);
      velocity_marker.pose.position.z += 0.2;

      // double to string
      std::ostringstream str_out;
      str_out &lt;&lt; lane_waypoints_array.lanes.at(i).waypoints.at(j).twist.twist.linear.x;
      //std::string vel = str_out.str();
      velocity_marker.text = str_out.str();//vel.erase(vel.find_first_of(&quot;.&quot;) + 2);

      tmp_marker_array.markers.push_back(velocity_marker);
    }
    count++;
  }

  markerArray.markers.insert(markerArray.markers.end(), tmp_marker_array.markers.begin(),
                                       tmp_marker_array.markers.end());
}

void RosHelpers::createGlobalLaneArrayOrientationMarker(const autoware_msgs::LaneArray &amp;lane_waypoints_array
		, visualization_msgs::MarkerArray&amp; markerArray)
{
  visualization_msgs::MarkerArray tmp_marker_array;
  visualization_msgs::Marker lane_waypoint_marker;
  lane_waypoint_marker.header.frame_id = &quot;map&quot;;
  lane_waypoint_marker.header.stamp = ros::Time();
  lane_waypoint_marker.type = visualization_msgs::Marker::ARROW;
  lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
  lane_waypoint_marker.scale.x = 0.3;
  lane_waypoint_marker.scale.y = 0.1;
  lane_waypoint_marker.scale.z = 0.1;
  lane_waypoint_marker.color.r = 1.0;
  lane_waypoint_marker.color.a = 0.8;
  //lane_waypoint_marker.frame_locked = false;

  lane_waypoint_marker.ns = &quot;global_lane_waypoint_orientation_marker&quot;;

  int count = 1;
  for (unsigned int i=0; i&lt;  lane_waypoints_array.lanes.size(); i++)
  {
//	  std::ostringstream str_ns;
//	  str_ns &lt;&lt; &quot;global_lane_waypoint_orientation_marker_&quot;;
//	  str_ns &lt;&lt; i;
//	 lane_waypoint_marker.ns = str_ns.str();

    for (unsigned int j=0; j &lt; lane_waypoints_array.lanes.at(i).waypoints.size(); j++)
    {
    	lane_waypoint_marker.id = count;
    	lane_waypoint_marker.pose = lane_waypoints_array.lanes.at(i).waypoints.at(j).pose.pose;

    	if(lane_waypoints_array.lanes.at(i).waypoints.at(j).dtlane.dir == 1)
    	{
    		lane_waypoint_marker.color.r = 0.0;
    		lane_waypoint_marker.color.g = 1.0;
    		lane_waypoint_marker.color.b = 0.0;
    		tmp_marker_array.markers.push_back(lane_waypoint_marker);
    	}
    	else if(lane_waypoints_array.lanes.at(i).waypoints.at(j).dtlane.dir == 2)
    	{
    		lane_waypoint_marker.color.r = 0.0;
			lane_waypoint_marker.color.g = 0.0;
			lane_waypoint_marker.color.b = 1.0;
			tmp_marker_array.markers.push_back(lane_waypoint_marker);
    	}
    	else
    	{
    		lane_waypoint_marker.color.r = 1.0;
			lane_waypoint_marker.color.g = 0.0;
			lane_waypoint_marker.color.b = 1.0;
			tmp_marker_array.markers.push_back(lane_waypoint_marker);
    	}
      count++;
    }
  }

  markerArray.markers.insert(markerArray.markers.end(), tmp_marker_array.markers.begin(),
										   tmp_marker_array.markers.end());
}

void RosHelpers::FindIncommingBranches(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths, const PlannerHNS::WayPoint&amp; currPose,const double&amp; min_distance,
			std::vector&lt;PlannerHNS::WayPoint*&gt;&amp; branches, PlannerHNS::WayPoint* currOptions)
{
	static int detection_range = 30; // meter
	if(globalPaths.size() &gt; 0)
	{
		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(globalPaths.at(0), currPose);
		PlannerHNS::WayPoint closest_wp = globalPaths.at(0).at(close_index);
		double d = 0;
		for(unsigned int i=close_index+1; i &lt; globalPaths.at(0).size(); i++)
		{
			d += hypot(globalPaths.at(0).at(i).pos.y - globalPaths.at(0).at(i-1).pos.y, globalPaths.at(0).at(i).pos.x - globalPaths.at(0).at(i-1).pos.x);

			if(d - min_distance &gt; detection_range)
				break;

			if(d &gt; min_distance &amp;&amp; globalPaths.at(0).at(i).pFronts.size() &gt; 1)
			{
				for(unsigned int j = 0; j&lt; globalPaths.at(0).at(i).pFronts.size(); j++)
				{
					PlannerHNS::WayPoint* wp =  globalPaths.at(0).at(i).pFronts.at(j);


					bool bFound = false;
					for(unsigned int ib=0; ib&lt; branches.size(); ib++)
					{
						if(wp-&gt;actionCost.size() &gt; 0 &amp;&amp;  branches.at(ib)-&gt;actionCost.size() &gt; 0 &amp;&amp; branches.at(ib)-&gt;actionCost.at(0).first == wp-&gt;actionCost.at(0).first)
						{
							bFound = true;
							break;
						}
					}

					if(wp-&gt;actionCost.size() &gt; 0 &amp;&amp; !bFound &amp;&amp; closest_wp.laneId != wp-&gt;laneId)
						branches.push_back(wp);
				}
			}
		}
	}
}

}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/mission/packages/way_planner/nodes/way_planner_core.cpp" new_path="ros/src/computing/planning/mission/packages/way_planner/nodes/way_planner_core.cpp">
				<diff>@@ -362,10 +362,12 @@ void way_planner_core::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, Planner
 	std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt; stop_line_data;
 	std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt; signal_data;
 	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
+	std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt; curb_data;
+	std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts,inters, areas, line_data, stop_line_data, signal_data, vector_data,conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data, curb_data, roadedge_data, conn_data, origin, out_map);
 }
 
 bool way_planner_core::GenerateGlobalPlan(PlannerHNS::WayPoint&amp; startPoint, PlannerHNS::WayPoint&amp; goalPoint, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; generatedTotalPaths)
@@ -586,7 +588,7 @@ bool way_planner_core::HMI_DoOneStep()
 
 		std::cout &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
 
-		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_GeneratedTotalPaths.at(0), startPoint);
+		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex_obsolete(m_GeneratedTotalPaths.at(0), startPoint);
 
 		for(unsigned int i=close_index+1; i &lt; m_GeneratedTotalPaths.at(0).size(); i++)
 		{
</diff>
				<old_file>/*
 *  Copyright (c) 2016, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;way_planner_core.h&quot;

namespace WayPlannerNS {

void way_planner_core::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
{
	static tf::TransformListener listener;

	int nFailedCounter = 0;
	while (1)
	{
		try
		{
			listener.lookupTransform(parent_frame, child_frame, ros::Time(0), transform);
			break;
		}
		catch (tf::TransformException&amp; ex)
		{
			if(nFailedCounter &gt; 2)
			{
				ROS_ERROR(&quot;%s&quot;, ex.what());
			}
			ros::Duration(1.0).sleep();
			nFailedCounter ++;
		}
	}
}

way_planner_core::way_planner_core()
{
	m_pCurrGoal = 0;
	m_iCurrentGoalIndex = 1;
	m_bKmlMap = false;
	//bStartPos = false;
	//bGoalPos = false;
	//bUsingCurrentPose = false;
	nh.getParam(&quot;/way_planner/pathDensity&quot; 			, m_params.pathDensity);
	nh.getParam(&quot;/way_planner/enableSmoothing&quot; 		, m_params.bEnableSmoothing);
	nh.getParam(&quot;/way_planner/enableLaneChange&quot; 	, m_params.bEnableLaneChange);
	nh.getParam(&quot;/way_planner/enableRvizInput&quot; 		, m_params.bEnableRvizInput);
	nh.getParam(&quot;/way_planner/enableReplan&quot; 		, m_params.bEnableReplanning);
	nh.getParam(&quot;/way_planner/enableHMI&quot; 			, m_params.bEnableHMI);

	int iSource = 0;
	nh.getParam(&quot;/way_planner/mapSource&quot; 			, iSource);
	if(iSource == 0)
		m_params.mapSource = MAP_AUTOWARE;
	else if (iSource == 1)
		m_params.mapSource = MAP_FOLDER;
	else if(iSource == 2)
		m_params.mapSource = MAP_KML_FILE;

	nh.getParam(&quot;/way_planner/mapFileName&quot; 			, m_params.KmlMapPath);


	tf::StampedTransform transform;
	GetTransformFromTF(&quot;map&quot;, &quot;world&quot;, transform);
	m_OriginPos.position.x  = transform.getOrigin().x();
	m_OriginPos.position.y  = transform.getOrigin().y();
	m_OriginPos.position.z  = transform.getOrigin().z();

	pub_Paths = nh.advertise&lt;autoware_msgs::LaneArray&gt;(&quot;lane_waypoints_array&quot;, 1, true);
	pub_PathsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;global_waypoints_rviz&quot;, 1, true);
	pub_StartPointRviz = nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;Global_StartPoint_rviz&quot;, 1, true);
	pub_GoalPointRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;Global_GoalPoints_rviz&quot;, 1, true);
	pub_NodesListRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;Goal_Nodes_Points_rviz&quot;, 1, true);
	pub_MapRviz  = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;vector_map_center_lines_rviz&quot;, 100, true);
	pub_TrafficInfoRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;Traffic_Lights_rviz&quot;, 1, true);

#ifdef ENABLE_VISUALIZE_PLAN
	m_CurrMaxCost = 1;
	m_iCurrLevel = 0;
	m_nLevelSize = 1;
	m_bSwitch = 0;
	pub_GlobalPlanAnimationRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;AnimateGlobalPlan&quot;, 1, true);
#endif

if(m_params.bEnableHMI)
{
	m_AvgResponseTime = 0;
	m_SocketServer.InitSocket(10001, 10002);
}

	/** @todo To achieve perfection , you need to start sometime */

	//if(m_params.bEnableRvizInput)
	{
		sub_start_pose 	= nh.subscribe(&quot;/initialpose&quot;, 					1, &amp;way_planner_core::callbackGetStartPose, 		this);
		sub_goal_pose 	= nh.subscribe(&quot;move_base_simple/goal&quot;, 		1, &amp;way_planner_core::callbackGetGoalPose, 		this);
	}
//	else
//	{
//		sub_start_pose 	= nh.subscribe(&quot;/GlobalStartPose&quot;, 				1, &amp;way_planner_core::callbackGetStartPose, 		this);
//		sub_goal_pose 	= nh.subscribe(&quot;/GlobalGoalPose&quot;, 				1, &amp;way_planner_core::callbackGetGoalPose, 		this);
//	}

	sub_current_pose 		= nh.subscribe(&quot;/current_pose&quot;, 			100,	&amp;way_planner_core::callbackGetCurrentPose, 		this);

	int bVelSource = 1;
	nh.getParam(&quot;/dp_planner/enableOdometryStatus&quot;, bVelSource);
	if(bVelSource == 0)
		sub_robot_odom 			= nh.subscribe(&quot;/odom&quot;, 					100,	&amp;way_planner_core::callbackGetRobotOdom, 	this);
	else if(bVelSource == 1)
		sub_current_velocity 	= nh.subscribe(&quot;/current_velocity&quot;,		100,	&amp;way_planner_core::callbackGetVehicleStatus, 	this);
	else if(bVelSource == 2)
		sub_can_info 			= nh.subscribe(&quot;/can_info&quot;,		100,	&amp;way_planner_core::callbackGetCanInfo, 	this);

	//sub_current_velocity 	= nh.subscribe(&quot;/current_velocity&quot;,			100,	&amp;way_planner_core::callbackGetVehicleStatus, 	this);
	sub_nodes_list 			= nh.subscribe(&quot;/GlobalNodesList&quot;, 			1, 		&amp;way_planner_core::callbackGetNodesList, 		this);

	if(m_params.mapSource == MAP_AUTOWARE)
	{
		sub_map_points 	= nh.subscribe(&quot;/vector_map_info/point&quot;, 		1, &amp;way_planner_core::callbackGetVMPoints, 		this);
		sub_map_lanes 	= nh.subscribe(&quot;/vector_map_info/lane&quot;, 		1, &amp;way_planner_core::callbackGetVMLanes, 		this);
		sub_map_nodes 	= nh.subscribe(&quot;/vector_map_info/node&quot;, 		1, &amp;way_planner_core::callbackGetVMNodes, 		this);
		sup_stop_lines 	= nh.subscribe(&quot;/vector_map_info/stop_line&quot;,	1, &amp;way_planner_core::callbackGetVMStopLines, 	this);
		sub_dtlanes 	= nh.subscribe(&quot;/vector_map_info/dtlane&quot;, 		1, &amp;way_planner_core::callbackGetVMCenterLines,	this);
	}
}

way_planner_core::~way_planner_core(){
}

void way_planner_core::callbackGetGoalPose(const geometry_msgs::PoseStampedConstPtr &amp;msg)
{
	PlannerHNS::WayPoint wp;
	wp = PlannerHNS::WayPoint(msg-&gt;pose.position.x+m_OriginPos.position.x, msg-&gt;pose.position.y+m_OriginPos.position.y,
			msg-&gt;pose.position.z+m_OriginPos.position.z, tf::getYaw(msg-&gt;pose.orientation));

	if(m_GoalsPos.size()==0)
	{
		ROS_INFO(&quot;Can Not add Goal, Select Start Position Fist !&quot;);
	}
	else
	{
		m_GoalsPos.push_back(wp);
		ROS_INFO(&quot;Received Goal Pose&quot;);
	}
}

void way_planner_core::callbackGetStartPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg)
{
//	if(m_GeneratedTotalPaths.size()&gt;0)
//	{
//		PlannerHNS::RelativeInfo info;
//		PlannerHNS::WayPoint p1(msg-&gt;pose.pose.position.x+m_OriginPos.position.x, msg-&gt;pose.pose.position.y+m_OriginPos.position.y, msg-&gt;pose.pose.position.z+m_OriginPos.position.z, tf::getYaw(msg-&gt;pose.pose.orientation));
//		bool ret = PlannerHNS::PlanningHelpers::GetRelativeInfo(m_GeneratedTotalPaths.at(0), p1, info);
//		std::cout &lt;&lt; &quot;Perp D: &quot; &lt;&lt; info.perp_distance &lt;&lt; &quot;, F D: &quot;&lt;&lt; info.to_front_distance &lt;&lt; &quot;, B D: &quot; &lt;&lt; info.from_back_distance &lt;&lt; &quot;, F Index: &quot;&lt;&lt; info.iFront &lt;&lt; &quot;, B Index: &quot; &lt;&lt; info.iBack &lt;&lt; &quot;, Angle: &quot;&lt;&lt; info.angle_diff  &lt;&lt; std::endl;
//	}

	m_CurrentPose = PlannerHNS::WayPoint(msg-&gt;pose.pose.position.x+m_OriginPos.position.x, msg-&gt;pose.pose.position.y+m_OriginPos.position.y,
			msg-&gt;pose.pose.position.z+m_OriginPos.position.z, tf::getYaw(msg-&gt;pose.pose.orientation));

	if(m_GoalsPos.size() &lt;= 1)
	{
		m_GoalsPos.clear();
		m_GoalsPos.push_back(m_CurrentPose);
		ROS_INFO(&quot;Received Start pose&quot;);
	}
}

void way_planner_core::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg)
{
	m_CurrentPose = PlannerHNS::WayPoint(msg-&gt;pose.position.x, msg-&gt;pose.position.y,
			msg-&gt;pose.position.z, tf::getYaw(msg-&gt;pose.orientation));

	if(m_GoalsPos.size() &lt;= 1)
	{
		m_GoalsPos.clear();
		m_GoalsPos.push_back(m_CurrentPose);
	}
}

void way_planner_core::callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg)
{
	m_VehicleState.speed = msg-&gt;twist.twist.linear.x;
	//m_VehicleState.steer += atan(m_LocalPlanner.m_CarInfo.wheel_base * msg-&gt;twist.twist.angular.z/msg-&gt;twist.twist.linear.x);

	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);
//	if(msg-&gt;vector.z == 0x00)
//		m_VehicleState.shift = AW_SHIFT_POS_BB;
//	else if(msg-&gt;vector.z == 0x10)
//		m_VehicleState.shift = AW_SHIFT_POS_DD;
//	else if(msg-&gt;vector.z == 0x20)
//		m_VehicleState.shift = AW_SHIFT_POS_NN;
//	else if(msg-&gt;vector.z == 0x40)
//		m_VehicleState.shift = AW_SHIFT_POS_RR;

	//std::cout &lt;&lt; &quot;PlannerX: Read Odometry (&quot;&lt;&lt; m_VehicleState.speed &lt;&lt; &quot;, &quot; &lt;&lt; m_VehicleState.steer&lt;&lt;&quot;)&quot; &lt;&lt; std::endl;
}

void way_planner_core::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg)
{
	m_VehicleState.speed = msg-&gt;twist.linear.x;
	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);
}

void way_planner_core::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
{
	m_VehicleState.speed = msg-&gt;speed/3.6;
	m_VehicleState.steer = msg-&gt;angle * 0.45 / 660;
	std::cout &lt;&lt; &quot;Can Info, Speed: &quot;&lt;&lt; m_VehicleState.speed &lt;&lt; &quot;, Steering: &quot; &lt;&lt; m_VehicleState.steer  &lt;&lt; std::endl;
}

void way_planner_core::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Points&quot;);
	m_AwMap.points = msg;
	m_AwMap.bPoints = true;
}

void way_planner_core::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Lane Array&quot;);
	m_AwMap.lanes = msg;
	m_AwMap.bLanes = true;
}

void way_planner_core::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
{
	//ROS_INFO(&quot;Received Map Nodes&quot;);


}

void way_planner_core::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
{
	//ROS_INFO(&quot;Received Map Stop Lines&quot;);
}

void way_planner_core::callbackGetVMCenterLines(const vector_map_msgs::DTLaneArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Center Lines&quot;);
	m_AwMap.dtlanes = msg;
	m_AwMap.bDtLanes = true;
}

void way_planner_core::callbackGetNodesList(const vector_map_msgs::NodeArray&amp; msg)
{

}

void way_planner_core::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::RoadNetwork&amp; out_map)
{
	std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt; lanes;
	for(unsigned int i=0; i &lt; src_map.lanes.data.size();i++)
	{
		UtilityHNS::AisanLanesFileReader::AisanLane l;
		l.BLID 		=  src_map.lanes.data.at(i).blid;
		l.BLID2 	=  src_map.lanes.data.at(i).blid2;
		l.BLID3 	=  src_map.lanes.data.at(i).blid3;
		l.BLID4 	=  src_map.lanes.data.at(i).blid4;
		l.BNID 		=  src_map.lanes.data.at(i).bnid;
		l.ClossID 	=  src_map.lanes.data.at(i).clossid;
		l.DID 		=  src_map.lanes.data.at(i).did;
		l.FLID 		=  src_map.lanes.data.at(i).flid;
		l.FLID2 	=  src_map.lanes.data.at(i).flid2;
		l.FLID3 	=  src_map.lanes.data.at(i).flid3;
		l.FLID4 	=  src_map.lanes.data.at(i).flid4;
		l.FNID 		=  src_map.lanes.data.at(i).fnid;
		l.JCT 		=  src_map.lanes.data.at(i).jct;
		l.LCnt 		=  src_map.lanes.data.at(i).lcnt;
		l.LnID 		=  src_map.lanes.data.at(i).lnid;
		l.Lno 		=  src_map.lanes.data.at(i).lno;
		l.Span 		=  src_map.lanes.data.at(i).span;
		l.RefVel	=  src_map.lanes.data.at(i).refvel;
		l.LimitVel	=  src_map.lanes.data.at(i).limitvel;

//		l.LaneChgFG =  src_map.lanes.at(i).;
//		l.LaneType 	=  src_map.lanes.at(i).blid;
//		l.LimitVel 	=  src_map.lanes.at(i).;
//		l.LinkWAID 	=  src_map.lanes.at(i).blid;
//		l.RefVel 	=  src_map.lanes.at(i).blid;
//		l.RoadSecID =  src_map.lanes.at(i).;

		lanes.push_back(l);
	}

	std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt; points;

	for(unsigned int i=0; i &lt; src_map.points.data.size();i++)
	{
		UtilityHNS::AisanPointsFileReader::AisanPoints p;
		double integ_part = src_map.points.data.at(i).l;
		double deg = trunc(src_map.points.data.at(i).l);
		double min = trunc((src_map.points.data.at(i).l - deg) * 100.0) / 60.0;
		double sec = modf((src_map.points.data.at(i).l - deg) * 100.0, &amp;integ_part)/36.0;
		double L =  deg + min + sec;

		deg = trunc(src_map.points.data.at(i).b);
		min = trunc((src_map.points.data.at(i).b - deg) * 100.0) / 60.0;
		sec = modf((src_map.points.data.at(i).b - deg) * 100.0, &amp;integ_part)/36.0;
		double B =  deg + min + sec;

		p.B 		= B;
		p.Bx 		= src_map.points.data.at(i).bx;
		p.H 		= src_map.points.data.at(i).h;
		p.L 		= L;
		p.Ly 		= src_map.points.data.at(i).ly;
		p.MCODE1 	= src_map.points.data.at(i).mcode1;
		p.MCODE2 	= src_map.points.data.at(i).mcode2;
		p.MCODE3 	= src_map.points.data.at(i).mcode3;
		p.PID 		= src_map.points.data.at(i).pid;
		p.Ref 		= src_map.points.data.at(i).ref;

		points.push_back(p);
	}


	std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt; dts;
	for(unsigned int i=0; i &lt; src_map.dtlanes.data.size();i++)
	{
		UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine dt;

		dt.Apara 	= src_map.dtlanes.data.at(i).apara;
		dt.DID 		= src_map.dtlanes.data.at(i).did;
		dt.Dir 		= src_map.dtlanes.data.at(i).dir;
		dt.Dist 	= src_map.dtlanes.data.at(i).dist;
		dt.LW 		= src_map.dtlanes.data.at(i).lw;
		dt.PID 		= src_map.dtlanes.data.at(i).pid;
		dt.RW 		= src_map.dtlanes.data.at(i).rw;
		dt.cant 	= src_map.dtlanes.data.at(i).cant;
		dt.r 		= src_map.dtlanes.data.at(i).r;
		dt.slope 	= src_map.dtlanes.data.at(i).slope;

		dts.push_back(dt);
	}

	std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt; areas;
	std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt; inters;
	std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt; line_data;
	std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt; stop_line_data;
	std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt; signal_data;
	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;

	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts,inters, areas, line_data, stop_line_data, signal_data, vector_data,conn_data, origin, out_map);
}

bool way_planner_core::GenerateGlobalPlan(PlannerHNS::WayPoint&amp; startPoint, PlannerHNS::WayPoint&amp; goalPoint, std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; generatedTotalPaths)
{

	generatedTotalPaths.clear();
#ifdef ENABLE_VISUALIZE_PLAN
	if(m_PlanningVisualizeTree.size() &gt; 0)
	{
		m_PlannerH.DeleteWaypoints(m_PlanningVisualizeTree);
		m_AccumPlanLevels.markers.clear();
		m_iCurrLevel = 0;
		m_nLevelSize = 1;
	}

	std::vector&lt;int&gt; predefinedLanesIds;
	double ret = m_PlannerH.PlanUsingDP(startPoint, goalPoint,
			MAX_GLOBAL_PLAN_DISTANCE, predefinedLanesIds,
			m_Map, generatedTotalPaths, &amp;m_PlanningVisualizeTree);

	m_pCurrGoal = PlannerHNS::MappingHelpers::GetClosestWaypointFromMap(goalPoint, m_Map);

#else
	std::vector&lt;int&gt; predefinedLanesIds;

	double ret = m_PlannerH.PlanUsingDP(startPoint, goalPoint,
					MAX_GLOBAL_PLAN_DISTANCE, m_params.bEnableLaneChange,
					predefinedLanesIds,
					m_Map, generatedTotalPaths);
#endif

if(m_params.bEnableHMI)
{
	for(unsigned int im = 0; im &lt; m_ModifiedWayPointsCosts.size(); im++)
		m_ModifiedWayPointsCosts.at(im)-&gt;actionCost.at(0).second = 0;

	m_ModifiedWayPointsCosts.clear();
}
	if(ret == 0) generatedTotalPaths.clear();


	if(generatedTotalPaths.size() &gt; 0 &amp;&amp; generatedTotalPaths.at(0).size()&gt;0)
	{
		if(m_params.bEnableSmoothing)
		{
			for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
			{
				PlannerHNS::PlanningHelpers::FixPathDensity(generatedTotalPaths.at(i), m_params.pathDensity);
				PlannerHNS::PlanningHelpers::SmoothPath(generatedTotalPaths.at(i), 0.49, 0.35 , 0.01);
			}
		}

		for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
		{
			PlannerHNS::PlanningHelpers::CalcAngleAndCost(generatedTotalPaths.at(i));
			std::cout &lt;&lt; &quot;New DP Path -&gt; &quot; &lt;&lt; generatedTotalPaths.at(i).size() &lt;&lt; std::endl;
		}

		return true;
	}
	else
	{
		std::cout &lt;&lt; &quot;Can't Generate Global Path for Start (&quot; &lt;&lt; startPoint.pos.ToString()
							&lt;&lt; &quot;) and Goal (&quot; &lt;&lt; goalPoint.pos.ToString() &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
	}
	return false;
}

void way_planner_core::VisualizeAndSend(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedTotalPaths)
{
	autoware_msgs::LaneArray lane_array;
	visualization_msgs::MarkerArray pathsToVisualize;

	for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
		RosHelpers::ConvertFromPlannerHToAutowarePathFormat(generatedTotalPaths.at(i), lane_array);

	std_msgs::ColorRGBA total_color;
	total_color.r = 0;
	total_color.g = 0.7;
	total_color.b = 1.0;
	total_color.a = 0.9;
	RosHelpers::createGlobalLaneArrayMarker(total_color, lane_array, pathsToVisualize);
	RosHelpers::createGlobalLaneArrayOrientationMarker(lane_array, pathsToVisualize);
	RosHelpers::createGlobalLaneArrayVelocityMarker(lane_array, pathsToVisualize);
	//RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(generatedTotalPaths, pathsToVisualize);
	pub_PathsRviz.publish(pathsToVisualize);
	pub_Paths.publish(lane_array);

#ifdef OPENPLANNER_ENABLE_LOGS
	for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
	{
		std::ostringstream str_out;
		str_out &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory();
		str_out &lt;&lt; UtilityHNS::DataRW::LoggingMainfolderName;
		str_out &lt;&lt; &quot;GlobalPath_&quot;;
		str_out &lt;&lt; i;
		str_out &lt;&lt; &quot;_&quot;;
		PlannerHNS::PlanningHelpers::WritePathToFile(str_out.str(), generatedTotalPaths.at(i));
	}
#endif
}

#ifdef ENABLE_VISUALIZE_PLAN
void way_planner_core::CreateNextPlanningTreeLevelMarker(std::vector&lt;PlannerHNS::WayPoint*&gt;&amp; level, visualization_msgs::MarkerArray&amp; markerArray, double max_cost)
{
	if(level.size() == 0 &amp;&amp; m_pCurrGoal)
		return;

	std::vector&lt;PlannerHNS::WayPoint*&gt; newlevel;

	//lane_waypoint_marker.frame_locked = false;

	for(unsigned int i = 0; i &lt; level.size(); i++)
	{
		visualization_msgs::Marker lane_waypoint_marker;
		lane_waypoint_marker.header.frame_id = &quot;map&quot;;
		lane_waypoint_marker.header.stamp = ros::Time();
		lane_waypoint_marker.type = visualization_msgs::Marker::ARROW;
		lane_waypoint_marker.ns = &quot;tree_levels&quot;;
		lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
		lane_waypoint_marker.scale.x = 1.0;
		lane_waypoint_marker.scale.y = 0.5;
		lane_waypoint_marker.scale.z = 0.5;
		lane_waypoint_marker.color.a = 0.8;
		lane_waypoint_marker.color.b = 1-0.0;

		float norm_cost = level.at(i)-&gt;cost / max_cost * 2.0;
		if(norm_cost &lt;= 1.0)
		{
			lane_waypoint_marker.color.r = 1-norm_cost;
			lane_waypoint_marker.color.g = 1-1.0;
		}
		else if(norm_cost &gt; 1.0)
		{
			lane_waypoint_marker.color.r = 1-1.0;
			lane_waypoint_marker.color.g = 1- (2.0 - norm_cost);
		}

		if(markerArray.markers.size() == 0)
			lane_waypoint_marker.id = 0;
		else
			lane_waypoint_marker.id = markerArray.markers.at(markerArray.markers.size()-1).id + 1;

		lane_waypoint_marker.pose.position.x = level.at(i)-&gt;pos.x;
		lane_waypoint_marker.pose.position.y = level.at(i)-&gt;pos.y;
		lane_waypoint_marker.pose.position.z = level.at(i)-&gt;pos.z;
		double a = UtilityHNS::UtilityH::SplitPositiveAngle(level.at(i)-&gt;pos.a);
		lane_waypoint_marker.pose.orientation = tf::createQuaternionMsgFromYaw(a);
		markerArray.markers.push_back(lane_waypoint_marker);

		if(level.at(i)-&gt;pLeft)
		{
			lane_waypoint_marker.pose.orientation = tf::createQuaternionMsgFromYaw(a + M_PI_2);
			newlevel.push_back(level.at(i)-&gt;pLeft);
			lane_waypoint_marker.id = markerArray.markers.at(markerArray.markers.size()-1).id + 1;
			markerArray.markers.push_back(lane_waypoint_marker);
		}
		if(level.at(i)-&gt;pRight)
		{
			newlevel.push_back(level.at(i)-&gt;pRight);
			lane_waypoint_marker.pose.orientation = tf::createQuaternionMsgFromYaw(a - M_PI_2);
			lane_waypoint_marker.id = markerArray.markers.at(markerArray.markers.size()-1).id + 1;
			markerArray.markers.push_back(lane_waypoint_marker);
		}

		for(unsigned int j = 0; j &lt; level.at(i)-&gt;pFronts.size(); j++)
			if(level.at(i)-&gt;pFronts.at(j))
				newlevel.push_back(level.at(i)-&gt;pFronts.at(j));

		if(hypot(m_pCurrGoal-&gt;pos.y - level.at(i)-&gt;pos.y, m_pCurrGoal-&gt;pos.x - level.at(i)-&gt;pos.x) &lt; 0.5)
		{
			newlevel.clear();
			break;
		}

		std::cout &lt;&lt; &quot;Levels: &quot; &lt;&lt;  lane_waypoint_marker.id &lt;&lt; &quot;, pLeft:&quot; &lt;&lt; level.at(i)-&gt;pLeft &lt;&lt; &quot;, pRight:&quot; &lt;&lt; level.at(i)-&gt;pRight &lt;&lt; &quot;, nFront:&quot; &lt;&lt; level.at(i)-&gt;pFronts.size() &lt;&lt; &quot;, Cost: &quot;&lt;&lt; norm_cost&lt;&lt; std::endl;
	}

	level = newlevel;

	//std::cout &lt;&lt; &quot;Levels: &quot; &lt;&lt;  level.size() &lt;&lt; std::endl;
}

#endif


bool way_planner_core::HMI_DoOneStep()
{
	double min_distance = m_AvgResponseTime * m_VehicleState.speed;
	std::vector&lt;PlannerHNS::WayPoint*&gt; branches;

	PlannerHNS::WayPoint startPoint;

	if(m_GoalsPos.size() &gt; 1)
		startPoint = m_CurrentPose;

	PlannerHNS::WayPoint* currOptions = 0;
	RosHelpers::FindIncommingBranches(m_GeneratedTotalPaths,startPoint, min_distance, branches, currOptions);
	if(branches.size() &gt; 0)
	{
		HMI_MSG msg;
		msg.type = OPTIONS_MSG;
		msg.options.clear();
		for(unsigned int i = 0; i&lt; branches.size(); i++)
			msg.options.push_back(branches.at(i)-&gt;actionCost.at(0).first);

		std::cout &lt;&lt; &quot;Send Message (&quot; &lt;&lt;  branches.size() &lt;&lt; &quot;) Branches (&quot; ;
		for(unsigned int i=0; i&lt; branches.size(); i++)
		{
			if(branches.at(i)-&gt;actionCost.at(0).first == PlannerHNS::FORWARD_ACTION)
				std::cout &lt;&lt; &quot;F,&quot;;
			else if(branches.at(i)-&gt;actionCost.at(0).first == PlannerHNS::LEFT_TURN_ACTION)
				std::cout &lt;&lt; &quot;L,&quot;;
			else if(branches.at(i)-&gt;actionCost.at(0).first == PlannerHNS::RIGHT_TURN_ACTION)
				std::cout &lt;&lt; &quot;R,&quot;;

		}

		std::cout &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;

		int close_index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_GeneratedTotalPaths.at(0), startPoint);

		for(unsigned int i=close_index+1; i &lt; m_GeneratedTotalPaths.at(0).size(); i++)
		{
			bool bFound = false;
			for(unsigned int j=0; j&lt; branches.size(); j++)
			{
				//if(wp != 0)sadasd
				{
					if(branches.at(j)-&gt;id == m_GeneratedTotalPaths.at(0).at(i).id)
					{
						currOptions = branches.at(j);
						bFound = true;
						break;
					}
				}
			}
			if(bFound)
				break;
		}

		if(currOptions !=0 )
		{
//				std::cout &lt;&lt;&quot; Current Option : &quot; ;
//				if(currOptions-&gt;actionCost.at(0).first == PlannerHNS::FORWARD_ACTION)
//					std::cout &lt;&lt; &quot;F,&quot;;
//				else if(currOptions-&gt;actionCost.at(0).first == PlannerHNS::LEFT_TURN_ACTION)
//					std::cout &lt;&lt; &quot;L,&quot;;
//				else if(currOptions-&gt;actionCost.at(0).first == PlannerHNS::RIGHT_TURN_ACTION)
//					std::cout &lt;&lt; &quot;R,&quot;;
//				std::cout &lt;&lt;std::endl;

//				HMI_MSG currOpMsg;
//				currOpMsg.type = CURR_OPTION_MSG;
//				currOpMsg.options.clear();
//				currOpMsg.options.push_back(currOptions-&gt;actionCost.at(0).first);
//				m_SocketServer.SendMSG(currOpMsg);
			msg.current = currOptions-&gt;actionCost.at(0).first;
			msg.currID = currOptions-&gt;laneId;

		}

		m_SocketServer.SendMSG(msg);

		double total_d = 0;
		for(unsigned int iwp =1; iwp &lt; m_GeneratedTotalPaths.at(0).size(); iwp++)
		{
			total_d += hypot(m_GeneratedTotalPaths.at(0).at(iwp).pos.y - m_GeneratedTotalPaths.at(0).at(iwp-1).pos.y, m_GeneratedTotalPaths.at(0).at(iwp).pos.x - m_GeneratedTotalPaths.at(0).at(iwp-1).pos.x);
		}

		HMI_MSG inc_msg;
		int bNew = m_SocketServer.GetLatestMSG(inc_msg);
		if(bNew&gt;0)
		{
			for(unsigned int i = 0; i&lt; branches.size(); i++)
			{
				for(unsigned int j = 0; j&lt; inc_msg.options.size(); j++)
				{
					if(branches.at(i)-&gt;actionCost.at(0).first == inc_msg.options.at(j))
					{
						branches.at(i)-&gt;actionCost.at(0).second = -total_d*4.0;
						m_ModifiedWayPointsCosts.push_back(branches.at(i));
					}
				}
			}

			return true;
		}
	}

	return false;
}

void way_planner_core::PlannerMainLoop()
{
	ros::Rate loop_rate(10);
	timespec animation_timer;
	UtilityHNS::UtilityH::GetTickCount(animation_timer);

	while (ros::ok())
	{
		ros::spinOnce();
		bool bMakeNewPlan = false;

		if(m_params.bEnableHMI)
			bMakeNewPlan = HMI_DoOneStep();

		//std::cout &lt;&lt; &quot;Main Loop ! &quot; &lt;&lt; std::endl;
		if(m_params.mapSource == MAP_KML_FILE &amp;&amp; !m_bKmlMap)
		{
			m_bKmlMap = true;
			PlannerHNS::MappingHelpers::LoadKML(m_params.KmlMapPath, m_Map);
			//PlannerHNS::MappingHelpers::WriteKML(&quot;/home/hatem/SimuLogs/KmlMaps/ToyotaMap2017.kml&quot;, &quot;/home/hatem/SimuLogs/KmlMaps/PlannerX_MapTemplate.kml&quot;, m_Map);
			visualization_msgs::MarkerArray map_marker_array;
			RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
			pub_MapRviz.publish(map_marker_array);
		}
		else if (m_params.mapSource == MAP_FOLDER &amp;&amp; !m_bKmlMap)
		{
			m_bKmlMap = true;
			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_params.KmlMapPath, m_Map, true);
			//PlannerHNS::MappingHelpers::WriteKML(&quot;/home/hatem/SimuLogs/KmlMaps/Moriyama_NoTransform_2017.kml&quot;, &quot;/home/hatem/SimuLogs/KmlMaps/PlannerX_MapTemplate.kml&quot;, m_Map);
			visualization_msgs::MarkerArray map_marker_array;
			RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);

			pub_MapRviz.publish(map_marker_array);

		}
		else if(m_params.mapSource == MAP_AUTOWARE)
		{
			 if(m_AwMap.bDtLanes &amp;&amp; m_AwMap.bLanes &amp;&amp; m_AwMap.bPoints)
			 {
				 m_AwMap.bDtLanes = m_AwMap.bLanes = m_AwMap.bPoints = false;
				 UpdateRoadMap(m_AwMap,m_Map);
				visualization_msgs::MarkerArray map_marker_array;
				RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(m_Map, map_marker_array);
				pub_MapRviz.publish(map_marker_array);
			 }
		}

		if(m_GoalsPos.size() &gt; 1)
		{
			//std::cout &lt;&lt; m_CurrentPose.pos.ToString() &lt;&lt; std::endl;
			PlannerHNS::WayPoint startPoint = m_CurrentPose;
			PlannerHNS::WayPoint goalPoint = m_GoalsPos.at(m_iCurrentGoalIndex);

			if(m_GeneratedTotalPaths.size() &gt; 0 &amp;&amp; m_GeneratedTotalPaths.at(0).size() &gt; 3)
			{
				if(m_params.bEnableReplanning)
				{
					PlannerHNS::RelativeInfo info;
					bool ret = PlannerHNS::PlanningHelpers::GetRelativeInfoRange(m_GeneratedTotalPaths, startPoint, 0.75, info);
					if(ret == true &amp;&amp; info.iGlobalPath &gt;= 0 &amp;&amp;  info.iGlobalPath &lt; m_GeneratedTotalPaths.size() &amp;&amp; info.iFront &gt; 0 &amp;&amp; info.iFront &lt; m_GeneratedTotalPaths.at(info.iGlobalPath).size())
					{
						double remaining_distance =    m_GeneratedTotalPaths.at(info.iGlobalPath).at(m_GeneratedTotalPaths.at(info.iGlobalPath).size()-1).cost - (m_GeneratedTotalPaths.at(info.iGlobalPath).at(info.iFront).cost + info.to_front_distance);
						if(remaining_distance &lt;= REPLANNING_DISTANCE)
						{
							m_iCurrentGoalIndex++;
							if(m_iCurrentGoalIndex &gt;= m_GoalsPos.size())
								m_iCurrentGoalIndex = 0;
							bMakeNewPlan = true;
						}
					}
				}
			}
			else
				bMakeNewPlan = true;

			if(bMakeNewPlan)
			{

					bool bNewPlan = GenerateGlobalPlan(startPoint, goalPoint, m_GeneratedTotalPaths);

					if(bNewPlan)
					{
						bMakeNewPlan = false;
						VisualizeAndSend(m_GeneratedTotalPaths);
#ifdef ENABLE_VISUALIZE_PLAN
						//calculate new max_cost
						if(m_PlanningVisualizeTree.size() &gt; 1)
						{
							m_CurrentLevel.push_back(m_PlanningVisualizeTree.at(0));
							m_CurrMaxCost = 0;
							for(unsigned int itree = 0; itree &lt; m_PlanningVisualizeTree.size(); itree++)
							{
								if(m_PlanningVisualizeTree.at(itree)-&gt;cost &gt; m_CurrMaxCost)
									m_CurrMaxCost = m_PlanningVisualizeTree.at(itree)-&gt;cost;
							}
						}
#endif
					}
			}

#ifdef ENABLE_VISUALIZE_PLAN
			if(UtilityHNS::UtilityH::GetTimeDiffNow(animation_timer) &gt; 0.5)
			{
				UtilityHNS::UtilityH::GetTickCount(animation_timer);
				m_CurrentLevel.clear();

				for(unsigned int ilev = 0; ilev &lt; m_nLevelSize &amp;&amp; m_iCurrLevel &lt; m_PlanningVisualizeTree.size() ; ilev ++)
				{
					m_CurrentLevel.push_back(m_PlanningVisualizeTree.at(m_iCurrLevel));
					m_nLevelSize += m_PlanningVisualizeTree.at(m_iCurrLevel)-&gt;pFronts.size() - 1;
					m_iCurrLevel++;
				}


				if(m_CurrentLevel.size() == 0 &amp;&amp; m_GeneratedTotalPaths.size() &gt; 0)
				{
					m_bSwitch++;
					m_AccumPlanLevels.markers.clear();

					if(m_bSwitch == 2)
					{
						for(unsigned int il = 0; il &lt; m_GeneratedTotalPaths.size(); il++)
							for(unsigned int ip = 0; ip &lt; m_GeneratedTotalPaths.at(il).size(); ip ++)
								m_CurrentLevel.push_back(&amp;m_GeneratedTotalPaths.at(il).at(ip));

						std::cout &lt;&lt; &quot;Switch On &quot; &lt;&lt; std::endl;

						m_bSwitch = 0;

					}
					else
					{
						for(unsigned int ilev = 0; ilev &lt; m_PlanningVisualizeTree.size()+200 ; ilev ++)
							m_CurrentLevel.push_back(m_PlanningVisualizeTree.at(0));

						std::cout &lt;&lt; &quot;Switch Off &quot; &lt;&lt; std::endl;
					}

					CreateNextPlanningTreeLevelMarker(m_CurrentLevel, m_AccumPlanLevels, m_CurrMaxCost);
					pub_GlobalPlanAnimationRviz.publish(m_AccumPlanLevels);
				}
				else
				{
					CreateNextPlanningTreeLevelMarker(m_CurrentLevel, m_AccumPlanLevels, m_CurrMaxCost);

					if(m_AccumPlanLevels.markers.size() &gt; 0)
						pub_GlobalPlanAnimationRviz.publish(m_AccumPlanLevels);
				}
			}
#endif

		}

		//ROS_INFO(&quot;Main Loop Step&quot;);
		loop_rate.sleep();
	}
}

}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/dp_planner/include/PolygonGenerator.h" new_path="ros/src/computing/planning/motion/packages/dp_planner/include/PolygonGenerator.h">
				<diff>@@ -9,6 +9,7 @@
 #define POLYGONGENERATOR_H_
 
 #include &quot;RoadNetwork.h&quot;
+#include &quot;PlanningHelpers.h&quot;
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
</diff>
				<old_file>/*
 * PolygonGenerator.h
 *
 *  Created on: Nov 2, 2016
 *      Author: ai-driver
 */

#ifndef POLYGONGENERATOR_H_
#define POLYGONGENERATOR_H_

#include &quot;RoadNetwork.h&quot;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;

namespace PlannerXNS
{

using namespace PlannerHNS;

#define QUARTERS_NUMBER 8
#define MIN_POINTS_PER_QUARTER 1
#define MIN_DISTANCE_BETWEEN_CORNERS 0.5

class QuarterView
{
public:
	int id;
	int min_ang;
	int max_ang;
	std::vector&lt;WayPoint&gt; vectorsFromCenter;

	QuarterView(const int&amp; min_a, const int&amp; max_a, const int&amp; index)
	{
		min_ang = min_a;
		max_ang = max_a;
		id = index;
	}

	void InitQuarterView(const int&amp; min_a, const int&amp; max_a, const int&amp; index)
	{
		min_ang = min_a;
		max_ang = max_a;
		id = index;
	}

	bool UpdateQuarterView(const WayPoint&amp; v)
	{
		if(v.pos.a &lt;= min_ang || v.pos.a &gt; max_ang)
			return false;

		bool bGreaterFound = false;
		unsigned int greaterIndex = 0;
		for(unsigned int i=0; i&lt; vectorsFromCenter.size(); i++)
		{
			if(vectorsFromCenter.at(i).cost &gt; v.cost)
			{
				bGreaterFound = true;
				greaterIndex = i;
				break;
			}
		}

		if(bGreaterFound)
		{
			if(greaterIndex &lt; vectorsFromCenter.size())
				vectorsFromCenter.insert(vectorsFromCenter.begin()+greaterIndex, v);
			else
				vectorsFromCenter.push_back(v);
		}
		else
			vectorsFromCenter.push_back(v);

		return true;

	}

	bool GetMaxPoint(WayPoint&amp; maxPoint)
	{
		if(vectorsFromCenter.size()==0)
			return false;

		maxPoint = vectorsFromCenter.at(vectorsFromCenter.size()-1);
		return vectorsFromCenter.size();
	}

	int GetPointsNumber()
	{
		return vectorsFromCenter.size();
	}
};

class PolygonGenerator
{

public:

	GPSPoint m_Centroid;
	PolygonGenerator();
	virtual ~PolygonGenerator();
	void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon);
	GPSPoint CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster);
	std::vector&lt;QuarterView&gt; CreateQuarterViews(const int&amp; nResolution);
	std::vector&lt;GPSPoint&gt; EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid );
};

} /* namespace PlannerXNS */

#endif /* POLYGONGENERATOR_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/dp_planner/nodes/PolygonGenerator.cpp" new_path="ros/src/computing/planning/motion/packages/dp_planner/nodes/PolygonGenerator.cpp">
				<diff>@@ -6,7 +6,6 @@
  */
 
 #include &quot;PolygonGenerator.h&quot;
-#include &quot;PlanningHelpers.h&quot;
 
 namespace PlannerXNS
 {
@@ -21,9 +20,9 @@ PolygonGenerator::~PolygonGenerator() {
 	// TODO Auto-generated destructor stub
 }
 
-GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster)
+PlannerHNS::GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster)
 {
-	GPSPoint c;
+	PlannerHNS::GPSPoint c;
 
 	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
 	{
@@ -37,21 +36,21 @@ GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ
 	return c;
 }
 
-std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid )
+std::vector&lt;PlannerHNS::GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const PlannerHNS::GPSPoint&amp; original_centroid )
 {
 	std::vector&lt;QuarterView&gt; quarters = CreateQuarterViews(QUARTERS_NUMBER);
 
 
 	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
 	{
-		WayPoint p;
+		PlannerHNS::WayPoint p;
 		p.pos.x = cluster.points.at(i).x;
 		p.pos.y = cluster.points.at(i).y;
 		p.pos.z = original_centroid.z;
 
-		POINT2D v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y);
+		PlannerHNS::GPSPoint v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y,p.pos.z,0);
 		p.cost = pointNorm(v);
-		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*RAD2DEG;
+		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*(180. / M_PI);
 
 		for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
 		{
@@ -60,12 +59,12 @@ std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointC
 		}
 	}
 
-	std::vector&lt;GPSPoint&gt; polygon;
+	std::vector&lt;PlannerHNS::GPSPoint&gt; polygon;
 
 	for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
 	{
 
-		WayPoint wp;
+		PlannerHNS::WayPoint wp;
 		int nPoints = quarters.at(j).GetMaxPoint(wp);
 		if(nPoints &gt;= MIN_POINTS_PER_QUARTER)
 		{
@@ -119,7 +118,7 @@ std::vector&lt;QuarterView&gt; PolygonGenerator::CreateQuarterViews(const int&amp; nResolu
 	return quarters;
 }
 
-void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon)
+void CheckConvexPoligon(std::vector&lt;PlannerHNS::WayPoint&gt;&amp; polygon)
 {
 
 //	if(polygon.size() &lt;= 3)
</diff>
				<old_file>/*
 * PolygonGenerator.cpp
 *
 *  Created on: Nov 2, 2016
 *      Author: ai-driver
 */

#include &quot;PolygonGenerator.h&quot;
#include &quot;PlanningHelpers.h&quot;

namespace PlannerXNS
{


PolygonGenerator::PolygonGenerator() {
	// TODO Auto-generated constructor stub

}

PolygonGenerator::~PolygonGenerator() {
	// TODO Auto-generated destructor stub
}

GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster)
{
	GPSPoint c;

	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
	{
		c.x += cluster.points.at(i).x;
		c.y += cluster.points.at(i).y;
	}

	c.x = c.x/cluster.points.size();
	c.y = c.y/cluster.points.size();

	return c;
}

std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid )
{
	std::vector&lt;QuarterView&gt; quarters = CreateQuarterViews(QUARTERS_NUMBER);


	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
	{
		WayPoint p;
		p.pos.x = cluster.points.at(i).x;
		p.pos.y = cluster.points.at(i).y;
		p.pos.z = original_centroid.z;

		POINT2D v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y);
		p.cost = pointNorm(v);
		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*RAD2DEG;

		for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
		{
			if(quarters.at(j).UpdateQuarterView(p))
				break;
		}
	}

	std::vector&lt;GPSPoint&gt; polygon;

	for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
	{

		WayPoint wp;
		int nPoints = quarters.at(j).GetMaxPoint(wp);
		if(nPoints &gt;= MIN_POINTS_PER_QUARTER)
		{
			polygon.push_back(wp.pos);
		}
	}

//	//Fix Resolution:
//	bool bChange = true;
//	while (bChange &amp;&amp; polygon.size()&gt;1)
//	{
//		bChange = false;
//		GPSPoint p1 =  polygon.at(polygon.size()-1);
//		for(unsigned int i=0; i&lt; polygon.size(); i++)
//		{
//			GPSPoint p2 = polygon.at(i);
//			double d = hypot(p2.y- p1.y, p2.x - p1.x);
//			if(d &gt; MIN_DISTANCE_BETWEEN_CORNERS)
//			{
//				GPSPoint center_p = p1;
//				center_p.x = (p2.x + p1.x)/2.0;
//				center_p.y = (p2.y + p1.y)/2.0;
//				polygon.insert(polygon.begin()+i, center_p);
//				bChange = true;
//				break;
//			}
//
//			p1 = p2;
//		}
//	}

	return polygon;

}

std::vector&lt;QuarterView&gt; PolygonGenerator::CreateQuarterViews(const int&amp; nResolution)
{
	std::vector&lt;QuarterView&gt; quarters;
	if(nResolution &lt;= 0)
		return quarters;

	double range = 360.0 / nResolution;
	double angle = 0;
	for(int i = 0; i &lt; nResolution; i++)
	{
		QuarterView q(angle, angle+range, i);
		quarters.push_back(q);
		angle+=range;
	}

	return quarters;
}

void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon)
{

//	if(polygon.size() &lt;= 3)
//		return;
//
//	WayPoint p1 = polygon.at(0);
//	WayPoint p3;
//	WayPoint p2;
//
//	for(int i=1; i&lt; polygon.size()-1; i++)
//	{
//		p1 = polygon.at(i-1);
//		if(i+2 == polygon.size())
//		{
//			p2 = polygon.at(polygon.size()-1);
//			p3 = polygon.at(0);
//		}
//		else
//		{
//			p2 = polygon.at(i);
//			p3 = polygon.at(i+1);
//		}
//
//	}
}

} /* namespace PlannerXNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/dp_planner/nodes/RosHelpers.cpp" new_path="ros/src/computing/planning/motion/packages/dp_planner/nodes/RosHelpers.cpp">
				<diff>@@ -62,11 +62,11 @@ void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;Plann
 		wp.pose.pose.position.z = path.at(i).pos.z;
 		wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(path.at(i).pos.a));
 		wp.twist.twist.linear.x = path.at(i).v;
-		if(path.at(i).bDir == FORWARD_DIR)
+		if(path.at(i).bDir == PlannerHNS::FORWARD_DIR)
 			wp.dtlane.dir = 0;
-		else if(path.at(i).bDir == FORWARD_LEFT_DIR)
+		else if(path.at(i).bDir == PlannerHNS::FORWARD_LEFT_DIR)
 			wp.dtlane.dir = 1;
-		else if(path.at(i).bDir == FORWARD_RIGHT_DIR)
+		else if(path.at(i).bDir == PlannerHNS::FORWARD_RIGHT_DIR)
 			wp.dtlane.dir = 2;
 		//PlannerHNS::GPSPoint p = path.at(i).pos;
 		//std::cout &lt;&lt; p.ToString() &lt;&lt; std::endl;
@@ -621,7 +621,7 @@ void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const Planne
 	{
 		PolygonGenerator polyGen;
 		PlannerHNS::DetectedObject obj;
-		obj.center.pos = GPSPoint(clusters.clusters.at(i).centroid_point.point.x,
+		obj.center.pos = PlannerHNS::GPSPoint(clusters.clusters.at(i).centroid_point.point.x,
 				clusters.clusters.at(i).centroid_point.point.y,
 				clusters.clusters.at(i).centroid_point.point.z,0);
 				//tf::getYaw(clusters.clusters.at(i).bounding_box.pose.orientation));
@@ -839,10 +839,12 @@ void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::R
 	std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt; stop_line_data;
 	std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt; signal_data;
 	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
+	std::vector&lt;UtilityHNS::AisanCurbFileReader::AisanCurb&gt; curb_data;
+	std::vector&lt;UtilityHNS::AisanRoadEdgeFileReader::AisanRoadEdge&gt; roadedge_data;
 	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;
 
 	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
-	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,conn_data, origin, out_map);
+	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,curb_data, roadedge_data, conn_data, origin, out_map);
 }
 
 }
</diff>
				<old_file>/*
 * RosHelpers.cpp
 *
 *  Created on: Jun 30, 2016
 *      Author: ai-driver
 */

#include &quot;RosHelpers.h&quot;

#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;math.h&gt;
#include &quot;PolygonGenerator.h&quot;
#include &quot;MappingHelpers.h&quot;
#include &quot;MatrixOperations.h&quot;


namespace PlannerXNS
{

RosHelpers::RosHelpers() {

}

RosHelpers::~RosHelpers() {
}

void RosHelpers::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
{
	static tf::TransformListener listener;

	int nFailedCounter = 0;
	while (1)
	{
		try
		{
			listener.lookupTransform(parent_frame, child_frame, ros::Time(0), transform);
			break;
		}
		catch (tf::TransformException&amp; ex)
		{
			if(nFailedCounter &gt; 2)
			{
				ROS_ERROR(&quot;%s&quot;, ex.what());
			}
			ros::Duration(1.0).sleep();
			nFailedCounter ++;
		}
	}
}

void RosHelpers::ConvertFromPlannerHToAutowarePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path, const int&amp; iStart,
		autoware_msgs::lane&amp; trajectory)
{
	trajectory.waypoints.clear();
	for(unsigned int i=iStart; i &lt; path.size(); i++)
	{
		autoware_msgs::waypoint wp;
		wp.pose.pose.position.x = path.at(i).pos.x;
		wp.pose.pose.position.y = path.at(i).pos.y;
		wp.pose.pose.position.z = path.at(i).pos.z;
		wp.pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(path.at(i).pos.a));
		wp.twist.twist.linear.x = path.at(i).v;
		if(path.at(i).bDir == FORWARD_DIR)
			wp.dtlane.dir = 0;
		else if(path.at(i).bDir == FORWARD_LEFT_DIR)
			wp.dtlane.dir = 1;
		else if(path.at(i).bDir == FORWARD_RIGHT_DIR)
			wp.dtlane.dir = 2;
		//PlannerHNS::GPSPoint p = path.at(i).pos;
		//std::cout &lt;&lt; p.ToString() &lt;&lt; std::endl;
		trajectory.waypoints.push_back(wp);
	}
}

void RosHelpers::ConvertFromRoadNetworkToAutowareVisualizeMapFormat(const PlannerHNS::RoadNetwork&amp; map,	visualization_msgs::MarkerArray&amp; markerArray)
{
	visualization_msgs::Marker lane_waypoint_marker;
	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	lane_waypoint_marker.header.stamp = ros::Time();
	lane_waypoint_marker.ns = &quot;road_network_vector_map&quot;;
	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
	lane_waypoint_marker.scale.x = 0.25;
	std_msgs::ColorRGBA roll_color, total_color, curr_color;
	roll_color.r = 1;
	roll_color.g = 1;
	roll_color.b = 1;
	roll_color.a = 0.5;

	lane_waypoint_marker.color = roll_color;
	lane_waypoint_marker.frame_locked = false;

	markerArray.markers.clear();

	for(unsigned int i = 0; i&lt; map.roadSegments.size(); i++)
	{
		for(unsigned int j = 0; j &lt; map.roadSegments.at(i).Lanes.size(); j++)
		{
			lane_waypoint_marker.points.clear();

			lane_waypoint_marker.id = map.roadSegments.at(i).Lanes.at(j).id;
			for(unsigned int p = 0; p &lt; map.roadSegments.at(i).Lanes.at(j).points.size(); p++)
			{
				geometry_msgs::Point point;



				  point.x = map.roadSegments.at(i).Lanes.at(j).points.at(p).pos.x;
				  point.y = map.roadSegments.at(i).Lanes.at(j).points.at(p).pos.y;
				  point.z = map.roadSegments.at(i).Lanes.at(j).points.at(p).pos.z;

				  lane_waypoint_marker.points.push_back(point);
			}

			markerArray.markers.push_back(lane_waypoint_marker);
		}
	}
}

void RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect,
		visualization_msgs::Marker&amp; marker)
{
	//if(safety_rect.size() != 4) return;

	visualization_msgs::Marker lane_waypoint_marker;
	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	lane_waypoint_marker.header.stamp = ros::Time();
	lane_waypoint_marker.ns = &quot;global_lane_array_marker&quot;;
	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
	lane_waypoint_marker.scale.x = 0.2;
	lane_waypoint_marker.scale.y = 0.2;
	//lane_waypoint_marker.scale.z = 0.1;
	lane_waypoint_marker.frame_locked = false;
	lane_waypoint_marker.color.r = 0.0;
	lane_waypoint_marker.color.g = 1.0;
	lane_waypoint_marker.color.b = 0.0;
	lane_waypoint_marker.color.a = 0.6;

	int id = 0;
	for(unsigned int i = 0; i &lt; safety_rect.size(); i++)
	{
		geometry_msgs::Point p;
		p.x = safety_rect.at(i).x;
		p.y = safety_rect.at(i).y;
		p.z = safety_rect.at(i).z;

		lane_waypoint_marker.points.push_back(p);
	}
	if(safety_rect.size() &gt; 0)
	{
		geometry_msgs::Point p;
		p.x = safety_rect.at(0).x;
		p.y = safety_rect.at(0).y;
		p.z = safety_rect.at(0).z;
		lane_waypoint_marker.points.push_back(p);
	}

//	geometry_msgs::Point p1, p2,p3,p4;
//	p1.x = safety_rect.at(0).x;
//	p1.y = safety_rect.at(0).y;
//	p1.z = safety_rect.at(0).z;
//
//	p2.x = safety_rect.at(1).x;
//	p2.y = safety_rect.at(1).y;
//	p2.z = safety_rect.at(1).z;
//
//	p3.x = safety_rect.at(2).x;
//	p3.y = safety_rect.at(2).y;
//	p3.z = safety_rect.at(2).z;
//
//	p4.x = safety_rect.at(3).x;
//	p4.y = safety_rect.at(3).y;
//	p4.z = safety_rect.at(3).z;
//
//	lane_waypoint_marker.points.push_back(p1);
//	lane_waypoint_marker.points.push_back(p2);
//	lane_waypoint_marker.points.push_back(p3);
//	lane_waypoint_marker.points.push_back(p4);
//	lane_waypoint_marker.points.push_back(p1);

	 marker = lane_waypoint_marker;

}

void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; curr_path,
		const std::vector&lt;std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; &gt;&amp; paths, const PlannerHNS::LocalPlannerH&amp; localPlanner,
			visualization_msgs::MarkerArray&amp; markerArray)
{
	visualization_msgs::Marker lane_waypoint_marker;
	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	lane_waypoint_marker.header.stamp = ros::Time();
	lane_waypoint_marker.ns = &quot;global_lane_array_marker&quot;;
	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
	lane_waypoint_marker.scale.x = 0.1;
	lane_waypoint_marker.scale.y = 0.1;
	//lane_waypoint_marker.scale.z = 0.1;
	lane_waypoint_marker.frame_locked = false;
	std_msgs::ColorRGBA  total_color, curr_color;


	int count = 0;
	for (unsigned int il = 0; il &lt; paths.size(); il++)
	{
		for (unsigned int i = 0; i &lt; paths.at(il).size(); i++)
		{
			lane_waypoint_marker.points.clear();
			lane_waypoint_marker.id = count;

			for (unsigned int j=0; j &lt; paths.at(il).at(i).size(); j++)
			{
			  geometry_msgs::Point point;

			  point.x = paths.at(il).at(i).at(j).pos.x;
			  point.y = paths.at(il).at(i).at(j).pos.y;
			  point.z = paths.at(il).at(i).at(j).pos.z;

			  lane_waypoint_marker.points.push_back(point);
			}

			lane_waypoint_marker.color.a = 0.9;
			if(localPlanner.m_TrajectoryCostsCalculatotor.m_TrajectoryCosts.size() == paths.size())
			{
				float norm_cost = localPlanner.m_TrajectoryCostsCalculatotor.m_TrajectoryCosts.at(i).cost * paths.size();
				if(norm_cost &lt;= 1.0)
				{
					lane_waypoint_marker.color.r = norm_cost;
					lane_waypoint_marker.color.g = 1.0;
				}
				else if(norm_cost &gt; 1.0)
				{
					lane_waypoint_marker.color.r = 1.0;
					lane_waypoint_marker.color.g = 2.0 - norm_cost;
				}
			}
			else
			{
				lane_waypoint_marker.color.r = 0.0;
				lane_waypoint_marker.color.g = 1.0;
			}

			if(i == localPlanner.m_iSafeTrajectory &amp;&amp; il == localPlanner.m_iCurrentTotalPathId)
			{
				lane_waypoint_marker.color.r = 1.0;
				lane_waypoint_marker.color.g = 0.0;
				lane_waypoint_marker.color.b = 1.0;
			}
			else
			{
				lane_waypoint_marker.color.b = 0;
			}

			markerArray.markers.push_back(lane_waypoint_marker);
			count++;
		}
	}
}

void RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(const std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt;&amp; globalPaths,
			visualization_msgs::MarkerArray&amp; markerArray)
{
	visualization_msgs::Marker lane_waypoint_marker;
	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	lane_waypoint_marker.header.stamp = ros::Time();
	lane_waypoint_marker.ns = &quot;global_lane_array_marker&quot;;
	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;


	std_msgs::ColorRGBA roll_color, total_color, curr_color;
	lane_waypoint_marker.points.clear();
	lane_waypoint_marker.id = 1;
	lane_waypoint_marker.scale.x = 0.1;
	lane_waypoint_marker.scale.y = 0.1;
	total_color.r = 1;
	total_color.g = 0;
	total_color.b = 0;
	total_color.a = 0.5;
	lane_waypoint_marker.color = total_color;
	lane_waypoint_marker.frame_locked = false;

	int count = 0;
	for (unsigned int i = 0; i &lt; globalPaths.size(); i++)
	{
		lane_waypoint_marker.points.clear();
		lane_waypoint_marker.id = count;

		for (unsigned int j=0; j &lt; globalPaths.at(i).size(); j++)
		{
		  geometry_msgs::Point point;

		  point.x = globalPaths.at(i).at(j).pos.x;
		  point.y = globalPaths.at(i).at(j).pos.y;
		  point.z = globalPaths.at(i).at(j).pos.z;

		  lane_waypoint_marker.points.push_back(point);
		}

		markerArray.markers.push_back(lane_waypoint_marker);
		count++;
	}
}

void RosHelpers::ConvertFromPlannerObstaclesToAutoware(const PlannerHNS::WayPoint&amp; currState, const std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; trackedObstacles,
		visualization_msgs::MarkerArray&amp; detectedPolygons)
{
	visualization_msgs::Marker lane_waypoint_marker;
	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	lane_waypoint_marker.header.stamp = ros::Time();
	lane_waypoint_marker.ns = &quot;detected_polygons&quot;;
	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
	lane_waypoint_marker.scale.x = .1;
	lane_waypoint_marker.scale.y = .1;
	//lane_waypoint_marker.scale.z = .05;
	lane_waypoint_marker.color.a = 0.8;
	lane_waypoint_marker.frame_locked = false;

	visualization_msgs::Marker corner_marker;
	corner_marker.header.frame_id = &quot;map&quot;;
	corner_marker.header.stamp = ros::Time();
	corner_marker.ns = &quot;Polygon_Corners&quot;;
	corner_marker.type = visualization_msgs::Marker::SPHERE;
	corner_marker.action = visualization_msgs::Marker::ADD;
	corner_marker.scale.x = .1;
	corner_marker.scale.y = .1;
	corner_marker.scale.z = .1;
	corner_marker.color.a = 0.8;
	corner_marker.frame_locked = false;


	visualization_msgs::Marker quarters_marker;
	quarters_marker.header.frame_id = &quot;map&quot;;
	quarters_marker.header.stamp = ros::Time();
	quarters_marker.ns = &quot;Quarters_Lines&quot;;
	quarters_marker.type = visualization_msgs::Marker::LINE_STRIP;
	quarters_marker.action = visualization_msgs::Marker::ADD;
	quarters_marker.scale.x = .03;
	quarters_marker.scale.y = .03;
	quarters_marker.scale.z = .03;
	quarters_marker.color.a = 0.8;
	quarters_marker.color.r = 0.6;
	quarters_marker.color.g = 0.5;
	quarters_marker.color.b = 0;
	quarters_marker.frame_locked = false;

	visualization_msgs::Marker direction_marker;
	direction_marker.header.frame_id = &quot;map&quot;;
	direction_marker.header.stamp = ros::Time();
	direction_marker.ns = &quot;Object_Direction&quot;;
	direction_marker.type = visualization_msgs::Marker::ARROW;
	direction_marker.action = visualization_msgs::Marker::ADD;
	direction_marker.scale.x = .9;
	direction_marker.scale.y = .4;
	direction_marker.scale.z = .4;
	direction_marker.color.a = 0.8;
	direction_marker.color.r = 0;
	direction_marker.color.g = 1;
	direction_marker.color.b = 0;
	direction_marker.frame_locked = false;


	visualization_msgs::Marker velocity_marker;
	velocity_marker.header.frame_id = &quot;map&quot;;
	velocity_marker.header.stamp = ros::Time();
	velocity_marker.ns = &quot;detected_polygons_velocity&quot;;
	velocity_marker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
	//velocity_marker.action = visualization_msgs::Marker::ADD;
	velocity_marker.scale.z = 0.9;
	velocity_marker.scale.x = 0.9;
	velocity_marker.scale.y = 0.9;
	velocity_marker.color.a = 0.5;

	velocity_marker.frame_locked = false;
	detectedPolygons.markers.clear();

	int pointID = 0;
	int quartersIds = 0;
	for(unsigned int i =0; i &lt; trackedObstacles.size(); i++)
	{
		//double distance = hypot(currState.pos.y-trackedObstacles.at(i).center.pos.y, currState.pos.x-trackedObstacles.at(i).center.pos.x);

		lane_waypoint_marker.color.g = 0;
		lane_waypoint_marker.color.r = 0;
		lane_waypoint_marker.color.b = 1;

		velocity_marker.color.r = 1;//trackedObstacles.at(i).center.v/16.0;
		velocity_marker.color.g = 1;// - trackedObstacles.at(i).center.v/16.0;
		velocity_marker.color.b = 1;

		lane_waypoint_marker.points.clear();
		lane_waypoint_marker.id = i;
		velocity_marker.id = i;

		//std::cout &lt;&lt; &quot; Distance : &quot; &lt;&lt; distance &lt;&lt; &quot;, Of Object&quot; &lt;&lt; trackedObstacles.at(i).id &lt;&lt; std::endl;

		for(unsigned int p = 0; p &lt; trackedObstacles.at(i).contour.size(); p++)
		{

			geometry_msgs::Point point;

			  point.x = trackedObstacles.at(i).contour.at(p).x;
			  point.y = trackedObstacles.at(i).contour.at(p).y;
			  point.z = trackedObstacles.at(i).contour.at(p).z;

			  lane_waypoint_marker.points.push_back(point);

			  corner_marker.pose.position = point;
			  corner_marker.color.r = 0.8;
			  corner_marker.color.g = 0;
			  corner_marker.color.b = 0.7;
			  corner_marker.color.a = 0.5;
			  corner_marker.id = pointID;
			  pointID++;

			  detectedPolygons.markers.push_back(corner_marker);
		}

		if(trackedObstacles.at(i).contour.size()&gt;0)
		{
		geometry_msgs::Point point;

		  point.x = trackedObstacles.at(i).contour.at(0).x;
		  point.y = trackedObstacles.at(i).contour.at(0).y;
		  point.z = trackedObstacles.at(i).contour.at(0).z+1;

		  lane_waypoint_marker.points.push_back(point);

		}


		geometry_msgs::Point point;

		point.x = trackedObstacles.at(i).center.pos.x;
		point.y = trackedObstacles.at(i).center.pos.y;
		point.z = trackedObstacles.at(i).center.pos.z+1;

//		geometry_msgs::Point relative_p;
		//relative_p.y = 0.5;
//		velocity_marker.pose.position = calcAbsoluteCoordinate(relative_p, point);
		velocity_marker.pose.position = point;
	    velocity_marker.pose.position.z += 0.5;

	    direction_marker.id = i;
	    direction_marker.pose.position = point;
	    direction_marker.pose.position.z += 0.5;
	    direction_marker.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(trackedObstacles.at(i).center.pos.a));


		for(unsigned int iq = 0; iq &lt; 8; iq++)
		{
			quarters_marker.points.clear();
			quarters_marker.id = quartersIds;
			quarters_marker.points.push_back(point);
			geometry_msgs::Point point2 = point;
			double a_q = UtilityHNS::UtilityH::SplitPositiveAngle(trackedObstacles.at(i).center.pos.a+(iq*M_PI_4));
			point2.x += 2.0*cos(a_q);
			point2.y += 1.5*sin(a_q);
			quarters_marker.points.push_back(point2);

			quartersIds++;
			detectedPolygons.markers.push_back(quarters_marker);
		}

		int speed = (trackedObstacles.at(i).center.v*3.6);

	  // double to string
	  std::ostringstream str_out;
	//  if(trackedObstacles.at(i).center.v &gt; 0.75)
	  str_out &lt;&lt; &quot;(&quot; &lt;&lt; trackedObstacles.at(i).id &lt;&lt; &quot; , &quot; &lt;&lt; speed &lt;&lt; &quot;)&quot;;
//	  else
//		  str_out &lt;&lt; trackedObstacles.at(i).id;
	  //std::string vel = str_out.str();
	  velocity_marker.text = str_out.str();//vel.erase(vel.find_first_of(&quot;.&quot;) + 2);
	  //if(speed &gt; 0.5)

	  detectedPolygons.markers.push_back(velocity_marker);
	  detectedPolygons.markers.push_back(lane_waypoint_marker);
	  detectedPolygons.markers.push_back(direction_marker);

	}
}

std::string RosHelpers::GetBehaviorNameFromCode(const PlannerHNS::STATE_TYPE&amp; behState)
{
	std::string str = &quot;Unknown&quot;;
	switch(behState)
	{
	case PlannerHNS::INITIAL_STATE:
		str = &quot;Init&quot;;
		break;
	case PlannerHNS::WAITING_STATE:
		str = &quot;Waiting&quot;;
		break;
	case PlannerHNS::FORWARD_STATE:
		str = &quot;Forward&quot;;
		break;
	case PlannerHNS::STOPPING_STATE:
		str = &quot;Stop&quot;;
		break;
	case PlannerHNS::FINISH_STATE:
		str = &quot;End&quot;;
		break;
	case PlannerHNS::FOLLOW_STATE:
		str = &quot;Follow&quot;;
		break;
	case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
		str = &quot;Swerving&quot;;
		break;
	case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
		str = &quot;Light Stop&quot;;
		break;
	case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
		str = &quot;Light Wait&quot;;
		break;
	case PlannerHNS::STOP_SIGN_STOP_STATE:
		str = &quot;Sign Stop&quot;;
		break;
	case PlannerHNS::STOP_SIGN_WAIT_STATE:
		str = &quot;Sign Wait&quot;;
		break;
	default:
		str = &quot;Unknown&quot;;
		break;
	}

	return str;
}

void RosHelpers::VisualizeBehaviorState(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::BehaviorState&amp; beh, const bool&amp; bGreenLight, const int&amp; avoidDirection, visualization_msgs::Marker&amp; behaviorMarker)
{
	behaviorMarker.header.frame_id = &quot;map&quot;;
	behaviorMarker.header.stamp = ros::Time();
	behaviorMarker.ns = &quot;detected_polygons_velocity&quot;;
	behaviorMarker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
	behaviorMarker.scale.z = 1.0;
	behaviorMarker.scale.x = 1.0;
	behaviorMarker.scale.y = 1.0;
	behaviorMarker.color.a = 0.9;
	behaviorMarker.frame_locked = false;
	if(bGreenLight)
	{
		behaviorMarker.color.r = 0.1;//trackedObstacles.at(i).center.v/16.0;
		behaviorMarker.color.g = 1;// - trackedObstacles.at(i).center.v/16.0;
		behaviorMarker.color.b = 0.1;
	}
	else
	{
		behaviorMarker.color.r = 1;//trackedObstacles.at(i).center.v/16.0;
		behaviorMarker.color.g = 0.1;// - trackedObstacles.at(i).center.v/16.0;
		behaviorMarker.color.b = 0.1;
		behaviorMarker.id = 0;
	}
	geometry_msgs::Point point;

	point.x = currState.pos.x;
	point.y = currState.pos.y;
	point.z = currState.pos.z+2.0;

	behaviorMarker.pose.position = point;

	std::ostringstream str_out;

	//str_out &lt;&lt; &quot;(&quot; &lt;&lt; (int)(beh.followDistance * 100) / 100 &lt;&lt;&quot;)&quot;;
	str_out &lt;&lt; &quot;(&quot; &lt;&lt; (int)(beh.stopDistance * 100.0) / 100.0 &lt;&lt;&quot;)&quot;;

	if(avoidDirection == -1)
		str_out &lt;&lt; &quot;&lt;&lt; &quot;;

	str_out &lt;&lt; GetBehaviorNameFromCode(beh.state);
	if(avoidDirection == 1)
		str_out &lt;&lt; &quot; &gt;&gt;&quot;;
	behaviorMarker.text = str_out.str();
}

void RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(const jsk_recognition_msgs::BoundingBoxArray&amp; detectedObstacles,
		std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list)
{
	obstacles_list.clear();
	for(unsigned int i =0; i &lt; detectedObstacles.boxes.size(); i++)
	{
		PlannerHNS::DetectedObject obj;
		obj.center = PlannerHNS::WayPoint(detectedObstacles.boxes.at(i).pose.position.x,
				detectedObstacles.boxes.at(i).pose.position.y,
				0,
				0);
		obj.w = detectedObstacles.boxes.at(i).dimensions.y;
		obj.l = detectedObstacles.boxes.at(i).dimensions.x;
		obj.h = detectedObstacles.boxes.at(i).dimensions.z;
		//double objSize = obj.w*obj.l;
		//double d = hypot(m_State.state.pos.y - obj.center.pos.y, m_State.state.pos.x - obj.center.pos.x);
		//std::cout &lt;&lt; &quot;, Distance of  : &quot; &lt;&lt; d;
		//if(d &lt; 7)
		{

			double l2 = obj.l/2.0;
			double w2 = obj.w/2.0;

			obj.contour.push_back(PlannerHNS::GPSPoint(-w2, -l2, 0,0));
			obj.contour.push_back(PlannerHNS::GPSPoint(w2, -l2, 0,0));
			obj.contour.push_back(PlannerHNS::GPSPoint(w2, l2, 0,0));
			obj.contour.push_back(PlannerHNS::GPSPoint(-w2, l2, 0,0));
			obstacles_list.push_back(obj);
		}
	}
}

void RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
		int&amp; nOriginalPoints, int&amp; nContourPoints)
{
	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);

	int nPoints = 0;
	int nOrPoints = 0;
	for(unsigned int i =0; i &lt; clusters.clusters.size(); i++)
	{
		PolygonGenerator polyGen;
		PlannerHNS::DetectedObject obj;
		obj.center.pos = GPSPoint(clusters.clusters.at(i).centroid_point.point.x,
				clusters.clusters.at(i).centroid_point.point.y,
				clusters.clusters.at(i).centroid_point.point.z,0);
				//tf::getYaw(clusters.clusters.at(i).bounding_box.pose.orientation));

		pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
		pcl::fromROSMsg(clusters.clusters.at(i).cloud, point_cloud);
		obj.contour = polyGen.EstimateClusterPolygon(point_cloud ,obj.center.pos);
		obj.w = clusters.clusters.at(i).dimensions.y;
		obj.l = clusters.clusters.at(i).dimensions.x;
		obj.h = clusters.clusters.at(i).dimensions.z;
		obj.id = 0;
		obj.distance_to_center = hypot(obj.center.pos.y-currState.pos.y, obj.center.pos.x-currState.pos.x);


		PlannerHNS::GPSPoint relative_point;
		relative_point = translationMat*obj.center.pos;
		relative_point = rotationMat*relative_point;

		double distance_x = fabs(relative_point.x - car_info.wheel_base/2.0);
		double distance_y = fabs(relative_point.y);

		double size = (obj.w+obj.l)/2.0;
//		if(size &lt;= 0.25 || size &gt;= 5 || distance_y &gt; 20.0 || distance_x &gt; 20.0)
//			continue;

//		if(distance_y &gt; 10.0 || distance_x &gt; 10.0)
//			continue;

		if(distance_x  &lt;= car_info.length/1.5 &amp;&amp; distance_y &lt;= car_info.width/1.5) // don't detect yourself
			continue;


		nOrPoints += point_cloud.points.size();
		nPoints += obj.contour.size();
		//std::cout &lt;&lt; &quot; Distance_X: &quot; &lt;&lt; distance_x &lt;&lt; &quot;, &quot; &lt;&lt; &quot; Distance_Y: &quot; &lt;&lt; distance_y &lt;&lt; &quot;, &quot; &lt;&lt; &quot; Size: &quot; &lt;&lt; size &lt;&lt; std::endl;

		obstacles_list.push_back(obj);
	}

	nOriginalPoints = nOrPoints;
	nContourPoints =  nPoints;
}

PlannerHNS::SHIFT_POS RosHelpers::ConvertShiftFromAutowareToPlannerH(const PlannerXNS::AUTOWARE_SHIFT_POS&amp; shift)
{
	if(shift == PlannerXNS::AW_SHIFT_POS_DD)
		return PlannerHNS::SHIFT_POS_DD;
	else if(shift == PlannerXNS::AW_SHIFT_POS_RR)
		return PlannerHNS::SHIFT_POS_RR;
	else if(shift == PlannerXNS::AW_SHIFT_POS_NN)
		return PlannerHNS::SHIFT_POS_NN;
	else if(shift == PlannerXNS::AW_SHIFT_POS_PP)
		return PlannerHNS::SHIFT_POS_PP;
	else if(shift == PlannerXNS::AW_SHIFT_POS_BB)
		return PlannerHNS::SHIFT_POS_BB;
	else if(shift == PlannerXNS::AW_SHIFT_POS_SS)
		return PlannerHNS::SHIFT_POS_SS;
	else
		return PlannerHNS::SHIFT_POS_UU;
}

PlannerXNS::AUTOWARE_SHIFT_POS RosHelpers::ConvertShiftFromPlannerHToAutoware(const PlannerHNS::SHIFT_POS&amp; shift)
{
	if(shift == PlannerHNS::SHIFT_POS_DD)
		return PlannerXNS::AW_SHIFT_POS_DD;
	else if(shift == PlannerHNS::SHIFT_POS_RR)
		return PlannerXNS::AW_SHIFT_POS_RR;
	else if(shift == PlannerHNS::SHIFT_POS_NN)
		return PlannerXNS::AW_SHIFT_POS_NN;
	else if(shift == PlannerHNS::SHIFT_POS_PP)
		return PlannerXNS::AW_SHIFT_POS_PP;
	else if(shift == PlannerHNS::SHIFT_POS_BB)
		return PlannerXNS::AW_SHIFT_POS_BB;
	else if(shift == PlannerHNS::SHIFT_POS_SS)
		return PlannerXNS::AW_SHIFT_POS_SS;
	else
		return PlannerXNS::AW_SHIFT_POS_UU;
}

PlannerXNS::AutowareBehaviorState RosHelpers::ConvertBehaviorStateFromPlannerHToAutoware(const PlannerHNS::BehaviorState&amp; beh)
{
	PlannerXNS::AutowareBehaviorState arw_state;
	arw_state.followDistance = beh.followDistance;
	arw_state.followVelocity = beh.followVelocity;
	arw_state.maxVelocity = beh.maxVelocity;
	arw_state.minVelocity = beh.minVelocity;
	arw_state.stopDistance = beh.stopDistance;

	if(beh.indicator == PlannerHNS::LIGHT_INDICATOR::INDICATOR_LEFT)
		arw_state.indicator = PlannerXNS::AW_INDICATOR_LEFT;
	else if(beh.indicator == PlannerHNS::LIGHT_INDICATOR::INDICATOR_RIGHT)
		arw_state.indicator = PlannerXNS::AW_INDICATOR_RIGHT;
	else if(beh.indicator == PlannerHNS::LIGHT_INDICATOR::INDICATOR_BOTH)
		arw_state.indicator = PlannerXNS::AW_INDICATOR_BOTH;
	else if(beh.indicator == PlannerHNS::LIGHT_INDICATOR::INDICATOR_NONE)
		arw_state.indicator = PlannerXNS::AW_INDICATOR_NONE;

	if(beh.state == PlannerHNS::INITIAL_STATE)
		arw_state.state = PlannerXNS::AW_INITIAL_STATE;
	else if(beh.state == PlannerHNS::WAITING_STATE)
		arw_state.state = PlannerXNS::AW_WAITING_STATE;
	else if(beh.state == PlannerHNS::FORWARD_STATE)
		arw_state.state = PlannerXNS::AW_FORWARD_STATE;
	else if(beh.state == PlannerHNS::STOPPING_STATE)
		arw_state.state = PlannerXNS::AW_STOPPING_STATE;
	else if(beh.state == PlannerHNS::EMERGENCY_STATE)
		arw_state.state = PlannerXNS::AW_EMERGENCY_STATE;
	else if(beh.state == PlannerHNS::TRAFFIC_LIGHT_STOP_STATE)
		arw_state.state = PlannerXNS::AW_TRAFFIC_LIGHT_STOP_STATE;
	else if(beh.state == PlannerHNS::STOP_SIGN_STOP_STATE)
		arw_state.state = PlannerXNS::AW_STOP_SIGN_STOP_STATE;
	else if(beh.state == PlannerHNS::FOLLOW_STATE)
		arw_state.state = PlannerXNS::AW_FOLLOW_STATE;
	else if(beh.state == PlannerHNS::LANE_CHANGE_STATE)
		arw_state.state = PlannerXNS::AW_LANE_CHANGE_STATE;
	else if(beh.state == PlannerHNS::OBSTACLE_AVOIDANCE_STATE)
		arw_state.state = PlannerXNS::AW_OBSTACLE_AVOIDANCE_STATE;
	else if(beh.state == PlannerHNS::FINISH_STATE)
		arw_state.state = PlannerXNS::AW_FINISH_STATE;


	return arw_state;

}

void RosHelpers::UpdateRoadMap(const AutowareRoadNetwork&amp; src_map, PlannerHNS::RoadNetwork&amp; out_map)
{
	std::vector&lt;UtilityHNS::AisanLanesFileReader::AisanLane&gt; lanes;
	for(unsigned int i=0; i &lt; src_map.lanes.data.size();i++)
	{
		UtilityHNS::AisanLanesFileReader::AisanLane l;
		l.BLID 		=  src_map.lanes.data.at(i).blid;
		l.BLID2 	=  src_map.lanes.data.at(i).blid2;
		l.BLID3 	=  src_map.lanes.data.at(i).blid3;
		l.BLID4 	=  src_map.lanes.data.at(i).blid4;
		l.BNID 		=  src_map.lanes.data.at(i).bnid;
		l.ClossID 	=  src_map.lanes.data.at(i).clossid;
		l.DID 		=  src_map.lanes.data.at(i).did;
		l.FLID 		=  src_map.lanes.data.at(i).flid;
		l.FLID2 	=  src_map.lanes.data.at(i).flid2;
		l.FLID3 	=  src_map.lanes.data.at(i).flid3;
		l.FLID4 	=  src_map.lanes.data.at(i).flid4;
		l.FNID 		=  src_map.lanes.data.at(i).fnid;
		l.JCT 		=  src_map.lanes.data.at(i).jct;
		l.LCnt 		=  src_map.lanes.data.at(i).lcnt;
		l.LnID 		=  src_map.lanes.data.at(i).lnid;
		l.Lno 		=  src_map.lanes.data.at(i).lno;
		l.Span 		=  src_map.lanes.data.at(i).span;
		l.RefVel	=  src_map.lanes.data.at(i).refvel;
		l.LimitVel	=  src_map.lanes.data.at(i).limitvel;

//		l.LaneChgFG =  src_map.lanes.at(i).;
//		l.LaneType 	=  src_map.lanes.at(i).blid;
//		l.LimitVel 	=  src_map.lanes.at(i).;
//		l.LinkWAID 	=  src_map.lanes.at(i).blid;
//		l.RefVel 	=  src_map.lanes.at(i).blid;
//		l.RoadSecID =  src_map.lanes.at(i).;

		lanes.push_back(l);
	}

	std::vector&lt;UtilityHNS::AisanPointsFileReader::AisanPoints&gt; points;

	for(unsigned int i=0; i &lt; src_map.points.data.size();i++)
	{
		UtilityHNS::AisanPointsFileReader::AisanPoints p;
		double integ_part = src_map.points.data.at(i).l;
		double deg = trunc(src_map.points.data.at(i).l);
		double min = trunc((src_map.points.data.at(i).l - deg) * 100.0) / 60.0;
		double sec = modf((src_map.points.data.at(i).l - deg) * 100.0, &amp;integ_part)/36.0;
		double L =  deg + min + sec;

		deg = trunc(src_map.points.data.at(i).b);
		min = trunc((src_map.points.data.at(i).b - deg) * 100.0) / 60.0;
		sec = modf((src_map.points.data.at(i).b - deg) * 100.0, &amp;integ_part)/36.0;
		double B =  deg + min + sec;

		p.B 		= B;
		p.Bx 		= src_map.points.data.at(i).bx;
		p.H 		= src_map.points.data.at(i).h;
		p.L 		= L;
		p.Ly 		= src_map.points.data.at(i).ly;
		p.MCODE1 	= src_map.points.data.at(i).mcode1;
		p.MCODE2 	= src_map.points.data.at(i).mcode2;
		p.MCODE3 	= src_map.points.data.at(i).mcode3;
		p.PID 		= src_map.points.data.at(i).pid;
		p.Ref 		= src_map.points.data.at(i).ref;

		points.push_back(p);
	}


	std::vector&lt;UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine&gt; dts;
	for(unsigned int i=0; i &lt; src_map.dtlanes.data.size();i++)
	{
		UtilityHNS::AisanCenterLinesFileReader::AisanCenterLine dt;

		dt.Apara 	= src_map.dtlanes.data.at(i).apara;
		dt.DID 		= src_map.dtlanes.data.at(i).did;
		dt.Dir 		= src_map.dtlanes.data.at(i).dir;
		dt.Dist 	= src_map.dtlanes.data.at(i).dist;
		dt.LW 		= src_map.dtlanes.data.at(i).lw;
		dt.PID 		= src_map.dtlanes.data.at(i).pid;
		dt.RW 		= src_map.dtlanes.data.at(i).rw;
		dt.cant 	= src_map.dtlanes.data.at(i).cant;
		dt.r 		= src_map.dtlanes.data.at(i).r;
		dt.slope 	= src_map.dtlanes.data.at(i).slope;

		dts.push_back(dt);
	}

	std::vector&lt;UtilityHNS::AisanAreasFileReader::AisanArea&gt; areas;
	std::vector&lt;UtilityHNS::AisanIntersectionFileReader::AisanIntersection&gt; inters;
	std::vector&lt;UtilityHNS::AisanLinesFileReader::AisanLine&gt; line_data;
	std::vector&lt;UtilityHNS::AisanStopLineFileReader::AisanStopLine&gt; stop_line_data;
	std::vector&lt;UtilityHNS::AisanSignalFileReader::AisanSignal&gt; signal_data;
	std::vector&lt;UtilityHNS::AisanVectorFileReader::AisanVector&gt; vector_data;
	std::vector&lt;UtilityHNS::AisanDataConnFileReader::DataConn&gt; conn_data;

	PlannerHNS::GPSPoint origin;//(m_OriginPos.position.x, m_OriginPos.position.y, m_OriginPos.position.z, 0);
	PlannerHNS::MappingHelpers::ConstructRoadNetworkFromRosMessage(lanes, points, dts, inters, areas, line_data, stop_line_data, signal_data, vector_data,conn_data, origin, out_map);
}

}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/dp_planner/nodes/dp_planner_core.cpp" new_path="ros/src/computing/planning/motion/packages/dp_planner/nodes/dp_planner_core.cpp">
				<diff>@@ -29,8 +29,6 @@
 #include &quot;dp_planner_core.h&quot;
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
-#include &quot;geo_pos_conv.hh&quot;
-
 
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
 #include &lt;pcl/io/io.h&gt;
@@ -771,7 +769,7 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 	if(msg-&gt;lanes.size() &gt; 0)
 	{
 		m_WayPlannerPaths.clear();
-		bool bOldGlobalPath = m_LocalPlanner.m_TotalPath.size() == msg-&gt;lanes.size();
+		bool bOldGlobalPath = m_LocalPlanner.m_TotalOriginalPath.size() == msg-&gt;lanes.size();
 		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
 		{
 			std::vector&lt;PlannerHNS::WayPoint&gt; path;
@@ -851,7 +849,7 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 
 			if(bOldGlobalPath)
 			{
-				bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(path, m_LocalPlanner.m_TotalPath.at(i));
+				bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(path, m_LocalPlanner.m_TotalOriginalPath.at(i));
 			}
 		}
 
@@ -861,7 +859,7 @@ void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp;
 			bWayPlannerPath = true;
 			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = true;
 			//m_CurrentGoal = m_WayPlannerPaths.at(0).at(m_WayPlannerPaths.at(0).size()-1);
-			m_LocalPlanner.m_TotalPath = m_WayPlannerPaths;
+			m_LocalPlanner.m_TotalOriginalPath = m_WayPlannerPaths;
 
 			cout &lt;&lt; &quot;Global Lanes Size = &quot; &lt;&lt; msg-&gt;lanes.size() &lt;&lt;&quot;, Conv Size= &quot; &lt;&lt; m_WayPlannerPaths.size() &lt;&lt; &quot;, First Lane Size: &quot; &lt;&lt; m_WayPlannerPaths.at(0).size() &lt;&lt; endl;
 
@@ -916,7 +914,7 @@ void PlannerX::PlannerMainLoop()
 		}
 
 		int iDirection = 0;
-		if(bInitPos &amp;&amp; m_LocalPlanner.m_TotalPath.size()&gt;0)
+		if(bInitPos &amp;&amp; m_LocalPlanner.m_TotalOriginalPath.size()&gt;0)
 		{
 //			bool bMakeNewPlan = false;
 //			double drift = hypot(m_LocalPlanner.state.pos.y-m_CurrentPos.pos.y, m_LocalPlanner.state .pos.x-m_CurrentPos.pos.x);
@@ -929,7 +927,8 @@ void PlannerX::PlannerMainLoop()
 			double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(m_PlanningTimer);
 			UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
 
-			m_CurrentBehavior = m_LocalPlanner.DoOneStep(dt, m_VehicleState, m_TrackedClusters, 1, m_Map, m_bEmergencyStop, m_bGreenLight, true);
+			std::vector&lt;PlannerHNS::TrafficLight&gt; trafficLight;
+			m_CurrentBehavior = m_LocalPlanner.DoOneStep(dt, m_VehicleState, m_TrackedClusters, 1, m_Map, m_bEmergencyStop, trafficLight, true);
 
 			visualization_msgs::Marker behavior_rviz;
 
</diff>
				<old_file>/*
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include &quot;dp_planner_core.h&quot;

#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &quot;geo_pos_conv.hh&quot;


#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &quot;UtilityH.h&quot;
#include &quot;MatrixOperations.h&quot;

namespace PlannerXNS
{

PlannerX::PlannerX()
{

	clock_gettime(0, &amp;m_Timer);
	m_counter = 0;
	m_frequency = 0;

	m_nTrackObjects = 0;
	m_nContourPoints = 0;
	m_nOriginalPoints = 0;
	m_TrackingTime = 0;
	bInitPos = false;
	bNewCurrentPos = false;
	bNewClusters = false;
	bNewBoxes = false;
	bVehicleState = false;
	bNewEmergency = false;
	m_bEmergencyStop = 0;
	bNewTrafficLigh = false;
	m_bGreenLight = false; UtilityHNS::UtilityH::GetTickCount(m_TrafficLightTimer);
	bNewOutsideControl = false;
	m_bOutsideControl = 0;
	bNewAStarPath = false;
	UtilityHNS::UtilityH::GetTickCount(m_AStartPlanningTimer);
	bWayPlannerPath = false;
	bKmlMapLoaded = false;
	m_bEnableTracking = true;
	m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 2.0;
	m_ObstacleTracking.m_MAX_TRACKS_AFTER_LOSING = 5;
	m_ObstacleTracking.m_DT = 0.12;
	m_ObstacleTracking.m_bUseCenterOnly = true;

	enablePlannerDynamicSwitch = false;


	int iSource = 0;
	nh.getParam(&quot;/dp_planner/mapSource&quot;, iSource);
	if(iSource == 0)
		m_MapSource = MAP_AUTOWARE;
	else if (iSource == 1)
		m_MapSource = MAP_FOLDER;
	else if(iSource == 2)
		m_MapSource = MAP_KML_FILE;

	nh.getParam(&quot;/dp_planner/mapFileName&quot;, m_KmlMapPath);

	UpdatePlanningParams();

	tf::StampedTransform transform;
	RosHelpers::GetTransformFromTF(&quot;map&quot;, &quot;world&quot;, transform);
	m_OriginPos.position.x  = transform.getOrigin().x();
	m_OriginPos.position.y  = transform.getOrigin().y();
	m_OriginPos.position.z  = transform.getOrigin().z();


	std::string topic_prefix;
	nh.getParam(&quot;/dp_planner/enablePlannerDynamicSwitch&quot;, enablePlannerDynamicSwitch);
	if(enablePlannerDynamicSwitch){
		topic_prefix = &quot;/dp&quot;;
		pub_LocalTrajectoriesRviz_dynamic = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;local_trajectories_dynamic&quot;, 1);
		pub_EnableLattice = nh.advertise&lt;std_msgs::Int32&gt;(&quot;enableLattice&quot;, 1);
	}

	pub_LocalPath = nh.advertise&lt;autoware_msgs::lane&gt;(topic_prefix + &quot;/final_waypoints&quot;, 100,true);
	pub_LocalBasePath = nh.advertise&lt;autoware_msgs::lane&gt;(topic_prefix + &quot;/base_waypoints&quot;, 100,true);
	pub_ClosestIndex = nh.advertise&lt;std_msgs::Int32&gt;(topic_prefix + &quot;/closest_waypoint&quot;, 100,true);

	pub_BehaviorState = nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;current_behavior&quot;, 1);
	pub_GlobalPlanNodes = nh.advertise&lt;geometry_msgs::PoseArray&gt;(&quot;global_plan_nodes&quot;, 1);
	pub_StartPoint = nh.advertise&lt;geometry_msgs::PoseWithCovarianceStamped&gt;(&quot;GlobalStartpose&quot;, 1);
	pub_GoalPoint = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;GlobalGoalPose&quot;, 1);
	pub_AStarStartPoint = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;global_plan_start&quot;, 1);
	pub_AStarGoalPoint = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;global_plan_goal&quot;, 1);

	pub_DetectedPolygonsRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;detected_polygons&quot;, 1, true);
	pub_TrackedObstaclesRviz = nh.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;dp_planner_tracked_boxes&quot;, 1);
	pub_LocalTrajectoriesRviz = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;local_trajectories&quot;, 1);
	
	pub_TestLineRviz	= nh.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;testing_line&quot;, 1);
	pub_BehaviorStateRviz = nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;behavior_state&quot;, 1);
	pub_SafetyBorderRviz  = nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;safety_border&quot;, 1);
	pub_cluster_cloud = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;simu_points_cluster&quot;,1);
	pub_SimuBoxPose	  = nh.advertise&lt;geometry_msgs::PoseArray&gt;(&quot;sim_box_pose_ego&quot;, 100);


	sub_initialpose 	= nh.subscribe(&quot;/initialpose&quot;, 				1,		&amp;PlannerX::callbackGetInitPose, 		this);
	sub_current_pose 	= nh.subscribe(&quot;/current_pose&quot;, 			1,		&amp;PlannerX::callbackGetCurrentPose, 		this);
	sub_cluster_cloud 	= nh.subscribe(&quot;/cloud_clusters&quot;,			1,		&amp;PlannerX::callbackGetCloudClusters, 	this);
	sub_bounding_boxs  	= nh.subscribe(&quot;/bounding_boxes&quot;,			1,		&amp;PlannerX::callbackGetBoundingBoxes, 	this);
	sub_WayPlannerPaths = nh.subscribe(&quot;/realtime_cost_map&quot;,		1,		&amp;PlannerX::callbackGetCostMap, 	this);

#ifdef DATASET_GENERATION_BLOCK

	m_iRecordNumber = 0;
//	tf::StampedTransform base_transform;
//	int nFailedCounter = 0;
//	while (1)
//	{
//		try
//		{
//			m_Transformation.lookupTransform(&quot;base_link&quot;, &quot;world&quot;, ros::Time(0), base_transform);
//			break;
//		}
//		catch (tf::TransformException&amp; ex)
//		{
//			if(nFailedCounter &gt; 2)
//			{
//				ROS_ERROR(&quot;%s&quot;, ex.what());
//			}
//			ros::Duration(1.0).sleep();
//			nFailedCounter ++;
//		}
//	}

	m_ImagesVectors.open(&quot;/home/user/data/db/input.csv&quot;);
	m_TrajVectors.open(&quot;/home/user/data/db/output.csv&quot;);

	sub_image_reader = nh.subscribe(&quot;/image_raw&quot;, 1, &amp;PlannerX::callbackReadImage, 		this);
#endif

	/**
	 * @todo This works only in simulation (Autoware or ff_Waypoint_follower), twist_cmd should be changed, consult team
	 */
	int bVelSource = 1;
	nh.getParam(&quot;/dp_planner/enableOdometryStatus&quot;, bVelSource);
	if(bVelSource == 0)
		sub_robot_odom 			= nh.subscribe(&quot;/odom&quot;, 					100,	&amp;PlannerX::callbackGetRobotOdom, 	this);
	else if(bVelSource == 1)
		sub_current_velocity 	= nh.subscribe(&quot;/current_velocity&quot;,		100,	&amp;PlannerX::callbackGetVehicleStatus, 	this);
	else if(bVelSource == 2)
		sub_can_info 			= nh.subscribe(&quot;/can_info&quot;,		100,	&amp;PlannerX::callbackGetCanInfo, 	this);



	sub_EmergencyStop 	= nh.subscribe(&quot;/emergency_stop_signal&quot;, 	100,	&amp;PlannerX::callbackGetEmergencyStop, 	this);
	sub_TrafficLight 	= nh.subscribe(&quot;/traffic_signal_info&quot;, 		10,		&amp;PlannerX::callbackGetTrafficLight, 	this);

	if(m_bEnableOutsideControl)
		sub_OutsideControl 	= nh.subscribe(&quot;/usb_controller_r_signal&quot;, 	10,		&amp;PlannerX::callbackGetOutsideControl, 	this);
	else
		m_bOutsideControl = 1;

	sub_AStarPath 		= nh.subscribe(&quot;/astar_path&quot;, 				10,		&amp;PlannerX::callbackGetAStarPath, 		this);
	sub_WayPlannerPaths = nh.subscribe(&quot;/lane_waypoints_array&quot;, 	1,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);

	if(m_MapSource == MAP_AUTOWARE)
	{
		sub_map_points 	= nh.subscribe(&quot;/vector_map_info/point&quot;, 		1, &amp;PlannerX::callbackGetVMPoints, 		this);
		sub_map_lanes 	= nh.subscribe(&quot;/vector_map_info/lane&quot;, 		1, &amp;PlannerX::callbackGetVMLanes, 		this);
		sub_map_nodes 	= nh.subscribe(&quot;/vector_map_info/node&quot;, 		1, &amp;PlannerX::callbackGetVMNodes, 		this);
		sup_stop_lines 	= nh.subscribe(&quot;/vector_map_info/stop_line&quot;,	1, &amp;PlannerX::callbackGetVMStopLines, 	this);
		sub_dtlanes 	= nh.subscribe(&quot;/vector_map_info/dtlane&quot;, 		1, &amp;PlannerX::callbackGetVMCenterLines,	this);
	}

	sub_simulated_obstacle_pose_rviz = nh.subscribe(&quot;/clicked_point&quot;, 		1, &amp;PlannerX::callbackGetRvizPoint,	this);
}

PlannerX::~PlannerX()
{
#ifdef OPENPLANNER_ENABLE_LOGS
	UtilityHNS::DataRW::WriteLogData(UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::StatesLogFolderName, &quot;MainLog&quot;,
			&quot;time,dt,Behavior State,behavior,num_Tracked_Objects,num_Cluster_Points,num_Contour_Points,t_Tracking,t_Calc_Cost, t_Behavior_Gen, t_Roll_Out_Gen, num_RollOuts, Full_Block, idx_Central_traj, iTrajectory, Stop Sign, Traffic Light, Min_Stop_Distance, follow_distance, follow_velocity, Velocity, Steering, X, Y, Z, heading,&quot;
			, m_LogData);
#endif

#ifdef DATASET_GENERATION_BLOCK
	m_ImagesVectors.close();
	m_TrajVectors.close();
#endif
}

#ifdef DATASET_GENERATION_BLOCK
void PlannerX::callbackReadImage(const sensor_msgs::ImageConstPtr&amp; img)
{
	//std::cout &lt;&lt; &quot;Reading Image Data ... &quot; &lt;&lt; std::endl;
	cv_bridge::CvImagePtr cv_image = cv_bridge::toCvCopy(img, sensor_msgs::image_encodings::BGR8);
	m_CurrImage = cv_image-&gt;image;

}

void PlannerX::ExtractPathFromDriveData(double max_extraction)
{
	double d = 0;
	DataPairs dp;

	for(int i = m_DrivePoints.size()-1; i &gt;= 0 ; i--)
	{
		d += m_DrivePoints.at(i).currentPos.cost;

		if(d &gt;= 30)
		{
			dp.image =  m_DrivePoints.at(i).image.clone();
			dp.currentPos =  m_DrivePoints.at(i).currentPos;
			dp.vehicleState = m_DrivePoints.at(i).vehicleState;
			cv::Mat gray_image;
			cvtColor( dp.image, gray_image, cv::COLOR_BGR2GRAY);
			cv::Rect roi;
			roi.x = 0;
			roi.y = gray_image.rows/3;
			roi.width = gray_image.cols;
			roi.height = gray_image.rows - gray_image.rows/3;
			cv::Mat halfImg = gray_image(roi);

			std::ostringstream image_name;
			image_name &lt;&lt; &quot;/home/user/data/db/vis/image_&quot; &lt;&lt; m_iRecordNumber &lt;&lt; &quot;.png&quot;;
			std::ostringstream half_image_name;
			half_image_name &lt;&lt;  &quot;/home/user/data/db/img/img_&quot;  &lt;&lt; m_iRecordNumber &lt;&lt; &quot;.png&quot;;
			std::ostringstream label_name ;
			label_name &lt;&lt; &quot;/home/user/data/db/csv/lbl_&quot; &lt;&lt; m_iRecordNumber &lt;&lt; &quot;.csv&quot;;


			PlannerHNS::Mat3 rotationMat(-dp.currentPos.pos.a);
			PlannerHNS::Mat3 translationMat(-dp.currentPos.pos.x, -dp.currentPos.pos.y);
			for(unsigned int ip=0; ip &lt; dp.path.size(); ip++)
			{
				dp.path.at(ip).pos = translationMat*dp.path.at(ip).pos;
				dp.path.at(ip).pos = rotationMat*dp.path.at(ip).pos;
			}

			PlannerHNS::PlanningHelpers::SmoothPath(dp.path, 0.45, 0.3, 0.01);
			PlannerHNS::PlanningHelpers::FixPathDensity(dp.path, d/20.0);
			PlannerHNS::PlanningHelpers::SmoothPath(dp.path, 0.45, 0.35, 0.01);

			for(unsigned int ip=0; ip &lt;dp.path.size()-1; ip++)
			{
				cv::Point p1;
				p1.y = dp.image.rows - (fabs(dp.path.at(ip).pos.x) *  halfImg.rows  / 40.0);
				p1.x = halfImg.cols/2 + (-dp.path.at(ip).pos.y * halfImg.cols / 20.0);

				cv::Point p2;
				p2.y = dp.image.rows - (fabs(dp.path.at(ip+1).pos.x) *  halfImg.rows  / 40.0);
				p2.x = halfImg.cols/2 + (-dp.path.at(ip+1).pos.y * halfImg.cols / 20.0);

				cv::line(dp.image, p1, p2,  cv::Scalar( 0, 255, 0 ), 2, 8);
			}

			WritePathCSV(label_name.str(), dp.path);
			imwrite(image_name.str(),  dp.image);
			imwrite(half_image_name.str(),  halfImg);

			WriteImageAndPathCSV(halfImg.clone(), dp.path);

			for(int j = 0; j &lt;= i; j++)
				if(m_DrivePoints.size() &gt; 0)
					m_DrivePoints.erase(m_DrivePoints.begin()+0);

			m_iRecordNumber++;
			std::cout &lt;&lt; &quot;Extract Data: &quot; &lt;&lt; &quot;Cost: &quot; &lt;&lt; d &lt;&lt; &quot;, Index: &quot; &lt;&lt; i &lt;&lt; &quot;, Path Size: &quot; &lt;&lt; dp.path.size() &lt;&lt; std::endl;
			return;
		}

		dp.path.insert(dp.path.begin(), m_DrivePoints.at(i).currentPos);
	}
}

void PlannerX::WriteImageAndPathCSV(cv::Mat img,std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
{
	if(m_ImagesVectors.is_open())
	{
		ostringstream str_img;
		str_img.precision(0);
		for(int c=0; c&lt;img.cols; c++)
		{
			for(int r=0; r&lt;img.rows; r++)
			{
				short x = img.at&lt;uchar&gt;(r, c);
				str_img &lt;&lt; x &lt;&lt; ',';
			}
		}

		m_ImagesVectors &lt;&lt; str_img.str() &lt;&lt; &quot;\r\n&quot;;
	}

	if(m_TrajVectors.is_open())
	{
		ostringstream strwp;
		 for(unsigned int i=0; i&lt;path.size(); i++)
		 {
			 strwp &lt;&lt; path.at(i).pos.x&lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).pos.y &lt;&lt; &quot;,&quot;;
		 }
		m_TrajVectors &lt;&lt; strwp.str() &lt;&lt; &quot;\r\n&quot;;
	}
}

void PlannerX::WritePathCSV(const std::string&amp; fName, std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
{
	vector&lt;string&gt; dataList;
	 for(unsigned int i=0; i&lt;path.size(); i++)
	 {
		 ostringstream strwp;
		 strwp &lt;&lt; path.at(i).pos.x&lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).pos.y &lt;&lt;&quot;,&quot;&lt;&lt; path.at(i).v &lt;&lt; &quot;,&quot;;
		 dataList.push_back(strwp.str());
	 }

	 std::ofstream f(fName.c_str());

	if(f.is_open())
	{
		for(unsigned int i = 0 ; i &lt; dataList.size(); i++)
			f &lt;&lt; dataList.at(i) &lt;&lt; &quot;\r\n&quot;;
	}

	f.close();
}

#endif

void PlannerX::callbackGetVMPoints(const vector_map_msgs::PointArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Points&quot;);
	m_AwMap.points = msg;
	m_AwMap.bPoints = true;
}

void PlannerX::callbackGetVMLanes(const vector_map_msgs::LaneArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Lane Array&quot;);
	m_AwMap.lanes = msg;
	m_AwMap.bLanes = true;
}

void PlannerX::callbackGetVMNodes(const vector_map_msgs::NodeArray&amp; msg)
{
}

void PlannerX::callbackGetVMStopLines(const vector_map_msgs::StopLineArray&amp; msg)
{
}

void PlannerX::callbackGetVMCenterLines(const vector_map_msgs::DTLaneArray&amp; msg)
{
	ROS_INFO(&quot;Received Map Center Lines&quot;);
	m_AwMap.dtlanes = msg;
	m_AwMap.bDtLanes = true;
}

void PlannerX::UpdatePlanningParams()
{
	PlannerHNS::PlanningParams params;

	nh.getParam(&quot;/dp_planner/enableSwerving&quot;, params.enableSwerving);
	if(params.enableSwerving)
		params.enableFollowing = true;
	else
		nh.getParam(&quot;/dp_planner/enableFollowing&quot;, params.enableFollowing);

	nh.getParam(&quot;/dp_planner/enableHeadingSmoothing&quot;, params.enableHeadingSmoothing);
	nh.getParam(&quot;/dp_planner/enableTrafficLightBehavior&quot;, params.enableTrafficLightBehavior);
	nh.getParam(&quot;/dp_planner/enableStopSignBehavior&quot;, params.enableStopSignBehavior);

	nh.getParam(&quot;/dp_planner/maxVelocity&quot;, params.maxSpeed);
	nh.getParam(&quot;/dp_planner/minVelocity&quot;, params.minSpeed);
	nh.getParam(&quot;/dp_planner/maxLocalPlanDistance&quot;, params.microPlanDistance);
	nh.getParam(&quot;/dp_planner/samplingTipMargin&quot;, params.carTipMargin);
	nh.getParam(&quot;/dp_planner/samplingOutMargin&quot;, params.rollInMargin);
	nh.getParam(&quot;/dp_planner/samplingSpeedFactor&quot;, params.rollInSpeedFactor);

	nh.getParam(&quot;/dp_planner/pathDensity&quot;, params.pathDensity);
	nh.getParam(&quot;/dp_planner/rollOutDensity&quot;, params.rollOutDensity);
	if(params.enableSwerving)
		nh.getParam(&quot;/dp_planner/rollOutsNumber&quot;, params.rollOutNumber);
	else
		params.rollOutNumber = 0;

	nh.getParam(&quot;/dp_planner/horizonDistance&quot;, params.horizonDistance);
	nh.getParam(&quot;/dp_planner/minFollowingDistance&quot;, params.minFollowingDistance);
	nh.getParam(&quot;/dp_planner/minDistanceToAvoid&quot;, params.minDistanceToAvoid);
	nh.getParam(&quot;/dp_planner/maxDistanceToAvoid&quot;, params.maxDistanceToAvoid);
	nh.getParam(&quot;/dp_planner/speedProfileFactor&quot;, params.speedProfileFactor);

	nh.getParam(&quot;/dp_planner/horizontalSafetyDistance&quot;, params.horizontalSafetyDistancel);
	nh.getParam(&quot;/dp_planner/verticalSafetyDistance&quot;, params.verticalSafetyDistance);

	nh.getParam(&quot;/dp_planner/enableLaneChange&quot;, params.enableLaneChange);
	nh.getParam(&quot;/dp_planner/enabTrajectoryVelocities&quot;, params.enabTrajectoryVelocities);

	nh.getParam(&quot;/dp_planner/enableObjectTracking&quot;, m_bEnableTracking);
	nh.getParam(&quot;/dp_planner/enableOutsideControl&quot;, m_bEnableOutsideControl);


	PlannerHNS::ControllerParams controlParams;
	controlParams.Steering_Gain = PlannerHNS::PID_CONST(0.07, 0.02, 0.01);
	controlParams.Velocity_Gain = PlannerHNS::PID_CONST(0.1, 0.005, 0.1);
	nh.getParam(&quot;/dp_planner/steeringDelay&quot;, controlParams.SteeringDelay);
	nh.getParam(&quot;/dp_planner/minPursuiteDistance&quot;, controlParams.minPursuiteDistance );

	PlannerHNS::CAR_BASIC_INFO vehicleInfo;

	nh.getParam(&quot;/dp_planner/width&quot;, vehicleInfo.width);
	nh.getParam(&quot;/dp_planner/length&quot;, vehicleInfo.length);
	nh.getParam(&quot;/dp_planner/wheelBaseLength&quot;, vehicleInfo.wheel_base);
	nh.getParam(&quot;/dp_planner/turningRadius&quot;, vehicleInfo.turning_radius);
	nh.getParam(&quot;/dp_planner/maxSteerAngle&quot;, vehicleInfo.max_steer_angle);
	vehicleInfo.max_speed_forward = params.maxSpeed;
	vehicleInfo.min_speed_forward = params.minSpeed;

	m_LocalPlanner.m_SimulationSteeringDelayFactor = controlParams.SimulationSteeringDelay;
	m_LocalPlanner.Init(controlParams, params, vehicleInfo);
	m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_Behavior = PlannerHNS::INITIAL_STATE;

}

void PlannerX::callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg)
{
	if(!bInitPos)
	{
		PlannerHNS::WayPoint p;
		ROS_INFO(&quot;init Simulation Rviz Pose Data: x=%f, y=%f, z=%f, freq=%d&quot;, msg-&gt;pose.pose.position.x, msg-&gt;pose.pose.position.y, msg-&gt;pose.pose.position.z, m_frequency);
		m_InitPos = PlannerHNS::WayPoint(msg-&gt;pose.pose.position.x+m_OriginPos.position.x,
				msg-&gt;pose.pose.position.y+m_OriginPos.position.y,
				msg-&gt;pose.pose.position.z+m_OriginPos.position.z,
				tf::getYaw(msg-&gt;pose.pose.orientation));
		m_CurrentPos = m_InitPos;
		bInitPos = true;
	}
}

void PlannerX::callbackGetCostMap(const nav_msgs::OccupancyGrid&amp; msg)
{
}

void PlannerX::callbackGetRvizPoint(const geometry_msgs::PointStampedConstPtr&amp; msg)
{
	//Add Simulated Obstacle polygon
	timespec t;
	UtilityHNS::UtilityH::GetTickCount(t);
	srand(t.tv_nsec);
	double width = SIMU_OBSTACLE_WIDTH;//((double)(rand()%10)/10.0) * 1.5 + 0.25;
	double length = SIMU_OBSTACLE_LENGTH;//((double)(rand()%10)/10.0) * 0.5 + 0.25;
	double height = SIMU_OBSTACLE_HEIGHT;

	geometry_msgs::PointStamped point;
	point.point.x = msg-&gt;point.x+m_OriginPos.position.x;
	point.point.y = msg-&gt;point.y+m_OriginPos.position.y;
	point.point.z = msg-&gt;point.z+m_OriginPos.position.z;

	autoware_msgs::CloudClusterArray clusters_array;
	clusters_array.clusters.push_back(GenerateSimulatedObstacleCluster(width, length, height, 50, point));
	m_OriginalClusters.clear();
	int nNum1, nNum2;
	RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_LocalPlanner.m_CarInfo, clusters_array, m_OriginalClusters, nNum1, nNum2);
	m_TrackedClusters = m_OriginalClusters;

	pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
	pcl::fromROSMsg(clusters_array.clusters.at(0).cloud, point_cloud);
	sensor_msgs::PointCloud2 cloud_msg;
	pcl::toROSMsg(point_cloud, cloud_msg);
	cloud_msg.header.frame_id = &quot;map&quot;;
	pub_cluster_cloud.publish(cloud_msg);

	if(m_TrackedClusters.size()&gt;0)
	{
		jsk_recognition_msgs::BoundingBoxArray boxes_array;
		boxes_array.header.frame_id = &quot;map&quot;;
		boxes_array.header.stamp  = ros::Time();
		jsk_recognition_msgs::BoundingBox box;
		box.header.frame_id = &quot;map&quot;;
		box.header.stamp = ros::Time();
		box.pose.position.x = m_TrackedClusters.at(0).center.pos.x;
		box.pose.position.y = m_TrackedClusters.at(0).center.pos.y;
		box.pose.position.z = m_TrackedClusters.at(0).center.pos.z;

		box.value = 0.9;

		//box.pose.orientation = detectedPolygons.markers.at(0)
		box.dimensions.x = SIMU_OBSTACLE_WIDTH;
		box.dimensions.y = SIMU_OBSTACLE_LENGTH;
		box.dimensions.z = SIMU_OBSTACLE_HEIGHT;
		boxes_array.boxes.push_back(box);

		pub_TrackedObstaclesRviz.publish(boxes_array);
	}

//	if(m_LocalPlanner.m_TotalPath.size() &gt; 0)
//	{
//		vector&lt;PlannerHNS::WayPoint&gt; line;
//		PlannerHNS::WayPoint p1(msg-&gt;point.x+m_OriginPos.position.x, msg-&gt;point.y+m_OriginPos.position.y, msg-&gt;point.z+m_OriginPos.position.z, 0);
//
//		//int index = PlannerHNS::PlanningHelpers::GetClosestNextPointIndex(m_LocalPlanner.m_TotalPath.at(0), p1);
////		PlannerHNS::WayPoint p_prev = m_LocalPlanner.m_TotalPath.at(0).at(index);
////		if(index &gt; 0)
////			p_prev = m_LocalPlanner.m_TotalPath.at(0).at(index-1);
////
////
////		double distance = 0;
////		PlannerHNS::WayPoint p2 = PlannerHNS::PlanningHelpers::GetPerpendicularOnTrajectory(m_LocalPlanner.m_TotalPath.at(0), p1, distance);
////
////		double perpDistance = PlannerHNS::PlanningHelpers::GetPerpDistanceToTrajectorySimple(m_LocalPlanner.m_TotalPath.at(0), p1);
////
////		double back_distance = hypot(p2.pos.y - p_prev.pos.y, p2.pos.x - p_prev.pos.x);
////		double direct_distance = hypot(p2.pos.y - p1.pos.y, p2.pos.x - p1.pos.x);
//
//
//		PlannerHNS::RelativeInfo info;
//		bool ret = PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_TotalPath.at(0), p1, info);
//		PlannerHNS::WayPoint p_prev = m_LocalPlanner.m_TotalPath.at(0).at(info.iBack);
//
//		std::cout &lt;&lt; &quot;Perp D: &quot; &lt;&lt; info.perp_distance &lt;&lt; &quot;, F D: &quot;&lt;&lt; info.to_front_distance &lt;&lt; &quot;, B D: &quot; &lt;&lt; info.from_back_distance &lt;&lt; &quot;, F Index: &quot;&lt;&lt; info.iFront &lt;&lt; &quot;, B Index: &quot; &lt;&lt; info.iBack &lt;&lt; &quot;, Size: &quot;&lt;&lt; m_LocalPlanner.m_TotalPath.at(0).size() &lt;&lt; std::endl;
//
//		line.push_back(p1);
//		line.push_back(info.perp_point);
//		line.push_back(p_prev);
//
//		std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; lines;
//		lines.push_back(line);
//		visualization_msgs::MarkerArray line_vis;
//		RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(lines, line_vis);
//		pub_TestLineRviz.publish(line_vis);
//	}
}

void PlannerX::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg)
{
	m_counter++;
	double dt = UtilityHNS::UtilityH::GetTimeDiffNow(m_Timer);
	if(dt &gt;= 1.0)
	{
		m_frequency = m_counter;
		m_counter = 0;
		clock_gettime(0, &amp;m_Timer);
	}

	m_CurrentPos = PlannerHNS::WayPoint(msg-&gt;pose.position.x, msg-&gt;pose.position.y,
					msg-&gt;pose.position.z, tf::getYaw(msg-&gt;pose.orientation));

	m_InitPos = m_CurrentPos;

	bNewCurrentPos = true;
	bInitPos = true;
#ifdef DATASET_GENERATION_BLOCK

	PlannerHNS::WayPoint p(m_CurrentPos.pos.x, m_CurrentPos.pos.y, 0, m_CurrentPos.pos.a);
	p.v = m_VehicleState.speed;

	DataPairs dp;
	if(m_DrivePoints.size() == 0)
	{
		dp.image = m_CurrImage;
		dp.currentPos = p;
		dp.vehicleState = m_VehicleState;
		m_DrivePoints.push_back(dp);
	}
	else
	{
		p.cost = hypot(p.pos.y - m_DrivePoints.at(m_DrivePoints.size()-1).currentPos.pos.y, p.pos.x - m_DrivePoints.at(m_DrivePoints.size()-1).currentPos.pos.x);
		if(p.cost &gt;= 0.25 &amp;&amp; p.cost &lt;= 3.0)
		{
			dp.image = m_CurrImage;
			dp.currentPos = p;
			dp.vehicleState = m_VehicleState;
			m_DrivePoints.push_back(dp);
			//std::cout &lt;&lt; &quot;Insert Pose: &quot; &lt;&lt; &quot;Cost: &quot; &lt;&lt; p.cost &lt;&lt; &quot;, Speed: &quot; &lt;&lt; p.v &lt;&lt; &quot;, Size: &quot; &lt;&lt; m_DrivePoints.size() &lt;&lt; std::endl;
		}
		else
		{
			//std::cout &lt;&lt; &quot;Miss Pose: &quot; &lt;&lt; &quot;Cost: &quot; &lt;&lt; p.cost &lt;&lt; &quot;, Speed: &quot; &lt;&lt; p.v &lt;&lt; &quot;, Size: &quot; &lt;&lt; m_DrivePoints.size() &lt;&lt; std::endl;
			if(m_DrivePoints.size() == 1)
				m_DrivePoints.clear();
		}
	}


	if(m_DrivePoints.size() &gt;= 20)
		ExtractPathFromDriveData();

#endif
}

autoware_msgs::CloudCluster PlannerX::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::PointStamped&amp; centerPose)
{
	autoware_msgs::CloudCluster cluster;
	cluster.centroid_point.point = centerPose.point;
	cluster.dimensions.x = x_rand;
	cluster.dimensions.y = y_rand;
	cluster.dimensions.z = z_rand;
	pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;

	timespec t;
	for(int i=1; i &lt; nPoints; i++)
	{
		UtilityHNS::UtilityH::GetTickCount(t);
		pcl::PointXYZ p;
		srand(t.tv_nsec/i);
		double x = (double)(rand()%100)/100.0 - 0.5;

		srand(t.tv_nsec/i*i);
		double y = (double)(rand()%100)/100.0 - 0.5;

		srand(t.tv_nsec);
		double z = (double)(rand()%100)/100.0 - 0.5;

		p.x = centerPose.point.x + x*x_rand;
		p.y = centerPose.point.y + y*y_rand;
		p.z = centerPose.point.z + z*z_rand;
		point_cloud.points.push_back(p);
	}

	pcl::toROSMsg(point_cloud, cluster.cloud);

	return cluster;
}

void PlannerX::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg)
{
	timespec timerTemp;
	UtilityHNS::UtilityH::GetTickCount(timerTemp);

	m_OriginalClusters.clear();
	RosHelpers::ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_CurrentPos, m_LocalPlanner.m_CarInfo, *msg, m_OriginalClusters, m_nOriginalPoints, m_nContourPoints);
	if(m_bEnableTracking)
	{
		m_ObstacleTracking.DoOneStep(m_CurrentPos, m_OriginalClusters);
		m_TrackedClusters = m_ObstacleTracking.m_DetectedObjects;
	}
	else
		m_TrackedClusters = m_OriginalClusters;

	m_nTrackObjects = m_TrackedClusters.size();
	m_TrackingTime = UtilityHNS::UtilityH::GetTimeDiffNow(timerTemp);
	bNewClusters = true;
}

void PlannerX::callbackGetBoundingBoxes(const jsk_recognition_msgs::BoundingBoxArrayConstPtr&amp; msg)
{
//	std::cout &lt;&lt; &quot; Number of Detected Boxes =&quot; &lt;&lt; msg-&gt;boxes.size() &lt;&lt; std::endl;
//	RosHelpers::ConvertFromAutowareBoundingBoxObstaclesToPlannerH(*msg, m_DetectedBoxes);
//	bNewBoxes = true;
}

void PlannerX::callbackGetVehicleStatus(const geometry_msgs::TwistStampedConstPtr&amp; msg)
{
	m_VehicleState.speed = msg-&gt;twist.linear.x;

	if(msg-&gt;twist.linear.x != 0)
		m_VehicleState.steer = atan(m_LocalPlanner.m_CarInfo.wheel_base * msg-&gt;twist.angular.z/msg-&gt;twist.linear.x);

	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);

	// If steering is in angular velocity
	//m_VehicleState.steer = atan(m_State.m_CarInfo.wheel_base * msg-&gt;twist.angular.z/msg-&gt;twist.linear.x);
//	if(msg-&gt;vector.z == 0x00)
//		m_VehicleState.shift = AW_SHIFT_POS_BB;
//	else if(msg-&gt;vector.z == 0x10)
//		m_VehicleState.shift = AW_SHIFT_POS_DD;
//	else if(msg-&gt;vector.z == 0x20)
//		m_VehicleState.shift = AW_SHIFT_POS_NN;
//	else if(msg-&gt;vector.z == 0x40)
//		m_VehicleState.shift = AW_SHIFT_POS_RR;

	//std::cout &lt;&lt; &quot;PlannerX: Read Status Twist_cmd (&quot;&lt;&lt; m_VehicleState.speed &lt;&lt; &quot;, &quot; &lt;&lt; m_VehicleState.steer&lt;&lt;&quot;)&quot; &lt;&lt; std::endl;
}

void PlannerX::callbackGetCanInfo(const autoware_msgs::CanInfoConstPtr &amp;msg)
{
	m_VehicleState.speed = msg-&gt;speed/3.6;
	m_VehicleState.steer = msg-&gt;angle * m_LocalPlanner.m_CarInfo.max_steer_angle / m_LocalPlanner.m_CarInfo.max_steer_value;
	std::cout &lt;&lt; &quot;Can Info, Speed: &quot;&lt;&lt; m_VehicleState.speed &lt;&lt; &quot;, Steering: &quot; &lt;&lt; m_VehicleState.steer  &lt;&lt; std::endl;
}

void PlannerX::callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg)
{
	m_VehicleState.speed = msg-&gt;twist.twist.linear.x;
	m_VehicleState.steer += atan(m_LocalPlanner.m_CarInfo.wheel_base * msg-&gt;twist.twist.angular.z/msg-&gt;twist.twist.linear.x);

	UtilityHNS::UtilityH::GetTickCount(m_VehicleState.tStamp);
//	if(msg-&gt;vector.z == 0x00)
//		m_VehicleState.shift = AW_SHIFT_POS_BB;
//	else if(msg-&gt;vector.z == 0x10)
//		m_VehicleState.shift = AW_SHIFT_POS_DD;
//	else if(msg-&gt;vector.z == 0x20)
//		m_VehicleState.shift = AW_SHIFT_POS_NN;
//	else if(msg-&gt;vector.z == 0x40)
//		m_VehicleState.shift = AW_SHIFT_POS_RR;

	//std::cout &lt;&lt; &quot;PlannerX: Read Odometry (&quot;&lt;&lt; m_VehicleState.speed &lt;&lt; &quot;, &quot; &lt;&lt; m_VehicleState.steer&lt;&lt;&quot;)&quot; &lt;&lt; std::endl;
}

void PlannerX::callbackGetEmergencyStop(const std_msgs::Int8&amp; msg)
{
	//std::cout &lt;&lt; &quot;Received Emergency Stop : &quot; &lt;&lt; msg.data &lt;&lt; std::endl;
	bNewEmergency  = true;
	m_bEmergencyStop = msg.data;
}

void PlannerX::callbackGetTrafficLight(const std_msgs::Int8&amp; msg)
{
	std::cout &lt;&lt; &quot;Received Traffic Light : &quot; &lt;&lt; msg.data &lt;&lt; std::endl;
	bNewTrafficLigh = true;
	if(msg.data == 2)
		m_bGreenLight = true;
	else
		m_bGreenLight = false;
}

void PlannerX::callbackGetOutsideControl(const std_msgs::Int8&amp; msg)
{
	std::cout &lt;&lt; &quot;Received Outside Control : &quot; &lt;&lt; msg.data &lt;&lt; std::endl;
	bNewOutsideControl = true;
	m_bOutsideControl  = msg.data;
}

void PlannerX::callbackGetAStarPath(const autoware_msgs::LaneArrayConstPtr&amp; msg)
{
	if(msg-&gt;lanes.size() &gt; 0)
	{
		m_AStarPath.clear();
		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
		{
			for(unsigned int j = 0 ; j &lt; msg-&gt;lanes.at(i).waypoints.size(); j++)
			{
				PlannerHNS::WayPoint wp(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.x,
						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.y,
						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.z,
						tf::getYaw(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.orientation));
				wp.v = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.x;
				//wp.bDir = msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir;
				m_AStarPath.push_back(wp);
			}
		}
		bNewAStarPath = true;
		m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bRePlan = true;
	}
}

void PlannerX::callbackGetWayPlannerPath(const autoware_msgs::LaneArrayConstPtr&amp; msg)
{
	if(msg-&gt;lanes.size() &gt; 0)
	{
		m_WayPlannerPaths.clear();
		bool bOldGlobalPath = m_LocalPlanner.m_TotalPath.size() == msg-&gt;lanes.size();
		for(unsigned int i = 0 ; i &lt; msg-&gt;lanes.size(); i++)
		{
			std::vector&lt;PlannerHNS::WayPoint&gt; path;
			PlannerHNS::Lane* pPrevValid = 0;
			for(unsigned int j = 0 ; j &lt; msg-&gt;lanes.at(i).waypoints.size(); j++)
			{
				PlannerHNS::WayPoint wp(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.x,
						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.y,
						msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.position.z,
						tf::getYaw(msg-&gt;lanes.at(i).waypoints.at(j).pose.pose.orientation));
				wp.v = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.x;
				wp.laneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.y;
				wp.stopLineID = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.linear.z;
				wp.laneChangeCost = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.x;
				wp.LeftLaneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.y;
				wp.RightLaneId = msg-&gt;lanes.at(i).waypoints.at(j).twist.twist.angular.z;

				if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 0)
					wp.bDir = PlannerHNS::FORWARD_DIR;
				else if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 1)
					wp.bDir = PlannerHNS::FORWARD_LEFT_DIR;
				else if(msg-&gt;lanes.at(i).waypoints.at(j).dtlane.dir == 2)
					wp.bDir = PlannerHNS::FORWARD_RIGHT_DIR;

				PlannerHNS::Lane* pLane = 0;
				pLane = PlannerHNS::MappingHelpers::GetLaneById(wp.laneId, m_Map);
				if(!pLane)
				{
					pLane = PlannerHNS::MappingHelpers::GetClosestLaneFromMapDirectionBased(wp, m_Map, 1);

					if(!pLane &amp;&amp; !pPrevValid)
					{
						ROS_ERROR(&quot;Map inconsistency between Global Path add Lal Planer, Can't identify current lane.&quot;);
						return;
					}

					if(!pLane)
						wp.pLane = pPrevValid;
					else
					{
						wp.pLane = pLane;
						pPrevValid = pLane ;
					}

					wp.laneId = wp.pLane-&gt;id;
				}
				else
					wp.pLane = pLane;

				path.push_back(wp);
			}

			PlannerHNS::PlanningHelpers::CalcAngleAndCost(path);

//			int prevStopID = -1;
//			for(unsigned int k= 0; k &lt; path.size(); k++)
//			{
//				if(path.at(k).pLane)
//				{
//					for(unsigned int si = 0; si &lt; path.at(k).pLane-&gt;stopLines.size(); si++)
//					{
//						if(prevStopID != path.at(k).pLane-&gt;stopLines.at(si).id)
//						{
//							PlannerHNS::WayPoint stopLineWP;
//							stopLineWP.pos = path.at(k).pLane-&gt;stopLines.at(si).points.at(0);
//							PlannerHNS::RelativeInfo info;
//							PlannerHNS::PlanningHelpers::GetRelativeInfo(path, stopLineWP, info, k);
//
//							path.at(info.iFront).stopLineID = path.at(k).pLane-&gt;stopLines.at(si).id;
//							prevStopID = path.at(info.iFront).stopLineID;
//						}
//					}
//				}
//			}

			m_WayPlannerPaths.push_back(path);

			if(bOldGlobalPath)
			{
				bOldGlobalPath = PlannerHNS::PlanningHelpers::CompareTrajectories(path, m_LocalPlanner.m_TotalPath.at(i));
			}
		}


		if(!bOldGlobalPath)
		{
			bWayPlannerPath = true;
			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = true;
			//m_CurrentGoal = m_WayPlannerPaths.at(0).at(m_WayPlannerPaths.at(0).size()-1);
			m_LocalPlanner.m_TotalPath = m_WayPlannerPaths;

			cout &lt;&lt; &quot;Global Lanes Size = &quot; &lt;&lt; msg-&gt;lanes.size() &lt;&lt;&quot;, Conv Size= &quot; &lt;&lt; m_WayPlannerPaths.size() &lt;&lt; &quot;, First Lane Size: &quot; &lt;&lt; m_WayPlannerPaths.at(0).size() &lt;&lt; endl;

//			for(unsigned int k= 0; k &lt; m_WayPlannerPaths.at(0).size(); k++)
//			{
//				if(m_WayPlannerPaths.at(0).at(k).stopLineID &gt; 0 &amp;&amp; m_WayPlannerPaths.at(0).at(k).pLane &amp;&amp; m_WayPlannerPaths.at(0).at(k).pLane-&gt;stopLines.size()&gt;0)
//				{
//					cout &lt;&lt; &quot;Stop Line IDs: &quot; &lt;&lt; m_WayPlannerPaths.at(0).at(k).stopLineID &lt;&lt; &quot;, Lane: &quot; &lt;&lt; m_WayPlannerPaths.at(0).at(k).pLane &lt;&lt; &quot;, Stop Lines: &quot;&lt;&lt; m_WayPlannerPaths.at(0).at(k).pLane-&gt;stopLines.size() &lt;&lt; endl;
//				}
//			}
		}
	}
}

void PlannerX::PlannerMainLoop()
{
	ros::Rate loop_rate(100);

	timespec trackingTimer;
	UtilityHNS::UtilityH::GetTickCount(trackingTimer);
	PlannerHNS::WayPoint prevState, state_change;

	while (ros::ok())
	{
		timespec iterationTime;
		UtilityHNS::UtilityH::GetTickCount(iterationTime);

		ros::spinOnce();

		if(m_MapSource == MAP_KML_FILE &amp;&amp; !bKmlMapLoaded)
		{
			bKmlMapLoaded = true;
			PlannerHNS::MappingHelpers::LoadKML(m_KmlMapPath, m_Map);
			//sub_WayPlannerPaths = nh.subscribe(&quot;/lane_waypoints_array&quot;, 	10,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);
		}
		else if(m_MapSource == MAP_FOLDER &amp;&amp; !bKmlMapLoaded)
		{
			bKmlMapLoaded = true;
			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_KmlMapPath, m_Map, true);
		}
		else if(m_MapSource == MAP_AUTOWARE)
		{
			 if(m_AwMap.bDtLanes &amp;&amp; m_AwMap.bLanes &amp;&amp; m_AwMap.bPoints)
			 {
				timespec timerTemp;
				UtilityHNS::UtilityH::GetTickCount(timerTemp);
				 m_AwMap.bDtLanes = m_AwMap.bLanes = m_AwMap.bPoints = false;
				 RosHelpers::UpdateRoadMap(m_AwMap,m_Map);
				 std::cout &lt;&lt; &quot;Converting Vector Map Time : &quot; &lt;&lt;UtilityHNS::UtilityH::GetTimeDiffNow(timerTemp) &lt;&lt; std::endl;
				 //sub_WayPlannerPaths = nh.subscribe(&quot;/lane_waypoints_array&quot;, 	10,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);
			 }
		}

		int iDirection = 0;
		if(bInitPos &amp;&amp; m_LocalPlanner.m_TotalPath.size()&gt;0)
		{
//			bool bMakeNewPlan = false;
//			double drift = hypot(m_LocalPlanner.state.pos.y-m_CurrentPos.pos.y, m_LocalPlanner.state .pos.x-m_CurrentPos.pos.x);
//			if(drift &gt; 10)
//				bMakeNewPlan = true;

			m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = m_bOutsideControl;
			m_LocalPlanner.state = m_CurrentPos;

			double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(m_PlanningTimer);
			UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);

			m_CurrentBehavior = m_LocalPlanner.DoOneStep(dt, m_VehicleState, m_TrackedClusters, 1, m_Map, m_bEmergencyStop, m_bGreenLight, true);

			visualization_msgs::Marker behavior_rviz;

			if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &gt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
				iDirection = 1;
			else if(m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCurrSafeTrajectory &lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory)
				iDirection = -1;

			RosHelpers::VisualizeBehaviorState(m_CurrentPos, m_CurrentBehavior, m_bGreenLight, iDirection, behavior_rviz);

			pub_BehaviorStateRviz.publish(behavior_rviz);

			if(m_CurrentBehavior.state != m_PrevBehavior.state)
			{
				//std::cout &lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;ToString(m_CurrentBehavior.state) &lt;&lt; &quot;, Speed : &quot; &lt;&lt; m_CurrentBehavior.maxVelocity &lt;&lt; std::endl;
				m_PrevBehavior = m_CurrentBehavior;
			}


			geometry_msgs::Twist t;
			geometry_msgs::TwistStamped behavior;
			t.linear.x = m_CurrentBehavior.followDistance;
			t.linear.y = m_CurrentBehavior.stopDistance;
			t.linear.z = (int)m_CurrentBehavior.indicator;

			t.angular.x = m_CurrentBehavior.followVelocity;
			t.angular.y = m_CurrentBehavior.maxVelocity;
			t.angular.z = (int)m_CurrentBehavior.state;

			behavior.twist = t;
			behavior.header.stamp = ros::Time::now();

			pub_BehaviorState.publish(behavior);

			visualization_msgs::MarkerArray detectedPolygons;
			RosHelpers::ConvertFromPlannerObstaclesToAutoware(m_CurrentPos, m_TrackedClusters, detectedPolygons);
			pub_DetectedPolygonsRviz.publish(detectedPolygons);

			visualization_msgs::Marker safety_box;
			RosHelpers::ConvertFromPlannerHRectangleToAutowareRviz(m_LocalPlanner.m_TrajectoryCostsCalculatotor.m_SafetyBorder.points, safety_box);
			pub_SafetyBorderRviz.publish(safety_box);

			geometry_msgs::PoseArray sim_data;
			geometry_msgs::Pose p_id, p_pose, p_box;


			sim_data.header.frame_id = &quot;map&quot;;
			sim_data.header.stamp = ros::Time();

			p_id.position.x = 0;

			p_pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(m_LocalPlanner.state.pos.a));
			p_pose.position.x = m_LocalPlanner.state.pos.x;
			p_pose.position.y = m_LocalPlanner.state.pos.y;
			p_pose.position.z = m_LocalPlanner.state.pos.z;



			p_box.position.x = m_LocalPlanner.m_CarInfo.width;
			p_box.position.y = m_LocalPlanner.m_CarInfo.length;
			p_box.position.z = 2.2;

			sim_data.poses.push_back(p_id);
			sim_data.poses.push_back(p_pose);
			sim_data.poses.push_back(p_box);

			pub_SimuBoxPose.publish(sim_data);

			timespec log_t;
			UtilityHNS::UtilityH::GetTickCount(log_t);
			std::ostringstream dataLine;
			std::ostringstream dataLineToOut;
			dataLine &lt;&lt; UtilityHNS::UtilityH::GetLongTime(log_t) &lt;&lt;&quot;,&quot; &lt;&lt; dt &lt;&lt; &quot;,&quot; &lt;&lt; m_CurrentBehavior.state &lt;&lt; &quot;,&quot;&lt;&lt; RosHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; &quot;,&quot; &lt;&lt;
					m_nTrackObjects &lt;&lt; &quot;,&quot; &lt;&lt; m_nOriginalPoints &lt;&lt; &quot;,&quot; &lt;&lt; m_nContourPoints &lt;&lt; &quot;,&quot; &lt;&lt; m_TrackingTime &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_CostCalculationTime &lt;&lt; &quot;,&quot; &lt;&lt; m_LocalPlanner.m_BehaviorGenTime &lt;&lt; &quot;,&quot; &lt;&lt; m_LocalPlanner.m_RollOutsGenerationTime &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_pParams-&gt;rollOutNumber &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bFullyBlock &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;iCentralTrajectory &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_iSafeTrajectory &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;currentStopSignID &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;currentTrafficLightID &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;minStoppingDistance &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;distanceToNext &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;velocityOfNext &lt;&lt; &quot;,&quot; &lt;&lt;
					m_VehicleState.speed &lt;&lt; &quot;,&quot; &lt;&lt;
					m_VehicleState.steer &lt;&lt; &quot;,&quot; &lt;&lt;
					m_LocalPlanner.state.pos.x &lt;&lt; &quot;,&quot; &lt;&lt; m_LocalPlanner.state.pos.y &lt;&lt; &quot;,&quot; &lt;&lt; m_LocalPlanner.state.pos.z &lt;&lt; &quot;,&quot; &lt;&lt; UtilityHNS::UtilityH::SplitPositiveAngle(m_LocalPlanner.state.pos.a)+M_PI &lt;&lt; &quot;,&quot;;
			m_LogData.push_back(dataLine.str());

//			dataLineToOut &lt;&lt; RosHelpers::GetBehaviorNameFromCode(m_CurrentBehavior.state) &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bFullyBlock &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_iSafeTrajectory &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;minStoppingDistance &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;distanceToNext &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;velocityOfNext &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;currentStopSignID &lt;&lt; &quot;,&quot;
//					&lt;&lt; m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;currentTrafficLightID &lt;&lt; &quot;,&quot;;
//
//			cout &lt;&lt; dataLineToOut.str() &lt;&lt; endl;


		}
		else
		{
			UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
			sub_WayPlannerPaths = nh.subscribe(&quot;/lane_waypoints_array&quot;, 	1,		&amp;PlannerX::callbackGetWayPlannerPath, 	this);
		}


		autoware_msgs::lane current_trajectory;
		std_msgs::Int32 closest_waypoint;
		PlannerHNS::RelativeInfo info;
		PlannerHNS::PlanningHelpers::GetRelativeInfo(m_LocalPlanner.m_Path, m_LocalPlanner.state, info);
		RosHelpers::ConvertFromPlannerHToAutowarePathFormat(m_LocalPlanner.m_Path, info.iBack, current_trajectory);
		closest_waypoint.data = 1;
		pub_ClosestIndex.publish(closest_waypoint);
		pub_LocalBasePath.publish(current_trajectory);
		pub_LocalPath.publish(current_trajectory);
		visualization_msgs::MarkerArray all_rollOuts;

	
		RosHelpers::ConvertFromPlannerHToAutowareVisualizePathFormat(m_LocalPlanner.m_Path, m_LocalPlanner.m_RollOuts, m_LocalPlanner, all_rollOuts);
		pub_LocalTrajectoriesRviz.publish(all_rollOuts);

		//Publish markers that visualize only when avoiding objects
		if(enablePlannerDynamicSwitch){
			visualization_msgs::MarkerArray all_rollOuts_dynamic;
			std_msgs::Int32 enableLattice;
			if(iDirection != 0) { // if obstacle avoidance state,
				all_rollOuts_dynamic = all_rollOuts;
		   		
			     	for(auto &amp;ro : all_rollOuts_dynamic.markers){
					ro.ns = &quot;global_lane_array_marker_dynamic&quot;;
				}
				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
				enableLattice.data = 1;
			}else{
				visualization_msgs::Marker delMarker;
#ifndef ROS_KINETIC
				delMarker.action = visualization_msgs::Marker::DELETE;
#else
				delMarker.action = visualization_msgs::Marker::DELETEALL;
#endif
				delMarker.ns = &quot;global_lane_array_marker_dynamic&quot;;
				all_rollOuts_dynamic.markers.push_back(delMarker);
				pub_LocalTrajectoriesRviz_dynamic.publish(all_rollOuts_dynamic);
				enableLattice.data = 0;
			}
			pub_EnableLattice.publish(enableLattice); //Publish flag of object avoidance
		}


		if(m_CurrentBehavior.bNewPlan)
		{
			std::ostringstream str_out;
			str_out &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory();
			str_out &lt;&lt; UtilityHNS::DataRW::LoggingMainfolderName;
			str_out &lt;&lt; UtilityHNS::DataRW::PathLogFolderName;
			str_out &lt;&lt; &quot;LocalPath_&quot;;
			PlannerHNS::PlanningHelpers::WritePathToFile(str_out.str(), m_LocalPlanner.m_Path);
		}


		//Traffic Light Simulation Part
		if(m_bGreenLight &amp;&amp; UtilityHNS::UtilityH::GetTimeDiffNow(m_TrafficLightTimer) &gt; 5)
		{
			m_bGreenLight = false;
			UtilityHNS::UtilityH::GetTickCount(m_TrafficLightTimer);
		}
		else if(!m_bGreenLight &amp;&amp; UtilityHNS::UtilityH::GetTimeDiffNow(m_TrafficLightTimer) &gt; 10.0)
		{
			m_bGreenLight = true;
			UtilityHNS::UtilityH::GetTickCount(m_TrafficLightTimer);
		}

		loop_rate.sleep();

		//double onePassTime = UtilityHNS::UtilityH::GetTimeDiffNow(iterationTime);
//		if(onePassTime &gt; 0.1)
//			std::cout &lt;&lt; &quot;Slow Iteration Time = &quot; &lt;&lt; onePassTime &lt;&lt; &quot; , for Obstacles : (&quot; &lt;&lt; m_TrackedClusters.size() &lt;&lt; &quot;, &quot; &lt;&lt; m_OriginalClusters.size() &lt;&lt; &quot;)&quot; &lt;&lt;  std::endl;
	}
}

}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/ff_waypoint_follower/nodes/ff_waypoint_follower_core.cpp" new_path="ros/src/computing/planning/motion/packages/ff_waypoint_follower/nodes/ff_waypoint_follower_core.cpp">
				<diff>@@ -33,7 +33,6 @@
 #include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;std_msgs/Float32.h&gt;
-#include &quot;geo_pos_conv.hh&quot;
 #include &quot;UtilityH.h&quot;
 #include &quot;math.h&quot;
 
@@ -658,36 +657,36 @@ void FFSteerControl::PlannerMainLoop()
 				std::cout &lt;&lt; &quot;Record One Point To Path: &quot; &lt;&lt;  m_CurrentPos.pos.ToString() &lt;&lt; std::endl;
 			}
 
-			if(totalDistance &gt; m_CmdParams.recordDistance || m_bOutsideControl != 0)
-			{
-				PlannerHNS::RoadNetwork roadMap;
-				PlannerHNS::RoadSegment segment;
-
-				segment.id = 1;
-
-				PlannerHNS::Lane lane;
-				lane.id = 1;
-				lane.num = 0;
-				lane.roadId = 1;
-				lane.points = path;
-
-				segment.Lanes.push_back(lane);
-				roadMap.roadSegments.push_back(segment);
-
-				ostringstream fileName;
-				fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName;
-				fileName &lt;&lt; UtilityHNS:: UtilityH::GetFilePrefixHourMinuteSeconds();
-				fileName &lt;&lt; &quot;_RoadNetwork.kml&quot;;
-				string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+&quot;PlannerX_MapTemplate.kml&quot;;
-
-				PlannerHNS::MappingHelpers::WriteKML(fileName.str(),kml_templateFilePath , roadMap);
-
-										//string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmltargetFile;
-					//PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
-
-				std::cout &lt;&lt; &quot; Mapped Saved Successfuly ... &quot; &lt;&lt; std::endl;
-				break;
-			}
+//			if(totalDistance &gt; m_CmdParams.recordDistance || m_bOutsideControl != 0)
+//			{
+//				PlannerHNS::RoadNetwork roadMap;
+//				PlannerHNS::RoadSegment segment;
+//
+//				segment.id = 1;
+//
+//				PlannerHNS::Lane lane;
+//				lane.id = 1;
+//				lane.num = 0;
+//				lane.roadId = 1;
+//				lane.points = path;
+//
+//				segment.Lanes.push_back(lane);
+//				roadMap.roadSegments.push_back(segment);
+//
+//				ostringstream fileName;
+//				fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName;
+//				fileName &lt;&lt; UtilityHNS:: UtilityH::GetFilePrefixHourMinuteSeconds();
+//				fileName &lt;&lt; &quot;_RoadNetwork.kml&quot;;
+//				string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+&quot;PlannerX_MapTemplate.kml&quot;;
+//
+//				//PlannerHNS::MappingHelpers::WriteKML(fileName.str(),kml_templateFilePath , roadMap);
+//
+//										//string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmltargetFile;
+//					//PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);
+//
+//				std::cout &lt;&lt; &quot; Mapped Saved Successfuly ... &quot; &lt;&lt; std::endl;
+//				break;
+//			}
 		 }
 
 		loop_rate.sleep();
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include &quot;ff_waypoint_follower_core.h&quot;
#include &quot;autoware_msgs/LaneArray.h&quot;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;visualization_msgs/InteractiveMarkerPose.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &quot;geo_pos_conv.hh&quot;
#include &quot;UtilityH.h&quot;
#include &quot;math.h&quot;

using namespace std;

namespace FFSteerControlNS
{

FFSteerControl::FFSteerControl()
{
	clock_gettime(0, &amp;m_Timer);

	int iSignal = 0;
	nh.getParam(&quot;/ff_waypoint_follower/signal&quot;, iSignal);
	if(iSignal == 0)
		m_CmdParams.statusSource = FFSteerControlNS::SIMULATION_STATUS;
	else if(iSignal == 1)
		m_CmdParams.statusSource = FFSteerControlNS::CONTROL_BOX_STATUS;
	else if(iSignal == 2)
		m_CmdParams.statusSource = FFSteerControlNS::ROBOT_STATUS;

	nh.getParam(&quot;/ff_waypoint_follower/bEnableLogs&quot;, m_CmdParams.bEnableLogs);
	nh.getParam(&quot;/ff_waypoint_follower/bCalibrationMode&quot;, m_CmdParams.bCalibration);
	if(m_CmdParams.bCalibration)
		m_CmdParams.bEnableLogs = true;

	string steerModeStr;
	nh.getParam(&quot;/ff_waypoint_follower/steerMode&quot;, steerModeStr );
	if(steerModeStr.compare(&quot;angle&quot;) == 0)
		m_CmdParams.bAngleMode = true;
	else if(steerModeStr.compare(&quot;torque&quot;) == 0)
		m_CmdParams.bAngleMode = false;

	string driveModeStr;
	nh.getParam(&quot;/ff_waypoint_follower/driveMode&quot;, driveModeStr );
	if(driveModeStr.compare(&quot;velocity&quot;) == 0)
		m_CmdParams.bVelocityMode = true;
	else if(driveModeStr.compare(&quot;stroke&quot;) == 0)
		m_CmdParams.bVelocityMode = false;

	string mapRecStr;
	nh.getParam(&quot;/ff_waypoint_follower/mapRecorder&quot;, m_CmdParams.iMapping );

	nh.getParam(&quot;/ff_waypoint_follower/mapDistance&quot;, m_CmdParams.recordDistance );

	nh.getParam(&quot;/ff_waypoint_follower/mapDensity&quot;, m_CmdParams.recordDensity );

	cout &lt;&lt; &quot;Initialize Controller .. &quot; &lt;&lt; &quot;, &quot;
			&lt;&lt; iSignal &lt;&lt; &quot;,&quot; &lt;&lt; steerModeStr &lt;&lt; &quot;, &quot;
			&lt;&lt; driveModeStr &lt;&lt; &quot;, &quot; &lt;&lt; m_CmdParams.iMapping &lt;&lt; &quot;, &quot;
			&lt;&lt; m_CmdParams.recordDistance &lt;&lt; &quot;, &quot; &lt;&lt; m_CmdParams.recordDensity &lt;&lt; endl;

	ReadParamFromLaunchFile(m_CarInfo, m_ControlParams);

	m_PredControl.Init(m_ControlParams, m_CarInfo, m_CmdParams.bEnableLogs, m_CmdParams.bCalibration);

	m_State.Init(m_ControlParams, m_PlanningParams, m_CarInfo);
	m_State.m_SimulationSteeringDelayFactor = 0.2;
	cout &lt;&lt; &quot;Current Steering Delay Factor = &quot; &lt;&lt; m_State.m_SimulationSteeringDelayFactor &lt;&lt; endl;

	m_counter = 0;
	m_frequency = 0;
	bNewCurrentPos = false;
	bVehicleStatus = false;
	bNewTrajectory = false;
	bNewVelocity = false;
	bNewBehaviorState = false;
	bInitPos = false;
	m_bOutsideControl = 0;


#ifdef ENABLE_ZMP_LIBRARY_LINK
	m_pComm = 0;
	if(m_CmdParams.statusSource == CONTROL_BOX_STATUS)
	{
		m_pComm = new HevComm();
		m_pComm-&gt;InitializeComm(m_CarInfo);
		m_pComm-&gt;StartComm();
	}
#endif


	tf::StampedTransform transform;
	GetTransformFromTF(&quot;map&quot;, &quot;world&quot;, transform);
	ROS_INFO(&quot;Origin : x=%f, y=%f, z=%f&quot;, transform.getOrigin().x(),transform.getOrigin().y(), transform.getOrigin().z());

	m_OriginPos.position.x  = transform.getOrigin().x();
	m_OriginPos.position.y  = transform.getOrigin().y();
	m_OriginPos.position.z  = transform.getOrigin().z();


	pub_VelocityAutoware 		= nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;twist_raw&quot;, 100);
	pub_StatusAutoware 			= nh.advertise&lt;std_msgs::Bool&gt;(&quot;wf_stat&quot;, 100);

	//For rviz visualization
	pub_CurrPoseRviz			= nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;curr_simu_pose&quot;, 100);
	pub_FollowPointRviz			= nh.advertise&lt;visualization_msgs::Marker&gt;(&quot;follow_pose&quot;, 100);

	pub_SimuPose				= nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;sim_pose&quot;, 100);
	pub_SimuVelocity			= nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;sim_velocity&quot;, 100);

	pub_VehicleCommand			= nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;twist_cmd&quot;, 100);
	pub_ControlBoxOdom			= nh.advertise&lt;nav_msgs::Odometry&gt;(&quot;ControlBoxOdom&quot;, 100);
	pub_VelocityRviz 			= nh.advertise&lt;std_msgs::Float32&gt;(&quot;linear_velocity_viz&quot;, 10);

	// define subscribers.
	sub_initialpose 		= nh.subscribe(&quot;/initialpose&quot;, 		100, &amp;FFSteerControl::callbackGetInitPose, 			this);

  	if(m_CmdParams.statusSource != SIMULATION_STATUS)
  		sub_current_pose 	= nh.subscribe(&quot;/current_pose&quot;, 		100, &amp;FFSteerControl::callbackGetCurrentPose, 		this);

  	if(m_CmdParams.statusSource == ROBOT_STATUS)
		sub_robot_odom			= nh.subscribe(&quot;/odom&quot;,				100, &amp;FFSteerControl::callbackGetRobotOdom, 		this);
  	else
  		sub_current_velocity= nh.subscribe(&quot;/current_velocity&quot;, 	100, &amp;FFSteerControl::callbackGetCurrentVelocity, 		this);

  	sub_behavior_state 		= nh.subscribe(&quot;/current_behavior&quot;,	10,  &amp;FFSteerControl::callbackGetBehaviorState, 	this);
  	sub_current_trajectory 	= nh.subscribe(&quot;/final_waypoints&quot;, 	10,	&amp;FFSteerControl::callbackGetCurrentTrajectory, this);



  	sub_OutsideControl 	= nh.subscribe(&quot;/usb_controller_r_signal&quot;, 	10,		&amp;FFSteerControl::callbackGetOutsideControl, 	this);

  	//sub_autoware_odom 		= nh.subscribe(&quot;/twist_odom&quot;, 		10,	&amp;FFSteerControl::callbackGetAutowareOdom, this);


	UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);

	std::cout &lt;&lt; &quot;ff_waypoint_follower initialized successfully &quot; &lt;&lt; std::endl;

}

void FFSteerControl::ReadParamFromLaunchFile(PlannerHNS::CAR_BASIC_INFO&amp; m_CarInfo,
		PlannerHNS::ControllerParams&amp; m_ControlParams)
{
	nh.getParam(&quot;/ff_waypoint_follower/width&quot;, 			m_CarInfo.width );
	nh.getParam(&quot;/ff_waypoint_follower/length&quot;, 		m_CarInfo.length );
	nh.getParam(&quot;/ff_waypoint_follower/wheelBaseLength&quot;, m_CarInfo.wheel_base );
	nh.getParam(&quot;/ff_waypoint_follower/turningRadius&quot;, m_CarInfo.turning_radius );
	nh.getParam(&quot;/ff_waypoint_follower/maxSteerAngle&quot;, m_CarInfo.max_steer_angle );

	nh.getParam(&quot;/ff_waypoint_follower/maxSteerValue&quot;, m_CarInfo.max_steer_value );
	nh.getParam(&quot;/ff_waypoint_follower/minSteerValue&quot;, m_CarInfo.min_steer_value );
	nh.getParam(&quot;/ff_waypoint_follower/maxVelocity&quot;, m_CarInfo.max_speed_forward );
	nh.getParam(&quot;/ff_waypoint_follower/minVelocity&quot;, m_CarInfo.min_speed_forward );
	nh.getParam(&quot;/ff_waypoint_follower/minVelocity&quot;, m_CarInfo.max_speed_backword );

	nh.getParam(&quot;/ff_waypoint_follower/steeringDelay&quot;, m_ControlParams.SteeringDelay );
	nh.getParam(&quot;/ff_waypoint_follower/minPursuiteDistance&quot;, m_ControlParams.minPursuiteDistance );
	nh.getParam(&quot;/ff_waypoint_follower/followDistance&quot;, m_ControlParams.FollowDistance );
	nh.getParam(&quot;/ff_waypoint_follower/lowpassSteerCutoff&quot;, m_ControlParams.LowpassSteerCutoff );

	nh.getParam(&quot;/ff_waypoint_follower/steerGainKP&quot;, m_ControlParams.Steering_Gain.kP );
	nh.getParam(&quot;/ff_waypoint_follower/steerGainKI&quot;, m_ControlParams.Steering_Gain.kI );
	nh.getParam(&quot;/ff_waypoint_follower/steerGainKD&quot;, m_ControlParams.Steering_Gain.kD );

	nh.getParam(&quot;/ff_waypoint_follower/velocityGainKP&quot;, m_ControlParams.Velocity_Gain.kP );
	nh.getParam(&quot;/ff_waypoint_follower/velocityGainKI&quot;, m_ControlParams.Velocity_Gain.kI );
	nh.getParam(&quot;/ff_waypoint_follower/velocityGainKD&quot;, m_ControlParams.Velocity_Gain.kD );
	nh.getParam(&quot;/ff_waypoint_follower/maxAcceleration&quot;, m_CarInfo.max_acceleration );
	nh.getParam(&quot;/ff_waypoint_follower/maxDeceleration&quot;, m_CarInfo.max_deceleration );

	m_PlanningParams.maxSpeed = m_CarInfo.max_speed_forward;
	m_PlanningParams.minSpeed = m_CarInfo.min_speed_forward;



}

FFSteerControl::~FFSteerControl()
{
#ifdef ENABLE_ZMP_LIBRARY_LINK
	if(m_pComm)
		delete m_pComm;
#endif
}

void FFSteerControl::callbackGetOutsideControl(const std_msgs::Int8&amp; msg)
{
	//std::cout &lt;&lt; &quot;Received Outside Control : &quot; &lt;&lt; msg.data &lt;&lt; std::endl;

	m_bOutsideControl  = msg.data;
}

void FFSteerControl::callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr &amp;msg)
{
	ROS_INFO(&quot;init Simulation Rviz Pose Data: x=%f, y=%f, z=%f, freq=%d&quot;, msg-&gt;pose.pose.position.x, msg-&gt;pose.pose.position.y, msg-&gt;pose.pose.position.z, m_frequency);

	geometry_msgs::Pose p;
	p.position.x  = msg-&gt;pose.pose.position.x + m_OriginPos.position.x;
	p.position.y  = msg-&gt;pose.pose.position.y + m_OriginPos.position.y;
	p.position.z  = msg-&gt;pose.pose.position.z + m_OriginPos.position.z;
	p.orientation = msg-&gt;pose.pose.orientation;

	m_InitPos =  PlannerHNS::WayPoint(p.position.x, p.position.y, p.position.z , tf::getYaw(p.orientation));
	m_State.FirstLocalizeMe(m_InitPos);
	m_CurrentPos = m_InitPos;
	bInitPos = true;
}

void FFSteerControl::callbackGetCurrentPose(const geometry_msgs::PoseStampedConstPtr&amp; msg)
{
	m_counter++;
	double dt = UtilityHNS::UtilityH::GetTimeDiffNow(m_Timer);
	if(dt &gt;= 1.0)
	{
		m_frequency = m_counter;
		m_counter = 0;
		clock_gettime(0, &amp;m_Timer);
	}

	m_CurrentPos = PlannerHNS::WayPoint(msg-&gt;pose.position.x, msg-&gt;pose.position.y, msg-&gt;pose.position.z, tf::getYaw(msg-&gt;pose.orientation));

	bNewCurrentPos = true;
}

void FFSteerControl::callbackGetCurrentVelocity(const geometry_msgs::TwistStampedConstPtr&amp; msg)
{
	m_CurrVehicleStatus.shift = PlannerHNS::SHIFT_POS_DD;
	m_CurrVehicleStatus.speed = msg-&gt;twist.linear.x;
	if(msg-&gt;twist.linear.x != 0)
		m_CurrVehicleStatus.steer = atan(m_CarInfo.wheel_base * msg-&gt;twist.angular.z/msg-&gt;twist.linear.x);

	UtilityHNS::UtilityH::GetTickCount(m_CurrVehicleStatus.tStamp);
}

void FFSteerControl::callbackGetBehaviorState(const geometry_msgs::TwistStampedConstPtr&amp; msg )
{
	m_CurrentBehavior = ConvertBehaviorStateFromAutowareToPlannerH(msg);
	bNewBehaviorState = true;
}

void FFSteerControl::callbackGetCurrentTrajectory(const autoware_msgs::laneConstPtr &amp;msg)
{
	m_State.m_Path.clear();
	for(unsigned int i = 0 ; i &lt; msg-&gt;waypoints.size(); i++)
	{
		PlannerHNS::WayPoint wp(msg-&gt;waypoints.at(i).pose.pose.position.x,
				msg-&gt;waypoints.at(i).pose.pose.position.y, msg-&gt;waypoints.at(i).pose.pose.position.z,
				tf::getYaw(msg-&gt;waypoints.at(i).pose.pose.orientation));
		wp.v = msg-&gt;waypoints.at(i).twist.twist.linear.x;

		if(msg-&gt;waypoints.at(i).twist.twist.linear.z == 0)
			wp.bDir = PlannerHNS::FORWARD_DIR;
		else if(msg-&gt;waypoints.at(i).twist.twist.linear.z == 1)
			wp.bDir = PlannerHNS::FORWARD_LEFT_DIR;
		else if(msg-&gt;waypoints.at(i).twist.twist.linear.z == 2)
			wp.bDir = PlannerHNS::FORWARD_RIGHT_DIR;
		else if(msg-&gt;waypoints.at(i).twist.twist.linear.z == 3)
			wp.bDir = PlannerHNS::BACKWARD_DIR;
		else if(msg-&gt;waypoints.at(i).twist.twist.linear.z == 4)
			wp.bDir = PlannerHNS::BACKWARD_LEFT_DIR;
		else if(msg-&gt;waypoints.at(i).twist.twist.linear.z == 5)
			wp.bDir = PlannerHNS::BACKWARD_RIGHT_DIR;
		else if(msg-&gt;waypoints.at(i).twist.twist.linear.z == 6)
			wp.bDir = PlannerHNS::STANDSTILL_DIR;
		else
			wp.bDir = PlannerHNS::STANDSTILL_DIR;

		m_State.m_Path.push_back(wp);
	}

//	cout &lt;&lt; &quot;### Current Trajectory CallBaclk -&gt; &quot; &lt;&lt; m_State.m_Path.size() &lt;&lt; endl;

	bNewTrajectory = true;
}

//void FFSteerControl::callbackGetAutowareOdom(const geometry_msgs::TwistStampedConstPtr &amp;msg)
//{
//}

void FFSteerControl::callbackGetRobotOdom(const nav_msgs::OdometryConstPtr&amp; msg)
{
	if(m_CmdParams.statusSource == ROBOT_STATUS)
	{
//		PlannerHNS::WayPoint odoPose = PlannerHNS::WayPoint(msg-&gt;pose.pose.position.x,
//				msg-&gt;pose.pose.position.y,msg-&gt;pose.pose.position.z , tf::getYaw(msg-&gt;pose.pose.orientation));

		m_CurrVehicleStatus.shift = PlannerHNS::SHIFT_POS_DD;
		m_CurrVehicleStatus.speed = msg-&gt;twist.twist.linear.x;
		if(msg-&gt;twist.twist.linear.x!=0)
			m_CurrVehicleStatus.steer = atan(m_CarInfo.wheel_base * msg-&gt;twist.twist.angular.z/msg-&gt;twist.twist.linear.x);
		UtilityHNS::UtilityH::GetTickCount(m_CurrVehicleStatus.tStamp);

//		std::cout &lt;&lt; &quot;###### Current Status From Robot Odometry -&gt; (&quot; &lt;&lt;  m_CurrVehicleStatus.speed &lt;&lt; &quot;, &quot; &lt;&lt; m_CurrVehicleStatus.steer &lt;&lt; &quot;)&quot;  &lt;&lt; std::endl;
	}
}

void FFSteerControl::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
{
	static tf::TransformListener listener;

	while (1)
	{
		try
		{
			listener.lookupTransform(parent_frame, child_frame, ros::Time(0), transform);
			break;
		}
		catch (tf::TransformException&amp; ex)
		{
			ROS_ERROR(&quot;%s&quot;, ex.what());
			ros::Duration(1.0).sleep();
		}
	}
}

void FFSteerControl::displayFollowingInfo(PlannerHNS::WayPoint&amp; curr_pose, PlannerHNS::WayPoint&amp; perp_pose, PlannerHNS::WayPoint&amp; follow_pose)
{
  visualization_msgs::Marker m1,m2,m3;
  m1.header.frame_id = &quot;map&quot;;
  m1.header.stamp = ros::Time();
  m1.ns = &quot;curr_simu_pose&quot;;
  m1.type = visualization_msgs::Marker::ARROW;
  m1.action = visualization_msgs::Marker::ADD;
  m1.pose.position.x = curr_pose.pos.x;
  m1.pose.position.y = curr_pose.pos.y;
  m1.pose.position.z = curr_pose.pos.z;
  m1.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(curr_pose.pos.a));
  std_msgs::ColorRGBA green;
  green.a = 1.0;
  green.b = 0.0;
  green.r = 0.0;
  green.g = 1.0;
  m1.color = green;
  m1.scale.x = 1.8;
  m1.scale.y = 0.5;
  m1.scale.z = 0.5;
  m1.frame_locked = true;
  pub_CurrPoseRviz.publish(m1);

  m3.header.frame_id = &quot;map&quot;;
  m3.header.stamp = ros::Time();
  m3.ns = &quot;follow_pose&quot;;
  m3.type = visualization_msgs::Marker::SPHERE;
  m3.action = visualization_msgs::Marker::ADD;
  m3.pose.position.x = follow_pose.pos.x;
  m3.pose.position.y = follow_pose.pos.y;
  m3.pose.position.z = follow_pose.pos.z;
  m3.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(follow_pose.pos.a));
  std_msgs::ColorRGBA red;
  red.a = 1.0;
  red.b = 0.0;
  red.r = 1.0;
  red.g = 0.0;
  m3.color = red;
  m3.scale.x = 0.7;
  m3.scale.y = 0.7;
  m3.scale.z = 0.7;
  m3.frame_locked = true;
  pub_FollowPointRviz.publish(m3);
}

PlannerHNS::BehaviorState FFSteerControl::ConvertBehaviorStateFromAutowareToPlannerH(const geometry_msgs::TwistStampedConstPtr&amp; msg)
{
	PlannerHNS::BehaviorState behavior;
	behavior.followDistance 	= msg-&gt;twist.linear.x;
	behavior.stopDistance 		= msg-&gt;twist.linear.y;
	behavior.followVelocity 	= msg-&gt;twist.angular.x;
	behavior.maxVelocity 		= msg-&gt;twist.angular.y;


	if(msg-&gt;twist.linear.z == PlannerHNS::LIGHT_INDICATOR::INDICATOR_LEFT)
		behavior.indicator = PlannerHNS::LIGHT_INDICATOR::INDICATOR_LEFT;
	else if(msg-&gt;twist.linear.z == PlannerHNS::LIGHT_INDICATOR::INDICATOR_RIGHT)
		behavior.indicator = PlannerHNS::LIGHT_INDICATOR::INDICATOR_RIGHT;
	else if(msg-&gt;twist.linear.z == PlannerHNS::LIGHT_INDICATOR::INDICATOR_BOTH)
		behavior.indicator = PlannerHNS::LIGHT_INDICATOR::INDICATOR_BOTH;
	else if(msg-&gt;twist.linear.z == PlannerHNS::LIGHT_INDICATOR::INDICATOR_NONE)
		behavior.indicator = PlannerHNS::LIGHT_INDICATOR::INDICATOR_NONE;

	if(msg-&gt;twist.angular.z == PlannerHNS::INITIAL_STATE)
		behavior.state = PlannerHNS::INITIAL_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::WAITING_STATE)
		behavior.state = PlannerHNS::WAITING_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::FORWARD_STATE)
		behavior.state = PlannerHNS::FORWARD_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::STOPPING_STATE)
		behavior.state = PlannerHNS::STOPPING_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::EMERGENCY_STATE)
		behavior.state = PlannerHNS::EMERGENCY_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::TRAFFIC_LIGHT_STOP_STATE)
		behavior.state = PlannerHNS::TRAFFIC_LIGHT_STOP_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::STOP_SIGN_STOP_STATE)
		behavior.state = PlannerHNS::STOP_SIGN_STOP_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::STOP_SIGN_WAIT_STATE)
		behavior.state = PlannerHNS::STOP_SIGN_WAIT_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::FOLLOW_STATE)
		behavior.state = PlannerHNS::FOLLOW_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::LANE_CHANGE_STATE)
		behavior.state = PlannerHNS::LANE_CHANGE_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::OBSTACLE_AVOIDANCE_STATE)
		behavior.state = PlannerHNS::OBSTACLE_AVOIDANCE_STATE;
	else if(msg-&gt;twist.angular.z == PlannerHNS::FINISH_STATE)
		behavior.state = PlannerHNS::FINISH_STATE;


	return behavior;

}

void FFSteerControl::PlannerMainLoop()
{

	ros::Rate loop_rate(100);
#ifdef ENABLE_ZMP_LIBRARY_LINK
	if(m_pComm)
		m_pComm-&gt;GoLive(true);
#endif

	vector&lt;PlannerHNS::WayPoint&gt; path;
	PlannerHNS::WayPoint p2;
	double totalDistance = 0;

	while (ros::ok())
	{
		ros::spinOnce();

		PlannerHNS::BehaviorState currMessage = m_CurrentBehavior;
		double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(m_PlanningTimer);
		UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);

		if(currMessage.state != PlannerHNS::INITIAL_STATE &amp;&amp;  (bInitPos || bNewCurrentPos))
		{
			/**
			 * Localization and Status Reading Part
			 * -----------------------------------------------------------------------------------
			 */
			if(m_CmdParams.statusSource == CONTROL_BOX_STATUS)
			{
				//Read StateData From Control Box
#ifdef ENABLE_ZMP_LIBRARY_LINK
				if(m_pComm &amp;&amp; m_pComm-&gt;IsAuto())
				{
					m_CurrVehicleStatus.steer = m_pComm-&gt;GetCurrentSteerAngle();
					m_CurrVehicleStatus.speed = m_pComm-&gt;GetCurrentSpeed();
					m_CurrVehicleStatus.shift = m_pComm-&gt;GetCurrentShift();

					//Send status over message to planner
					nav_msgs::Odometry control_box_status;
					control_box_status.header.stamp = ros::Time::now();
					control_box_status.twist.twist.angular.z = m_CurrVehicleStatus.steer;
					control_box_status.twist.twist.linear.x = m_CurrVehicleStatus.speed;
					control_box_status.twist.twist.linear.z = (int)m_CurrVehicleStatus.shift;

					control_box_status.pose.pose.position.x = m_CurrentPos.pos.x;
					control_box_status.pose.pose.position.y = m_CurrentPos.pos.y;
					control_box_status.pose.pose.position.z = m_CurrentPos.pos.z;
					control_box_status.pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(m_CurrentPos.pos.a));

					pub_ControlBoxOdom.publish(control_box_status);

					cout &lt;&lt; &quot;Read Live Car Info .. &quot; &lt;&lt; endl;
				}
				else
				{
					cout &lt;&lt; &quot;&gt;&gt;&gt; Error, Disconnected from Car Control Box !&quot; &lt;&lt; endl;
				}
#endif
			}
			else if(m_CmdParams.statusSource == SIMULATION_STATUS)
			{
				//m_CurrVehicleStatus = m_PrevStepTargetStatus;
				//m_State.SimulateOdoPosition(dt, m_CurrVehicleStatus);

				m_State.SimulateOdoPosition(dt, m_PrevStepTargetStatus);
				m_CurrVehicleStatus.steer = m_State.m_CurrentSteering;
				m_CurrVehicleStatus.speed = m_State.m_CurrentVelocity;
				m_CurrVehicleStatus.shift = m_PrevStepTargetStatus.shift;
				m_CurrentPos = m_State.state;

				geometry_msgs::TwistStamped vehicle_status;
				vehicle_status.header.stamp = ros::Time::now();
				vehicle_status.twist.linear.x = m_CurrVehicleStatus.speed;
				vehicle_status.twist.angular.z = ( vehicle_status.twist.linear.x / m_CarInfo.wheel_base ) * tan(m_CurrVehicleStatus.steer);

				vehicle_status.twist.linear.z = (int)m_CurrVehicleStatus.shift;
				pub_SimuVelocity.publish(vehicle_status);

				geometry_msgs::PoseStamped pose;
				pose.header.stamp = ros::Time::now();
				pose.pose.position.x = m_CurrentPos.pos.x;
				pose.pose.position.y = m_CurrentPos.pos.y;
				pose.pose.position.z = m_CurrentPos.pos.z;
				pose.pose.orientation = tf::createQuaternionMsgFromYaw(UtilityHNS::UtilityH::SplitPositiveAngle(m_CurrentPos.pos.a));
				//cout &lt;&lt; &quot;Send Simulated Position &quot;&lt;&lt; m_CurrentPos.pos.ToString() &lt;&lt; endl;

				pub_SimuPose.publish(pose);

				static tf::TransformBroadcaster odom_broadcaster;
				geometry_msgs::TransformStamped odom_trans;
				odom_trans.header.stamp = ros::Time::now();
				odom_trans.header.frame_id = &quot;map&quot;;
				odom_trans.child_frame_id = &quot;base_link&quot;;

				odom_trans.transform.translation.x = pose.pose.position.x;
				odom_trans.transform.translation.y = pose.pose.position.y;
				odom_trans.transform.translation.z = pose.pose.position.z;
				odom_trans.transform.rotation = pose.pose.orientation;

				// send the transform
				odom_broadcaster.sendTransform(odom_trans);
			}
			else if(m_CmdParams.statusSource == ROBOT_STATUS)
			{
//				geometry_msgs::TwistStamped vehicle_status;
//				vehicle_status.header.stamp = ros::Time::now();
//				vehicle_status.twist.angular.z = m_CurrVehicleStatus.steer;
//				vehicle_status.twist.linear.x = m_CurrVehicleStatus.speed;
//				vehicle_status.twist.linear.z = (int)m_CurrVehicleStatus.shift;
//				pub_VehicleStatus.publish(vehicle_status);
			}
			//----------------------------------------------------------------------------------------------//


			/**
			 * Path Following Part
			 * -----------------------------------------------------------------------------------------------
			 */

			bool bNewPath = false;
			if(PlannerHNS::PlanningHelpers::CompareTrajectories(m_FollowingTrajectory , m_State.m_Path) == false &amp;&amp; m_State.m_Path.size()&gt;0)
			{
				m_FollowingTrajectory = m_State.m_Path;
				bNewPath = true;
//				cout &lt;&lt; &quot;Path is Updated in the controller .. &quot; &lt;&lt; m_State.m_Path.size() &lt;&lt; endl;
			}

			//PlannerHNS::ControllerParams c_params = m_ControlParams;
			//c_params.SteeringDelay = m_ControlParams.SteeringDelay / (1.0- UtilityHNS::UtilityH::GetMomentumScaleFactor(m_CurrVehicleStatus.speed));
			//m_PredControl.Init(c_params, m_CarInfo);
			m_PrevStepTargetStatus = m_PredControl.DoOneStep(dt, currMessage, m_FollowingTrajectory, m_CurrentPos, m_CurrVehicleStatus, bNewPath);
			//m_PrevStepTargetStatus.speed = 3.0;
			m_State.state.pos.z = m_PerpPoint.pos.z;
			m_FollowPoint  = m_PredControl.m_FollowMePoint;
			m_PerpPoint    = m_PredControl.m_PerpendicularPoint;

//			cout &lt;&lt; &quot;Target Status (&quot; &lt;&lt;m_PrevStepTargetStatus.steer &lt;&lt; &quot;, &quot; &lt;&lt; m_PrevStepTargetStatus.speed
//					&lt;&lt; &quot;, &quot; &lt;&lt; m_PrevStepTargetStatus.shift &lt;&lt; &quot;)&quot; &lt;&lt; endl;

			//----------------------------------------------------------------------------------------------//



			if(m_CmdParams.statusSource == CONTROL_BOX_STATUS) //send directly to ZMP control box
			{
#ifdef ENABLE_ZMP_LIBRARY_LINK
				if(m_pComm &amp;&amp; m_pComm-&gt;IsAuto())
				{
					m_pComm-&gt;SetNormalizedSteeringAngle(m_PrevStepTargetStatus.steer);
					m_pComm-&gt;SetNormalizedSpeed(m_PrevStepTargetStatus.speed);
					m_pComm-&gt;SetShift(m_PrevStepTargetStatus.shift);
					cout &lt;&lt; &quot;Sending Data to Control Box (&quot; &lt;&lt;m_PrevStepTargetStatus.steer &lt;&lt; &quot;, &quot; &lt;&lt; m_PrevStepTargetStatus.speed
							&lt;&lt; &quot;, &quot; &lt;&lt; m_PrevStepTargetStatus.shift &lt;&lt; &quot;)&quot; &lt;&lt; endl;
				}
				else
				{
					cout &lt;&lt; &quot;&gt;&gt;&gt; Error, Disconnected from Car Control Box !&quot; &lt;&lt; endl;
				}
#endif
			}
			else if(m_CmdParams.statusSource == ROBOT_STATUS)
			{
				cout &lt;&lt; &quot;Send Data To Robot : Max Speed=&quot; &lt;&lt; m_CarInfo.max_speed_forward &lt;&lt; &quot;, actual = &quot; &lt;&lt;  m_PrevStepTargetStatus.speed &lt;&lt; endl;
				geometry_msgs::Twist t;
				geometry_msgs::TwistStamped twist;
				t.linear.x = m_PrevStepTargetStatus.speed;

				if(t.linear.x &gt; m_CarInfo.max_speed_forward)
					t.linear.x = m_CarInfo.max_speed_forward;

				t.angular.z = m_PrevStepTargetStatus.steer;

				if(t.angular.z &gt; m_CarInfo.max_steer_angle)
					t.angular.z = m_CarInfo.max_steer_angle;
				else if(t.angular.z &lt; -m_CarInfo.max_steer_angle)
					t.angular.z = -m_CarInfo.max_steer_angle;

				twist.twist = t;
				twist.header.stamp = ros::Time::now();

				pub_VehicleCommand.publish(twist);
			}
			else if(m_CmdParams.statusSource == SIMULATION_STATUS)
			{
			}

			displayFollowingInfo(m_CurrentPos, m_PerpPoint, m_FollowPoint);

			std_msgs::Float32 vel_rviz;
			vel_rviz.data = m_CurrVehicleStatus.speed;
			pub_VelocityRviz.publish(vel_rviz);

		}

		 if (m_CmdParams.iMapping == 1 &amp;&amp; bNewCurrentPos == true)
		 {
			 bNewCurrentPos = false;
			double _d = hypot(m_CurrentPos.pos.y - p2.pos.y, m_CurrentPos.pos.x - p2.pos.x);
			if(_d &gt; m_CmdParams.recordDensity)
			{
				p2 = m_CurrentPos;

				if(path.size() &gt; 0)
					totalDistance += _d;

				m_CurrentPos.pos.lat = m_CurrentPos.pos.x;
				m_CurrentPos.pos.lon = m_CurrentPos.pos.y;
				m_CurrentPos.pos.alt = m_CurrentPos.pos.z;
				m_CurrentPos.pos.dir = m_CurrentPos.pos.a;

				m_CurrentPos.laneId = 1;
				m_CurrentPos.id = path.size()+1;
				if(path.size() &gt; 0)
				{
					path.at(path.size()-1).toIds.push_back(m_CurrentPos.id);
					m_CurrentPos.fromIds.clear();
					m_CurrentPos.fromIds.push_back(path.at(path.size()-1).id);
				}

				path.push_back(m_CurrentPos);
				std::cout &lt;&lt; &quot;Record One Point To Path: &quot; &lt;&lt;  m_CurrentPos.pos.ToString() &lt;&lt; std::endl;
			}

			if(totalDistance &gt; m_CmdParams.recordDistance || m_bOutsideControl != 0)
			{
				PlannerHNS::RoadNetwork roadMap;
				PlannerHNS::RoadSegment segment;

				segment.id = 1;

				PlannerHNS::Lane lane;
				lane.id = 1;
				lane.num = 0;
				lane.roadId = 1;
				lane.points = path;

				segment.Lanes.push_back(lane);
				roadMap.roadSegments.push_back(segment);

				ostringstream fileName;
				fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName;
				fileName &lt;&lt; UtilityHNS:: UtilityH::GetFilePrefixHourMinuteSeconds();
				fileName &lt;&lt; &quot;_RoadNetwork.kml&quot;;
				string kml_templateFilePath = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName + UtilityHNS::DataRW::KmlMapsFolderName+&quot;PlannerX_MapTemplate.kml&quot;;

				PlannerHNS::MappingHelpers::WriteKML(fileName.str(),kml_templateFilePath , roadMap);

										//string kml_fileToSave =UtilityH::GetHomeDirectory()+DataRW::LoggingMainfolderName + DataRW::KmlMapsFolderName+kmltargetFile;
					//PlannerHNS::MappingHelpers::WriteKML(kml_fileToSave, kml_templateFilePath, m_RoadMap);

				std::cout &lt;&lt; &quot; Mapped Saved Successfuly ... &quot; &lt;&lt; std::endl;
				break;
			}
		 }

		loop_rate.sleep();
	}
}

}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/op_simulator/include/PolygonGenerator.h" new_path="ros/src/computing/planning/motion/packages/op_simulator/include/PolygonGenerator.h">
				<diff>@@ -8,6 +8,10 @@
 #ifndef POLYGONGENERATORSIMU_H_
 #define POLYGONGENERATORSIMU_H_
 
+#include &quot;RoadNetwork.h&quot;
+#include &quot;PlanningHelpers.h&quot;
+
+
 #include &lt;sensor_msgs/PointCloud2.h&gt;
 #include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;pcl_conversions/pcl_conversions.h&gt;
@@ -15,8 +19,6 @@
 #include &lt;pcl/io/pcd_io.h&gt;
 #include &lt;pcl/point_types.h&gt;
 
-#include &lt;RoadNetwork.h&gt;
-
 namespace OpenPlannerSimulatorNS
 {
 
</diff>
				<old_file>/*
 * PolygonGenerator.h
 *
 *  Created on: Nov 2, 2016
 *      Author: ai-driver
 */

#ifndef POLYGONGENERATORSIMU_H_
#define POLYGONGENERATORSIMU_H_

#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;visualization_msgs/Marker.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;

#include &lt;RoadNetwork.h&gt;

namespace OpenPlannerSimulatorNS
{

using namespace PlannerHNS;

#define QUARTERS_NUMBER 8
#define MIN_POINTS_PER_QUARTER 1
#define MIN_DISTANCE_BETWEEN_CORNERS 0.5

class QuarterView
{
public:
	int id;
	int min_ang;
	int max_ang;
	std::vector&lt;WayPoint&gt; vectorsFromCenter;

	QuarterView(const int&amp; min_a, const int&amp; max_a, const int&amp; index)
	{
		min_ang = min_a;
		max_ang = max_a;
		id = index;
	}

	void InitQuarterView(const int&amp; min_a, const int&amp; max_a, const int&amp; index)
	{
		min_ang = min_a;
		max_ang = max_a;
		id = index;
	}

	bool UpdateQuarterView(const WayPoint&amp; v)
	{
		if(v.pos.a &lt;= min_ang || v.pos.a &gt; max_ang)
			return false;

		bool bGreaterFound = false;
		unsigned int greaterIndex = 0;
		for(unsigned int i=0; i&lt; vectorsFromCenter.size(); i++)
		{
			if(vectorsFromCenter.at(i).cost &gt; v.cost)
			{
				bGreaterFound = true;
				greaterIndex = i;
				break;
			}
		}

		if(bGreaterFound)
		{
			if(greaterIndex &lt; vectorsFromCenter.size())
				vectorsFromCenter.insert(vectorsFromCenter.begin()+greaterIndex, v);
			else
				vectorsFromCenter.push_back(v);
		}
		else
			vectorsFromCenter.push_back(v);

		return true;

	}

	bool GetMaxPoint(WayPoint&amp; maxPoint)
	{
		if(vectorsFromCenter.size()==0)
			return false;

		maxPoint = vectorsFromCenter.at(vectorsFromCenter.size()-1);
		return vectorsFromCenter.size();
	}

	int GetPointsNumber()
	{
		return vectorsFromCenter.size();
	}
};

class PolygonGenerator
{

public:

	GPSPoint m_Centroid;
	PolygonGenerator();
	virtual ~PolygonGenerator();
	void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon);
	GPSPoint CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster);
	std::vector&lt;QuarterView&gt; CreateQuarterViews(const int&amp; nResolution);
	std::vector&lt;GPSPoint&gt; EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid );
};

} /* namespace PlannerSimulator */

#endif /* POLYGONGENERATOR_H_ */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/op_simulator/nodes/OpenPlannerSimulator_core.cpp" new_path="ros/src/computing/planning/motion/packages/op_simulator/nodes/OpenPlannerSimulator_core.cpp">
				<diff>@@ -29,7 +29,7 @@
 */
 #include &quot;../include/OpenPlannerSimulator_core.h&quot;
 
-#include &quot;geo_pos_conv.hh&quot;
+
 #include &quot;UtilityH.h&quot;
 #include &quot;math.h&quot;
 #include &quot;MatrixOperations.h&quot;
@@ -633,7 +633,8 @@ void OpenPlannerSimulator::PlannerMainLoop()
 			}
 
 			//Local Planning
-			currBehavior = m_LocalPlanner.DoOneStep(dt, currStatus, m_TrackedClusters, 1, m_Map, 0, 1, true);
+			std::vector&lt;TrafficLight&gt; trafficLight;
+			currBehavior = m_LocalPlanner.DoOneStep(dt, currStatus, m_TrackedClusters, 1, m_Map, 0, trafficLight, true);
 
 			 //Odometry Simulation and Update
 			m_LocalPlanner.SetSimulatedTargetOdometryReadings(desiredStatus.speed, desiredStatus.steer, desiredStatus.shift);
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include &quot;../include/OpenPlannerSimulator_core.h&quot;

#include &quot;geo_pos_conv.hh&quot;
#include &quot;UtilityH.h&quot;
#include &quot;math.h&quot;
#include &quot;MatrixOperations.h&quot;
#include &lt;geometry_msgs/PoseArray.h&gt;
#include &quot;PolygonGenerator.h&quot;

using namespace std;

namespace OpenPlannerSimulatorNS
{

#define REPLANNING_DISTANCE 20
#define PLANNING_DISTANCE 50

OpenPlannerSimulator::OpenPlannerSimulator()
{

	m_bMap = false;
	bNewClusters = false;

	int iSource = 0;
	ros::NodeHandle nh(&quot;~&quot;);
	nh.getParam(&quot;mapSource&quot; 			, iSource);
	if(iSource == 0)
		m_SimParams.mapSource = MAP_AUTOWARE;
	else if (iSource == 1)
		m_SimParams.mapSource = MAP_FOLDER;
	else if(iSource == 2)
		m_SimParams.mapSource = MAP_KML_FILE;

	nh.getParam(&quot;mapFileName&quot; 		, m_SimParams.KmlMapPath);
	nh.getParam(&quot;id&quot; 		, m_SimParams.strID);
	nh.getParam(&quot;id&quot; 		, m_SimParams.id);
	nh.getParam(&quot;enableRvizPoseEst&quot; 	, m_SimParams.bRandomStart);
	nh.getParam(&quot;enableLooper&quot; 			, m_SimParams.bLooper);
	nh.getParam(&quot;startPoseX&quot; 			, m_SimParams.startPose.pos.x);
	nh.getParam(&quot;startPoseY&quot; 			, m_SimParams.startPose.pos.y);
	nh.getParam(&quot;startPoseA&quot; 			, m_SimParams.startPose.pos.a);

	nh.getParam(&quot;meshPath&quot; 				, m_SimParams.meshPath);
	nh.getParam(&quot;baseColorR&quot; 			, m_SimParams.modelColor.r);
	nh.getParam(&quot;baseColorG&quot; 			, m_SimParams.modelColor.g);
	nh.getParam(&quot;baseColorB&quot; 			, m_SimParams.modelColor.b);

	nh.getParam(&quot;logFolder&quot; 			, m_SimParams.logPath);

	ReadParamFromLaunchFile(m_CarInfo, m_ControlParams);

	tf::StampedTransform transform;
	GetTransformFromTF(&quot;map&quot;, &quot;world&quot;, transform);
	ROS_INFO(&quot;Origin : x=%f, y=%f, z=%f&quot;, transform.getOrigin().x(),transform.getOrigin().y(), transform.getOrigin().z());

	m_OriginPos.position.x  = transform.getOrigin().x();
	m_OriginPos.position.y  = transform.getOrigin().y();
	m_OriginPos.position.z  = transform.getOrigin().z();


	m_ObstacleTracking.m_MAX_ASSOCIATION_DISTANCE = 6.0;
	m_ObstacleTracking.m_MAX_TRACKS_AFTER_LOSING = 5;
	m_ObstacleTracking.m_DT = 0.12;
	m_ObstacleTracking.m_bUseCenterOnly = true;

	m_PredControl.Init(m_ControlParams, m_CarInfo, false, false);

	m_LocalPlanner.Init(m_ControlParams, m_PlanningParams, m_CarInfo);
	m_LocalPlanner.m_SimulationSteeringDelayFactor = 0.2;

	//For rviz visualization
	std::ostringstream str_s1, str_s2, str_s3, str_s4, str_s5, str_s6;
	str_s1 &lt;&lt; &quot;curr_simu_pose_&quot;;
	str_s1 &lt;&lt; m_SimParams.id;

	str_s2 &lt;&lt; &quot;sim_beh_txt_&quot; &lt;&lt; m_SimParams.id;

	str_s5 &lt;&lt; &quot;sim_box_pose_&quot;;
	str_s5 &lt;&lt; m_SimParams.id;

	str_s3 &lt;&lt; &quot;sim_velocity_&quot;;
	str_s3 &lt;&lt; m_SimParams.id;

	str_s4 &lt;&lt; &quot;safety_border_&quot;;
	str_s4 &lt;&lt; m_SimParams.id;

	str_s6 &lt;&lt; &quot;simu_local_trajectory_&quot;;
	str_s6 &lt;&lt; m_SimParams.id;

	pub_CurrPoseRviz			= nh.advertise&lt;visualization_msgs::Marker&gt;(str_s1.str() , 100);
	pub_SimuBoxPose				= nh.advertise&lt;geometry_msgs::PoseArray&gt;(str_s5.str(), 100);
	//pub_SimuVelocity			= nh.advertise&lt;geometry_msgs::TwistStamped&gt;(str_s3.str(), 100);
	pub_SafetyBorderRviz  		= nh.advertise&lt;visualization_msgs::Marker&gt;(str_s4.str(), 1);
	pub_LocalTrajectoriesRviz   = nh.advertise&lt;visualization_msgs::MarkerArray&gt;(str_s6.str(), 1);
	pub_BehaviorStateRviz		= nh.advertise&lt;visualization_msgs::Marker&gt;(str_s2.str(), 1);

	// define subscribers.
	if(m_SimParams.bRandomStart)
	{
		bInitPos = false;
		sub_initialpose 		= nh.subscribe(&quot;/initialpose&quot;, 		100, &amp;OpenPlannerSimulator::callbackGetInitPose, 		this);
	}
	else
	{
		bInitPos = true;
		PlannerHNS::WayPoint start_p;
		if(LoadSimulationData(start_p))
		{
			m_SimParams.startPose.pos = start_p.pos;
			m_CarInfo.max_speed_forward = start_p.v;
		}

		//InitializeSimuCar(m_SimParams.startPose);
	}

	sub_cloudClusters 		= nh.subscribe(&quot;/cloud_clusters&quot;, 	1, &amp;OpenPlannerSimulator::callbackGetCloudClusters, 		this);

	UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);
	std::cout &lt;&lt; &quot;OpenPlannerSimulator initialized successfully &quot; &lt;&lt; std::endl;
}

void OpenPlannerSimulator::ReadParamFromLaunchFile(PlannerHNS::CAR_BASIC_INFO&amp; m_CarInfo,
		PlannerHNS::ControllerParams&amp; m_ControlParams)
{
	ros::NodeHandle nh(&quot;~&quot;);
	nh.getParam(&quot;width&quot;, 			m_CarInfo.width );
	nh.getParam(&quot;length&quot;, 		m_CarInfo.length );
	nh.getParam(&quot;wheelBaseLength&quot;, m_CarInfo.wheel_base );
	nh.getParam(&quot;turningRadius&quot;, m_CarInfo.turning_radius );
	nh.getParam(&quot;maxSteerAngle&quot;, m_CarInfo.max_steer_angle );

	nh.getParam(&quot;maxVelocity&quot;, m_CarInfo.max_speed_forward );
	nh.getParam(&quot;minVelocity&quot;, m_CarInfo.min_speed_forward );
	nh.getParam(&quot;minVelocity&quot;, m_CarInfo.max_speed_backword );
	nh.getParam(&quot;maxAcceleration&quot;, m_CarInfo.max_acceleration );
	nh.getParam(&quot;maxDeceleration&quot;, m_CarInfo.max_deceleration );

	nh.getParam(&quot;steeringDelay&quot;, m_ControlParams.SteeringDelay );
	nh.getParam(&quot;minPursuiteDistance&quot;, m_ControlParams.minPursuiteDistance );

	m_ControlParams.Steering_Gain = PlannerHNS::PID_CONST(0.07, 0.02, 0.01); // for 3 m/s

	m_PlanningParams.maxSpeed = m_CarInfo.max_speed_forward;
	m_PlanningParams.minSpeed = m_CarInfo.min_speed_forward;
	m_PlanningParams.enableFollowing = true;
	m_PlanningParams.enableHeadingSmoothing = false;
	m_PlanningParams.enableLaneChange = false;
	m_PlanningParams.enableStopSignBehavior = false;
	m_PlanningParams.enableSwerving = false;
	m_PlanningParams.enableTrafficLightBehavior = false;
	m_PlanningParams.horizonDistance = 100;
	m_PlanningParams.horizontalSafetyDistancel = 0.1;
	m_PlanningParams.verticalSafetyDistance = 0.8;
	m_PlanningParams.maxDistanceToAvoid = 2;
	m_PlanningParams.microPlanDistance = 50;
	m_PlanningParams.minDistanceToAvoid = 4;
	m_PlanningParams.minFollowingDistance = 7;
	m_PlanningParams.pathDensity = 0.5;
	m_PlanningParams.planningDistance = 1000;
	m_PlanningParams.carTipMargin = 2;
	m_PlanningParams.rollInMargin = 10;
	m_PlanningParams.rollOutDensity = 0.5;
	m_PlanningParams.rollOutNumber = 0;

}

OpenPlannerSimulator::~OpenPlannerSimulator()
{
}

void OpenPlannerSimulator::callbackGetInitPose(const geometry_msgs::PoseWithCovarianceStampedConstPtr&amp; msg)
{
	if(!bInitPos)
	{
		ROS_INFO(&quot;init Simulation Rviz Pose Data: x=%f, y=%f, z=%f, freq=%d&quot;, msg-&gt;pose.pose.position.x, msg-&gt;pose.pose.position.y, msg-&gt;pose.pose.position.z);

		geometry_msgs::Pose p;
		p.position.x  = msg-&gt;pose.pose.position.x + m_OriginPos.position.x;
		p.position.y  = msg-&gt;pose.pose.position.y + m_OriginPos.position.y;
		p.position.z  = msg-&gt;pose.pose.position.z + m_OriginPos.position.z;
		p.orientation = msg-&gt;pose.pose.orientation;
		m_SimParams.startPose =  PlannerHNS::WayPoint(p.position.x, p.position.y, p.position.z , tf::getYaw(p.orientation));

		SaveSimulationData();

		InitializeSimuCar(m_SimParams.startPose);

		bInitPos = true;
	}
}

void OpenPlannerSimulator::InitializeSimuCar(PlannerHNS::WayPoint start_pose)
{
	m_LocalPlanner.m_pCurrentBehaviorState = m_LocalPlanner.m_pInitState;
	m_LocalPlanner.m_TotalPath.clear();
	m_LocalPlanner.m_Path.clear();
	m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_Behavior = PlannerHNS::INITIAL_STATE;
	m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bOutsideControl = 1;
	m_LocalPlanner.FirstLocalizeMe(start_pose);
	m_LocalPlanner.LocalizeMe(0);

	cout &lt;&lt; endl &lt;&lt; &quot;LocalPlannerInit: ID &quot; &lt;&lt; m_SimParams.strID &lt;&lt; &quot; , Pose = ( &quot;  &lt;&lt; start_pose.pos.ToString() &lt;&lt; &quot;)&quot; &lt;&lt; endl;
}

void OpenPlannerSimulator::GetTransformFromTF(const std::string parent_frame, const std::string child_frame, tf::StampedTransform &amp;transform)
{
	static tf::TransformListener listener;

	while (1)
	{
		try
		{
			listener.lookupTransform(parent_frame, child_frame, ros::Time(0), transform);
			break;
		}
		catch (tf::TransformException&amp; ex)
		{
			ROS_ERROR(&quot;%s&quot;, ex.what());
			ros::Duration(1.0).sleep();
		}
	}
}

void OpenPlannerSimulator::callbackGetCloudClusters(const autoware_msgs::CloudClusterArrayConstPtr&amp; msg)
{
	m_OriginalClusters.clear();
	int nOriginalPoints=0, nContourPoints = 0;

	ConvertFromAutowareCloudClusterObstaclesToPlannerH(m_LocalPlanner.state, m_LocalPlanner.m_CarInfo, *msg, m_OriginalClusters, nOriginalPoints, nContourPoints);
	//m_ObstacleTracking.DoOneStep(m_LocalPlanner.state, m_OriginalClusters);
	//m_TrackedClusters = m_ObstacleTracking.m_DetectedObjects;
	m_TrackedClusters = m_OriginalClusters;

	//m_nTrackObjects = m_TrackedClusters.size();
	//m_TrackingTime = UtilityHNS::UtilityH::GetTimeDiffNow(timerTemp);
	bNewClusters = true;
}

PlannerHNS::WayPoint OpenPlannerSimulator::GetRealCenter(const PlannerHNS::WayPoint&amp; currState)
{
	PlannerHNS::WayPoint pose_center = currState;
	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);

	PlannerHNS::Mat3 rotationMatInv(currState.pos.a);
	PlannerHNS::Mat3 translationMatInv(currState.pos.x, currState.pos.y);

	pose_center.pos = translationMat*pose_center.pos;
	pose_center.pos = rotationMat*pose_center.pos;

	pose_center.pos.x += m_CarInfo.wheel_base/3.0;

	pose_center.pos = rotationMatInv*pose_center.pos;
	pose_center.pos = translationMatInv*pose_center.pos;

	return pose_center;
}

void OpenPlannerSimulator::displayFollowingInfo(const std::vector&lt;PlannerHNS::GPSPoint&gt;&amp; safety_rect, PlannerHNS::WayPoint&amp; curr_pose)
{
  static visualization_msgs::Marker m1;
  m1.header.frame_id = &quot;map&quot;;
  m1.header.stamp = ros::Time();
  m1.ns = &quot;curr_simu_pose&quot;;
  //m1.type = visualization_msgs::Marker::ARROW;
  m1.type = visualization_msgs::Marker::MESH_RESOURCE;
  m1.mesh_resource = m_SimParams.meshPath;
  m1.mesh_use_embedded_materials = true;
  m1.action = visualization_msgs::Marker::ADD;

  PlannerHNS::WayPoint pose_center = GetRealCenter(curr_pose);

  m1.pose.position.x = pose_center.pos.x;
  m1.pose.position.y = pose_center.pos.y;
  m1.pose.position.z = pose_center.pos.z;

  m1.pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(curr_pose.pos.a));
  m1.color = m_SimParams.modelColor;
  m1.scale.x = 1.0*m_CarInfo.length/4.2;
  m1.scale.y = 1.0*m_CarInfo.width/1.85;
  m1.scale.z = 1.0;
  m1.frame_locked = true;
  pub_CurrPoseRviz.publish(m1);

  visualization_msgs::Marker lane_waypoint_marker;
  	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
  	lane_waypoint_marker.header.stamp = ros::Time();
  	lane_waypoint_marker.ns = &quot;safety_simu_box&quot;;
  	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
  	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;
  	lane_waypoint_marker.scale.x = 0.2;
  	lane_waypoint_marker.scale.y = 0.2;
  	//lane_waypoint_marker.scale.z = 0.1;
  	lane_waypoint_marker.frame_locked = false;
  	lane_waypoint_marker.color.r = 0.0;
  	lane_waypoint_marker.color.g = 1.0;
  	lane_waypoint_marker.color.b = 0.0;
  	lane_waypoint_marker.color.a = 0.6;

  	for(unsigned int i=0; i &lt; safety_rect.size(); i ++)
  	{
  		geometry_msgs::Point p1;
  		p1.x = safety_rect.at(i).x;
		p1.y = safety_rect.at(i).y;
		p1.z = safety_rect.at(i).z;
		lane_waypoint_marker.points.push_back(p1);
  	}
  	pub_SafetyBorderRviz.publish(lane_waypoint_marker);

}

void OpenPlannerSimulator::visualizePath(const std::vector&lt;PlannerHNS::WayPoint&gt;&amp; path)
{
	visualization_msgs::MarkerArray markerArray;

	visualization_msgs::Marker lane_waypoint_marker;
	lane_waypoint_marker.header.frame_id = &quot;map&quot;;
	lane_waypoint_marker.header.stamp = ros::Time();
	std::ostringstream str_sn;
	str_sn &lt;&lt; &quot;simu_car_path_&quot;;
	str_sn &lt;&lt; m_SimParams.id;
	lane_waypoint_marker.ns = str_sn.str();
	lane_waypoint_marker.type = visualization_msgs::Marker::LINE_STRIP;
	lane_waypoint_marker.action = visualization_msgs::Marker::ADD;


	std_msgs::ColorRGBA roll_color, curr_color;
	lane_waypoint_marker.points.clear();
	lane_waypoint_marker.id = 1;
	lane_waypoint_marker.scale.x = 0.1;
	lane_waypoint_marker.scale.y = 0.1;
	lane_waypoint_marker.color.a = 0.5;
	lane_waypoint_marker.color = m_SimParams.modelColor;
	lane_waypoint_marker.frame_locked = false;

	int count = 0;
	for (unsigned int i = 0; i &lt; path.size(); i++)
	{
		geometry_msgs::Point point;
		point.x = path.at(i).pos.x;
		point.y = path.at(i).pos.y;
		point.z = path.at(i).pos.z;

		lane_waypoint_marker.points.push_back(point);
		count++;
	}

	markerArray.markers.push_back(lane_waypoint_marker);

	pub_LocalTrajectoriesRviz.publish(markerArray);
}

void OpenPlannerSimulator::ConvertFromAutowareCloudClusterObstaclesToPlannerH(const PlannerHNS::WayPoint&amp; currState, const PlannerHNS::CAR_BASIC_INFO&amp; car_info,
		const autoware_msgs::CloudClusterArray&amp; clusters, std::vector&lt;PlannerHNS::DetectedObject&gt;&amp; obstacles_list,
		int&amp; nOriginalPoints, int&amp; nContourPoints)
{
	PlannerHNS::Mat3 rotationMat(-currState.pos.a);
	PlannerHNS::Mat3 translationMat(-currState.pos.x, -currState.pos.y);

	int nPoints = 0;
	int nOrPoints = 0;
	for(unsigned int i =0; i &lt; clusters.clusters.size(); i++)
	{
		if(clusters.clusters.at(i).id == m_SimParams.id)
		{
			//std::cout &lt;&lt; &quot;Skip Same ID &quot; &lt;&lt; std::endl;
			continue;
		}

		PolygonGenerator polyGen;
		PlannerHNS::DetectedObject obj;
		obj.center.pos = GPSPoint(clusters.clusters.at(i).centroid_point.point.x,
				clusters.clusters.at(i).centroid_point.point.y,
				clusters.clusters.at(i).centroid_point.point.z,0);
				//tf::getYaw(clusters.clusters.at(i).bounding_box.pose.orientation));

		pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;
		pcl::fromROSMsg(clusters.clusters.at(i).cloud, point_cloud);
		obj.contour = polyGen.EstimateClusterPolygon(point_cloud ,obj.center.pos);
		obj.w = clusters.clusters.at(i).dimensions.y;
		obj.l = clusters.clusters.at(i).dimensions.x;
		obj.h = clusters.clusters.at(i).dimensions.z;
		obj.id = 0;


		PlannerHNS::GPSPoint relative_point;
		relative_point = translationMat*obj.center.pos;
		relative_point = rotationMat*relative_point;

		double distance_x = fabs(relative_point.x);
		double distance_y = fabs(relative_point.y);

//		double size = (obj.w+obj.l)/2.0;
//		if(size &lt;= 0.25 || size &gt;= 5 || distance_y &gt; 20.0 || distance_x &gt; 20.0)
//			continue;

//		if(distance_x &lt;= car_info.length &amp;&amp; distance_y &lt;= car_info.width/1.5) // don't detect yourself
//			continue;


		nOrPoints += point_cloud.points.size();
		nPoints += obj.contour.size();
		//std::cout &lt;&lt; &quot; Distance_X: &quot; &lt;&lt; distance_x &lt;&lt; &quot;, &quot; &lt;&lt; &quot; Distance_Y: &quot; &lt;&lt; distance_y &lt;&lt; &quot;, &quot; &lt;&lt; &quot; Size: &quot; &lt;&lt; size &lt;&lt; std::endl;

		obstacles_list.push_back(obj);
	}

	nOriginalPoints = nOrPoints;
	nContourPoints =  nPoints;
}

void OpenPlannerSimulator::visualizeBehaviors()
{
	visualization_msgs::Marker behaviorMarker;
	behaviorMarker.header.frame_id = &quot;map&quot;;
	behaviorMarker.header.stamp = ros::Time();
	std::ostringstream str_sn;
	str_sn &lt;&lt; &quot;sim_behavior_&quot; &lt;&lt; m_SimParams.id;
	behaviorMarker.ns = str_sn.str();
	behaviorMarker.type = visualization_msgs::Marker::TEXT_VIEW_FACING;
	behaviorMarker.scale.z = 1.0;
	behaviorMarker.scale.x = 1.0;
	behaviorMarker.scale.y = 1.0;
	behaviorMarker.color.a = 1.0;
	behaviorMarker.frame_locked = false;

	behaviorMarker.color.r = 1.0;//trackedObstacles.at(i).center.v/16.0;
	behaviorMarker.color.g = 1.0;// - trackedObstacles.at(i).center.v/16.0;
	behaviorMarker.color.b = 1.0;

	geometry_msgs::Point point;

	point.x = m_LocalPlanner.state.pos.x;
	point.y = m_LocalPlanner.state.pos.y;
	point.z = m_LocalPlanner.state.pos.z+2.5;

	behaviorMarker.pose.position = point;

	behaviorMarker.id = 1;

	std::string str = &quot;Unknown&quot;;
	switch(m_LocalPlanner.m_pCurrentBehaviorState-&gt;m_Behavior)
	{
	case PlannerHNS::INITIAL_STATE:
		str = &quot;Init&quot;;
		break;
	case PlannerHNS::WAITING_STATE:
		str = &quot;Waiting&quot;;
		break;
	case PlannerHNS::FORWARD_STATE:
		str = &quot;Forward&quot;;
		break;
	case PlannerHNS::STOPPING_STATE:
		str = &quot;Stop&quot;;
		break;
	case PlannerHNS::FINISH_STATE:
		str = &quot;End&quot;;
		break;
	case PlannerHNS::FOLLOW_STATE:
		str = &quot;Follow&quot;;
		break;
	case PlannerHNS::OBSTACLE_AVOIDANCE_STATE:
		str = &quot;Swerving&quot;;
		break;
	case PlannerHNS::TRAFFIC_LIGHT_STOP_STATE:
		str = &quot;Light Stop&quot;;
		break;
	case PlannerHNS::TRAFFIC_LIGHT_WAIT_STATE:
		str = &quot;Light Wait&quot;;
		break;
	case PlannerHNS::STOP_SIGN_STOP_STATE:
		str = &quot;Sign Stop&quot;;
		break;
	case PlannerHNS::STOP_SIGN_WAIT_STATE:
		str = &quot;Sign Wait&quot;;
		break;
	default:
		str = &quot;Unknown&quot;;
		break;
	}

	std::ostringstream str_out;
	str_out &lt;&lt; str &lt;&lt; &quot;(&quot; &lt;&lt; m_SimParams.id &lt;&lt; &quot;)&quot; ;
	behaviorMarker.text = str_out.str();

	pub_BehaviorStateRviz.publish(behaviorMarker);
}

void OpenPlannerSimulator::SaveSimulationData()
{
	std::vector&lt;std::string&gt; simulationDataPoints;
	std::ostringstream startStr;
	startStr &lt;&lt; m_SimParams.startPose.pos.x &lt;&lt; &quot;,&quot; &lt;&lt; m_SimParams.startPose.pos.y &lt;&lt; &quot;,&quot; &lt;&lt; m_SimParams.startPose.pos.z &lt;&lt; &quot;,&quot; &lt;&lt; m_SimParams.startPose.pos.a &lt;&lt; &quot;,&quot;&lt;&lt; m_SimParams.startPose.cost &lt;&lt; &quot;,&quot; &lt;&lt; m_CarInfo.max_speed_forward &lt;&lt; &quot;,&quot;;
	simulationDataPoints.push_back(startStr.str());
	std::ostringstream goalStr;
	simulationDataPoints.push_back(goalStr.str());

	std::string header = &quot;X,Y,Z,A,C,V,&quot;;

	ostringstream fileName;
	fileName &lt;&lt; UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::SimulationFolderName;
	fileName &lt;&lt; &quot;SimuCar_&quot;;
	fileName &lt;&lt; m_SimParams.id;
	fileName &lt;&lt; &quot;.csv&quot;;

	std::ofstream f(fileName.str().c_str());

	if(f.is_open())
	{
		if(header.size() &gt; 0)
			f &lt;&lt; header &lt;&lt; &quot;\r\n&quot;;
		for(unsigned int i = 0 ; i &lt; simulationDataPoints.size(); i++)
			f &lt;&lt; simulationDataPoints.at(i) &lt;&lt; &quot;\r\n&quot;;
	}

	f.close();
}

bool OpenPlannerSimulator::LoadSimulationData(PlannerHNS::WayPoint&amp; start_p)
{
	ostringstream fileName;
	fileName &lt;&lt; &quot;SimuCar_&quot;;
	fileName &lt;&lt; m_SimParams.id;
	fileName &lt;&lt; &quot;.csv&quot;;

	string simuDataFileName = UtilityHNS::UtilityH::GetHomeDirectory()+UtilityHNS::DataRW::LoggingMainfolderName+UtilityHNS::DataRW::SimulationFolderName + fileName.str();
	UtilityHNS::SimulationFileReader sfr(simuDataFileName);
	UtilityHNS::SimulationFileReader::SimulationData data;

	if(sfr.ReadAllData(data) == 0)
		return false;

	start_p = PlannerHNS::WayPoint(data.startPoint.x, data.startPoint.y, data.startPoint.z, data.startPoint.a);
	start_p.v = data.startPoint.v;
	start_p.cost = data.startPoint.c;
	return true;
}

void OpenPlannerSimulator::PlannerMainLoop()
{

	ros::Rate loop_rate(100);
	//PlannerHNS::WayPoint defaultStart(3704.15014648,-99459.0743942, 88, 3.12940141294);
	PlannerHNS::BehaviorState currBehavior;
	PlannerHNS::VehicleState  currStatus;
	PlannerHNS::VehicleState  desiredStatus;

	while (ros::ok())
	{
		ros::spinOnce();

		bool bMakeNewPlan = false;

		if(m_SimParams.mapSource == MAP_KML_FILE &amp;&amp; !m_bMap)
		{
			m_bMap = true;
			PlannerHNS::MappingHelpers::LoadKML(m_SimParams.KmlMapPath, m_Map);
			if(!m_SimParams.bRandomStart)
				InitializeSimuCar(m_SimParams.startPose);
		}
		else if (m_SimParams.mapSource == MAP_FOLDER &amp;&amp; !m_bMap)
		{
			m_bMap = true;
			PlannerHNS::MappingHelpers::ConstructRoadNetworkFromDataFiles(m_SimParams.KmlMapPath, m_Map, true);
			if(!m_SimParams.bRandomStart)
				InitializeSimuCar(m_SimParams.startPose);
		}

		if(m_bMap &amp;&amp; bInitPos)
		{
			double dt  = UtilityHNS::UtilityH::GetTimeDiffNow(m_PlanningTimer);
			UtilityHNS::UtilityH::GetTickCount(m_PlanningTimer);

			//Global Planning Step
			if(m_LocalPlanner.m_TotalPath.size() &gt; 0 &amp;&amp; m_LocalPlanner.m_TotalPath.at(0).size() &gt; 3)
			{
				PlannerHNS::RelativeInfo info;
				bool ret = PlannerHNS::PlanningHelpers::GetRelativeInfoRange(m_LocalPlanner.m_TotalPath, m_LocalPlanner.state, 0.75, info);
				if(ret == true &amp;&amp; info.iGlobalPath &gt;= 0 &amp;&amp;  info.iGlobalPath &lt; m_LocalPlanner.m_TotalPath.size() &amp;&amp; info.iFront &gt; 0 &amp;&amp; info.iFront &lt; m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).size())
				{
					double remaining_distance =  m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).at(m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).size()-1).cost - (m_LocalPlanner.m_TotalPath.at(info.iGlobalPath).at(info.iFront).cost + info.to_front_distance);
					if(remaining_distance &lt;= REPLANNING_DISTANCE)
					{
						bMakeNewPlan = true;
						if(m_SimParams.bLooper)
							InitializeSimuCar(m_SimParams.startPose);
					}
				}
			}
			else
				bMakeNewPlan = true;

			if(bMakeNewPlan)
			{
				std::vector&lt;std::vector&lt;PlannerHNS::WayPoint&gt; &gt; generatedTotalPaths;
				double ret = m_GlobalPlanner.PlanUsingDPRandom(m_LocalPlanner.state, PLANNING_DISTANCE, m_Map, generatedTotalPaths);
				for(unsigned int i=0; i &lt; generatedTotalPaths.size(); i++)
				{
					PlannerHNS::PlanningHelpers::CalcAngleAndCost(generatedTotalPaths.at(i));
				}

				m_LocalPlanner.m_TotalPath = generatedTotalPaths;
				m_LocalPlanner.m_pCurrentBehaviorState-&gt;GetCalcParams()-&gt;bNewGlobalPath = true;
			}

			//Local Planning
			currBehavior = m_LocalPlanner.DoOneStep(dt, currStatus, m_TrackedClusters, 1, m_Map, 0, 1, true);

			 //Odometry Simulation and Update
			m_LocalPlanner.SetSimulatedTargetOdometryReadings(desiredStatus.speed, desiredStatus.steer, desiredStatus.shift);
			m_LocalPlanner.UpdateState(desiredStatus, false);
			m_LocalPlanner.LocalizeMe(dt);
			currStatus.shift = desiredStatus.shift;
			currStatus.steer = m_LocalPlanner.m_CurrentSteering;
			currStatus.speed = m_LocalPlanner.m_CurrentVelocity;


			//Path Following and Control
			desiredStatus = m_PredControl.DoOneStep(dt, currBehavior, m_LocalPlanner.m_Path, m_LocalPlanner.state, currStatus, currBehavior.bNewPlan);

			displayFollowingInfo(m_LocalPlanner.m_TrajectoryCostsCalculatotor.m_SafetyBorder.points, m_LocalPlanner.state);
			visualizePath(m_LocalPlanner.m_Path);
			visualizeBehaviors();


			geometry_msgs::PoseArray sim_data;
			geometry_msgs::Pose p_id, p_pose, p_box;


			sim_data.header.frame_id = &quot;map&quot;;
			sim_data.header.stamp = ros::Time();

			p_id.position.x = m_SimParams.id;

			PlannerHNS::WayPoint pose_center = GetRealCenter(m_LocalPlanner.state);

			p_pose.orientation = tf::createQuaternionMsgFromRollPitchYaw(0, 0, UtilityHNS::UtilityH::SplitPositiveAngle(pose_center.pos.a));
			p_pose.position.x = pose_center.pos.x;
			p_pose.position.y = pose_center.pos.y;
			p_pose.position.z = pose_center.pos.z;



			p_box.position.x = m_CarInfo.width;
			p_box.position.y = m_CarInfo.length;
			p_box.position.z = 2.2;

			sim_data.poses.push_back(p_id);
			sim_data.poses.push_back(p_pose);
			sim_data.poses.push_back(p_box);

			pub_SimuBoxPose.publish(sim_data);

			if(currBehavior.bNewPlan)
			{
				std::ostringstream str_out;
				str_out &lt;&lt; m_SimParams.logPath;
				str_out &lt;&lt; &quot;LocalPath_&quot;;
				PlannerHNS::PlanningHelpers::WritePathToFile(str_out.str(),  m_LocalPlanner.m_Path);
			}

			if(m_SimParams.bLooper &amp;&amp; currBehavior.state == PlannerHNS::FINISH_STATE)
			{
				InitializeSimuCar(m_SimParams.startPose);
			}
		}

		loop_rate.sleep();
	}
}

}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/op_simulator/nodes/PolygonGenerator.cpp" new_path="ros/src/computing/planning/motion/packages/op_simulator/nodes/PolygonGenerator.cpp">
				<diff>@@ -5,8 +5,9 @@
  *      Author: ai-driver
  */
 
+
 #include &quot;PolygonGenerator.h&quot;
-#include &quot;PlanningHelpers.h&quot;
+
 
 namespace OpenPlannerSimulatorNS
 {
@@ -49,9 +50,9 @@ std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointC
 		p.pos.y = cluster.points.at(i).y;
 		p.pos.z = original_centroid.z;
 
-		POINT2D v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y);
+		GPSPoint v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y, p.pos.z,0);
 		p.cost = pointNorm(v);
-		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*RAD2DEG;
+		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*(180. / M_PI);
 
 		for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
 		{
</diff>
				<old_file>/*
 * PolygonGenerator.cpp
 *
 *  Created on: Nov 2, 2016
 *      Author: ai-driver
 */

#include &quot;PolygonGenerator.h&quot;
#include &quot;PlanningHelpers.h&quot;

namespace OpenPlannerSimulatorNS
{


PolygonGenerator::PolygonGenerator() {
	// TODO Auto-generated constructor stub

}

PolygonGenerator::~PolygonGenerator() {
	// TODO Auto-generated destructor stub
}

GPSPoint PolygonGenerator::CalculateCentroid(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster)
{
	GPSPoint c;

	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
	{
		c.x += cluster.points.at(i).x;
		c.y += cluster.points.at(i).y;
	}

	c.x = c.x/cluster.points.size();
	c.y = c.y/cluster.points.size();

	return c;
}

std::vector&lt;GPSPoint&gt; PolygonGenerator::EstimateClusterPolygon(const pcl::PointCloud&lt;pcl::PointXYZ&gt;&amp; cluster, const GPSPoint&amp; original_centroid )
{
	std::vector&lt;QuarterView&gt; quarters = CreateQuarterViews(QUARTERS_NUMBER);


	for(unsigned int i=0; i&lt; cluster.points.size(); i++)
	{
		WayPoint p;
		p.pos.x = cluster.points.at(i).x;
		p.pos.y = cluster.points.at(i).y;
		p.pos.z = original_centroid.z;

		POINT2D v(p.pos.x - original_centroid.x , p.pos.y - original_centroid.y);
		p.cost = pointNorm(v);
		p.pos.a = UtilityHNS::UtilityH::FixNegativeAngle(atan2(v.y, v.x))*RAD2DEG;

		for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
		{
			if(quarters.at(j).UpdateQuarterView(p))
				break;
		}
	}

	std::vector&lt;GPSPoint&gt; polygon;

	for(unsigned int j = 0 ; j &lt; quarters.size(); j++)
	{

		WayPoint wp;
		int nPoints = quarters.at(j).GetMaxPoint(wp);
		if(nPoints &gt;= MIN_POINTS_PER_QUARTER)
		{
			polygon.push_back(wp.pos);
		}
	}

	//Fix Resolution:
	bool bChange = true;
	while (bChange &amp;&amp; polygon.size()&gt;1)
	{
		bChange = false;
		GPSPoint p1 =  polygon.at(polygon.size()-1);
		for(unsigned int i=0; i&lt; polygon.size(); i++)
		{
			GPSPoint p2 = polygon.at(i);
			double d = hypot(p2.y- p1.y, p2.x - p1.x);
			if(d &gt; MIN_DISTANCE_BETWEEN_CORNERS)
			{
				GPSPoint center_p = p1;
				center_p.x = (p2.x + p1.x)/2.0;
				center_p.y = (p2.y + p1.y)/2.0;
				polygon.insert(polygon.begin()+i, center_p);
				bChange = true;
				break;
			}

			p1 = p2;
		}
	}

	return polygon;

}

std::vector&lt;QuarterView&gt; PolygonGenerator::CreateQuarterViews(const int&amp; nResolution)
{
	std::vector&lt;QuarterView&gt; quarters;
	if(nResolution &lt;= 0)
		return quarters;

	double range = 360.0 / nResolution;
	double angle = 0;
	for(int i = 0; i &lt; nResolution; i++)
	{
		QuarterView q(angle, angle+range, i);
		quarters.push_back(q);
		angle+=range;
	}

	return quarters;
}

void CheckConvexPoligon(std::vector&lt;WayPoint&gt;&amp; polygon)
{

//	if(polygon.size() &lt;= 3)
//		return;
//
//	WayPoint p1 = polygon.at(0);
//	WayPoint p3;
//	WayPoint p2;
//
//	for(int i=1; i&lt; polygon.size()-1; i++)
//	{
//		p1 = polygon.at(i-1);
//		if(i+2 == polygon.size())
//		{
//			p2 = polygon.at(polygon.size()-1);
//			p3 = polygon.at(0);
//		}
//		else
//		{
//			p2 = polygon.at(i);
//			p3 = polygon.at(i+1);
//		}
//
//	}
}

} /* namespace PlannerXNS */
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/motion/packages/op_simulator_perception/nodes/OpenPlannerSimulatorPerception_core.cpp" new_path="ros/src/computing/planning/motion/packages/op_simulator_perception/nodes/OpenPlannerSimulatorPerception_core.cpp">
				<diff>@@ -29,7 +29,6 @@
 */
 #include &quot;../include/OpenPlannerSimulatorPerception_core.h&quot;
 
-#include &quot;geo_pos_conv.hh&quot;
 #include &quot;UtilityH.h&quot;
 #include &quot;math.h&quot;
 #include &quot;MatrixOperations.h&quot;
</diff>
				<old_file>/*
 *  Copyright (c) 2017, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
#include &quot;../include/OpenPlannerSimulatorPerception_core.h&quot;

#include &quot;geo_pos_conv.hh&quot;
#include &quot;UtilityH.h&quot;
#include &quot;math.h&quot;
#include &quot;MatrixOperations.h&quot;

#include &lt;pcl_conversions/pcl_conversions.h&gt;
#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;

using namespace std;

namespace OpenPlannerSimulatorPerceptionNS
{

OpenPlannerSimulatorPerception::OpenPlannerSimulatorPerception()
{
	nh.getParam(&quot;/op_simulator_perception/simObjNumber&quot; 			, m_DecParams.nSimuObjs);
	nh.getParam(&quot;/op_simulator_perception/GuassianErrorFactor&quot; 	, m_DecParams.errFactor);

	pub_DetectedObjects 	= nh.advertise&lt;autoware_msgs::CloudClusterArray&gt;(&quot;cloud_clusters&quot;,1);

	for(int i=1; i &lt;= m_DecParams.nSimuObjs; i++)
	{
		std::ostringstream str_pose;
		str_pose &lt;&lt; &quot;/op_simulator&quot; &lt;&lt; i &lt;&lt; &quot;/sim_box_pose_&quot; &lt;&lt; i;
		std::cout &lt;&lt; &quot;Subscribe to Topic : &quot; &lt;&lt;  str_pose.str() &lt;&lt;  std::endl;

		ros::Subscriber _sub;
		_sub =  nh.subscribe(str_pose.str(), 10, &amp;OpenPlannerSimulatorPerception::callbackGetSimuData, 		this);
		sub_objs.push_back(_sub);
	}

	ros::Subscriber _sub;
	_sub =  nh.subscribe(&quot;/sim_box_pose_ego&quot;, 10, &amp;OpenPlannerSimulatorPerception::callbackGetSimuData, 		this);
	sub_objs.push_back(_sub);

	std::cout &lt;&lt; &quot;OpenPlannerSimulatorPerception initialized successfully &quot; &lt;&lt; std::endl;

}

OpenPlannerSimulatorPerception::~OpenPlannerSimulatorPerception()
{
}

void OpenPlannerSimulatorPerception::callbackGetSimuData(const geometry_msgs::PoseArray &amp;msg)
{
	int obj_id = -1;
	if(msg.poses.size() &gt; 0 )
	{
		obj_id = msg.poses.at(0).position.x;

	}

//	ROS_INFO(&quot;Obj ID = %d&quot;, obj_id);

	if(obj_id &lt; 0)
		return;

	int index = -1;
	for(int i = 0; i &lt; m_ObjClustersArray.clusters.size() ; i++ )
	{
		if(m_ObjClustersArray.clusters.at(i).id == obj_id)
		{
			index = i;
			break;
		}
	}

	autoware_msgs::CloudCluster c = GenerateSimulatedObstacleCluster(msg.poses.at(2).position.y, msg.poses.at(2).position.x, msg.poses.at(2).position.y, 50, msg.poses.at(1));
	c.id = obj_id;

	if(index &gt;= 0) // update existing
	{
		m_ObjClustersArray.clusters.at(index) = c;
		m_keepTime.at(index).second = 10;
	//	ROS_INFO(&quot;Update Obj ID = %d&quot;, c.id);
	}
	else
	{
		m_ObjClustersArray.clusters.push_back(c);
		m_keepTime.push_back(make_pair(c.id, 10));
	//	ROS_INFO(&quot;Insert Obj ID = %d&quot;, c.id);
	}

//	geometry_msgs::Pose p;
//	p.position.x  = msg-&gt;pose.position.x + m_OriginPos.position.x;
//	p.position.y  = msg-&gt;pose.position.y + m_OriginPos.position.y;
//	p.position.z  = msg-&gt;pose.position.z + m_OriginPos.position.z;
//	p.orientation = msg-&gt;pose.orientation;

	//m_SimParams.startPose =  PlannerHNS::WayPoint(p.position.x, p.position.y, p.position.z , tf::getYaw(p.orientation));

}

autoware_msgs::CloudCluster OpenPlannerSimulatorPerception::GenerateSimulatedObstacleCluster(const double&amp; x_rand, const double&amp; y_rand, const double&amp; z_rand, const int&amp; nPoints, const geometry_msgs::Pose&amp; centerPose)
{
	autoware_msgs::CloudCluster cluster;

	cluster.centroid_point.point.x = centerPose.position.x;
	cluster.centroid_point.point.y = centerPose.position.y;
	cluster.centroid_point.point.z = centerPose.position.z;

	cluster.dimensions.x = x_rand;
	cluster.dimensions.y = y_rand;
	cluster.dimensions.z = z_rand;
	pcl::PointCloud&lt;pcl::PointXYZ&gt; point_cloud;

	timespec t;
	for(int i=1; i &lt; nPoints; i++)
	{
		UtilityHNS::UtilityH::GetTickCount(t);
		pcl::PointXYZ p;
		srand(t.tv_nsec/i);
		double x = (double)(rand()%100)/100.0 - 0.5;

		srand(t.tv_nsec/i*i);
		double y = (double)(rand()%100)/100.0 - 0.5;

		srand(t.tv_nsec);
		double z = (double)(rand()%100)/100.0 - 0.5;

		p.x = centerPose.position.x + x*x_rand;
		p.y = centerPose.position.y + y*y_rand;
		p.z = centerPose.position.z + z*z_rand;
		point_cloud.points.push_back(p);
	}

	pcl::toROSMsg(point_cloud, cluster.cloud);

	return cluster;
}

void OpenPlannerSimulatorPerception::MainLoop()
{

	ros::Rate loop_rate(15);

	while (ros::ok())
	{
		ros::spinOnce();

		if(m_ObjClustersArray.clusters.size()&gt;0)
			pub_DetectedObjects.publish(m_ObjClustersArray);

		//clean old data
		for(unsigned int i = 0 ; i &lt; m_keepTime.size(); i++)
		{
			if(m_keepTime.at(i).second &lt;= 0)
			{
				m_keepTime.erase(m_keepTime.begin()+i);
				m_ObjClustersArray.clusters.erase(m_ObjClustersArray.clusters.begin()+i);
				i--;
			}
			else
				m_keepTime.at(i).second -= 1;
		}

		std::cout &lt;&lt; &quot;Number of Obstacles: (&quot; &lt;&lt; m_keepTime.size() &lt;&lt; &quot;, &quot; &lt;&lt; m_ObjClustersArray.clusters.size() &lt;&lt; &quot;) &quot;&lt;&lt; std::endl;

		loop_rate.sleep();
	}
}

}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="9c0b00d6a6e5cd878600f0b6c698a32158eefffd" fix_time="0,0">
		<msg>Fix redeclaration error when compiling ndt_mapping.cpp and ndt_matching.cpp</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_mapping/ndt_mapping.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_mapping/ndt_mapping.cpp">
				<diff>@@ -67,14 +67,6 @@
 #endif
 
 
-#ifndef USE_FAST_PCL
-  #include &lt;fast_pcl/filters/voxel_grid.h&gt;
-  #include &lt;fast_pcl/registration/ndt.h&gt;
-#else
-  #include &lt;pcl/filters/voxel_grid.h&gt;
-  #include &lt;pcl/registration/ndt.h&gt;
-#endif
-
 #ifdef CUDA_FOUND
   #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization and mapping program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#define OUTPUT  // If you want to output &quot;position_log.txt&quot;, &quot;#define OUTPUT&quot;.

#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#ifdef USE_FAST_PCL
  #include &lt;fast_pcl/filters/voxel_grid.h&gt;
  #include &lt;fast_pcl/registration/ndt.h&gt;
#else
  #include &lt;pcl/filters/voxel_grid.h&gt;
  #include &lt;pcl/registration/ndt.h&gt;
#endif


#ifndef USE_FAST_PCL
  #include &lt;fast_pcl/filters/voxel_grid.h&gt;
  #include &lt;fast_pcl/registration/ndt.h&gt;
#else
  #include &lt;pcl/filters/voxel_grid.h&gt;
  #include &lt;pcl/registration/ndt.h&gt;
#endif

#ifdef CUDA_FOUND
  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
#endif


#include &lt;autoware_msgs/ConfigNdtMapping.h&gt;
#include &lt;autoware_msgs/ConfigNdtMappingOutput.h&gt;

#include &lt;time.h&gt;


#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
#include &lt;fast_pcl/filters/voxel_grid.h&gt; //??
#include &lt;fast_pcl/registration/ndt.h&gt;	//??


struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

// global variables
static pose previous_pose, guess_pose, guess_pose_imu, guess_pose_odom, guess_pose_imu_odom, current_pose,
    current_pose_imu, current_pose_odom, current_pose_imu_odom, ndt_pose, added_pose, localizer_pose;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;  // current_pose - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
    offset_imu_odom_yaw;

static double current_velocity_x = 0.0;
static double current_velocity_y = 0.0;
static double current_velocity_z = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static pcl::PointCloud&lt;pcl::PointXYZI&gt; map;

// Added for GPU ndt
#ifdef CUDA_FOUND
static gpu::GNormalDistributionsTransform gpu_ndt;
#endif

// Added for CPU ndt testing version
static cpu::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; cpu_ndt;

static pcl::NormalDistributionsTransform&lt;pcl::PointXYZI, pcl::PointXYZI&gt; ndt;
// end of adding

// Default values
static int max_iter = 30;        // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

// Leaf size of VoxelGrid filter.
static double voxel_leaf_size = 2.0;

static ros::Time callback_start, callback_end, t1_start, t1_end, t2_start, t2_end, t3_start, t3_end, t4_start, t4_end,
    t5_start, t5_end;
static ros::Duration d_callback, d1, d2, d3, d4, d5;

static ros::Publisher ndt_map_pub;
static ros::Publisher current_pose_pub;
static ros::Publisher guess_pose_linaer_pub;
static geometry_msgs::PoseStamped current_pose_msg, guess_pose_msg;

static ros::Publisher ndt_stat_pub;
static std_msgs::Bool ndt_stat_msg;

static int initial_scan_loaded = 0;

static Eigen::Matrix4f gnss_transform = Eigen::Matrix4f::Identity();

static double min_scan_range = 5.0;
static double min_add_scan_shift = 1.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol, tf_ltob;

static bool isMapUpdate = true;

#ifdef USE_FAST_PCL
static bool _use_openmp = false;
#endif
#ifdef CUDA_FOUND
static bool _use_gpu = false;
#endif

static bool _use_fast_pcl = false;

static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;

static double fitness_score;
static bool has_converged;
static int final_num_iteration;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;

static void param_callback(const autoware_msgs::ConfigNdtMapping::ConstPtr&amp; input)
{
  ndt_res = input-&gt;resolution;
  step_size = input-&gt;step_size;
  trans_eps = input-&gt;trans_epsilon;
  max_iter = input-&gt;max_iterations;
  voxel_leaf_size = input-&gt;leaf_size;
  min_scan_range = input-&gt;min_scan_range;
  min_add_scan_shift = input-&gt;min_add_scan_shift;

  std::cout &lt;&lt; &quot;param_callback&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;ndt_res: &quot; &lt;&lt; ndt_res &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;step_size: &quot; &lt;&lt; step_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;trans_epsilon: &quot; &lt;&lt; trans_eps &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;max_iter: &quot; &lt;&lt; max_iter &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;voxel_leaf_size: &quot; &lt;&lt; voxel_leaf_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;min_scan_range: &quot; &lt;&lt; min_scan_range &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;min_add_scan_shift: &quot; &lt;&lt; min_add_scan_shift &lt;&lt; std::endl;
}

static void output_callback(const autoware_msgs::ConfigNdtMappingOutput::ConstPtr&amp; input)
{
  double filter_res = input-&gt;filter_res;
  std::string filename = input-&gt;filename;
  std::cout &lt;&lt; &quot;output_callback&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;filter_res: &quot; &lt;&lt; filter_res &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;filename: &quot; &lt;&lt; filename &lt;&lt; std::endl;

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_filtered(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  map_ptr-&gt;header.frame_id = &quot;map&quot;;
  map_filtered-&gt;header.frame_id = &quot;map&quot;;
  sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);

  // Apply voxelgrid filter
  if (filter_res == 0.0)
  {
    std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    pcl::toROSMsg(*map_ptr, *map_msg_ptr);
  }
  else
  {
    pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
    voxel_grid_filter.setLeafSize(filter_res, filter_res, filter_res);
    voxel_grid_filter.setInputCloud(map_ptr);
    voxel_grid_filter.filter(*map_filtered);
    std::cout &lt;&lt; &quot;Original: &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Filtered: &quot; &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    pcl::toROSMsg(*map_filtered, *map_msg_ptr);
  }

  ndt_map_pub.publish(*map_msg_ptr);

  // Writing Point Cloud data to PCD file
  if (filter_res == 0.0)
  {
    pcl::io::savePCDFileASCII(filename, *map_ptr);
    std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; map_ptr-&gt;points.size() &lt;&lt; &quot; data points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
  }
  else
  {
    pcl::io::savePCDFileASCII(filename, *map_filtered);
    std::cout &lt;&lt; &quot;Saved &quot; &lt;&lt; map_filtered-&gt;points.size() &lt;&lt; &quot; data points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
  }
}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw += diff_imu_yaw;

  guess_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
  guess_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
  guess_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
  guess_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
  guess_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  guess_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;

  previous_time = current_time;
}

static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);

  offset_odom_roll += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw += diff_odom_yaw;

  guess_pose_odom.x = previous_pose.x + offset_odom_x;
  guess_pose_odom.y = previous_pose.y + offset_odom_y;
  guess_pose_odom.z = previous_pose.z + offset_odom_z;
  guess_pose_odom.roll = previous_pose.roll + offset_odom_roll;
  guess_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  guess_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;

  previous_time = current_time;
}

static void imu_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw += diff_imu_yaw;

  guess_pose_imu.x = previous_pose.x + offset_imu_x;
  guess_pose_imu.y = previous_pose.y + offset_imu_y;
  guess_pose_imu.z = previous_pose.z + offset_imu_z;
  guess_pose_imu.roll = previous_pose.roll + offset_imu_roll;
  guess_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  guess_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;

  previous_time = current_time;
}

static double wrapToPm(double a_num, const double a_max)
{
  if (a_num &gt;= a_max)
  {
    a_num -= 2.0 * a_max;
  }
  return a_num;
}

static double wrapToPmPi(double a_angle_rad)
{
  return wrapToPm(a_angle_rad, M_PI);
}

static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}

static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll *= -1;
  input_pitch *= -1;
  input_yaw *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}

static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if (_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time = (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll = imu_roll - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if (imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
    else
      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
  }
  else
    diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if (diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw = imu_yaw;
}

static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  double r;
  pcl::PointXYZI p;
  pcl::PointCloud&lt;pcl::PointXYZI&gt; tmp, scan;
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;());
  tf::Quaternion q;

  Eigen::Matrix4f t_localizer(Eigen::Matrix4f::Identity());
  Eigen::Matrix4f t_base_link(Eigen::Matrix4f::Identity());
  tf::TransformBroadcaster br;
  tf::Transform transform;

  current_scan_time = input-&gt;header.stamp;

  pcl::fromROSMsg(*input, tmp);

  for (pcl::PointCloud&lt;pcl::PointXYZI&gt;::const_iterator item = tmp.begin(); item != tmp.end(); item++)
  {
    p.x = (double)item-&gt;x;
    p.y = (double)item-&gt;y;
    p.z = (double)item-&gt;z;
    p.intensity = (double)item-&gt;intensity;

    r = sqrt(pow(p.x, 2.0) + pow(p.y, 2.0));
    if (r &gt; min_scan_range)
    {
      scan.push_back(p);
    }
  }

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(scan));

  // Add initial point cloud to velodyne_map
  if (initial_scan_loaded == 0)
  {
    pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, tf_btol);
    map += *transformed_scan_ptr;
    initial_scan_loaded = 1;
  }

  // Apply voxelgrid filter
  pcl::VoxelGrid&lt;pcl::PointXYZI&gt; voxel_grid_filter;
  voxel_grid_filter.setLeafSize(voxel_leaf_size, voxel_leaf_size, voxel_leaf_size);
  voxel_grid_filter.setInputCloud(scan_ptr);
  voxel_grid_filter.filter(*filtered_scan_ptr);

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZI&gt;(map));

#ifdef CUDA_FOUND
  if (_use_gpu == true)
  {
    gpu_ndt.setTransformationEpsilon(trans_eps);
    gpu_ndt.setStepSize(step_size);
    gpu_ndt.setResolution(ndt_res);
    gpu_ndt.setMaximumIterations(max_iter);
    gpu_ndt.setInputSource(filtered_scan_ptr);
  }
  else
#endif
  {
	  if (!_use_fast_pcl)
	  {
		ndt.setTransformationEpsilon(trans_eps);
		ndt.setStepSize(step_size);
		ndt.setResolution(ndt_res);
		ndt.setMaximumIterations(max_iter);
		ndt.setInputSource(filtered_scan_ptr);
	  }
	  else
	  {
		cpu_ndt.setTransformationEpsilon(trans_eps);
		cpu_ndt.setStepSize(step_size);
		cpu_ndt.setResolution(ndt_res);
		cpu_ndt.setMaximumIterations(max_iter);
		cpu_ndt.setInputSource(filtered_scan_ptr);
	  }
  }
  if (isMapUpdate == true)
  {
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setInputTarget(map_ptr);
    }
    else
    {
    	if (!_use_fast_pcl)
    	{
    		ndt.setInputTarget(map_ptr);
    	}
		else
		{
			cpu_ndt.setInputTarget(map_ptr);
		}
    }
#else
    	if (!_use_fast_pcl)
    	{
    		ndt.setInputTarget(map_ptr);
    	}
    	else
    	{
    		cpu_ndt.setInputTarget(map_ptr);
    	}
#endif

    isMapUpdate = false;
  }

  guess_pose.x = previous_pose.x + diff_x;
  guess_pose.y = previous_pose.y + diff_y;
  guess_pose.z = previous_pose.z + diff_z;
  guess_pose.roll = previous_pose.roll;
  guess_pose.pitch = previous_pose.pitch;
  guess_pose.yaw = previous_pose.yaw + diff_yaw;

  if (_use_imu == true &amp;&amp; _use_odom == true)
    imu_odom_calc(current_scan_time);
  if (_use_imu == true &amp;&amp; _use_odom == false)
    imu_calc(current_scan_time);
  if (_use_imu == false &amp;&amp; _use_odom == true)
    odom_calc(current_scan_time);

  pose guess_pose_for_ndt;
  if (_use_imu == true &amp;&amp; _use_odom == true)
    guess_pose_for_ndt = guess_pose_imu_odom;
  else if (_use_imu == true &amp;&amp; _use_odom == false)
    guess_pose_for_ndt = guess_pose_imu;
  else if (_use_imu == false &amp;&amp; _use_odom == true)
    guess_pose_for_ndt = guess_pose_odom;
  else
    guess_pose_for_ndt = guess_pose;

  Eigen::AngleAxisf init_rotation_x(guess_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
  Eigen::AngleAxisf init_rotation_y(guess_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf init_rotation_z(guess_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());

  Eigen::Translation3f init_translation(guess_pose_for_ndt.x, guess_pose_for_ndt.y, guess_pose_for_ndt.z);

  Eigen::Matrix4f init_guess =
      (init_translation * init_rotation_z * init_rotation_y * init_rotation_x).matrix() * tf_btol;

  t3_end = ros::Time::now();
  d3 = t3_end - t3_start;

  t4_start = ros::Time::now();

  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZI&gt;);

#ifdef CUDA_FOUND

  if (_use_gpu == true)
  {
    gpu_ndt.align(init_guess);
    t_localizer = gpu_ndt.getFinalTransformation();
    has_converged = gpu_ndt.hasConverged();
    fitness_score = gpu_ndt.getFitnessScore();
    final_num_iteration = gpu_ndt.getFinalNumIteration();
  }
#ifdef USE_FAST_PCL
  else if (_use_openmp == true)
  {
    ndt.omp_align(*output_cloud, init_guess);
    t_localizer = ndt.getFinalTransformation();
    has_converged = ndt.hasConverged();
    fitness_score = ndt.omp_getFitnessScore();
    final_num_iteration = ndt.getFinalNumIteration();
  }
#endif
  else
  {
	  if (!_use_fast_pcl)
	  {
		ndt.align(*output_cloud, init_guess);
		t_localizer = ndt.getFinalTransformation();
		has_converged = ndt.hasConverged();
		fitness_score = ndt.getFitnessScore();
		final_num_iteration = ndt.getFinalNumIteration();
	  }
	  else
	  {
		cpu_ndt.align(init_guess);
		t_localizer = cpu_ndt.getFinalTransformation();
		has_converged = cpu_ndt.hasConverged();
		fitness_score = cpu_ndt.getFitnessScore();
		final_num_iteration = cpu_ndt.getFinalNumIteration();
	  }
  }
#else
#ifdef USE_FAST_PCL
  if (_use_openmp == true)
  {

    ndt.omp_align(*output_cloud, init_guess);
    t_localizer = ndt.getFinalTransformation();
    has_converged = ndt.hasConverged();
    fitness_score = ndt.omp_getFitnessScore();
    final_num_iteration = ndt.getFinalNumIteration();
  }
  else
  {
#endif
	  if (!_use_fast_pcl)
	  {
		ndt.align(*output_cloud, init_guess);
		t_localizer = ndt.getFinalTransformation();
		has_converged = ndt.hasConverged();
		fitness_score = ndt.getFitnessScore();
		final_num_iteration = ndt.getFinalNumIteration();
	  }
	  else
	  {
		cpu_ndt.align(init_guess);
		t_localizer = cpu_ndt.getFinalTransformation();
		has_converged = cpu_ndt.hasConverged();
		fitness_score = cpu_ndt.getFitnessScore();
		final_num_iteration = cpu_ndt.getFinalNumIteration();
	  }
#ifdef USE_FAST_PCL
  }
#endif
#endif



  t_base_link = t_localizer * tf_ltob;

  pcl::transformPointCloud(*scan_ptr, *transformed_scan_ptr, t_localizer);

  tf::Matrix3x3 mat_l, mat_b;

  mat_l.setValue(static_cast&lt;double&gt;(t_localizer(0, 0)), static_cast&lt;double&gt;(t_localizer(0, 1)),
                 static_cast&lt;double&gt;(t_localizer(0, 2)), static_cast&lt;double&gt;(t_localizer(1, 0)),
                 static_cast&lt;double&gt;(t_localizer(1, 1)), static_cast&lt;double&gt;(t_localizer(1, 2)),
                 static_cast&lt;double&gt;(t_localizer(2, 0)), static_cast&lt;double&gt;(t_localizer(2, 1)),
                 static_cast&lt;double&gt;(t_localizer(2, 2)));

  mat_b.setValue(static_cast&lt;double&gt;(t_base_link(0, 0)), static_cast&lt;double&gt;(t_base_link(0, 1)),
                 static_cast&lt;double&gt;(t_base_link(0, 2)), static_cast&lt;double&gt;(t_base_link(1, 0)),
                 static_cast&lt;double&gt;(t_base_link(1, 1)), static_cast&lt;double&gt;(t_base_link(1, 2)),
                 static_cast&lt;double&gt;(t_base_link(2, 0)), static_cast&lt;double&gt;(t_base_link(2, 1)),
                 static_cast&lt;double&gt;(t_base_link(2, 2)));

  // Update localizer_pose.
  localizer_pose.x = t_localizer(0, 3);
  localizer_pose.y = t_localizer(1, 3);
  localizer_pose.z = t_localizer(2, 3);
  mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

  // Update ndt_pose.
  ndt_pose.x = t_base_link(0, 3);
  ndt_pose.y = t_base_link(1, 3);
  ndt_pose.z = t_base_link(2, 3);
  mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

  current_pose.x = ndt_pose.x;
  current_pose.y = ndt_pose.y;
  current_pose.z = ndt_pose.z;
  current_pose.roll = ndt_pose.roll;
  current_pose.pitch = ndt_pose.pitch;
  current_pose.yaw = ndt_pose.yaw;

  transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
  q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
  transform.setRotation(q);

  br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;map&quot;, &quot;base_link&quot;));

  scan_duration = current_scan_time - previous_scan_time;
  double secs = scan_duration.toSec();

  // Calculate the offset (curren_pos - previous_pos)
  diff_x = current_pose.x - previous_pose.x;
  diff_y = current_pose.y - previous_pose.y;
  diff_z = current_pose.z - previous_pose.z;
  diff_yaw = current_pose.yaw - previous_pose.yaw;
  diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

  current_velocity_x = diff_x / secs;
  current_velocity_y = diff_y / secs;
  current_velocity_z = diff_z / secs;

  current_pose_imu.x = current_pose.x;
  current_pose_imu.y = current_pose.y;
  current_pose_imu.z = current_pose.z;
  current_pose_imu.roll = current_pose.roll;
  current_pose_imu.pitch = current_pose.pitch;
  current_pose_imu.yaw = current_pose.yaw;

  current_pose_odom.x = current_pose.x;
  current_pose_odom.y = current_pose.y;
  current_pose_odom.z = current_pose.z;
  current_pose_odom.roll = current_pose.roll;
  current_pose_odom.pitch = current_pose.pitch;
  current_pose_odom.yaw = current_pose.yaw;

  current_pose_imu_odom.x = current_pose.x;
  current_pose_imu_odom.y = current_pose.y;
  current_pose_imu_odom.z = current_pose.z;
  current_pose_imu_odom.roll = current_pose.roll;
  current_pose_imu_odom.pitch = current_pose.pitch;
  current_pose_imu_odom.yaw = current_pose.yaw;

  current_velocity_imu_x = current_velocity_x;
  current_velocity_imu_y = current_velocity_y;
  current_velocity_imu_z = current_velocity_z;

  // Update position and posture. current_pos -&gt; previous_pos
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  previous_scan_time.sec = current_scan_time.sec;
  previous_scan_time.nsec = current_scan_time.nsec;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;

  // Calculate the shift between added_pos and current_pos
  double shift = sqrt(pow(current_pose.x - added_pose.x, 2.0) + pow(current_pose.y - added_pose.y, 2.0));
  if (shift &gt;= min_add_scan_shift)
  {
    map += *transformed_scan_ptr;
    added_pose.x = current_pose.x;
    added_pose.y = current_pose.y;
    added_pose.z = current_pose.z;
    added_pose.roll = current_pose.roll;
    added_pose.pitch = current_pose.pitch;
    added_pose.yaw = current_pose.yaw;
    isMapUpdate = true;
  }

  sensor_msgs::PointCloud2::Ptr map_msg_ptr(new sensor_msgs::PointCloud2);
  pcl::toROSMsg(*map_ptr, *map_msg_ptr);
  ndt_map_pub.publish(*map_msg_ptr);

  q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
  current_pose_msg.header.frame_id = &quot;map&quot;;
  current_pose_msg.header.stamp = current_scan_time;
  current_pose_msg.pose.position.x = current_pose.x;
  current_pose_msg.pose.position.y = current_pose.y;
  current_pose_msg.pose.position.z = current_pose.z;
  current_pose_msg.pose.orientation.x = q.x();
  current_pose_msg.pose.orientation.y = q.y();
  current_pose_msg.pose.orientation.z = q.z();
  current_pose_msg.pose.orientation.w = q.w();

  current_pose_pub.publish(current_pose_msg);

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Sequence number: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of scan points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of filtered scan points: &quot; &lt;&lt; filtered_scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;transformed_scan_ptr: &quot; &lt;&lt; transformed_scan_ptr-&gt;points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;map: &quot; &lt;&lt; map.points.size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; has_converged &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Fitness score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Number of iteration: &quot; &lt;&lt; final_num_iteration &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw):&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
            &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Transformation Matrix:&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; t_localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;shift: &quot; &lt;&lt; shift &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
}

int main(int argc, char** argv)
{
  previous_pose.x = 0.0;
  previous_pose.y = 0.0;
  previous_pose.z = 0.0;
  previous_pose.roll = 0.0;
  previous_pose.pitch = 0.0;
  previous_pose.yaw = 0.0;

  ndt_pose.x = 0.0;
  ndt_pose.y = 0.0;
  ndt_pose.z = 0.0;
  ndt_pose.roll = 0.0;
  ndt_pose.pitch = 0.0;
  ndt_pose.yaw = 0.0;

  current_pose.x = 0.0;
  current_pose.y = 0.0;
  current_pose.z = 0.0;
  current_pose.roll = 0.0;
  current_pose.pitch = 0.0;
  current_pose.yaw = 0.0;

  current_pose_imu.x = 0.0;
  current_pose_imu.y = 0.0;
  current_pose_imu.z = 0.0;
  current_pose_imu.roll = 0.0;
  current_pose_imu.pitch = 0.0;
  current_pose_imu.yaw = 0.0;

  guess_pose.x = 0.0;
  guess_pose.y = 0.0;
  guess_pose.z = 0.0;
  guess_pose.roll = 0.0;
  guess_pose.pitch = 0.0;
  guess_pose.yaw = 0.0;

  added_pose.x = 0.0;
  added_pose.y = 0.0;
  added_pose.z = 0.0;
  added_pose.roll = 0.0;
  added_pose.pitch = 0.0;
  added_pose.yaw = 0.0;

  diff_x = 0.0;
  diff_y = 0.0;
  diff_z = 0.0;
  diff_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;

  std::cout &lt;&lt; &quot;INITIALILZEEEEEEEEEEEEEEEEEEEEEEEE&quot; &lt;&lt; std::endl;
  ros::init(argc, argv, &quot;ndt_mapping&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

// setting parameters
#ifdef CUDA_FOUND
  private_nh.getParam(&quot;use_gpu&quot;, _use_gpu);
  std::cout &lt;&lt; &quot;use_gpu: &quot; &lt;&lt; _use_gpu &lt;&lt; std::endl;
#endif
#ifdef USE_FAST_PCL
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
#endif

  private_nh.getParam(&quot;use_fast_pcl&quot;, _use_fast_pcl);
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;

  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
  if (_use_gpu == true &amp;&amp; _use_openmp == true)
  {
    std::cout &lt;&lt; &quot;use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false.&quot; &lt;&lt; std::endl;
    _use_openmp = false;
  }
#endif

  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  Eigen::Translation3f tl_ltob((-1.0) * _tf_x, (-1.0) * _tf_y, (-1.0) * _tf_z);  // tl: translation
  Eigen::AngleAxisf rot_x_ltob((-1.0) * _tf_roll, Eigen::Vector3f::UnitX());     // rot: rotation
  Eigen::AngleAxisf rot_y_ltob((-1.0) * _tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_ltob((-1.0) * _tf_yaw, Eigen::Vector3f::UnitZ());
  tf_ltob = (tl_ltob * rot_z_ltob * rot_y_ltob * rot_x_ltob).matrix();

  map.header.frame_id = &quot;map&quot;;

  ndt_map_pub = nh.advertise&lt;sensor_msgs::PointCloud2&gt;(&quot;/ndt_map&quot;, 1000);
  current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);

  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt_mapping&quot;, 10, param_callback);
  ros::Subscriber output_sub = nh.subscribe(&quot;config/ndt_mapping_output&quot;, 10, output_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;points_raw&quot;, 100000, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, 100000, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic, 100000, imu_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp">
				<diff>@@ -69,12 +69,6 @@
   #include &lt;pcl/registration/ndt.h&gt;
 #endif
 
-
-#ifdef USE_FAST_PCL
-  #include &lt;fast_pcl/registration/ndt.h&gt;
-#else
-  #include &lt;pcl/registration/ndt.h&gt;
-#endif
 #ifdef CUDA_FOUND
   #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
 #endif
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;

#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;

#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;tf/transform_listener.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#ifdef USE_FAST_PCL
  #include &lt;fast_pcl/registration/ndt.h&gt;
#else
  #include &lt;pcl/registration/ndt.h&gt;
#endif


#ifdef USE_FAST_PCL
  #include &lt;fast_pcl/registration/ndt.h&gt;
#else
  #include &lt;pcl/registration/ndt.h&gt;
#endif
#ifdef CUDA_FOUND
  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
#endif

//End of adding

#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_ros/transforms.h&gt;

#include &lt;autoware_msgs/ConfigNdt.h&gt;

#include &lt;autoware_msgs/ndt_stat.h&gt;

//Added for testing on cpu
#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
//End of adding

#define PREDICT_POSE_THRESHOLD 0.5

#define Wa 0.4
#define Wb 0.3
#define Wc 0.3

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose,
    ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose,
    previous_gnss_pose, current_gnss_pose;

static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
    offset_imu_odom_yaw;

// Can't load if typed &quot;pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;&quot;
static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;

// If the map is loaded, map_loaded will be 1.
static int map_loaded = 0;
static int _use_gnss = 1;
static int init_pos_set = 0;

#ifdef CUDA_FOUND
static gpu::GNormalDistributionsTransform gpu_ndt;
#endif


static cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; cpu_ndt;

static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;

// Default values
static int max_iter = 30;        // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

static ros::Publisher predict_pose_pub;
static geometry_msgs::PoseStamped predict_pose_msg;

static ros::Publisher predict_pose_imu_pub;
static geometry_msgs::PoseStamped predict_pose_imu_msg;

static ros::Publisher predict_pose_odom_pub;
static geometry_msgs::PoseStamped predict_pose_odom_msg;

static ros::Publisher predict_pose_imu_odom_pub;
static geometry_msgs::PoseStamped predict_pose_imu_odom_msg;

static ros::Publisher ndt_pose_pub;
static geometry_msgs::PoseStamped ndt_pose_msg;

// current_pose is published by vel_pose_mux
/*
static ros::Publisher current_pose_pub;
static geometry_msgs::PoseStamped current_pose_msg;
*/

static ros::Publisher localizer_pose_pub;
static geometry_msgs::PoseStamped localizer_pose_msg;

static ros::Publisher estimate_twist_pub;
static geometry_msgs::TwistStamped estimate_twist_msg;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double exe_time = 0.0;
static bool has_converged;
static int iteration = 0;
static double fitness_score = 0.0;
static double trans_probability = 0.0;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;

static double current_velocity = 0.0, previous_velocity = 0.0, previous_previous_velocity = 0.0;  // [m/s]
static double current_velocity_x = 0.0, previous_velocity_x = 0.0;
static double current_velocity_y = 0.0, previous_velocity_y = 0.0;
static double current_velocity_z = 0.0, previous_velocity_z = 0.0;
// static double current_velocity_yaw = 0.0, previous_velocity_yaw = 0.0;
static double current_velocity_smooth = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static double current_accel = 0.0, previous_accel = 0.0;  // [m/s^2]
static double current_accel_x = 0.0;
static double current_accel_y = 0.0;
static double current_accel_z = 0.0;
// static double current_accel_yaw = 0.0;

static double angular_velocity = 0.0;

static int use_predict_pose = 0;

static ros::Publisher estimated_vel_mps_pub, estimated_vel_kmph_pub, estimated_vel_pub;
static std_msgs::Float32 estimated_vel_mps, estimated_vel_kmph, previous_estimated_vel_kmph;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; matching_start, matching_end;

static ros::Publisher time_ndt_matching_pub;
static std_msgs::Float32 time_ndt_matching;

static int _queue_size = 1000;

static ros::Publisher ndt_stat_pub;
static autoware_msgs::ndt_stat ndt_stat_msg;

static double predict_pose_error = 0.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol;

static std::string _localizer = &quot;velodyne&quot;;
static std::string _offset = &quot;linear&quot;;  // linear, zero, quadratic

static ros::Publisher ndt_reliability_pub;
static std_msgs::Float32 ndt_reliability;

#ifdef CUDA_FOUND
static bool _use_gpu = false;
#endif
#ifdef USE_FAST_PCL
static bool _use_openmp = false;
#endif

static bool _use_fast_pcl = true;

static bool _get_height = false;
static bool _use_local_transform = false;
static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;

static std::ofstream ofs;
static std::string filename;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;

// static tf::TransformListener local_transform_listener;
static tf::StampedTransform local_transform;

static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
{
  if (_use_gnss != input-&gt;init_pos_gnss)
  {
    init_pos_set = 0;
  }
  else if (_use_gnss == 0 &amp;&amp;
           (initial_pose.x != input-&gt;x || initial_pose.y != input-&gt;y || initial_pose.z != input-&gt;z ||
            initial_pose.roll != input-&gt;roll || initial_pose.pitch != input-&gt;pitch || initial_pose.yaw != input-&gt;yaw))
  {
    init_pos_set = 0;
  }

  _use_gnss = input-&gt;init_pos_gnss;

  // Setting parameters
  if (input-&gt;resolution != ndt_res)
  {
    ndt_res = input-&gt;resolution;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setResolution(ndt_res);
    }
    else
    {
#endif
		if (!_use_fast_pcl)
		{
		  ndt.setResolution(ndt_res);
		}
		else
		{
		  cpu_ndt.setResolution(ndt_res);
		}
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;step_size != step_size)
  {
    step_size = input-&gt;step_size;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setStepSize(step_size);
    }
    else
    {
#endif
		if (!_use_fast_pcl)
		{
		  ndt.setStepSize(step_size);
		}
		else
		{
		  cpu_ndt.setStepSize(step_size);
		}
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;trans_epsilon != trans_eps)
  {
    trans_eps = input-&gt;trans_epsilon;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setTransformationEpsilon(trans_eps);
    }
    else
    {
#endif
		if (!_use_fast_pcl)
		{
		  ndt.setTransformationEpsilon(trans_eps);
		}
		else
		{
		  cpu_ndt.setTransformationEpsilon(trans_eps);
		}
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;max_iterations != max_iter)
  {
    max_iter = input-&gt;max_iterations;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setMaximumIterations(max_iter);
    }
    else
    {
#endif
		if (!_use_fast_pcl)
		{
		  ndt.setMaximumIterations(max_iter);
		}
		else
		{
		  cpu_ndt.setMaximumIterations(max_iter);
		}
#ifdef CUDA_FOUND
    }
#endif
  }

  if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
  {
    initial_pose.x = input-&gt;x;
    initial_pose.y = input-&gt;y;
    initial_pose.z = input-&gt;z;
    initial_pose.roll = input-&gt;roll;
    initial_pose.pitch = input-&gt;pitch;
    initial_pose.yaw = input-&gt;yaw;

    if (_use_local_transform == true)
    {
      tf::Vector3 v(input-&gt;x, input-&gt;y, input-&gt;z);
      tf::Quaternion q;
      q.setRPY(input-&gt;roll, input-&gt;pitch, input-&gt;yaw);
      tf::Transform transform(q, v);
      initial_pose.x = (local_transform.inverse() * transform).getOrigin().getX();
      initial_pose.y = (local_transform.inverse() * transform).getOrigin().getY();
      initial_pose.z = (local_transform.inverse() * transform).getOrigin().getZ();

      tf::Matrix3x3 m(q);
      m.getRPY(initial_pose.roll, initial_pose.pitch, initial_pose.yaw);

      std::cout &lt;&lt; &quot;initial_pose.x: &quot; &lt;&lt; initial_pose.x &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.y: &quot; &lt;&lt; initial_pose.y &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.z: &quot; &lt;&lt; initial_pose.z &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.roll: &quot; &lt;&lt; initial_pose.roll &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.pitch: &quot; &lt;&lt; initial_pose.pitch &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.yaw: &quot; &lt;&lt; initial_pose.yaw &lt;&lt; std::endl;
    }

    // Setting position and posture for the first time.
    localizer_pose.x = initial_pose.x;
    localizer_pose.y = initial_pose.y;
    localizer_pose.z = initial_pose.z;
    localizer_pose.roll = initial_pose.roll;
    localizer_pose.pitch = initial_pose.pitch;
    localizer_pose.yaw = initial_pose.yaw;

    previous_pose.x = initial_pose.x;
    previous_pose.y = initial_pose.y;
    previous_pose.z = initial_pose.z;
    previous_pose.roll = initial_pose.roll;
    previous_pose.pitch = initial_pose.pitch;
    previous_pose.yaw = initial_pose.yaw;

    current_pose.x = initial_pose.x;
    current_pose.y = initial_pose.y;
    current_pose.z = initial_pose.z;
    current_pose.roll = initial_pose.roll;
    current_pose.pitch = initial_pose.pitch;
    current_pose.yaw = initial_pose.yaw;

    current_velocity = 0;
    current_velocity_x = 0;
    current_velocity_y = 0;
    current_velocity_z = 0;
    angular_velocity = 0;

    current_pose_imu.x = 0;
    current_pose_imu.y = 0;
    current_pose_imu.z = 0;
    current_pose_imu.roll = 0;
    current_pose_imu.pitch = 0;
    current_pose_imu.yaw = 0;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;
    init_pos_set = 1;
  }
}

static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 0)
  {
    // Convert the data type(from sensor_msgs to pcl).
    pcl::fromROSMsg(*input, map);

    if (_use_local_transform == true)
    {
      tf::TransformListener local_transform_listener;
      try
      {
        ros::Time now = ros::Time(0);
        local_transform_listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
        local_transform_listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, local_transform);
      }
      catch (tf::TransformException&amp; ex)
      {
        ROS_ERROR(&quot;%s&quot;, ex.what());
      }

      pcl_ros::transformPointCloud(map, map, local_transform.inverse());
    }

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));


// Setting point cloud to be aligned to.
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setInputTarget(map_ptr);
      gpu_ndt.setMaximumIterations(max_iter);
      gpu_ndt.setResolution(ndt_res);
      gpu_ndt.setStepSize(step_size);
      gpu_ndt.setTransformationEpsilon(trans_eps);
    }
    else
    {
#endif
		if (!_use_fast_pcl)
		{
		  ndt.setInputTarget(map_ptr);
		  ndt.setMaximumIterations(max_iter);
		  ndt.setResolution(ndt_res);
		  ndt.setStepSize(step_size);
		  ndt.setTransformationEpsilon(trans_eps);
		}
		else
		{
		  cpu_ndt.setInputTarget(map_ptr);
		  cpu_ndt.setMaximumIterations(max_iter);
		  cpu_ndt.setResolution(ndt_res);
		  cpu_ndt.setStepSize(step_size);
		  cpu_ndt.setTransformationEpsilon(trans_eps);
		}
#ifdef CUDA_FOUND
    }
#endif
    map_loaded = 1;
  }
}

static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
{
  tf::Quaternion gnss_q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z,
                        input-&gt;pose.orientation.w);
  tf::Matrix3x3 gnss_m(gnss_q);
  current_gnss_pose.x = input-&gt;pose.position.x;
  current_gnss_pose.y = input-&gt;pose.position.y;
  current_gnss_pose.z = input-&gt;pose.position.z;
  gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);

  if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= 500.0)
  {
    previous_pose.x = previous_gnss_pose.x;
    previous_pose.y = previous_gnss_pose.y;
    previous_pose.z = previous_gnss_pose.z;
    previous_pose.roll = previous_gnss_pose.roll;
    previous_pose.pitch = previous_gnss_pose.pitch;
    previous_pose.yaw = previous_gnss_pose.yaw;

    current_pose.x = current_gnss_pose.x;
    current_pose.y = current_gnss_pose.y;
    current_pose.z = current_gnss_pose.z;
    current_pose.roll = current_gnss_pose.roll;
    current_pose.pitch = current_gnss_pose.pitch;
    current_pose.yaw = current_gnss_pose.yaw;

    current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;

    offset_x = current_pose.x - previous_pose.x;
    offset_y = current_pose.y - previous_pose.y;
    offset_z = current_pose.z - previous_pose.z;
    offset_yaw = current_pose.yaw - previous_pose.yaw;

    init_pos_set = 1;
  }

  previous_gnss_pose.x = current_gnss_pose.x;
  previous_gnss_pose.y = current_gnss_pose.y;
  previous_gnss_pose.z = current_gnss_pose.z;
  previous_gnss_pose.roll = current_gnss_pose.roll;
  previous_gnss_pose.pitch = current_gnss_pose.pitch;
  previous_gnss_pose.yaw = current_gnss_pose.yaw;
}

static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
{
  tf::TransformListener listener;
  tf::StampedTransform transform;
  try
  {
    ros::Time now = ros::Time(0);
    listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
    listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, transform);
  }
  catch (tf::TransformException&amp; ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
  }

  tf::Quaternion q(input-&gt;pose.pose.orientation.x, input-&gt;pose.pose.orientation.y, input-&gt;pose.pose.orientation.z,
                   input-&gt;pose.pose.orientation.w);
  tf::Matrix3x3 m(q);

  if (_use_local_transform == true)
  {
    current_pose.x = input-&gt;pose.pose.position.x;
    current_pose.y = input-&gt;pose.pose.position.y;
    current_pose.z = input-&gt;pose.pose.position.z;
  }
  else
  {
    current_pose.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
    current_pose.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
    current_pose.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
  }
  m.getRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);

  if (_get_height == true &amp;&amp; map_loaded == 1)
  {
    double min_distance = DBL_MAX;
    double nearest_z = current_pose.z;
    for (const auto&amp; p : map)
    {
      double distance = hypot(current_pose.x - p.x, current_pose.y - p.y);
      if (distance &lt; min_distance)
      {
        min_distance = distance;
        nearest_z = p.z;
      }
    }
    current_pose.z = nearest_z;
  }

  current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  offset_x = 0.0;
  offset_y = 0.0;
  offset_z = 0.0;
  offset_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;
}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw += diff_imu_yaw;

  predict_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
  predict_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
  predict_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
  predict_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
  predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  predict_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;

  previous_time = current_time;
}

static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);

  offset_odom_roll += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw += diff_odom_yaw;

  predict_pose_odom.x = previous_pose.x + offset_odom_x;
  predict_pose_odom.y = previous_pose.y + offset_odom_y;
  predict_pose_odom.z = previous_pose.z + offset_odom_z;
  predict_pose_odom.roll = previous_pose.roll + offset_odom_roll;
  predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  predict_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;

  previous_time = current_time;
}

static void imu_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw += diff_imu_yaw;

  predict_pose_imu.x = previous_pose.x + offset_imu_x;
  predict_pose_imu.y = previous_pose.y + offset_imu_y;
  predict_pose_imu.z = previous_pose.z + offset_imu_z;
  predict_pose_imu.roll = previous_pose.roll + offset_imu_roll;
  predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  predict_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;

  previous_time = current_time;
}

static const double wrapToPm(double a_num, const double a_max)
{
  if (a_num &gt;= a_max)
  {
    a_num -= 2.0 * a_max;
  }
  return a_num;
}

static const double wrapToPmPi(double a_angle_rad)
{
  return wrapToPm(a_angle_rad, M_PI);
}

static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}

static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll *= -1;
  input_pitch *= -1;
  input_yaw *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}

static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if (_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time = (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll = imu_roll - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if (imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
    else
      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
  }
  else
    diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if (diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw = imu_yaw;
}

static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
  {
    matching_start = std::chrono::system_clock::now();

    static tf::TransformBroadcaster br;
    tf::Transform transform;
    tf::Quaternion predict_q, ndt_q, current_q, localizer_q;

    pcl::PointXYZ p;
    pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;

    current_scan_time = input-&gt;header.stamp;

    pcl::fromROSMsg(*input, filtered_scan);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan));
    int scan_points_num = filtered_scan_ptr-&gt;size();

    Eigen::Matrix4f t(Eigen::Matrix4f::Identity());   // base_link
    Eigen::Matrix4f t2(Eigen::Matrix4f::Identity());  // localizer

    std::chrono::time_point&lt;std::chrono::system_clock&gt; align_start, align_end, getFitnessScore_start,
        getFitnessScore_end;
    static double align_time, getFitnessScore_time = 0.0;

#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setInputSource(filtered_scan_ptr);
    }
    else
    {
#endif
		if (!_use_fast_pcl)
		{
		  ndt.setInputSource(filtered_scan_ptr);
		}
		else
		{
		  cpu_ndt.setInputSource(filtered_scan_ptr);
		}
#ifdef CUDA_FOUND
    }
#endif

    // Guess the initial gross estimation of the transformation
    predict_pose.x = previous_pose.x + offset_x;
    predict_pose.y = previous_pose.y + offset_y;
    predict_pose.z = previous_pose.z + offset_z;
    predict_pose.roll = previous_pose.roll;
    predict_pose.pitch = previous_pose.pitch;
    predict_pose.yaw = previous_pose.yaw + offset_yaw;

    if (_use_imu == true &amp;&amp; _use_odom == true)
      imu_odom_calc(current_scan_time);
    if (_use_imu == true &amp;&amp; _use_odom == false)
      imu_calc(current_scan_time);
    if (_use_imu == false &amp;&amp; _use_odom == true)
      odom_calc(current_scan_time);

    pose predict_pose_for_ndt;
    if (_use_imu == true &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_imu_odom;
    else if (_use_imu == true &amp;&amp; _use_odom == false)
      predict_pose_for_ndt = predict_pose_imu;
    else if (_use_imu == false &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_odom;
    else
      predict_pose_for_ndt = predict_pose;

    Eigen::Translation3f init_translation(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z);
    Eigen::AngleAxisf init_rotation_x(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
    Eigen::AngleAxisf init_rotation_y(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
    Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      align_start = std::chrono::system_clock::now();
      gpu_ndt.align(init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = gpu_ndt.hasConverged();

      t = gpu_ndt.getFinalTransformation();
      iteration = gpu_ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = gpu_ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = gpu_ndt.getTransformationProbability();
    }
#ifdef USE_FAST_PCL
    else if (_use_openmp == true)
    {
      align_start = std::chrono::system_clock::now();
      ndt.omp_align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.omp_getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
    }
#endif
    else
    {
    	if (!_use_fast_pcl)
    	{
		  align_start = std::chrono::system_clock::now();
		  ndt.align(*output_cloud, init_guess);
		  align_end = std::chrono::system_clock::now();

		  has_converged = ndt.hasConverged();

		  t = ndt.getFinalTransformation();
		  iteration = ndt.getFinalNumIteration();

		  getFitnessScore_start = std::chrono::system_clock::now();
		  fitness_score = ndt.getFitnessScore();
		  getFitnessScore_end = std::chrono::system_clock::now();

		  trans_probability = ndt.getTransformationProbability();
    	}
    	else
    	{
		  align_start = std::chrono::system_clock::now();
		  cpu_ndt.align(init_guess);
		  align_end = std::chrono::system_clock::now();

		  has_converged = cpu_ndt.hasConverged();

		  t = cpu_ndt.getFinalTransformation();
		  iteration = cpu_ndt.getFinalNumIteration();

		  getFitnessScore_start = std::chrono::system_clock::now();
		  fitness_score = cpu_ndt.getFitnessScore();
		  getFitnessScore_end = std::chrono::system_clock::now();

		  trans_probability = cpu_ndt.getTransformationProbability();
    	}
    }
#else
#ifdef USE_FAST_PCL
    if (_use_openmp == true)
    {
      align_start = std::chrono::system_clock::now();
      ndt.omp_align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.omp_getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
    }
    else
    {
#endif
      align_start = std::chrono::system_clock::now();
      ndt.align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
#ifdef USE_FAST_PCL
    }
#endif
#endif

    align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;

    t2 = t * tf_btol.inverse();

    getFitnessScore_time =
        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() /
        1000.0;

    tf::Matrix3x3 mat_l;  // localizer
    mat_l.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)),
                   static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)),
                   static_cast&lt;double&gt;(t(2, 0)), static_cast&lt;double&gt;(t(2, 1)), static_cast&lt;double&gt;(t(2, 2)));

    // Update localizer_pose
    localizer_pose.x = t(0, 3);
    localizer_pose.y = t(1, 3);
    localizer_pose.z = t(2, 3);
    mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

    tf::Matrix3x3 mat_b;  // base_link
    mat_b.setValue(static_cast&lt;double&gt;(t2(0, 0)), static_cast&lt;double&gt;(t2(0, 1)), static_cast&lt;double&gt;(t2(0, 2)),
                   static_cast&lt;double&gt;(t2(1, 0)), static_cast&lt;double&gt;(t2(1, 1)), static_cast&lt;double&gt;(t2(1, 2)),
                   static_cast&lt;double&gt;(t2(2, 0)), static_cast&lt;double&gt;(t2(2, 1)), static_cast&lt;double&gt;(t2(2, 2)));

    // Update ndt_pose
    ndt_pose.x = t2(0, 3);
    ndt_pose.y = t2(1, 3);
    ndt_pose.z = t2(2, 3);
    mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

    // Calculate the difference between ndt_pose and predict_pose
    predict_pose_error = sqrt((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) +
                              (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) +
                              (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));

    if (predict_pose_error &lt;= PREDICT_POSE_THRESHOLD)
    {
      use_predict_pose = 0;
    }
    else
    {
      use_predict_pose = 1;
    }
    use_predict_pose = 0;

    if (use_predict_pose == 0)
    {
      current_pose.x = ndt_pose.x;
      current_pose.y = ndt_pose.y;
      current_pose.z = ndt_pose.z;
      current_pose.roll = ndt_pose.roll;
      current_pose.pitch = ndt_pose.pitch;
      current_pose.yaw = ndt_pose.yaw;
    }
    else
    {
      current_pose.x = predict_pose_for_ndt.x;
      current_pose.y = predict_pose_for_ndt.y;
      current_pose.z = predict_pose_for_ndt.z;
      current_pose.roll = predict_pose_for_ndt.roll;
      current_pose.pitch = predict_pose_for_ndt.pitch;
      current_pose.yaw = predict_pose_for_ndt.yaw;
    }

    // Compute the velocity and acceleration
    scan_duration = current_scan_time - previous_scan_time;
    double secs = scan_duration.toSec();
    diff_x = current_pose.x - previous_pose.x;
    diff_y = current_pose.y - previous_pose.y;
    diff_z = current_pose.z - previous_pose.z;
    diff_yaw = current_pose.yaw - previous_pose.yaw;
    diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

    current_velocity = diff / secs;
    current_velocity_x = diff_x / secs;
    current_velocity_y = diff_y / secs;
    current_velocity_z = diff_z / secs;
    angular_velocity = diff_yaw / secs;

    current_pose_imu.x = current_pose.x;
    current_pose_imu.y = current_pose.y;
    current_pose_imu.z = current_pose.z;
    current_pose_imu.roll = current_pose.roll;
    current_pose_imu.pitch = current_pose.pitch;
    current_pose_imu.yaw = current_pose.yaw;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;

    current_pose_odom.x = current_pose.x;
    current_pose_odom.y = current_pose.y;
    current_pose_odom.z = current_pose.z;
    current_pose_odom.roll = current_pose.roll;
    current_pose_odom.pitch = current_pose.pitch;
    current_pose_odom.yaw = current_pose.yaw;

    current_pose_imu_odom.x = current_pose.x;
    current_pose_imu_odom.y = current_pose.y;
    current_pose_imu_odom.z = current_pose.z;
    current_pose_imu_odom.roll = current_pose.roll;
    current_pose_imu_odom.pitch = current_pose.pitch;
    current_pose_imu_odom.yaw = current_pose.yaw;

    current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
    if (current_velocity_smooth &lt; 0.2)
    {
      current_velocity_smooth = 0.0;
    }

    current_accel = (current_velocity - previous_velocity) / secs;
    current_accel_x = (current_velocity_x - previous_velocity_x) / secs;
    current_accel_y = (current_velocity_y - previous_velocity_y) / secs;
    current_accel_z = (current_velocity_z - previous_velocity_z) / secs;

    estimated_vel_mps.data = current_velocity;
    estimated_vel_kmph.data = current_velocity * 3.6;

    estimated_vel_mps_pub.publish(estimated_vel_mps);
    estimated_vel_kmph_pub.publish(estimated_vel_kmph);

    // Set values for publishing pose
    predict_q.setRPY(predict_pose.roll, predict_pose.pitch, predict_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(predict_pose.x, predict_pose.y, predict_pose.z);
      tf::Transform transform(predict_q, v);
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      predict_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      predict_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      predict_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      predict_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      predict_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      predict_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = predict_pose.x;
      predict_pose_msg.pose.position.y = predict_pose.y;
      predict_pose_msg.pose.position.z = predict_pose.z;
      predict_pose_msg.pose.orientation.x = predict_q.x();
      predict_pose_msg.pose.orientation.y = predict_q.y();
      predict_pose_msg.pose.orientation.z = predict_q.z();
      predict_pose_msg.pose.orientation.w = predict_q.w();
    }

    tf::Quaternion predict_q_imu;
    predict_q_imu.setRPY(predict_pose_imu.roll, predict_pose_imu.pitch, predict_pose_imu.yaw);
    predict_pose_imu_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_msg.pose.position.x = predict_pose_imu.x;
    predict_pose_imu_msg.pose.position.y = predict_pose_imu.y;
    predict_pose_imu_msg.pose.position.z = predict_pose_imu.z;
    predict_pose_imu_msg.pose.orientation.x = predict_q_imu.x();
    predict_pose_imu_msg.pose.orientation.y = predict_q_imu.y();
    predict_pose_imu_msg.pose.orientation.z = predict_q_imu.z();
    predict_pose_imu_msg.pose.orientation.w = predict_q_imu.w();
    predict_pose_imu_pub.publish(predict_pose_imu_msg);

    tf::Quaternion predict_q_odom;
    predict_q_odom.setRPY(predict_pose_odom.roll, predict_pose_odom.pitch, predict_pose_odom.yaw);
    predict_pose_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_odom_msg.pose.position.x = predict_pose_odom.x;
    predict_pose_odom_msg.pose.position.y = predict_pose_odom.y;
    predict_pose_odom_msg.pose.position.z = predict_pose_odom.z;
    predict_pose_odom_msg.pose.orientation.x = predict_q_odom.x();
    predict_pose_odom_msg.pose.orientation.y = predict_q_odom.y();
    predict_pose_odom_msg.pose.orientation.z = predict_q_odom.z();
    predict_pose_odom_msg.pose.orientation.w = predict_q_odom.w();
    predict_pose_odom_pub.publish(predict_pose_odom_msg);

    tf::Quaternion predict_q_imu_odom;
    predict_q_imu_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
    predict_pose_imu_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_odom_msg.pose.position.x = predict_pose_imu_odom.x;
    predict_pose_imu_odom_msg.pose.position.y = predict_pose_imu_odom.y;
    predict_pose_imu_odom_msg.pose.position.z = predict_pose_imu_odom.z;
    predict_pose_imu_odom_msg.pose.orientation.x = predict_q_imu_odom.x();
    predict_pose_imu_odom_msg.pose.orientation.y = predict_q_imu_odom.y();
    predict_pose_imu_odom_msg.pose.orientation.z = predict_q_imu_odom.z();
    predict_pose_imu_odom_msg.pose.orientation.w = predict_q_imu_odom.w();
    predict_pose_imu_odom_pub.publish(predict_pose_imu_odom_msg);

    ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(ndt_pose.x, ndt_pose.y, ndt_pose.z);
      tf::Transform transform(ndt_q, v);
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      ndt_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      ndt_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      ndt_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      ndt_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      ndt_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      ndt_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = ndt_pose.x;
      ndt_pose_msg.pose.position.y = ndt_pose.y;
      ndt_pose_msg.pose.position.z = ndt_pose.z;
      ndt_pose_msg.pose.orientation.x = ndt_q.x();
      ndt_pose_msg.pose.orientation.y = ndt_q.y();
      ndt_pose_msg.pose.orientation.z = ndt_q.z();
      ndt_pose_msg.pose.orientation.w = ndt_q.w();
    }

    current_q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
    // current_pose is published by vel_pose_mux
    /*
    current_pose_msg.header.frame_id = &quot;/map&quot;;
    current_pose_msg.header.stamp = current_scan_time;
    current_pose_msg.pose.position.x = current_pose.x;
    current_pose_msg.pose.position.y = current_pose.y;
    current_pose_msg.pose.position.z = current_pose.z;
    current_pose_msg.pose.orientation.x = current_q.x();
    current_pose_msg.pose.orientation.y = current_q.y();
    current_pose_msg.pose.orientation.z = current_q.z();
    current_pose_msg.pose.orientation.w = current_q.w();
    */

    localizer_q.setRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(localizer_pose.x, localizer_pose.y, localizer_pose.z);
      tf::Transform transform(localizer_q, v);
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      localizer_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      localizer_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      localizer_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      localizer_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      localizer_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      localizer_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = localizer_pose.x;
      localizer_pose_msg.pose.position.y = localizer_pose.y;
      localizer_pose_msg.pose.position.z = localizer_pose.z;
      localizer_pose_msg.pose.orientation.x = localizer_q.x();
      localizer_pose_msg.pose.orientation.y = localizer_q.y();
      localizer_pose_msg.pose.orientation.z = localizer_q.z();
      localizer_pose_msg.pose.orientation.w = localizer_q.w();
    }

    predict_pose_pub.publish(predict_pose_msg);
    ndt_pose_pub.publish(ndt_pose_msg);
    // current_pose is published by vel_pose_mux
    //    current_pose_pub.publish(current_pose_msg);
    localizer_pose_pub.publish(localizer_pose_msg);

    // Send TF &quot;/base_link&quot; to &quot;/map&quot;
    transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
    transform.setRotation(current_q);
    //    br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    if (_use_local_transform == true)
    {
      br.sendTransform(tf::StampedTransform(local_transform * transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }
    else
    {
      br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }

    matching_end = std::chrono::system_clock::now();
    exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
    time_ndt_matching.data = exe_time;
    time_ndt_matching_pub.publish(time_ndt_matching);

    // Set values for /estimate_twist
    estimate_twist_msg.header.stamp = current_scan_time;
    estimate_twist_msg.header.frame_id = &quot;/base_link&quot;;
    estimate_twist_msg.twist.linear.x = current_velocity;
    estimate_twist_msg.twist.linear.y = 0.0;
    estimate_twist_msg.twist.linear.z = 0.0;
    estimate_twist_msg.twist.angular.x = 0.0;
    estimate_twist_msg.twist.angular.y = 0.0;
    estimate_twist_msg.twist.angular.z = angular_velocity;

    estimate_twist_pub.publish(estimate_twist_msg);

    geometry_msgs::Vector3Stamped estimate_vel_msg;
    estimate_vel_msg.header.stamp = current_scan_time;
    estimate_vel_msg.vector.x = current_velocity;
    estimated_vel_pub.publish(estimate_vel_msg);

    // Set values for /ndt_stat
    ndt_stat_msg.header.stamp = current_scan_time;
    ndt_stat_msg.exe_time = time_ndt_matching.data;
    ndt_stat_msg.iteration = iteration;
    ndt_stat_msg.score = fitness_score;
    ndt_stat_msg.velocity = current_velocity;
    ndt_stat_msg.acceleration = current_accel;
    ndt_stat_msg.use_predict_pose = 0;

    ndt_stat_pub.publish(ndt_stat_msg);
    /* Compute NDT_Reliability */
    ndt_reliability.data = Wa * (exe_time / 100.0) * 100.0 + Wb * (iteration / 10.0) * 100.0 +
                           Wc * ((2.0 - trans_probability) / 2.0) * 100.0;
    ndt_reliability_pub.publish(ndt_reliability);

    // Write log
    if (!ofs)
    {
      std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      exit(1);
    }
    static ros::Time start_time = input-&gt;header.stamp;

    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; &quot;,&quot; &lt;&lt; scan_points_num &lt;&lt; &quot;,&quot; &lt;&lt; step_size &lt;&lt; &quot;,&quot; &lt;&lt; trans_eps &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed
        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.pitch
        &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.y &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.z &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose_error &lt;&lt; &quot;,&quot; &lt;&lt; iteration &lt;&lt; &quot;,&quot; &lt;&lt; fitness_score &lt;&lt; &quot;,&quot; &lt;&lt; trans_probability &lt;&lt; &quot;,&quot;
        &lt;&lt; ndt_reliability.data &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity_smooth &lt;&lt; &quot;,&quot; &lt;&lt; current_accel
        &lt;&lt; &quot;,&quot; &lt;&lt; angular_velocity &lt;&lt; &quot;,&quot; &lt;&lt; time_ndt_matching.data &lt;&lt; &quot;,&quot; &lt;&lt; align_time &lt;&lt; &quot;,&quot; &lt;&lt; getFitnessScore_time
        &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Sequence: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Timestamp: &quot; &lt;&lt; input-&gt;header.stamp &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Frame ID: &quot; &lt;&lt; input-&gt;header.frame_id &lt;&lt; std::endl;
    //		std::cout &lt;&lt; &quot;Number of Scan Points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Filtered Scan Points: &quot; &lt;&lt; scan_points_num &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; has_converged &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Fitness Score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Probability: &quot; &lt;&lt; trans_probability &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Execution Time: &quot; &lt;&lt; exe_time &lt;&lt; &quot; ms.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Iterations: &quot; &lt;&lt; iteration &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT Reliability: &quot; &lt;&lt; ndt_reliability.data &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw): &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
              &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Matrix: &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; t &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Align time: &quot; &lt;&lt; align_time &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Get fitness score time: &quot; &lt;&lt; getFitnessScore_time &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

    // Update offset
    if (_offset == &quot;linear&quot;)
    {
      offset_x = diff_x;
      offset_y = diff_y;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;quadratic&quot;)
    {
      offset_x = (current_velocity_x + current_accel_x * secs) * secs;
      offset_y = (current_velocity_y + current_accel_y * secs) * secs;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;zero&quot;)
    {
      offset_x = 0.0;
      offset_y = 0.0;
      offset_z = 0.0;
      offset_yaw = 0.0;
    }

    offset_imu_x = 0.0;
    offset_imu_y = 0.0;
    offset_imu_z = 0.0;
    offset_imu_roll = 0.0;
    offset_imu_pitch = 0.0;
    offset_imu_yaw = 0.0;

    offset_odom_x = 0.0;
    offset_odom_y = 0.0;
    offset_odom_z = 0.0;
    offset_odom_roll = 0.0;
    offset_odom_pitch = 0.0;
    offset_odom_yaw = 0.0;

    offset_imu_odom_x = 0.0;
    offset_imu_odom_y = 0.0;
    offset_imu_odom_z = 0.0;
    offset_imu_odom_roll = 0.0;
    offset_imu_odom_pitch = 0.0;
    offset_imu_odom_yaw = 0.0;

    // Update previous_***
    previous_pose.x = current_pose.x;
    previous_pose.y = current_pose.y;
    previous_pose.z = current_pose.z;
    previous_pose.roll = current_pose.roll;
    previous_pose.pitch = current_pose.pitch;
    previous_pose.yaw = current_pose.yaw;

    previous_scan_time.sec = current_scan_time.sec;
    previous_scan_time.nsec = current_scan_time.nsec;

    previous_previous_velocity = previous_velocity;
    previous_velocity = current_velocity;
    previous_velocity_x = current_velocity_x;
    previous_velocity_y = current_velocity_y;
    previous_velocity_z = current_velocity_z;
    previous_accel = current_accel;

    previous_estimated_vel_kmph.data = estimated_vel_kmph.data;
  }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;ndt_matching&quot;);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  // Set log file name.
  char buffer[80];
  std::time_t now = std::time(NULL);
  std::tm* pnow = std::localtime(&amp;now);
  std::strftime(buffer, 80, &quot;%Y%m%d_%H%M%S&quot;, pnow);
  filename = &quot;ndt_matching_&quot; + std::string(buffer) + &quot;.csv&quot;;
  ofs.open(filename.c_str(), std::ios::app);

  // Geting parameters
  private_nh.getParam(&quot;use_gnss&quot;, _use_gnss);
  private_nh.getParam(&quot;queue_size&quot;, _queue_size);
  private_nh.getParam(&quot;offset&quot;, _offset);
#ifdef USE_FAST_PCL
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
#endif
#ifdef CUDA_FOUND
  private_nh.getParam(&quot;use_gpu&quot;, _use_gpu);
#endif
  private_nh.getParam(&quot;use_fast_pcl&quot;, _use_fast_pcl);
  private_nh.getParam(&quot;get_height&quot;, _get_height);
  private_nh.getParam(&quot;use_local_transform&quot;, _use_local_transform);
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
  if (_use_gpu == true &amp;&amp; _use_openmp == true)
  {
    std::cout &lt;&lt; &quot;use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false.&quot; &lt;&lt; std::endl;
    _use_openmp = false;
  }
#endif

  if (nh.getParam(&quot;localizer&quot;, _localizer) == false)
  {
    std::cout &lt;&lt; &quot;localizer is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Log file: &quot; &lt;&lt; filename &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_gnss: &quot; &lt;&lt; _use_gnss &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;queue_size: &quot; &lt;&lt; _queue_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;offset: &quot; &lt;&lt; _offset &lt;&lt; std::endl;
#ifdef CUDA_FOUND
  std::cout &lt;&lt; &quot;use_gpu: &quot; &lt;&lt; _use_gpu &lt;&lt; std::endl;
#endif
#ifdef USE_FAST_PCL
  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
#endif
  std::cout &lt;&lt; &quot;get_height: &quot; &lt;&lt; _get_height &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_local_transform: &quot; &lt;&lt; _use_local_transform &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;localizer: &quot; &lt;&lt; _localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  // Updated in initialpose_callback or gnss_callback
  initial_pose.x = 0.0;
  initial_pose.y = 0.0;
  initial_pose.z = 0.0;
  initial_pose.roll = 0.0;
  initial_pose.pitch = 0.0;
  initial_pose.yaw = 0.0;

  // Publishers
  predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose&quot;, 1000);
  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu&quot;, 1000);
  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_odom&quot;, 1000);
  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu_odom&quot;, 1000);
  ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/ndt_pose&quot;, 1000);
  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);
  localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/localizer_pose&quot;, 1000);
  estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;/estimate_twist&quot;, 1000);
  estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_mps&quot;, 1000);
  estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_kmph&quot;, 1000);
  estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;(&quot;/estimated_vel&quot;, 1000);
  time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/time_ndt_matching&quot;, 1000);
  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;(&quot;/ndt_stat&quot;, 1000);
  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/ndt_reliability&quot;, 1000);

  // Subscribers
  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt&quot;, 10, param_callback);
  ros::Subscriber gnss_sub = nh.subscribe(&quot;gnss_pose&quot;, 10, gnss_callback);
  ros::Subscriber map_sub = nh.subscribe(&quot;points_map&quot;, 10, map_callback);
  ros::Subscriber initialpose_sub = nh.subscribe(&quot;initialpose&quot;, 1000, initialpose_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;filtered_points&quot;, _queue_size, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, _queue_size * 10, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size * 10, imu_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="bc5b8440b91fb65ad769a8b4dae4cf123847f98b" fix_time="647,69755">
		<msg>Fix feature/points2image bug multicam support (#886)

* pointgrey

* Added New Calibration node

* Added parameters, plane fitting

* added mirror node, etc

* Points2Image
Calibration Publisher
now works with multiple cameras using ros namespaces

* Including only points2image

* Added Launch file for points2 image specific for the ladybug camera</msg>
		<modified_files>
			<file old_path="ros/src/sensing/fusion/packages/calibration_camera_lidar/nodes/calibration_publisher/calibration_publisher.cpp" new_path="ros/src/sensing/fusion/packages/calibration_camera_lidar/nodes/calibration_publisher/calibration_publisher.cpp">
				<diff>@@ -11,6 +11,7 @@ static cv::Mat  CameraExtrinsicMat;
 static cv::Mat  CameraMat;
 static cv::Mat  DistCoeff;
 static cv::Size ImageSize;
+static std::string DistModel;
 
 static ros::Publisher camera_info_pub;
 static ros::Publisher projection_matrix_pub;
@@ -47,39 +48,27 @@ void tfRegistration (const cv::Mat &amp;camExtMat, const ros::Time&amp; timeStamp)
   //broadcaster.sendTransform(tf::StampedTransform(transform, ros::Time::now(), &quot;velodyne&quot;, &quot;camera&quot;));
 }
 
-
-static void image_raw_cb(const sensor_msgs::Image&amp; image_msg)
+void projectionMatrix_sender(const cv::Mat  &amp;projMat, const ros::Time&amp; timeStamp)
 {
-  //ros::Time timeStampOfImage = image_msg.header.stamp;
-
-  ros::Time timeStampOfImage;
-  timeStampOfImage.sec = image_msg.header.stamp.sec;
-  timeStampOfImage.nsec = image_msg.header.stamp.nsec;
-
-
-  /* create TF between velodyne and camera with time stamp of /image_raw */
-  tfRegistration(CameraExtrinsicMat, timeStampOfImage);
+  autoware_msgs::projection_matrix projMsg;
 
-}
+  projMsg.header.frame_id=camera_id_str;
 
-void projectionMatrix_sender(const cv::Mat  &amp;projMat)
-{
-	autoware_msgs::projection_matrix projMsg;
-
-	projMsg.header.frame_id=camera_id_str;
-
-	for (int row=0; row&lt;4; row++) {
-	      for (int col=0; col&lt;4; col++) {
-	    	  	  projMsg.projection_matrix[row * 4 + col] = projMat.at&lt;double&gt;(row, col);
+  for (int row=0; row&lt;4; row++) {
+    for (int col=0; col&lt;4; col++) {
+      projMsg.projection_matrix[row * 4 + col] = projMat.at&lt;double&gt;(row, col);
 
-	      }
-	}
-	projection_matrix_pub.publish(projMsg);
+    }
+  }
+  projMsg.header.stamp = timeStamp;
+  projection_matrix_pub.publish(projMsg);
 }
 
 void cameraInfo_sender(const cv::Mat  &amp;camMat,
                        const cv::Mat  &amp;distCoeff,
-                       const cv::Size &amp;imgSize)
+                       const cv::Size &amp;imgSize,
+                       const std::string&amp; distModel,
+                       const ros::Time&amp; timeStamp)
 {
   sensor_msgs::CameraInfo msg;
 
@@ -89,10 +78,10 @@ void cameraInfo_sender(const cv::Mat  &amp;camMat,
   msg.width  = imgSize.width;
 
   for (int row=0; row&lt;3; row++) {
-      for (int col=0; col&lt;3; col++) {
-        msg.K[row * 3 + col] = camMat.at&lt;double&gt;(row, col);
-        }
+    for (int col=0; col&lt;3; col++) {
+      msg.K[row * 3 + col] = camMat.at&lt;double&gt;(row, col);
     }
+  }
 
   for (int row=0; row&lt;3; row++) {
     for (int col=0; col&lt;4; col++) {
@@ -109,10 +98,35 @@ void cameraInfo_sender(const cv::Mat  &amp;camMat,
       msg.D.push_back(distCoeff.at&lt;double&gt;(row, col));
     }
   }
+  msg.header.stamp = timeStamp;
+  msg.distortion_model = distModel;
 
   camera_info_pub.publish(msg);
 }
 
+static void image_raw_cb(const sensor_msgs::Image&amp; image_msg)
+{
+  //ros::Time timeStampOfImage = image_msg.header.stamp;
+
+  ros::Time timeStampOfImage;
+  timeStampOfImage.sec = image_msg.header.stamp.sec;
+  timeStampOfImage.nsec = image_msg.header.stamp.nsec;
+
+
+  /* create TF between velodyne and camera with time stamp of /image_raw */
+  if (isRegister_tf) {
+    tfRegistration(CameraExtrinsicMat, timeStampOfImage);
+  }
+
+  if (isPublish_cameraInfo) {
+    cameraInfo_sender(CameraMat, DistCoeff, ImageSize, DistModel, timeStampOfImage);
+  }
+  if (isPublish_extrinsic) {
+    projectionMatrix_sender(CameraExtrinsicMat, timeStampOfImage);
+  }
+
+}
+
 
 int main(int argc, char* argv[])
 {
@@ -149,9 +163,10 @@ int main(int argc, char* argv[])
   fs[&quot;CameraMat&quot;] &gt;&gt; CameraMat;
   fs[&quot;DistCoeff&quot;] &gt;&gt; DistCoeff;
   fs[&quot;ImageSize&quot;] &gt;&gt; ImageSize;
+  fs[&quot;DistModel&quot;] &gt;&gt; DistModel;
 
   std::string image_topic_name(&quot;/image_raw&quot;);
-  std::string camera_info_name(&quot;/camera/camera_info&quot;);
+  std::string camera_info_name(&quot;/camera_info&quot;);
   std::string projection_matrix_name(&quot;/projection_matrix&quot;);
 
   std::string name_space_str = ros::this_node::getNamespace();
@@ -169,19 +184,13 @@ int main(int argc, char* argv[])
   }
 
   ros::Subscriber image_sub;
-  if (isRegister_tf) {
-    image_sub = n.subscribe(image_topic_name, 10, image_raw_cb);
-  }
 
-  if (isPublish_cameraInfo) {
-    camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(camera_info_name, 10, true);
-    cameraInfo_sender(CameraMat, DistCoeff, ImageSize);
-  }
+  image_sub = n.subscribe(image_topic_name, 10, image_raw_cb);
+
+  camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(camera_info_name, 10, false);
+
+  projection_matrix_pub = n.advertise&lt;autoware_msgs::projection_matrix&gt;(projection_matrix_name, 10, false);
 
-  if (isPublish_extrinsic) {
-    projection_matrix_pub = n.advertise&lt;autoware_msgs::projection_matrix&gt;(projection_matrix_name, 10, true);
-    projectionMatrix_sender(CameraExtrinsicMat);
-  }
 
   ros::spin();
 
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;
#include &lt;sensor_msgs/Image.h&gt;
#include &quot;autoware_msgs/projection_matrix.h&quot;

static cv::Mat  CameraExtrinsicMat;
static cv::Mat  CameraMat;
static cv::Mat  DistCoeff;
static cv::Size ImageSize;

static ros::Publisher camera_info_pub;
static ros::Publisher projection_matrix_pub;

static bool isRegister_tf;
static bool isPublish_extrinsic;
static bool isPublish_cameraInfo;

static std::string camera_id_str;

void tfRegistration (const cv::Mat &amp;camExtMat, const ros::Time&amp; timeStamp)
{
  tf::Matrix3x3 rotation_mat;
  double roll = 0, pitch = 0, yaw = 0;
  tf::Quaternion quaternion;
  tf::Transform transform;
  static tf::TransformBroadcaster broadcaster;

 rotation_mat.setValue(camExtMat.at&lt;double&gt;(0, 0), camExtMat.at&lt;double&gt;(0, 1), camExtMat.at&lt;double&gt;(0, 2),
                        camExtMat.at&lt;double&gt;(1, 0), camExtMat.at&lt;double&gt;(1, 1), camExtMat.at&lt;double&gt;(1, 2),
                        camExtMat.at&lt;double&gt;(2, 0), camExtMat.at&lt;double&gt;(2, 1), camExtMat.at&lt;double&gt;(2, 2));

  rotation_mat.getRPY(roll, pitch, yaw, 1);

  quaternion.setRPY(roll, pitch, yaw);

  transform.setOrigin(tf::Vector3(camExtMat.at&lt;double&gt;(0, 3),
                                  camExtMat.at&lt;double&gt;(1, 3),
                                  camExtMat.at&lt;double&gt;(2, 3)));

  transform.setRotation(quaternion);

  broadcaster.sendTransform(tf::StampedTransform(transform, timeStamp, &quot;velodyne&quot;, camera_id_str));
  //broadcaster.sendTransform(tf::StampedTransform(transform, ros::Time::now(), &quot;velodyne&quot;, &quot;camera&quot;));
}


static void image_raw_cb(const sensor_msgs::Image&amp; image_msg)
{
  //ros::Time timeStampOfImage = image_msg.header.stamp;

  ros::Time timeStampOfImage;
  timeStampOfImage.sec = image_msg.header.stamp.sec;
  timeStampOfImage.nsec = image_msg.header.stamp.nsec;


  /* create TF between velodyne and camera with time stamp of /image_raw */
  tfRegistration(CameraExtrinsicMat, timeStampOfImage);

}

void projectionMatrix_sender(const cv::Mat  &amp;projMat)
{
	autoware_msgs::projection_matrix projMsg;

	projMsg.header.frame_id=camera_id_str;

	for (int row=0; row&lt;4; row++) {
	      for (int col=0; col&lt;4; col++) {
	    	  	  projMsg.projection_matrix[row * 4 + col] = projMat.at&lt;double&gt;(row, col);

	      }
	}
	projection_matrix_pub.publish(projMsg);
}

void cameraInfo_sender(const cv::Mat  &amp;camMat,
                       const cv::Mat  &amp;distCoeff,
                       const cv::Size &amp;imgSize)
{
  sensor_msgs::CameraInfo msg;

  msg.header.frame_id = camera_id_str;

  msg.height = imgSize.height;
  msg.width  = imgSize.width;

  for (int row=0; row&lt;3; row++) {
      for (int col=0; col&lt;3; col++) {
        msg.K[row * 3 + col] = camMat.at&lt;double&gt;(row, col);
        }
    }

  for (int row=0; row&lt;3; row++) {
    for (int col=0; col&lt;4; col++) {
      if (col == 3) {
        msg.P[row * 4 + col] = 0.0f;
      } else {
        msg.P[row * 4 + col] = camMat.at&lt;double&gt;(row, col);
      }
    }
  }

  for (int row=0; row&lt;distCoeff.rows; row++) {
    for (int col=0; col&lt;distCoeff.cols; col++) {
      msg.D.push_back(distCoeff.at&lt;double&gt;(row, col));
    }
  }

  camera_info_pub.publish(msg);
}


int main(int argc, char* argv[])
{
  ros::init(argc, argv, &quot;calibration_publisher&quot;);
  ros::NodeHandle n;
  ros::NodeHandle private_nh(&quot;~&quot;);

  if (!private_nh.getParam(&quot;register_lidar2camera_tf&quot;, isRegister_tf)) {
    isRegister_tf = true;
  }

  if (!private_nh.getParam(&quot;publish_extrinsic_mat&quot;, isPublish_extrinsic)) {
    isPublish_extrinsic = true; /* publish extrinsic_mat in default */
  }

  if (!private_nh.getParam(&quot;publish_camera_info&quot;, isPublish_cameraInfo)) {
    isPublish_extrinsic = false; /* doesn't publish camera_info in default */
  }

  if (argc &lt; 2)
    {
      std::cout &lt;&lt; &quot;Usage: calibration_publisher &lt;calibration-file&gt;.&quot; &lt;&lt; std::endl;
      return -1;
    }

  cv::FileStorage fs(argv[1], cv::FileStorage::READ);
  if (!fs.isOpened())
    {
      std::cout &lt;&lt; &quot;Cannot open &quot; &lt;&lt; argv[1] &lt;&lt; std::endl;
      return -1;
    }

  fs[&quot;CameraExtrinsicMat&quot;] &gt;&gt; CameraExtrinsicMat;
  fs[&quot;CameraMat&quot;] &gt;&gt; CameraMat;
  fs[&quot;DistCoeff&quot;] &gt;&gt; DistCoeff;
  fs[&quot;ImageSize&quot;] &gt;&gt; ImageSize;

  std::string image_topic_name(&quot;/image_raw&quot;);
  std::string camera_info_name(&quot;/camera/camera_info&quot;);
  std::string projection_matrix_name(&quot;/projection_matrix&quot;);

  std::string name_space_str = ros::this_node::getNamespace();
  camera_id_str = &quot;camera&quot;;
  if (name_space_str != &quot;/&quot;) {
    image_topic_name = name_space_str + image_topic_name;
    camera_info_name = name_space_str + camera_info_name;
    projection_matrix_name = name_space_str + projection_matrix_name;
    if (name_space_str.substr(0, 2) == &quot;//&quot;) {
      /* if name space obtained by ros::this::node::getNamespace()
         starts with &quot;//&quot;, delete one of them */
      name_space_str.erase(name_space_str.begin());
    }
    camera_id_str = name_space_str;
  }

  ros::Subscriber image_sub;
  if (isRegister_tf) {
    image_sub = n.subscribe(image_topic_name, 10, image_raw_cb);
  }

  if (isPublish_cameraInfo) {
    camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(camera_info_name, 10, true);
    cameraInfo_sender(CameraMat, DistCoeff, ImageSize);
  }

  if (isPublish_extrinsic) {
    projection_matrix_pub = n.advertise&lt;autoware_msgs::projection_matrix&gt;(projection_matrix_name, 10, true);
    projectionMatrix_sender(CameraExtrinsicMat);
  }

  ros::spin();

  return 0;

}
</old_file>
			</file>
			<file old_path="ros/src/sensing/fusion/packages/calibration_camera_lidar/nodes/calibration_toolkit/mainwindow.cpp" new_path="ros/src/sensing/fusion/packages/calibration_camera_lidar/nodes/calibration_toolkit/mainwindow.cpp">
				<diff>@@ -18,7 +18,7 @@ MainWindow::MainWindow(QWidget *parent) :
     std::vector&lt;std::string&gt; image_raw_topics;
     FILE *fp;
 
-    if(!(fp = popen(&quot;rostopic list | grep image_raw&quot;, &quot;r&quot;))) {
+    if(!(fp = popen(&quot;rostopic list&quot;, &quot;r&quot;))) {
       fprintf(stderr, &quot;cannot get image_raw topic list\n&quot;);
       exit(EXIT_FAILURE);
     }
@@ -27,7 +27,7 @@ MainWindow::MainWindow(QWidget *parent) :
     char topic[256];
     while((fgets(topic, 256, fp)) != NULL)
     {
-     if ((strstr(topic, &quot;image_raw&quot;)) != NULL)
+     //if ((strstr(topic, &quot;image_raw&quot;)) != NULL)
      {
        strtok(topic, &quot;\n\0&quot;);  // delete line feed code ('\n')
        image_raw_topics.push_back(std::string(topic));
</diff>
				<old_file>#include &quot;mainwindow.h&quot;
#include &quot;ui_mainwindow.h&quot;
#include &lt;stdio.h&gt;
#include &lt;string&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

#define CALIBCAMERA QString(&quot;Camera Only&quot;)
#define CALIBCAMERAVELODYNE QString(&quot;Camera -&gt; Velodyne&quot;)
#define CALIBCAMERA2DLIDAR QString(&quot;Camera -&gt; 2D LIDAR&quot;)

MainWindow::MainWindow(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::MainWindow)
{
    ui-&gt;setupUi(this);

    std::vector&lt;std::string&gt; image_raw_topics;
    FILE *fp;

    if(!(fp = popen(&quot;rostopic list | grep image_raw&quot;, &quot;r&quot;))) {
      fprintf(stderr, &quot;cannot get image_raw topic list\n&quot;);
      exit(EXIT_FAILURE);
    }


    char topic[256];
    while((fgets(topic, 256, fp)) != NULL)
    {
     if ((strstr(topic, &quot;image_raw&quot;)) != NULL)
     {
       strtok(topic, &quot;\n\0&quot;);  // delete line feed code ('\n')
       image_raw_topics.push_back(std::string(topic));
     }
    }

    if(image_raw_topics.empty())
    {
      QMessageBox msgBox(this);
      msgBox.setWindowTitle(tr(&quot;Warning&quot;));
      msgBox.setIcon(QMessageBox::Warning);
      msgBox.setText(tr(&quot;No image_raw topic found.\nProgram exits.&quot;));
      msgBox.exec();
      exit(EXIT_FAILURE);
    }

    pclose(fp);

    QStringList items;
    for (const auto&amp; ch : image_raw_topics)
    {
      items &lt;&lt; QString::fromStdString(ch);
    }

    QString inputcameratopic=QInputDialog::getItem(this, &quot;Select Input&quot;, &quot;Select Input Image Topic&quot;, items);
    QString selection=QInputDialog::getItem(this,&quot;Choose Calibration Type&quot;, &quot;Calibration Type&quot;,QStringList()&lt;&lt;CALIBCAMERA&lt;&lt;CALIBCAMERAVELODYNE&lt;&lt;CALIBCAMERA2DLIDAR,0,0);

    QSettings settings(&quot;RobotSDK&quot;,&quot;CalibrationToolkit&quot;);

    QSizeF patternsize=settings.value(&quot;PatternSize&quot;,QSizeF(0.035,0.035)).toSizeF();
    ui-&gt;patternwidth-&gt;setText(QString(&quot;%1&quot;).arg(patternsize.width()));
    ui-&gt;patternheight-&gt;setText(QString(&quot;%1&quot;).arg(patternsize.height()));
    cv::Size2f cvpatternsize=cv::Size2f(patternsize.width(),patternsize.height());

    QSize patternnum=settings.value(&quot;PatternNum&quot;,QSize(8,6)).toSize();
    ui-&gt;patterncolumn-&gt;setText(QString(&quot;%1&quot;).arg(patternnum.width()));
    ui-&gt;patternrow-&gt;setText(QString(&quot;%1&quot;).arg(patternnum.height()));
    cv::Size cvpatternnum=cv::Size(patternnum.width(),patternnum.height());


    if(selection==CALIBCAMERA)
    {
        QString cameratopic=inputcameratopic;
        CalibrateCameraChessboardROS * calibration=new CalibrateCameraChessboardROS(cameratopic,1000,10,cvpatternsize,cvpatternnum);
        ui-&gt;tabWidget-&gt;addTab(calibration,CALIBCAMERA);
        connect(ui-&gt;grab,SIGNAL(clicked()),calibration,SLOT(grabCalibDataSlot()));
        connect(ui-&gt;remove,SIGNAL(clicked()),calibration,SLOT(removeCalibDataSlot()));
        connect(ui-&gt;calibrate,SIGNAL(clicked()),calibration,SLOT(calibrateSensorSlot()));
        connect(ui-&gt;load,SIGNAL(clicked()),calibration,SLOT(loadCalibResultSlot()));
        connect(ui-&gt;save,SIGNAL(clicked()),calibration,SLOT(saveCalibResultSlot()));
        connect(ui-&gt;refresh,SIGNAL(clicked()),calibration,SLOT(refreshParametersSlot()));
        ui-&gt;Project-&gt;setEnabled(0);
    }
    else if(selection==CALIBCAMERAVELODYNE)
    {
        QString cameratopic=inputcameratopic;
        QString velodynetopic=&quot;/points_raw&quot;;
        CalibrateCameraVelodyneChessboardROS * calibration=new CalibrateCameraVelodyneChessboardROS(cameratopic,1000,10,velodynetopic,1000,10,100,cvpatternsize,cvpatternnum);
        ui-&gt;tabWidget-&gt;addTab(calibration,CALIBCAMERAVELODYNE);
        connect(ui-&gt;grab,SIGNAL(clicked()),calibration,SLOT(grabCalibDataSlot()));
        connect(ui-&gt;remove,SIGNAL(clicked()),calibration,SLOT(removeCalibDataSlot()));
        connect(ui-&gt;calibrate,SIGNAL(clicked()),calibration,SLOT(calibrateSensorSlot()));
        connect(ui-&gt;load,SIGNAL(clicked()),calibration,SLOT(loadCalibResultSlot()));
        connect(ui-&gt;save,SIGNAL(clicked()),calibration,SLOT(saveCalibResultSlot()));
        connect(ui-&gt;refresh,SIGNAL(clicked()),calibration,SLOT(refreshParametersSlot()));
        connect(ui-&gt;Project,SIGNAL(clicked()),calibration,SLOT(projectPointsSlot()));
    }
    else if(selection==CALIBCAMERA2DLIDAR)
    {
        QString cameratopic=inputcameratopic;
        QString lidartopic=&quot;/scan&quot;;
        CalibrateCameraLidarChessboardROS * calibration=new CalibrateCameraLidarChessboardROS(cameratopic,1000,10,lidartopic,1000,10,100,cvpatternsize,cvpatternnum);
        ui-&gt;tabWidget-&gt;addTab(calibration,CALIBCAMERA2DLIDAR);
        connect(ui-&gt;grab,SIGNAL(clicked()),calibration,SLOT(grabCalibDataSlot()));
        connect(ui-&gt;remove,SIGNAL(clicked()),calibration,SLOT(removeCalibDataSlot()));
        connect(ui-&gt;calibrate,SIGNAL(clicked()),calibration,SLOT(calibrateSensorSlot()));
        connect(ui-&gt;load,SIGNAL(clicked()),calibration,SLOT(loadCalibResultSlot()));
        connect(ui-&gt;save,SIGNAL(clicked()),calibration,SLOT(saveCalibResultSlot()));
        connect(ui-&gt;refresh,SIGNAL(clicked()),calibration,SLOT(refreshParametersSlot()));
        connect(ui-&gt;Project,SIGNAL(clicked()),calibration,SLOT(projectPointsSlot()));
    }
}

MainWindow::~MainWindow()
{
    QSettings settings(&quot;RobotSDK&quot;,&quot;CalibrationToolkit&quot;);
    settings.setValue(&quot;PatternSize&quot;,QSizeF(ui-&gt;patternwidth-&gt;text().toFloat(),ui-&gt;patternheight-&gt;text().toFloat()));
    settings.setValue(&quot;PatternNum&quot;,QSize(ui-&gt;patterncolumn-&gt;text().toInt(),ui-&gt;patternrow-&gt;text().toInt()));
    delete ui;
}
</old_file>
			</file>
			<file old_path="ros/src/sensing/fusion/packages/points2image/lib/points_image/points_image.cpp" new_path="ros/src/sensing/fusion/packages/points2image/lib/points_image/points_image.cpp">
				<diff>@@ -72,7 +72,7 @@ pointcloud2_to_image(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud2,
 			point.at&lt;double&gt;(2) = double(fp[2]);
 			point = point * invR.t() + invT.t();
 
-			if (point.at&lt;double&gt;(2) &lt;= 2.5) {
+			if (point.at&lt;double&gt;(2) &lt;= 1) {
 				continue;
 			}
 
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;vector&gt;
#include &lt;points_image.hpp&gt;
#include &lt;stdint.h&gt;
#include &lt;iostream&gt;

autoware_msgs::PointsImage
pointcloud2_to_image(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud2,
		     const cv::Mat&amp; cameraExtrinsicMat,
		     const cv::Mat&amp; cameraMat, const cv::Mat&amp; distCoeff,
		     const cv::Size&amp; imageSize)
{
	int w = imageSize.width;
	int h = imageSize.height;

	autoware_msgs::PointsImage msg;

	msg.header = pointcloud2-&gt;header;

	msg.intensity.assign(w * h, 0);
	msg.distance.assign(w * h, 0);
	msg.min_height.assign(w * h, 0);
	msg.max_height.assign(w * h, 0);

	cv::Mat invR = cameraExtrinsicMat(cv::Rect(0,0,3,3)).t();
	cv::Mat invT = -invR*(cameraExtrinsicMat(cv::Rect(3,0,1,3)));
	uintptr_t cp = (uintptr_t)pointcloud2-&gt;data.data();

	msg.max_y = -1;
	msg.min_y = h;

	msg.image_height = imageSize.height;
	msg.image_width = imageSize.width;

	for (uint32_t y = 0; y &lt; pointcloud2-&gt;height; ++y) {
		for (uint32_t x = 0; x &lt; pointcloud2-&gt;width; ++x) {
			float* fp = (float *)(cp + (x + y*pointcloud2-&gt;width) * pointcloud2-&gt;point_step);
			double intensity = fp[4];

			cv::Mat point(1, 3, CV_64F);
			point.at&lt;double&gt;(0) = double(fp[0]);
			point.at&lt;double&gt;(1) = double(fp[1]);
			point.at&lt;double&gt;(2) = double(fp[2]);
			point = point * invR.t() + invT.t();

			if (point.at&lt;double&gt;(2) &lt;= 2.5) {
				continue;
			}

			double tmpx = point.at&lt;double&gt;(0) / point.at&lt;double&gt;(2);
			double tmpy = point.at&lt;double&gt;(1)/point.at&lt;double&gt;(2);
			double r2 = tmpx * tmpx + tmpy * tmpy;
			double tmpdist = 1 + distCoeff.at&lt;double&gt;(0) * r2
				+ distCoeff.at&lt;double&gt;(1) * r2 * r2
				+ distCoeff.at&lt;double&gt;(4) * r2 * r2 * r2;

			cv::Point2d imagepoint;
			imagepoint.x = tmpx * tmpdist
				+ 2 * distCoeff.at&lt;double&gt;(2) * tmpx * tmpy
				+ distCoeff.at&lt;double&gt;(3) * (r2 + 2 * tmpx * tmpx);
			imagepoint.y = tmpy * tmpdist
				+ distCoeff.at&lt;double&gt;(2) * (r2 + 2 * tmpy * tmpy)
				+ 2 * distCoeff.at&lt;double&gt;(3) * tmpx * tmpy;
			imagepoint.x = cameraMat.at&lt;double&gt;(0,0) * imagepoint.x + cameraMat.at&lt;double&gt;(0,2);
			imagepoint.y = cameraMat.at&lt;double&gt;(1,1) * imagepoint.y + cameraMat.at&lt;double&gt;(1,2);

			int px = int(imagepoint.x + 0.5);
			int py = int(imagepoint.y + 0.5);
			if(0 &lt;= px &amp;&amp; px &lt; w &amp;&amp; 0 &lt;= py &amp;&amp; py &lt; h)
			{
				int pid = py * w + px;
				if(msg.distance[pid] == 0 ||
				   msg.distance[pid] &gt; point.at&lt;double&gt;(2))
				{
					msg.distance[pid] = float(point.at&lt;double&gt;(2) * 100);
					msg.intensity[pid] = float(intensity);

					msg.max_y = py &gt; msg.max_y ? py : msg.max_y;
					msg.min_y = py &lt; msg.min_y ? py : msg.min_y;

				}
				if (0 == y &amp;&amp; pointcloud2-&gt;height == 2)//process simultaneously min and max during the first layer
				{
					float* fp2 = (float *)(cp + (x + (y+1)*pointcloud2-&gt;width) * pointcloud2-&gt;point_step);
					msg.min_height[pid] = fp[2];
					msg.max_height[pid] = fp2[2];
				}
				else
				{
					msg.min_height[pid] = -1.25;
					msg.max_height[pid] = 0;
				}
			}
		}
	}

	return msg;
}

/*autoware_msgs::CameraExtrinsic
pointcloud2_to_3d_calibration(const sensor_msgs::PointCloud2ConstPtr&amp; pointcloud2,
			      const cv::Mat&amp; cameraExtrinsicMat)
{
	autoware_msgs::CameraExtrinsic msg;
	std::vector&lt;double&gt; cali;
	for (int y = 0; y &lt; msg.ysize ; ++y) {
		for (int x = 0; x &lt; msg.xsize ; ++x){
			cali.push_back(cameraExtrinsicMat.at&lt;double&gt;(y,x));
		}
	}

	msg.calibration = cali;
	return msg;
}
*/
</old_file>
			</file>
			<file old_path="ros/src/sensing/fusion/packages/points2image/nodes/points2image/points2image.cpp" new_path="ros/src/sensing/fusion/packages/points2image/nodes/points2image/points2image.cpp">
				<diff>@@ -81,7 +81,7 @@ static void callback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
 {
 	if (cameraExtrinsicMat.empty() || cameraMat.empty() || distCoeff.empty() || imageSize.height == 0 || imageSize.width == 0)
 	{
-		ROS_INFO(&quot;Looks like /camera/camera_info or /projection_matrix are not being published.. Please check that both are running..&quot;);
+		ROS_INFO(&quot;[points2image]Looks like camera_info or projection_matrix are not being published.. Please check that both are running..&quot;);
 		return;
 	}
 
@@ -89,10 +89,6 @@ static void callback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
 		= pointcloud2_to_image(msg, cameraExtrinsicMat, cameraMat,
 				       distCoeff, imageSize);
 	pub.publish(pub_msg);
-
-	/*autoware_msgs::CameraExtrinsic cpub_msg
-		= pointcloud2_to_3d_calibration(msg, cameraExtrinsicMat);
-	cpub.publish(cpub_msg);*/
 }
 
 int main(int argc, char *argv[])
@@ -100,64 +96,48 @@ int main(int argc, char *argv[])
 	ros::init(argc, argv, &quot;points2image&quot;);
 	ros::NodeHandle n;
 
-	/*if(argc &lt; 2){
-		std::cout&lt;&lt;&quot;Need calibration filename as the first parameter.&quot;;
-		return 0;
-	}*/
-
-	/*cv::FileStorage fs(argv[1], cv::FileStorage::READ);
-	if(!fs.isOpened()){
-		std::cout&lt;&lt;&quot;Invalid calibration filename.&quot;;
-		return 0;
-	}*/
-
-	/*fs[CAMERAEXTRINSICMAT] &gt;&gt; cameraExtrinsicMat;
-	fs[CAMERAMAT] &gt;&gt; cameraMat;
-	fs[DISTCOEFF] &gt;&gt; distCoeff;
-	fs[IMAGESIZE] &gt;&gt; imageSize;*/
-	//imageSize.width = IMAGE_WIDTH;
-	//imageSize.height = IMAGE_HEIGHT;
-
-	pub = n.advertise&lt;autoware_msgs::PointsImage&gt;(&quot;points_image&quot;, 10);
-	//cpub = n.advertise&lt;autoware_msgs::CameraExtrinsic&gt;(&quot;threeD_calibration&quot;, 1);
 	ros::NodeHandle private_nh(&quot;~&quot;);
 
-	std::string points_topic;
-	if (private_nh.getParam(&quot;points_node&quot;, points_topic))
-	{
-		ROS_INFO(&quot;Setting points node to %s&quot;, points_topic.c_str());
-	}
-	else
-	{
-		ROS_INFO(&quot;No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC&quot;);
-		points_topic = &quot;points_raw&quot;;
-	}
+	std::string camera_info_topic_str;
+	std::string projection_matrix_topic;
+	std::string pub_topic_str=&quot;/points_image&quot;;
 
-	std::string camera_info_topic;
-	if (private_nh.getParam(&quot;camera_info_topic&quot;, camera_info_topic))
-	{
-		ROS_INFO(&quot;Setting camera_info topic to %s&quot;, camera_info_topic.c_str());
-	}
-	else
-	{
-		ROS_INFO(&quot;No camera info topic received, defaulting to /camera/camera_info, you can use _camera_info_topic:=YOUR_TOPIC&quot;);
-		camera_info_topic = &quot;/camera/camera_info&quot;;
+	private_nh.param&lt;std::string&gt;(&quot;projection_matrix_topic&quot;, projection_matrix_topic, &quot;/projection_matrix&quot;);
+	private_nh.param&lt;std::string&gt;(&quot;camera_info_topic&quot;, camera_info_topic_str, &quot;/camera_info&quot;);
+
+	std::string name_space_str = ros::this_node::getNamespace();
+
+	if (name_space_str != &quot;/&quot;) {
+		if (name_space_str.substr(0, 2) == &quot;//&quot;) {
+			/* if name space obtained by ros::this::node::getNamespace()
+			   starts with &quot;//&quot;, delete one of them */
+			name_space_str.erase(name_space_str.begin());
+		}
+		pub_topic_str = name_space_str + pub_topic_str;
+		projection_matrix_topic = name_space_str+projection_matrix_topic;
+		camera_info_topic_str = name_space_str + camera_info_topic_str;
 	}
 
-	std::string projection_matrix_topic;
-	if (private_nh.getParam(&quot;projection_matrix_topic&quot;, projection_matrix_topic))
+	std::string points_topic;
+	if (private_nh.getParam(&quot;points_node&quot;, points_topic))
 	{
-		ROS_INFO(&quot;Setting projection_matrix topic to %s&quot;, projection_matrix_topic.c_str());
+		ROS_INFO(&quot;[points2image]Setting points node to %s&quot;, points_topic.c_str());
 	}
 	else
 	{
-		ROS_INFO(&quot;No projection matrix topic received, defaulting to /projection_matrix, you can use _projection_matrix_topic:=YOUR_TOPIC&quot;);
-		projection_matrix_topic = &quot;/projection_matrix&quot;;
+		ROS_INFO(&quot;[points2image]No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC&quot;);
+		points_topic = &quot;/points_raw&quot;;
 	}
 
+	ROS_INFO(&quot;[points2image]Publishing to... %s&quot;, pub_topic_str.c_str());
+	pub = n.advertise&lt;autoware_msgs::PointsImage&gt;(pub_topic_str, 10);
+
 	ros::Subscriber sub = n.subscribe(points_topic, 1, callback);
+
+	ROS_INFO(&quot;[points2image]Subscribing to... %s&quot;, projection_matrix_topic.c_str());
 	ros::Subscriber projection = n.subscribe(projection_matrix_topic, 1, projection_callback);
-	ros::Subscriber intrinsic = n.subscribe(camera_info_topic, 1, intrinsic_callback);
+	ROS_INFO(&quot;[points2image]Subscribing to... %s&quot;, camera_info_topic_str.c_str());
+	ros::Subscriber intrinsic = n.subscribe(camera_info_topic_str, 1, intrinsic_callback);
 
 	ros::spin();
 	return 0;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &quot;autoware_msgs/PointsImage.h&quot;
#include &quot;autoware_msgs/projection_matrix.h&quot;
//#include &quot;autoware_msgs/CameraExtrinsic.h&quot;

#include &lt;points_image.hpp&gt;

#define CAMERAEXTRINSICMAT &quot;CameraExtrinsicMat&quot;
#define CAMERAMAT &quot;CameraMat&quot;
#define DISTCOEFF &quot;DistCoeff&quot;
#define IMAGESIZE &quot;ImageSize&quot;

static cv::Mat cameraExtrinsicMat;
static cv::Mat cameraMat;
static cv::Mat distCoeff;
static cv::Size imageSize;

static ros::Publisher pub;

static void projection_callback(const autoware_msgs::projection_matrix&amp; msg)
{
	cameraExtrinsicMat = cv::Mat(4,4,CV_64F);
	for (int row=0; row&lt;4; row++) {
		for (int col=0; col&lt;4; col++) {
			cameraExtrinsicMat.at&lt;double&gt;(row, col) = msg.projection_matrix[row * 4 + col];
		}
	}
}

static void intrinsic_callback(const sensor_msgs::CameraInfo&amp; msg)
{
	imageSize.height = msg.height;
	imageSize.width = msg.width;

	cameraMat = cv::Mat(3,3, CV_64F);
	for (int row=0; row&lt;3; row++) {
		for (int col=0; col&lt;3; col++) {
			cameraMat.at&lt;double&gt;(row, col) = msg.K[row * 3 + col];
		}
	}

	distCoeff = cv::Mat(1,5,CV_64F);
	for (int col=0; col&lt;5; col++) {
		distCoeff.at&lt;double&gt;(col) = msg.D[col];
	}
}

static void callback(const sensor_msgs::PointCloud2ConstPtr&amp; msg)
{
	if (cameraExtrinsicMat.empty() || cameraMat.empty() || distCoeff.empty() || imageSize.height == 0 || imageSize.width == 0)
	{
		ROS_INFO(&quot;Looks like /camera/camera_info or /projection_matrix are not being published.. Please check that both are running..&quot;);
		return;
	}

	autoware_msgs::PointsImage pub_msg
		= pointcloud2_to_image(msg, cameraExtrinsicMat, cameraMat,
				       distCoeff, imageSize);
	pub.publish(pub_msg);

	/*autoware_msgs::CameraExtrinsic cpub_msg
		= pointcloud2_to_3d_calibration(msg, cameraExtrinsicMat);
	cpub.publish(cpub_msg);*/
}

int main(int argc, char *argv[])
{
	ros::init(argc, argv, &quot;points2image&quot;);
	ros::NodeHandle n;

	/*if(argc &lt; 2){
		std::cout&lt;&lt;&quot;Need calibration filename as the first parameter.&quot;;
		return 0;
	}*/

	/*cv::FileStorage fs(argv[1], cv::FileStorage::READ);
	if(!fs.isOpened()){
		std::cout&lt;&lt;&quot;Invalid calibration filename.&quot;;
		return 0;
	}*/

	/*fs[CAMERAEXTRINSICMAT] &gt;&gt; cameraExtrinsicMat;
	fs[CAMERAMAT] &gt;&gt; cameraMat;
	fs[DISTCOEFF] &gt;&gt; distCoeff;
	fs[IMAGESIZE] &gt;&gt; imageSize;*/
	//imageSize.width = IMAGE_WIDTH;
	//imageSize.height = IMAGE_HEIGHT;

	pub = n.advertise&lt;autoware_msgs::PointsImage&gt;(&quot;points_image&quot;, 10);
	//cpub = n.advertise&lt;autoware_msgs::CameraExtrinsic&gt;(&quot;threeD_calibration&quot;, 1);
	ros::NodeHandle private_nh(&quot;~&quot;);

	std::string points_topic;
	if (private_nh.getParam(&quot;points_node&quot;, points_topic))
	{
		ROS_INFO(&quot;Setting points node to %s&quot;, points_topic.c_str());
	}
	else
	{
		ROS_INFO(&quot;No points node received, defaulting to points_raw, you can use _points_node:=YOUR_TOPIC&quot;);
		points_topic = &quot;points_raw&quot;;
	}

	std::string camera_info_topic;
	if (private_nh.getParam(&quot;camera_info_topic&quot;, camera_info_topic))
	{
		ROS_INFO(&quot;Setting camera_info topic to %s&quot;, camera_info_topic.c_str());
	}
	else
	{
		ROS_INFO(&quot;No camera info topic received, defaulting to /camera/camera_info, you can use _camera_info_topic:=YOUR_TOPIC&quot;);
		camera_info_topic = &quot;/camera/camera_info&quot;;
	}

	std::string projection_matrix_topic;
	if (private_nh.getParam(&quot;projection_matrix_topic&quot;, projection_matrix_topic))
	{
		ROS_INFO(&quot;Setting projection_matrix topic to %s&quot;, projection_matrix_topic.c_str());
	}
	else
	{
		ROS_INFO(&quot;No projection matrix topic received, defaulting to /projection_matrix, you can use _projection_matrix_topic:=YOUR_TOPIC&quot;);
		projection_matrix_topic = &quot;/projection_matrix&quot;;
	}

	ros::Subscriber sub = n.subscribe(points_topic, 1, callback);
	ros::Subscriber projection = n.subscribe(projection_matrix_topic, 1, projection_callback);
	ros::Subscriber intrinsic = n.subscribe(camera_info_topic, 1, intrinsic_callback);

	ros::spin();
	return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="e11218575c498c7534bbbd2bb8510ea27e2dc80c" fix_time="808,56431">
		<msg>add fix2tfpose.launch</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/localization/packages/gnss_localizer/nodes/fix2tfpose/fix2tfpose.cpp" new_path="ros/src/computing/perception/localization/packages/gnss_localizer/nodes/fix2tfpose/fix2tfpose.cpp">
				<diff>@@ -28,11 +28,11 @@
  *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include &lt;ros/ros.h&gt;
 #include &lt;geometry_msgs/PointStamped.h&gt;
 #include &lt;geometry_msgs/PoseStamped.h&gt;
-#include &lt;sensor_msgs/NavSatFix.h&gt;
 #include &lt;geometry_msgs/Twist.h&gt;
+#include &lt;ros/ros.h&gt;
+#include &lt;sensor_msgs/NavSatFix.h&gt;
 #include &lt;std_msgs/Bool.h&gt;
 #include &lt;tf/transform_broadcaster.h&gt;
 
@@ -49,73 +49,72 @@ static geometry_msgs::PoseStamped _prev_pose;
 static geometry_msgs::Quaternion _quat;
 static double yaw;
 
+static int _plane;
+
 static void GNSSCallback(const sensor_msgs::NavSatFixConstPtr &amp;msg)
 {
-    geo_pos_conv geo;
-
-    geo.set_plane(7);
-    geo.llh_to_xyz(msg-&gt;latitude, msg-&gt;longitude, msg-&gt;altitude);
-
-    static tf::TransformBroadcaster pose_broadcaster;
-    tf::Transform pose_transform;
-    tf::Quaternion pose_q;
-
-    geometry_msgs::PoseStamped pose;
-    pose.header = msg-&gt;header;
-   // pose.header.stamp = ros::Time::now();
-    pose.header.frame_id = &quot;map&quot;;
-    pose.pose.position.x = geo.y();
-    pose.pose.position.y = geo.x();
-    pose.pose.position.z = geo.z();
-
-    // set gnss_stat
-    if(pose.pose.position.x == 0.0 || pose.pose.position.y == 0.0 || pose.pose.position.z == 0.0){
-      gnss_stat_msg.data = false;
-    } else{
-      gnss_stat_msg.data = true;
-    }
-    
-    double distance = sqrt(
-            pow(pose.pose.position.y - _prev_pose.pose.position.y, 2)
-                    + pow(pose.pose.position.x - _prev_pose.pose.position.x,
-                            2));
-    std::cout &lt;&lt; &quot;distance : &quot; &lt;&lt; distance &lt;&lt; std::endl;
-
-    if (distance &gt; 0.2) {
-        yaw = atan2(pose.pose.position.y - _prev_pose.pose.position.y,
-                pose.pose.position.x - _prev_pose.pose.position.x);
-        _quat = tf::createQuaternionMsgFromYaw(yaw);
-        _prev_pose = pose;
-    }
-
-    pose.pose.orientation = _quat;
-    pose_publisher.publish(pose);
-    stat_publisher.publish(gnss_stat_msg);
-
-    //座標変換
-    static tf::TransformBroadcaster br;
-    tf::Transform transform;
-    tf::Quaternion q;
-    transform.setOrigin(
-            tf::Vector3(pose.pose.position.x, pose.pose.position.y,
-                    pose.pose.position.z));
-    q.setRPY(0, 0, yaw);
-    transform.setRotation(q);
-    br.sendTransform(
-            tf::StampedTransform(transform, msg-&gt;header.stamp, &quot;map&quot;,
-                    &quot;gps&quot;));
+  geo_pos_conv geo;
+
+  geo.set_plane(_plane);
+  geo.llh_to_xyz(msg-&gt;latitude, msg-&gt;longitude, msg-&gt;altitude);
+
+  static tf::TransformBroadcaster pose_broadcaster;
+  tf::Transform pose_transform;
+  tf::Quaternion pose_q;
+
+  geometry_msgs::PoseStamped pose;
+  pose.header = msg-&gt;header;
+  // pose.header.stamp = ros::Time::now();
+  pose.header.frame_id = &quot;map&quot;;
+  pose.pose.position.x = geo.y();
+  pose.pose.position.y = geo.x();
+  pose.pose.position.z = geo.z();
+
+  // set gnss_stat
+  if (pose.pose.position.x == 0.0 || pose.pose.position.y == 0.0 || pose.pose.position.z == 0.0)
+  {
+    gnss_stat_msg.data = false;
+  }
+  else
+  {
+    gnss_stat_msg.data = true;
+  }
+
+  double distance = sqrt(pow(pose.pose.position.y - _prev_pose.pose.position.y, 2) +
+                         pow(pose.pose.position.x - _prev_pose.pose.position.x, 2));
+  std::cout &lt;&lt; &quot;distance : &quot; &lt;&lt; distance &lt;&lt; std::endl;
+
+  if (distance &gt; 0.2)
+  {
+    yaw = atan2(pose.pose.position.y - _prev_pose.pose.position.y, pose.pose.position.x - _prev_pose.pose.position.x);
+    _quat = tf::createQuaternionMsgFromYaw(yaw);
+    _prev_pose = pose;
+  }
+
+  pose.pose.orientation = _quat;
+  pose_publisher.publish(pose);
+  stat_publisher.publish(gnss_stat_msg);
+
+  //座標変換
+  static tf::TransformBroadcaster br;
+  tf::Transform transform;
+  tf::Quaternion q;
+  transform.setOrigin(tf::Vector3(pose.pose.position.x, pose.pose.position.y, pose.pose.position.z));
+  q.setRPY(0, 0, yaw);
+  transform.setRotation(q);
+  br.sendTransform(tf::StampedTransform(transform, msg-&gt;header.stamp, &quot;map&quot;, &quot;gps&quot;));
 }
 
 int main(int argc, char **argv)
 {
-    ros::init(argc, argv, &quot;gnss_pos&quot;);
-    ros::NodeHandle nh;
-    pose_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;gnss_pose&quot;,
-            1000);
-    stat_publisher = nh.advertise&lt;std_msgs::Bool&gt;(&quot;/gnss_stat&quot;, 1000);
-    ros::Subscriber gnss_pose_subscriber = nh.subscribe(&quot;fix&quot;, 100,
-            GNSSCallback);
-
-    ros::spin();
-    return 0;
+  ros::init(argc, argv, &quot;fix2tfpose&quot;);
+  ros::NodeHandle nh;
+  ros::NodeHandle private_nh(&quot;~&quot;);
+  private_nh.getParam(&quot;plane&quot;, _plane);
+  pose_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;gnss_pose&quot;, 1000);
+  stat_publisher = nh.advertise&lt;std_msgs::Bool&gt;(&quot;/gnss_stat&quot;, 1000);
+  ros::Subscriber gnss_pose_subscriber = nh.subscribe(&quot;fix&quot;, 100, GNSSCallback);
+
+  ros::spin();
+  return 0;
 }
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &lt;ros/ros.h&gt;
#include &lt;geometry_msgs/PointStamped.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;sensor_msgs/NavSatFix.h&gt;
#include &lt;geometry_msgs/Twist.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;

#include &lt;iostream&gt;

#include &quot;geo_pos_conv.hh&quot;

static ros::Publisher pose_publisher;

static ros::Publisher stat_publisher;
static std_msgs::Bool gnss_stat_msg;

static geometry_msgs::PoseStamped _prev_pose;
static geometry_msgs::Quaternion _quat;
static double yaw;

static void GNSSCallback(const sensor_msgs::NavSatFixConstPtr &amp;msg)
{
    geo_pos_conv geo;

    geo.set_plane(7);
    geo.llh_to_xyz(msg-&gt;latitude, msg-&gt;longitude, msg-&gt;altitude);

    static tf::TransformBroadcaster pose_broadcaster;
    tf::Transform pose_transform;
    tf::Quaternion pose_q;

    geometry_msgs::PoseStamped pose;
    pose.header = msg-&gt;header;
   // pose.header.stamp = ros::Time::now();
    pose.header.frame_id = &quot;map&quot;;
    pose.pose.position.x = geo.y();
    pose.pose.position.y = geo.x();
    pose.pose.position.z = geo.z();

    // set gnss_stat
    if(pose.pose.position.x == 0.0 || pose.pose.position.y == 0.0 || pose.pose.position.z == 0.0){
      gnss_stat_msg.data = false;
    } else{
      gnss_stat_msg.data = true;
    }
    
    double distance = sqrt(
            pow(pose.pose.position.y - _prev_pose.pose.position.y, 2)
                    + pow(pose.pose.position.x - _prev_pose.pose.position.x,
                            2));
    std::cout &lt;&lt; &quot;distance : &quot; &lt;&lt; distance &lt;&lt; std::endl;

    if (distance &gt; 0.2) {
        yaw = atan2(pose.pose.position.y - _prev_pose.pose.position.y,
                pose.pose.position.x - _prev_pose.pose.position.x);
        _quat = tf::createQuaternionMsgFromYaw(yaw);
        _prev_pose = pose;
    }

    pose.pose.orientation = _quat;
    pose_publisher.publish(pose);
    stat_publisher.publish(gnss_stat_msg);

    //座標変換
    static tf::TransformBroadcaster br;
    tf::Transform transform;
    tf::Quaternion q;
    transform.setOrigin(
            tf::Vector3(pose.pose.position.x, pose.pose.position.y,
                    pose.pose.position.z));
    q.setRPY(0, 0, yaw);
    transform.setRotation(q);
    br.sendTransform(
            tf::StampedTransform(transform, msg-&gt;header.stamp, &quot;map&quot;,
                    &quot;gps&quot;));
}

int main(int argc, char **argv)
{
    ros::init(argc, argv, &quot;gnss_pos&quot;);
    ros::NodeHandle nh;
    pose_publisher = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;gnss_pose&quot;,
            1000);
    stat_publisher = nh.advertise&lt;std_msgs::Bool&gt;(&quot;/gnss_stat&quot;, 1000);
    ros::Subscriber gnss_pose_subscriber = nh.subscribe(&quot;fix&quot;, 100,
            GNSSCallback);

    ros::spin();
    return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="9b16d08867b160038e073bbe0c107ba491d776fe" fix_time="34,59693">
		<msg>Add feature of to find stopline. and following minor fixes
- to change vectormap operation to vectormap lib.
- to change state operation</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/libs/libamathutils/include/amathutils.hpp" new_path="ros/src/computing/planning/decision/libs/libamathutils/include/amathutils.hpp">
				<diff>@@ -51,6 +51,13 @@ inline double getAcceleration(double v0, double v, double x)
 inline double getTimefromAcceleration(double v0, double v, double a)
 {
 	return  (v - v0) / a;
-} 
 }
+
+
+bool isIntersectLine(double p1x, double p1y, double p2x, double p2y,
+			double p3x, double p3y, double p4x, double p4y);
+
+}
+ int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y,
+		  double line_p2x, double line_p2y);
 #endif
</diff>
				<old_file>#ifndef __AMATHUTILS_HPP
#define __AMATHUTILS_HPP

#include &lt;cmath&gt;
#include &lt;iostream&gt;

using namespace std;

namespace amathutils
{

class point
{
private:
public:
  double x, y, z;

  point(void)
  {
    x = y = z = 0.0;
  }

  point(double _x, double _y, double _z)
  {
    x = _x;
    y = _y;
    z = _z;
  }
};
double find_distance(point *_a, point *_b);
double find_angle(point *_a, point *_b);

inline double mps2kmph(double _mpsval)
{
  return (_mpsval * 0.36 );// mps * 60secs * 60minutes / 1000m
}

#define G_MPSS 9.80665 // m/s^2


inline double getGravityAcceleration(double acceleration_mpss)
{
	return acceleration_mpss /  G_MPSS;
}

inline double getAcceleration(double v0, double v, double x)
{
	return  (v * v - v0 * v0) / 2 / x;
}

inline double getTimefromAcceleration(double v0, double v, double a)
{
	return  (v - v0) / a;
} 
}
#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libamathutils/src/Amathutils.cpp" new_path="ros/src/computing/planning/decision/libs/libamathutils/src/Amathutils.cpp">
				<diff>@@ -20,6 +20,35 @@ namespace amathutils
     return _angle * 360 / (2 * M_PI);
   }
 
+  bool isIntersectLine(double p1x, double p1y, double p2x, double p2y,
+		  double p3x, double p3y, double p4x, double p4y)
+  {
+	  double ta = (p3x - p4x) * (p1y-p3y) + (p3y - p4y) * (p3x - p4x);
+	  double tb = (p3x - p4x) * (p2y-p3y) + (p3y - p4y) * (p3x - p2x);
+	  double tc = (p1x - p2x) * (p3y-p1y) + (p1y - p2y) * (p1x - p3x);
+	  double td = (p1x - p2x) * (p4y-p1y) + (p1y - p2y) * (p1x - p4x);
+
+
+	  if( tc * td &lt; 0 &amp;&amp; ta * tb &lt; 0)
+		  return true;
+	  else
+		  return false;
+  }
+#define LEFT 1
+#define RIGHT -1
+#define ONLINE 0
+
+  int isPointLeftFromLine(double p1x, double p1y, double line_p1x, double line_p1y,
+		  double line_p2x, double line_p2y){
+
+	  double n = p1x * (line_p1y - line_p2y) + 
+		  line_p1x * (line_p2y - p1y) + 
+		  line_p2x * (p1y - line_p1y);
+
+	  return n &gt; 0? 1:
+		  n &lt; 0? -1: 0;
+
+  }
 
 
 } 
</diff>
				<old_file>#include &quot;amathutils.hpp&quot;

namespace amathutils
{
  double find_distance(point *_a, point *_b)
  {
    return std::hypot(std::hypot(_a-&gt;x - _b-&gt;x, _a-&gt;y - _b-&gt;y), _a-&gt;z - _b-&gt;z);
  }
  double find_distance(point &amp;_a, point &amp;_b)
  {
    return std::hypot(std::hypot(_a.x - _b.x, _a.y - _b.y), _a.z - _b.z);
  }

  double find_angle(point *_a, point *_b)
  {
    double _angle = std::atan2(_b-&gt;y - _a-&gt;y, _b-&gt;x - _a-&gt;x);
    if (_angle &lt; 0.0)
      _angle = _angle + 2 * M_PI;

    return _angle * 360 / (2 * M_PI);
  }



} 
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp">
				<diff>@@ -51,7 +51,8 @@ public:
   virtual unsigned long long getStateNum(void) = 0;
   virtual std::string getStateName(void) = 0;
   virtual unsigned char getStateKind(void) = 0;
-  virtual void setCallbackFunc(std::function&lt;void(void)&gt; _f)=0;
+  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)=0;
+  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)=0;
 };
 
 // Interface
@@ -64,7 +65,8 @@ protected:
   unsigned long long StateTransMask;
   unsigned char StateKind;
 
-  std::function&lt;void(void)&gt; StateCallbackFunc;
+  std::function&lt;void(void)&gt; StateUpdateFunc;
+  std::function&lt;void(void)&gt; StateChangedFunc;
   
   State()
   {
@@ -75,12 +77,16 @@ protected:
 
 public:
   virtual void update(void){
-	if(StateCallbackFunc)
-		StateCallbackFunc();
+	if(StateUpdateFunc)
+		StateUpdateFunc();
   }
 
-  virtual void setCallbackFunc(std::function&lt;void(void)&gt; _f){
-	StateCallbackFunc = _f;
+  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f){
+	StateUpdateFunc = _f;
+  }
+
+  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f){
+	StateChangedFunc = _f;
   }
 
   void showStateName(void)
</diff>
				<old_file>#ifndef __STATE_HPP__
#define __STATE_HPP__

#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;state_flags.hpp&gt;

namespace state_machine
{
class StartState;
class InitialState;
class LocateVehicleState;

class DriveState;
// Accel/Brake subState
class DriveAccAccelerationState;
class DriveAccDecelerationState;
class DriveAccKeepState;
class DriveAccStopState;
// Steering subState
class DriveStrStraightState;
class DriveStrLeftTurnState;
class DriveStrRightTurnState;

// Behavior subState
class DriveBehaviorLaneChangeLeftState;
class DriveBehaviorLaneChangeRightState;
class DriveBehaviorObstacleAvoidanceState;

// Perception subState
class DriveDetectObstacleState;
class DriveDetectStoplineState;
class DriveDetectTrafficlightRedState;

class MissionCompleteState;
class EmergencyState;

// base class
class BaseState
{
protected:
  BaseState()
  {
  }
public:
  virtual void update(void) = 0;
  virtual void showStateName(void) = 0;
  virtual unsigned long long getStateTransMask(void) = 0;
  virtual unsigned long long getStateNum(void) = 0;
  virtual std::string getStateName(void) = 0;
  virtual unsigned char getStateKind(void) = 0;
  virtual void setCallbackFunc(std::function&lt;void(void)&gt; _f)=0;
};

// Interface
template &lt;class T&gt;
class State : public BaseState
{
protected:
  std::string StateName = &quot;Base&quot;;
  unsigned long long StateNum;
  unsigned long long StateTransMask;
  unsigned char StateKind;

  std::function&lt;void(void)&gt; StateCallbackFunc;
  
  State()
  {
    StateNum = 0;
    StateTransMask = (unsigned long long)STATE_END - 1;
    StateKind = UNKNOWN_STATE;
  }

public:
  virtual void update(void){
	if(StateCallbackFunc)
		StateCallbackFunc();
  }

  virtual void setCallbackFunc(std::function&lt;void(void)&gt; _f){
	StateCallbackFunc = _f;
  }

  void showStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }

  static T* getInstance(void)
  {
    static T singleton;
    return &amp;singleton;
  }

  std::string getStateName(void)
  {
    return std::string(StateName);
  }

  unsigned char getStateKind(void)
  {
    return StateKind;
  }

  unsigned long long getStateTransMask(void)
  {
    return StateTransMask;
  }
  unsigned long long getStateNum(void)
  {
    return StateNum;
  }
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp">
				<diff>@@ -41,14 +41,13 @@ private:
   std::atomic&lt;bool&gt; thread_loop;
 
   std::thread *thr_state_dec;
-
-
   std::mutex change_state_mutex;
 
   void showStateMove(unsigned long long _state_num)
   {
     std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
   }
+  bool setCurrentState(BaseState *state);
 
 
 public:
@@ -104,7 +103,6 @@ public:
   bool inState(unsigned long long _state_num);
 
   bool setCurrentState(StateFlags flag);
-  bool setCurrentState(BaseState *state);
   bool disableCurrentState(unsigned long long);
 
   BaseState *getCurrentMainState(void);
@@ -115,6 +113,12 @@ public:
   void showCurrentStateName(void);
   std::string createStateMessageText(void);
 
+  unsigned long long getStateStateNum(BaseState *_state);
+  unsigned long long getStateTransMask(BaseState *_state);
+  bool isEmptyMainState(void);
+  bool isDifferentState(BaseState *_state_a, BaseState *_state_b);
+  unsigned char getStateFlags(BaseState *_state);
+
   std::string getCurrentStateName(StateKinds en);
 
   bool setEnableForceSetState(bool force_flag);
</diff>
				<old_file>#ifndef __STATE_CONTEXT_HPP__
#define __STATE_CONTEXT_HPP__

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;


#include &quot;state.hpp&quot;
#include &quot;state_main.hpp&quot;
#include &quot;state_drive.hpp&quot;
#include &quot;state_emg.hpp&quot;

namespace state_machine
{
class StateContext
{
private:

  class StateHolder
  {
  public:
    BaseState *MainState;
    BaseState *AccState;
    BaseState *StrState;
    BaseState *BehaviorState;
    BaseState *PerceptionState;
    BaseState *OtherState;
  } current_state_;

  std::vector&lt;BaseState **&gt; HolderList;

  std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;

  bool enableForceSetState;
  std::queue&lt;unsigned long long&gt; ChangeStateFlags;
  std::atomic&lt;bool&gt; thread_loop;

  std::thread *thr_state_dec;


  std::mutex change_state_mutex;

  void showStateMove(unsigned long long _state_num)
  {
    std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }


public:
  StateContext(void)
  {
    StateStores[START_STATE] = StartState::getInstance();
    StateStores[INITIAL_STATE] = InitialState::getInstance();
    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
    StateStores[DRIVE_STATE] = DriveState::getInstance();
    StateStores[DRIVE_ACC_ACCELERATION_STATE] = DriveAccAccelerationState::getInstance();
    StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
    StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
    StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
    StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
    StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
    StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
    StateStores[DRIVE_DETECT_OBSTACLE_STATE] = DriveDetectObstacleState::getInstance();
    StateStores[DRIVE_DETECT_STOPLINE_STATE] = DriveDetectStoplineState::getInstance();
    StateStores[DRIVE_DETECT_TRAFFICLIGHT_RED_STATE] = DriveDetectTrafficlightRedState::getInstance();
    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
    StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();

    HolderList.push_back(&amp;current_state_.MainState);
    HolderList.push_back(&amp;current_state_.AccState);
    HolderList.push_back(&amp;current_state_.StrState);
    HolderList.push_back(&amp;current_state_.BehaviorState);
    HolderList.push_back(&amp;current_state_.PerceptionState);
    HolderList.push_back(&amp;current_state_.OtherState);

    for (auto &amp;&amp;p : HolderList)
    {
      *p = nullptr;
    }
    thread_loop = true;

    this-&gt;InitContext();
  }

  ~StateContext()
  {
    thread_loop = false;
  }

  void update(void);
  void stateDecider(void);

  bool isState(BaseState *base, unsigned long long _state_num);
  bool isCurrentState(unsigned long long _state_num);
  bool isCurrentState(unsigned char _state_kind, unsigned long long _state_num);
  bool inState(unsigned long long _state_num);

  bool setCurrentState(StateFlags flag);
  bool setCurrentState(BaseState *state);
  bool disableCurrentState(unsigned long long);

  BaseState *getCurrentMainState(void);
  BaseState *getCurrentState(void);
  std::string getCurrentStateName(void);
  std::string getStateName(void);
  BaseState **getCurrentStateHolderPtr(unsigned long long _state_num);
  void showCurrentStateName(void);
  std::string createStateMessageText(void);

  std::string getCurrentStateName(StateKinds en);

  bool setEnableForceSetState(bool force_flag);
  BaseState *getStateObject(unsigned long long _state_num);
  void InitContext(void);

  bool TFInitialized(void);

  void handleTrafficLight(uint32_t _light_color);
  bool handleCurrentPose(double x, double y, double z, double roll, double pitch, double yaw);
  bool handlePointsRaw(bool _hasLidarData);

  bool handleIntersection(bool _hasIntersection, double _angle);
  bool handleTwistCmd(bool _hasTwistCmd);
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp" new_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp">
				<diff>@@ -53,16 +53,110 @@ void StateContext::showCurrentStateName(void)
 }
 
 
-/**
- * @fn
- * set to current state
- * @brief standard out a state name
- * @param (state) Setting class
- * @return void
- */
+bool StateContext::isDifferentState(BaseState *_state_a, BaseState *_state_b)
+{
+	return _state_a == _state_b;
+}
+
+bool StateContext::isEmptyMainState(void){
+	if(current_state_.MainState)
+		return false;
+	return true;
+}
+
+unsigned char StateContext::getStateFlags(BaseState *_state)
+{
+	if(_state)
+		return _state-&gt;getStateKind();
+	else
+		return NULL_STATE;
+}
+
+unsigned long long StateContext::getStateTransMask(BaseState *_state)
+{
+	if(_state)
+		return _state-&gt;getStateTransMask();
+	else
+		return 0;
+}
+
+unsigned long long StateContext::getStateStateNum(BaseState *_state)
+{
+	if(_state)
+		return _state-&gt;getStateNum();
+	else
+		return 0;
+}
+
+
+bool StateContext::setCurrentState(BaseState *_state)
+{
+  change_state_mutex.lock();
+
+  BaseState *prevState = current_state_.MainState;
+
+  if (isEmptyMainState() &amp;&amp; _state )
+  {
+    current_state_.MainState = _state;
+    std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
+              &lt;&lt; &quot;NULL&quot;
+              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
+              &lt;&lt; &quot;NULL&quot;
+              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
+  }
+  else
+  {
+    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
+    {
+      switch (getStateFlags(_state))
+      {
+        case MAIN_STATE:
+          current_state_.MainState = _state;
+          current_state_.AccState = nullptr;
+          current_state_.StrState = nullptr;
+          current_state_.BehaviorState = nullptr;
+          current_state_.PerceptionState = nullptr;
+          current_state_.OtherState = nullptr;
+          break;
+        case ACC_STATE:
+          current_state_.AccState = _state;
+          break;
+        case STR_STATE:
+          current_state_.StrState = _state;
+          break;
+        case BEHAVIOR_STATE:
+          current_state_.BehaviorState = _state;
+          break;
+        case PERCEPTION_STATE:
+          current_state_.PerceptionState = _state;
+          break;
+        case OTHER_STATE:
+          current_state_.OtherState = _state;
+          break;
+      }
+      std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; prevState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName()
+                &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot; &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; &quot;-&quot;
+                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
+    }
+    else
+    {
+      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot;
+                &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
+                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
+      prevState = nullptr;
+      change_state_mutex.unlock();
+      return false;
+    }
+  }
+  change_state_mutex.unlock();
+  return true;
+}
+
+#if 0
 bool StateContext::setCurrentState(BaseState *_state)
 {
   change_state_mutex.lock();
+
   BaseState *prevState = current_state_.MainState;
 
   if (!prevState)
@@ -121,10 +215,12 @@ bool StateContext::setCurrentState(BaseState *_state)
   change_state_mutex.unlock();
   return true;
 }
+#endif
 
 bool StateContext::setCurrentState(StateFlags flag)
 {
-  this-&gt;setCurrentState(StateStores[flag]);
+  bool ret = this-&gt;setCurrentState(StateStores[flag]);
+  return ret;
 }
 
 bool StateContext::setEnableForceSetState(bool force_flag)
@@ -247,7 +343,7 @@ std::string StateContext::createStateMessageText(void)
 bool StateContext::handleTwistCmd(bool _hasTwistCmd)
 {
   if (_hasTwistCmd)
-    return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
+    return this-&gt;setCurrentState(DRIVE_STATE);
   else
     return false;
 }
@@ -255,28 +351,17 @@ bool StateContext::handleTwistCmd(bool _hasTwistCmd)
 void StateContext::stateDecider(void)
 {
   // not running
-  while (thread_loop)
-  {
-    if (!ChangeStateFlags.empty())
-    {
-      this-&gt;setCurrentState(StateStores[ChangeStateFlags.front()]);
-      ChangeStateFlags.pop();
-    }
-    std::this_thread::sleep_for(std::chrono::microseconds(1000));
-  }
-  std::cerr &lt;&lt; &quot;StateDecider thread will be closed&quot; &lt;&lt; std::endl;
-  return;
 }
 
 void StateContext::InitContext(void)
 {
   thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
   thr_state_dec-&gt;detach();
-  this-&gt;setCurrentState(StateStores[START_STATE]);
+  this-&gt;setCurrentState(START_STATE);
   return;
 }
 bool StateContext::TFInitialized(void)
 {
-  return this-&gt;setCurrentState(StateStores[INITIAL_STATE]);
+  return this-&gt;setCurrentState(INITIAL_STATE);
 }
 }
</diff>
				<old_file>#include &lt;sched.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

#include &lt;cassert&gt;
#include &lt;mutex&gt;

#include &lt;state_context.hpp&gt;

#include &lt;state.hpp&gt;
#include &lt;state_common.hpp&gt;

/**
 *
 * @file StateContext.cpp
 * @brief state context class
 * @author Yusuke Fujii
 * @date  2017/07/25
 *
 **/

namespace state_machine
{
void StateContext::update(void)
{
	for(auto &amp;&amp;p : HolderList){
		if(*p){
			(*p)-&gt;update();
		}
	}

}


void StateContext::showCurrentStateName(void)
{
  for (auto &amp;&amp;p : HolderList) {
    if (*p)
    {
      (*p)-&gt;showStateName();
    }
  }

#if 0
  if (sub_state)
    sub_state-&gt;showStateName();
  if (sub_sub_state)
    sub_sub_state-&gt;showStateName();
#endif
  std::cout &lt;&lt; std::endl;
}


/**
 * @fn
 * set to current state
 * @brief standard out a state name
 * @param (state) Setting class
 * @return void
 */
bool StateContext::setCurrentState(BaseState *_state)
{
  change_state_mutex.lock();
  BaseState *prevState = current_state_.MainState;

  if (!prevState)
  {
    current_state_.MainState = _state;
    std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }
  else
  {
    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
    {
      switch (_state-&gt;getStateKind())
      {
        case MAIN_STATE:
          current_state_.MainState = _state;
          current_state_.AccState = nullptr;
          current_state_.StrState = nullptr;
          current_state_.BehaviorState = nullptr;
          current_state_.PerceptionState = nullptr;
          current_state_.OtherState = nullptr;
          break;
        case ACC_STATE:
          current_state_.AccState = _state;
          break;
        case STR_STATE:
          current_state_.StrState = _state;
          break;
        case BEHAVIOR_STATE:
          current_state_.BehaviorState = _state;
          break;
        case PERCEPTION_STATE:
          current_state_.PerceptionState = _state;
          break;
        case OTHER_STATE:
          current_state_.OtherState = _state;
          break;
      }
      std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; prevState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName()
                &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot; &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; &quot;-&quot;
                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    }
    else
    {
      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot;
                &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
      prevState = nullptr;
      change_state_mutex.unlock();
      return false;
    }
  }
  change_state_mutex.unlock();
  return true;
}

bool StateContext::setCurrentState(StateFlags flag)
{
  this-&gt;setCurrentState(StateStores[flag]);
}

bool StateContext::setEnableForceSetState(bool force_flag)
{
  enableForceSetState = force_flag;
  return true;
}

std::string StateContext::getCurrentStateName(StateKinds en)
{
  for (auto &amp;&amp;p : HolderList)
  {
    if (*p &amp;&amp; (*p)-&gt;getStateKind() == en)
	      return (*p)-&gt;getStateName();
  }
  return std::string(&quot;&quot;);
}
std::string StateContext::getCurrentStateName(void)
{
	return this-&gt;getCurrentStateName(MAIN_STATE);
}

BaseState *StateContext::getCurrentMainState(void)
{
  return current_state_.MainState;
}

BaseState *StateContext::getStateObject(unsigned long long _state_num)
{
  return StateStores[_state_num];
}

BaseState **StateContext::getCurrentStateHolderPtr(unsigned long long _state_num)
{
  BaseState **state_ptr;
  switch (getStateObject(_state_num)-&gt;getStateKind())
  {
    case MAIN_STATE:
      state_ptr = &amp;current_state_.MainState;
      break;
    case ACC_STATE:
      state_ptr = &amp;current_state_.AccState;
      break;
    case STR_STATE:
      state_ptr = &amp;current_state_.StrState;
      break;
    case BEHAVIOR_STATE:
      state_ptr = &amp;current_state_.BehaviorState;
      break;
    case PERCEPTION_STATE:
      state_ptr = &amp;current_state_.PerceptionState;
      break;
    case OTHER_STATE:
      state_ptr = &amp;current_state_.OtherState;
      break;
    default:
      state_ptr = nullptr;
      break;
  }
  return state_ptr;
}

bool StateContext::disableCurrentState(unsigned long long _state_num)
{
  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
  if (state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num))
  {
    *state_ptr = nullptr;
    return true;
  }
  else
  {
    return false;
  }
}

bool StateContext::isCurrentState(unsigned long long _state_num)
{
  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
  return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
}

bool StateContext::isState(BaseState *base, unsigned long long _state_num)
{
  return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
}

bool StateContext::inState(unsigned long long _state_num)
{
  if (current_state_.MainState)
  {
    return ((current_state_.MainState-&gt;getStateNum() &amp; _state_num) != 0) ? true : false;
  }
  else
  {
    return false;
  }
}

bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
{
    /* deprecated */
	return false;
}

std::string StateContext::createStateMessageText(void)
{
  std::string ret;

  for (auto &amp;&amp;p : HolderList)
  {
    if (*p)
    {
      ret = ret + &quot;\n&quot; + (*p)-&gt;getStateName();
    }
  }
  return ret;
}

bool StateContext::handleTwistCmd(bool _hasTwistCmd)
{
  if (_hasTwistCmd)
    return this-&gt;setCurrentState(StateStores[DRIVE_STATE]);
  else
    return false;
}

void StateContext::stateDecider(void)
{
  // not running
  while (thread_loop)
  {
    if (!ChangeStateFlags.empty())
    {
      this-&gt;setCurrentState(StateStores[ChangeStateFlags.front()]);
      ChangeStateFlags.pop();
    }
    std::this_thread::sleep_for(std::chrono::microseconds(1000));
  }
  std::cerr &lt;&lt; &quot;StateDecider thread will be closed&quot; &lt;&lt; std::endl;
  return;
}

void StateContext::InitContext(void)
{
  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
  thr_state_dec-&gt;detach();
  this-&gt;setCurrentState(StateStores[START_STATE]);
  return;
}
bool StateContext::TFInitialized(void)
{
  return this-&gt;setCurrentState(StateStores[INITIAL_STATE]);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/cross_road_area.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/cross_road_area.hpp">
				<diff>@@ -10,7 +10,7 @@
 
 namespace decision_maker
 {
-#define CROSS_ROAD 3232
+
 class CrossRoadArea
 {
 public:
</diff>
				<old_file>#ifndef __CROSS_ROAD_AREA_HPP
#define __CROSS_ROAD_AREA_HPP

#include &lt;vector&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;

#include &lt;autoware_msgs/lane.h&gt;

namespace decision_maker
{
#define CROSS_ROAD 3232
class CrossRoadArea
{
public:
  int id;
  int area_id;
  std::vector&lt;geometry_msgs::Point&gt; points;
  jsk_recognition_msgs::BoundingBox bbox;

  std::vector&lt;autoware_msgs::lane&gt; insideLanes;
  std::vector&lt;geometry_msgs::Point&gt; insideWaypoint_points;

  CrossRoadArea(void)
  {
    id = 0;
    area_id = 0;
    points.clear();
    insideLanes.clear();
    insideWaypoint_points.clear();
  }

  static CrossRoadArea *findClosestCrossRoad(const autoware_msgs::lane &amp;_finalwaypoints,
		  std::vector&lt;CrossRoadArea&gt; &amp;intersects);
  static bool isInsideArea(const CrossRoadArea* _TargetArea,
 		  geometry_msgs::Point pt);


  static CrossRoadArea *getCrossRoadArea(std::vector&lt;CrossRoadArea&gt; &amp;areas, int aid)
  {
	  CrossRoadArea *ret = nullptr;
	  for( auto &amp;area : areas){
		  if(area.area_id == aid){
			  ret = &amp;area;
			  break;
		  }
	  }
	  return ret;
  }

};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp">
				<diff>@@ -18,13 +18,13 @@
 
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 
-//#include &lt;vector_map_server/GetCrossRoad.h&gt;
-
 #include &lt;vector_map_msgs/AreaArray.h&gt;
 #include &lt;vector_map_msgs/CrossRoadArray.h&gt;
 #include &lt;vector_map_msgs/LineArray.h&gt;
 #include &lt;vector_map_msgs/PointArray.h&gt;
 
+#include &lt;vector_map/vector_map.h&gt;
+
 #include &lt;geometry_msgs/Point.h&gt;
 
 // lib
@@ -32,14 +32,12 @@
 #include &lt;amathutils.hpp&gt;
 #include &lt;state.hpp&gt;
 #include &lt;state_context.hpp&gt;
-
 #include &lt;decision_maker_param.hpp&gt;
 
-//#include &lt;dynamic_reconfigure/server.h&gt;
-//#include &lt;decision_maker/decision_makerConfig.h&gt;
-
 namespace decision_maker
 {
+using namespace vector_map;
+
 enum class EControl : int32_t
 {
   KEEP = -1,
@@ -93,10 +91,10 @@ private:
 
   std::vector&lt;geometry_msgs::Point&gt; inside_points_;
 
-
   autoware_msgs::LaneArray current_based_lane_array_;
   autoware_msgs::LaneArray current_controlled_lane_array_;
 
+
   // Current way/behavior status
   double current_velocity_;
   double average_velocity_;
@@ -157,7 +155,8 @@ private:
   void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
 
 
-  void callbackStateSTR(int status);
+  void updateStateSTR(int status);
+  void updateStateStop(int status);
   void setupStateCallback(void);
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
@@ -179,6 +178,7 @@ private:
 
 public:
   state_machine::StateContext *ctx;
+  VectorMap g_vmap;
 
   DecisionMakerNode(int argc, char **argv)
   {
</diff>
				<old_file>#ifndef __DECISION_MAKER_NODE__
#define __DECISION_MAKER_NODE__

#include &lt;mutex&gt;
#include &lt;unordered_map&gt;

#include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/LaneArray.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;

#include &lt;visualization_msgs/MarkerArray.h&gt;

//#include &lt;vector_map_server/GetCrossRoad.h&gt;

#include &lt;vector_map_msgs/AreaArray.h&gt;
#include &lt;vector_map_msgs/CrossRoadArray.h&gt;
#include &lt;vector_map_msgs/LineArray.h&gt;
#include &lt;vector_map_msgs/PointArray.h&gt;

#include &lt;geometry_msgs/Point.h&gt;

// lib
#include &lt;cross_road_area.hpp&gt;
#include &lt;amathutils.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_param.hpp&gt;

//#include &lt;dynamic_reconfigure/server.h&gt;
//#include &lt;decision_maker/decision_makerConfig.h&gt;

namespace decision_maker
{
enum class EControl : int32_t
{
  KEEP = -1,
  STOP = 1,
  DECELERATE = 2,
  ACCELERATE = 3,
  OTHERS = 4,
};

enum class E_ChangeFlags : int32_t
{
  STRAIGHT,
  RIGHT,
  LEFT,

  UNKNOWN = -1,
};

inline bool hasvMap(void)
{
  return true;
}

template &lt;class T&gt;
typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
{
  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
}

class DecisionMakerNode
{
private:
  ros::NodeHandle nh_;
  // Publishers
  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
  // Subscribers
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;

  // ROS Messages
  std_msgs::String state_string_msg;
  geometry_msgs::PoseStamped current_pose_;

  jsk_rviz_plugins::OverlayText state_text_msg;

  // ROS Messages(Autoware)
  autoware_msgs::lane current_finalwaypoints_;
  vector_map_msgs::AreaArray vMap_Areas;
  vector_map_msgs::PointArray vMap_Points;
  vector_map_msgs::LineArray vMap_Lines;
  vector_map_msgs::CrossRoadArray vMap_CrossRoads;

  std::vector&lt;geometry_msgs::Point&gt; inside_points_;


  autoware_msgs::LaneArray current_based_lane_array_;
  autoware_msgs::LaneArray current_controlled_lane_array_;

  // Current way/behavior status
  double current_velocity_;
  double average_velocity_;
  int current_traffic_light;
  CrossRoadArea *ClosestArea_;
  std::string CurrentStateName;
  std::string TextOffset;
  std::vector&lt;CrossRoadArea&gt; intersects;
  double displacement_from_path_;

  // Param
  bool enableDisplayMarker;
  bool enableForceStateChange;
  int param_convergence_count_;
  int param_target_waypoint_;
  double param_convergence_threshold_;

  // for vectormap server
  // ros::ServiceClient cross_road_cli;
  // vector_map_server::GetCrossRoad cross_road_srv;

  // initialization flags for initialized by callback
  bool vector_map_init;
  bool vMap_Areas_flag;
  bool vMap_Points_flag;
  bool vMap_Lines_flag;
  bool vMap_CrossRoads_flag;
  bool SimulationMode;
  std::mutex vMap_mutex;

  // initialization method
  void initROS(int argc, char **argv);
  void initVectorMap(void);
  void initStateMsgs(void);
  bool initVectorMapClient(void);

  // looping method
  void update(void);
  void update_msgs(void);
  void update_pubsub(void);
  void displayMarker(void);

  void publishToVelocityArray();
  std::string createStateMessageText();
  int createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale);


  // judge method
  // in near future, these methods will be deprecate to decision_maker library
  bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
  bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
  bool handleStateCmd(const unsigned long long _state_num);
  //double calcIntersectWayAngle(const CrossRoadArea&amp; area);
  double calcIntersectWayAngle(const autoware_msgs::lane&amp; laneinArea);

  void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);

  void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);


  void callbackStateSTR(int status);
  void setupStateCallback(void);
  // callback by topic subscribing
  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event);
  void callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg);
  void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
  void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
  void callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg);
  void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromStateCmd(const std_msgs::Int32 &amp;msg);
  void callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg);

  void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
  void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
  void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
  void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);

public:
  state_machine::StateContext *ctx;

  DecisionMakerNode(int argc, char **argv)
  {
    SimulationMode = false;
    enableDisplayMarker = DEFAULT_DISPLAY_FLAG;
    param_convergence_threshold_ = DEFAULT_CONVERGENCE_THRESHOLD;
    param_convergence_count_ = DEFAULT_CONVERGENCE_COUNT;
    param_target_waypoint_ = DEFAULT_TARGET_WAYPOINT;

    ctx = new state_machine::StateContext();
    this-&gt;initROS(argc, argv);

    vector_map_init = false;
    vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;

    ClosestArea_ = nullptr;
    displacement_from_path_ = 0.0;
  }

  void run(void);
};

}  // namespace decision_maker

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_param.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_param.hpp">
				<diff>@@ -19,6 +19,15 @@ namespace decision_maker
 #define ANGLE_CURVE 40
 #define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
 #define ANGLE_RIGHT (ANGLE_NEUTRAL + ANGLE_CURVE)
+
+#define TPNAME_BASED_LANE_WAYPOINTS_ARRAY &quot;/based/lane_waypoints_array&quot;
+#define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY &quot;/lane_waypoints_array&quot;
+#define LAMP_EMPTY  0
+#define LAMP_LEFT   1
+#define LAMP_RIGHT  2
+#define LAMP_HAZARD 3
+#define LAMP_ON 1
+#define LAMP_OFF 0
 }
 
 #endif
</diff>
				<old_file>#ifndef __DECISION_MAKER_PARAM_HPP__
#define __DECISION_MAKER_PARAM_HPP__

namespace decision_maker
{
//#define DEBUG_PRINT

#define DEFAULT_DISPLAY_FLAG false
#define DEFAULT_FORCE_STATE_CHANGE true

#define VEL_AVERAGE_COUNT 10
#define DEFAULT_CONVERGENCE_COUNT 5
#define DEFAULT_CONVERGENCE_THRESHOLD 0.01

#define DOUBLE_MAX 1.7976931348623158e308
#define DEFAULT_TARGET_WAYPOINT 14

#define ANGLE_NEUTRAL 0
#define ANGLE_CURVE 40
#define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
#define ANGLE_RIGHT (ANGLE_NEUTRAL + ANGLE_CURVE)
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -179,8 +179,18 @@ void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadAr
   }
 }
 
+geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
+{
+  geometry_msgs::Point gp;
+  gp.x = vp.ly;
+  gp.y = vp.bx;
+  gp.z = vp.h;
+  return gp;
+}
+
 void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
 {
+  // STR
   for (auto &amp;area : intersects)
   {
     for (auto &amp;laneinArea : area.insideLanes)
@@ -210,6 +220,42 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
       ROS_INFO(&quot;%d: %d  angle_deg :%d\n&quot;, area.area_id, steering_state, angle_deg);
     }
   }
+
+  // STOP
+  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([](const StopLine &amp;stopline) { return true; });
+  for (auto &amp;lane : lane_array.lanes)
+  {
+    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
+    {
+      for (auto &amp;stopline : stoplines)
+      {
+        if (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == vector_map_msgs::RoadSign::TYPE_STOP)
+        {
+          geometry_msgs::Point bp =
+              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
+          geometry_msgs::Point fp =
+              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
+	 
+
+          if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
+                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
+                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
+                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
+          {
+	    geometry_msgs::Point center_point;
+	    center_point.x = (bp.x*2 + fp.x)/3;
+	    center_point.y = (bp.y*2 + fp.y)/3;
+
+	    if(isPointLeftFromLine){
+		    lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
+		    lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
+	    }
+
+	  }
+	}
+      }
+    }
+  }
 }
 
 // for based waypoint
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
  ctx-&gt;setEnableForceSetState(false);

  if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE) ||
      ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
  {
    int count = 0;
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      autoware_msgs::lane temp_lane = lane;
      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
      {
        double v0 = temp_lane.waypoints.at(wpi - 1).twist.twist.linear.x;
        double v = temp_lane.waypoints.at(wpi).twist.twist.linear.x;

        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
        double _weight = distance * 0.05;
        if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE))
        {
          _weight *= 1;
        }
        else if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
        {
          _weight *= -1;
        }
        lane.waypoints.at(wpi).twist.twist.linear.x =
            lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
      }
    }
    Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
  }
  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request&quot;);
  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
  if (msg.enable_force_state_change)
  {
    if (msg.MainState_ChangeFlag)
      handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
    if (msg.SubState_Acc_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
    if (msg.SubState_Str_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
    if (msg.SubState_Behavior_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
    if (msg.SubState_Perception_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
  }
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);
  const autoware_msgs::traffic_light *light = event.getMessage().get();

  current_traffic_light = light-&gt;traffic_light;
  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
  {
    ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  // ctx-&gt;handleTrafficLight(CurrentTrafficlight);
}

//
void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            ;
            area.insideLanes.push_back(nlane);
          }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;lane : lane_array.lanes)
      {
        for (auto &amp;wp : lane.waypoints)
        {
          if (area.area_id == wp.wpstate.aid)
          {
            wp.wpstate.steering_state = steering_state;
          }
        }
      }
      ROS_INFO(&quot;%d: %d  angle_deg :%d\n&quot;, area.area_id, steering_state, angle_deg);
    }
  }
}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  current_based_lane_array_ = msg;  // cached based path

  // indexing
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int gid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      int lid = 0;
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }

  current_controlled_lane_array_ = current_based_lane_array_;  // controlled path
  insertPointWithinCrossRoad(intersects, current_controlled_lane_array_);
  setWaypointState(current_controlled_lane_array_);

  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  // steering
  if (current_finalwaypoints_.waypoints.size() &gt; param_target_waypoint_)
    ctx-&gt;setCurrentState(
        getStateFlags(current_finalwaypoints_.waypoints.at(param_target_waypoint_).wpstate.steering_state));

#if 0
	// velocity
	double _temp_sum = 0;
	for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
	{
		_temp_sum += amathutils::mps2kmph(msg.waypoints[i].twist.twist.linear.x);
	}
	average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;

	if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
	else if (average_velocity_ - current_velocity_)
		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
	else
		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
#endif

  // for publish plan of velocity
  publishToVelocityArray();

#ifdef DEBUG_PRINT
  std::cout &lt;&lt; &quot;Velocity: &quot; &lt;&lt; current_velocity_ &lt;&lt; &quot; to &quot; &lt;&lt; average_velocity_ &lt;&lt; std::endl;
#endif
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
#if 0
void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
	ROS_INFO(&quot;Reconfigure Request: %d &quot;, config.TARGET_WAYPOINT_COUNT);
}
#endif
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_init.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_init.cpp">
				<diff>@@ -15,9 +15,9 @@
 #include &lt;decision_maker_node.hpp&gt;
 //#include &lt;vector_map/vector_map.h&gt;
 
-#include &lt;autoware_msgs/lamp_cmd.h&gt;
 #include &lt;autoware_msgs/lane.h&gt;
 #include &lt;autoware_msgs/state.h&gt;
+#include &lt;autoware_msgs/lamp_cmd.h&gt;
 #include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
 #include &lt;visualization_msgs/MarkerArray.h&gt;
 #include &lt;random&gt;
@@ -28,50 +28,6 @@
 
 namespace decision_maker
 {
-#define TPNAME_BASED_LANE_WAYPOINTS_ARRAY &quot;/based/lane_waypoints_array&quot;
-#define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY &quot;/lane_waypoints_array&quot;
-#define LAMP_EMPTY  0
-#define LAMP_LEFT   1
-#define LAMP_RIGHT  2
-#define LAMP_HAZARD 3
-#define LAMP_ON 1
-#define LAMP_OFF 0
-
-void DecisionMakerNode::callbackStateSTR(int status)
-{
-  ROS_INFO(&quot;[%s]:%d\n&quot;, __func__, status);
-  autoware_msgs::lamp_cmd lamp_msg;
-
-  switch(status){
-	  case LAMP_LEFT:
-		  lamp_msg.l = LAMP_ON;
-		  lamp_msg.r = LAMP_OFF;
-		  break;
-	  case LAMP_RIGHT:
-		  lamp_msg.l = LAMP_OFF;
-		  lamp_msg.r = LAMP_ON;
-		  break;
-	  case LAMP_HAZARD:
-		  lamp_msg.l = LAMP_ON;
-		  lamp_msg.r = LAMP_ON;
-		  break;
-	  case LAMP_EMPTY:
-	  default:
-		  lamp_msg.l = LAMP_OFF;
-		  lamp_msg.r = LAMP_OFF;
-		  break;
-  }
-}
-
-void DecisionMakerNode::setupStateCallback(void)
-{
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)
-      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 1));
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)
-      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 2));
-  ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)
-      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 0));
-}
 
 void DecisionMakerNode::initROS(int argc, char **argv)
 {
@@ -89,16 +45,16 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs[&quot;change_flag&quot;] = nh_.subscribe(&quot;change_flag&quot;, 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
   Subs[&quot;state_cmd&quot;] = nh_.subscribe(&quot;state_cmd&quot;, 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
 
-  // vector map subscriber
-  Subs[&quot;vector_map_area&quot;] =
-      nh_.subscribe(&quot;/vector_map_info/area&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
-  Subs[&quot;vector_map_point&quot;] =
-      nh_.subscribe(&quot;/vector_map_info/point&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
-  Subs[&quot;vector_map_line&quot;] =
-      nh_.subscribe(&quot;/vector_map_info/line&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
-  Subs[&quot;vector_map_crossroad&quot;] =
-      nh_.subscribe(&quot;/vector_map_info/cross_road&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
-
+//  // vector map subscriber
+//  Subs[&quot;vector_map_area&quot;] =
+//      nh_.subscribe(&quot;/vector_map_info/area&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
+//  Subs[&quot;vector_map_point&quot;] =
+//      nh_.subscribe(&quot;/vector_map_info/point&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
+//  Subs[&quot;vector_map_line&quot;] =
+//      nh_.subscribe(&quot;/vector_map_info/line&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
+//  Subs[&quot;vector_map_crossroad&quot;] =
+//      nh_.subscribe(&quot;/vector_map_info/cross_road&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
+//
   // Config subscriber
   Subs[&quot;config/decision_maker&quot;] =
       nh_.subscribe(&quot;/config/decision_maker&quot;, 3, &amp;DecisionMakerNode::callbackFromConfig, this);
@@ -138,16 +94,17 @@ void DecisionMakerNode::initROS(int argc, char **argv)
 
   // to move initial state from start state
   // this part confirm broadcasting tf(map to world)
-  {
-    std::cout &lt;&lt; &quot;wait for tf of map to world&quot; &lt;&lt; std::endl;
-    tf::TransformListener tf;
+  std::cout &lt;&lt; &quot;wait for tf of map to world&quot; &lt;&lt; std::endl;
+  tf::TransformListener tf;
+  tf.waitForTransform(&quot;map&quot;, &quot;world&quot;, ros::Time(), ros::Duration(15));
+  if (!ctx-&gt;TFInitialized())
+	  std::cerr &lt;&lt; &quot;failed initialization &quot; &lt;&lt; std::endl;
+  g_vmap.subscribe(nh_, 
+		  Category::POINT |  Category::LINE |  Category::VECTOR | Category::AREA | Category::POLE | //basic class
+		  Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
+  initVectorMap();
 
-    tf.waitForTransform(&quot;map&quot;, &quot;world&quot;, ros::Time(), ros::Duration(15));
-    if (!ctx-&gt;TFInitialized())
-      std::cerr &lt;&lt; &quot;failed initialization &quot; &lt;&lt; std::endl;
-  }
   {
-    initVectorMapClient();
     if (enableDisplayMarker)
       displayMarker();
   }
@@ -155,98 +112,88 @@ void DecisionMakerNode::initROS(int argc, char **argv)
 
 void DecisionMakerNode::initVectorMap(void)
 {
-  if (!vector_map_init)
-  {
-    vMap_mutex.lock();
-    if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
-    {
-      vector_map_init = true;
-
       int _index = 0;
+      if(vector_map_init)
+	      return;
 
-      // parse vmap
-      for (const auto &amp;cross_road : vMap_CrossRoads.data)
+      std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad){return true;});
+      if(crossroads.empty()){
+	      ROS_INFO(&quot;crossroad have not found\n&quot;);
+	      return;
+      }
+
+      vector_map_init = true; //loaded flag
+      for(const auto &amp;cross_road : crossroads)
       {
-        for (const auto &amp;area : vMap_Areas.data)
-        {
-          if (cross_road.aid == area.aid)
-          {
-            CrossRoadArea carea;
-            carea.id = _index++;
-            carea.area_id = area.aid;
-
-            double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
-            double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
-            double z = 0.0;
-            int points_count = 0;
-
-            for (const auto &amp;line : vMap_Lines.data)
-            {
-              if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
-              {
-                geometry_msgs::Point _prev_point;
-                for (const auto &amp;point : vMap_Points.data)
-                {
-                  if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
-                  {
-                    geometry_msgs::Point _point;
-                    _point.x = point.bx;
-                    _point.y = point.ly;
-                    _point.z = point.h;
-
-                    if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
-                      continue;
-
-                    _prev_point = _point;
-                    points_count++;
-                    carea.points.push_back(_point);
-
-                    // calc a centroid point and about intersects size
-                    x_avg += _point.x;
-                    y_avg += _point.y;
-                    x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
-                    x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
-                    y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
-                    y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
-                    z = _point.z;
-
-                  }  // if pid
-                }    // points iter
-              }      // if lid
-            }        // line iter
-            carea.bbox.pose.position.x = x_avg / (double)points_count;
-            carea.bbox.pose.position.y = y_avg / (double)points_count;
-            carea.bbox.pose.position.z = z;
-            carea.bbox.dimensions.x = x_max - x_min;
-            carea.bbox.dimensions.y = y_max - y_min;
-            carea.bbox.dimensions.z = 2;
-            carea.bbox.label = 1;
-            intersects.push_back(carea);
-          }
-        }
+	Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
+	CrossRoadArea carea;
+	carea.id = _index++;
+	carea.area_id = area.aid;
+	
+	double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
+	double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
+	double z = 0.0;
+	int points_count = 0;
+
+	std::vector&lt;Line&gt; lines = g_vmap.findByFilter([&amp;area](const Line &amp;line){return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid;});
+	for (const auto &amp;line : lines)
+	{
+		geometry_msgs::Point _prev_point;
+		std::vector&lt;Point&gt; points = g_vmap.findByFilter([&amp;line](const Point &amp;point){return line.bpid == point.pid || point.pid == line.fpid;});
+		for (const auto &amp;point : points)
+		{
+			geometry_msgs::Point _point;
+			_point.x = point.ly;
+			_point.y = point.bx;
+			_point.z = point.h;
+
+			if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
+				continue;
+
+			_prev_point = _point;
+			points_count++;
+			carea.points.push_back(_point);
+
+			// calc a centroid point and about intersects size
+			x_avg += _point.x;
+			y_avg += _point.y;
+			x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
+			x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
+			y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
+			y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
+			z = _point.z;
+
+		}    // points iter
+	}        // line iter
+	carea.bbox.pose.position.x = x_avg / (double)points_count;
+	carea.bbox.pose.position.y = y_avg / (double)points_count;
+	carea.bbox.pose.position.z = z;
+	carea.bbox.dimensions.x = x_max - x_min;
+	carea.bbox.dimensions.y = y_max - y_min;
+	carea.bbox.dimensions.z = 2;
+	carea.bbox.label = 1;
+	intersects.push_back(carea);
       }
-    }
-    vMap_mutex.unlock();
-    Subs[&quot;lane_waypoints_array&quot;] =
-        nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
-  }
+
+      Subs[&quot;lane_waypoints_array&quot;] =
+	      nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
 }
 
 bool DecisionMakerNode::initVectorMapClient()
 {
 #ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
-  // server
+	// server
 
-  vector_map::VectorMap vmap;
-  vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
+	vector_map::VectorMap vmap;
+	vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));
 
-  cross_road_srv.request.pose = current_pose_;
-  cross_road_srv.request.waypoints = current_finalwaypoints_;
+	cross_road_srv.request.pose = current_pose_;
+	cross_road_srv.request.waypoints = current_finalwaypoints_;
 
-  cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;(&quot;vector_map_server/get_cross_road&quot;);
+	cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;(&quot;vector_map_server/get_cross_road&quot;);
 
-  return cross_road_cli.call(cross_road_srv);
+	return cross_road_cli.call(cross_road_srv);
 #endif
-  return false;
+	return false;
 }
 }
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;mutex&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;
//#include &lt;vector_map/vector_map.h&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/state.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
#define TPNAME_BASED_LANE_WAYPOINTS_ARRAY &quot;/based/lane_waypoints_array&quot;
#define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY &quot;/lane_waypoints_array&quot;
#define LAMP_EMPTY  0
#define LAMP_LEFT   1
#define LAMP_RIGHT  2
#define LAMP_HAZARD 3
#define LAMP_ON 1
#define LAMP_OFF 0

void DecisionMakerNode::callbackStateSTR(int status)
{
  ROS_INFO(&quot;[%s]:%d\n&quot;, __func__, status);
  autoware_msgs::lamp_cmd lamp_msg;

  switch(status){
	  case LAMP_LEFT:
		  lamp_msg.l = LAMP_ON;
		  lamp_msg.r = LAMP_OFF;
		  break;
	  case LAMP_RIGHT:
		  lamp_msg.l = LAMP_OFF;
		  lamp_msg.r = LAMP_ON;
		  break;
	  case LAMP_HAZARD:
		  lamp_msg.l = LAMP_ON;
		  lamp_msg.r = LAMP_ON;
		  break;
	  case LAMP_EMPTY:
	  default:
		  lamp_msg.l = LAMP_OFF;
		  lamp_msg.r = LAMP_OFF;
		  break;
  }
}

void DecisionMakerNode::setupStateCallback(void)
{
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)
      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)
      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 2));
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)
      -&gt;setCallbackFunc(std::bind(&amp;DecisionMakerNode::callbackStateSTR, this, 0));
}

void DecisionMakerNode::initROS(int argc, char **argv)
{
  // status subscriber
  Subs[&quot;sim_pose&quot;] = nh_.subscribe(&quot;sim_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromSimPose, this);
  Subs[&quot;current_pose&quot;] = nh_.subscribe(&quot;current_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
  Subs[&quot;current_velocity&quot;] =
      nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
  Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
  Subs[&quot;light_color_managed&quot;] =
      nh_.subscribe(&quot;light_color_managed&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
  Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
  Subs[&quot;final_waypoints&quot;] = nh_.subscribe(&quot;final_waypoints&quot;, 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
  Subs[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
  Subs[&quot;change_flag&quot;] = nh_.subscribe(&quot;change_flag&quot;, 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
  Subs[&quot;state_cmd&quot;] = nh_.subscribe(&quot;state_cmd&quot;, 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);

  // vector map subscriber
  Subs[&quot;vector_map_area&quot;] =
      nh_.subscribe(&quot;/vector_map_info/area&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
  Subs[&quot;vector_map_point&quot;] =
      nh_.subscribe(&quot;/vector_map_info/point&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
  Subs[&quot;vector_map_line&quot;] =
      nh_.subscribe(&quot;/vector_map_info/line&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
  Subs[&quot;vector_map_crossroad&quot;] =
      nh_.subscribe(&quot;/vector_map_info/cross_road&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);

  // Config subscriber
  Subs[&quot;config/decision_maker&quot;] =
      nh_.subscribe(&quot;/config/decision_maker&quot;, 3, &amp;DecisionMakerNode::callbackFromConfig, this);

  // pub
  Pubs[&quot;state&quot;] = nh_.advertise&lt;std_msgs::String&gt;(&quot;state&quot;, 1);
  Pubs[&quot;lane_waypoints_array&quot;] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
  Pubs[&quot;states&quot;] = nh_.advertise&lt;autoware_msgs::state&gt;(&quot;/decisionmaker/states&quot;, 1, true);

  Pubs[&quot;lamp_cmd&quot;] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;(&quot;/lamp_cmd&quot;, 1);

  // for visualize
  Pubs[&quot;state_overlay&quot;] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;(&quot;/state/overlay_text&quot;, 1);
  Pubs[&quot;crossroad_marker&quot;] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;/state/cross_road_marker&quot;, 1);
  Pubs[&quot;crossroad_inside_marker&quot;] = nh_.advertise&lt;visualization_msgs::Marker&gt;(&quot;/state/cross_inside_marker&quot;, 1);
  Pubs[&quot;crossroad_bbox&quot;] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;/state/crossroad_bbox&quot;, 10);

  // for debug
  Pubs[&quot;target_velocity_array&quot;] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;(&quot;/target_velocity_array&quot;, 1);
  Pubs[&quot;state_local_diffdistance&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/val_diff_distance&quot;, 1);
  Pubs[&quot;exectime&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/exectime&quot;, 1);
  // message setup
  state_text_msg.text_size = 18;
  state_text_msg.line_width = 0;
  state_text_msg.font = &quot;DejaVu Sans Mono&quot;;
  state_text_msg.width = 500;
  state_text_msg.height = 50;
  state_text_msg.top = 10;
  state_text_msg.left = 10;
  state_text_msg.text = &quot;UNDEFINED&quot;;

  // initial publishing state message
  update_msgs();

  // setup a callback for state update();
  setupStateCallback();

  // to move initial state from start state
  // this part confirm broadcasting tf(map to world)
  {
    std::cout &lt;&lt; &quot;wait for tf of map to world&quot; &lt;&lt; std::endl;
    tf::TransformListener tf;

    tf.waitForTransform(&quot;map&quot;, &quot;world&quot;, ros::Time(), ros::Duration(15));
    if (!ctx-&gt;TFInitialized())
      std::cerr &lt;&lt; &quot;failed initialization &quot; &lt;&lt; std::endl;
  }
  {
    initVectorMapClient();
    if (enableDisplayMarker)
      displayMarker();
  }
}

void DecisionMakerNode::initVectorMap(void)
{
  if (!vector_map_init)
  {
    vMap_mutex.lock();
    if (!vector_map_init &amp;&amp; vMap_Areas_flag &amp; vMap_Points_flag &amp; vMap_Lines_flag &amp; vMap_CrossRoads_flag)
    {
      vector_map_init = true;

      int _index = 0;

      // parse vmap
      for (const auto &amp;cross_road : vMap_CrossRoads.data)
      {
        for (const auto &amp;area : vMap_Areas.data)
        {
          if (cross_road.aid == area.aid)
          {
            CrossRoadArea carea;
            carea.id = _index++;
            carea.area_id = area.aid;

            double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
            double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
            double z = 0.0;
            int points_count = 0;

            for (const auto &amp;line : vMap_Lines.data)
            {
              if (area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid)
              {
                geometry_msgs::Point _prev_point;
                for (const auto &amp;point : vMap_Points.data)
                {
                  if (line.fpid &lt;= point.pid &amp;&amp; point.pid &lt;= line.fpid)
                  {
                    geometry_msgs::Point _point;
                    _point.x = point.bx;
                    _point.y = point.ly;
                    _point.z = point.h;

                    if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
                      continue;

                    _prev_point = _point;
                    points_count++;
                    carea.points.push_back(_point);

                    // calc a centroid point and about intersects size
                    x_avg += _point.x;
                    y_avg += _point.y;
                    x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
                    x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
                    y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
                    y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
                    z = _point.z;

                  }  // if pid
                }    // points iter
              }      // if lid
            }        // line iter
            carea.bbox.pose.position.x = x_avg / (double)points_count;
            carea.bbox.pose.position.y = y_avg / (double)points_count;
            carea.bbox.pose.position.z = z;
            carea.bbox.dimensions.x = x_max - x_min;
            carea.bbox.dimensions.y = y_max - y_min;
            carea.bbox.dimensions.z = 2;
            carea.bbox.label = 1;
            intersects.push_back(carea);
          }
        }
      }
    }
    vMap_mutex.unlock();
    Subs[&quot;lane_waypoints_array&quot;] =
        nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
  }
}

bool DecisionMakerNode::initVectorMapClient()
{
#ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
  // server

  vector_map::VectorMap vmap;
  vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));

  cross_road_srv.request.pose = current_pose_;
  cross_road_srv.request.waypoints = current_finalwaypoints_;

  cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;(&quot;vector_map_server/get_cross_road&quot;);

  return cross_road_cli.call(cross_road_srv);
#endif
  return false;
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_publish.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_publish.cpp">
				<diff>@@ -54,8 +54,6 @@ void DecisionMakerNode::displayMarker(void)
 {
   // vector_map init
   // parse vectormap
-  initVectorMap();
-
   jsk_recognition_msgs::BoundingBoxArray bbox_array;
 
   static visualization_msgs::MarkerArray marker_array;
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/state.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
void DecisionMakerNode::update_pubsub(void)
{
  // if state machine require to re-subscribe topic,
  // this function will re-definition subscriber.
}

int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale)
{
  crossroad_marker.header.frame_id = &quot;/map&quot;;
  crossroad_marker.header.stamp = ros::Time();
  crossroad_marker.id = 1;
  crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
  crossroad_marker.action = visualization_msgs::Marker::ADD;
  crossroad_marker.ns = &quot;crossroad&quot;;

  crossroad_marker.scale.x = scale;
  crossroad_marker.scale.y = scale;
  crossroad_marker.scale.z = 0.5;
  crossroad_marker.color.a = 0.15;
  crossroad_marker.color.r = 1.0;
  crossroad_marker.color.g = 0.0;
  crossroad_marker.color.b = 0.0;
  crossroad_marker.frame_locked = true;
  crossroad_marker.lifetime = ros::Duration(0.3);
}

void DecisionMakerNode::displayMarker(void)
{
  // vector_map init
  // parse vectormap
  initVectorMap();

  jsk_recognition_msgs::BoundingBoxArray bbox_array;

  static visualization_msgs::MarkerArray marker_array;
  static visualization_msgs::Marker crossroad_marker;
  static visualization_msgs::Marker inside_marker;

  double scale = 3.0;
  createCrossRoadAreaMarker(crossroad_marker, scale);

  inside_marker = crossroad_marker;
  inside_marker.scale.x = scale / 3;
  inside_marker.scale.y = scale / 3;
  inside_marker.scale.z = 0.5;
  inside_marker.color.a = 0.5;
  inside_marker.color.r = 1.0;
  inside_marker.color.g = 0.0;
  inside_marker.color.b = 0.0;
  inside_marker.ns = &quot;inside&quot;;
  inside_marker.lifetime = ros::Duration();

  bbox_array.header = crossroad_marker.header;

  inside_marker.points.clear();

  for (auto &amp;area : intersects)
  {
    area.bbox.header = crossroad_marker.header;
    bbox_array.boxes.push_back(area.bbox);
    for (const auto &amp;p : area.insideWaypoint_points)
    {
      inside_marker.points.push_back(p);
    }
  }

  Pubs[&quot;crossroad_bbox&quot;].publish(bbox_array);
  bbox_array.boxes.clear();
  Pubs[&quot;crossroad_inside_marker&quot;].publish(inside_marker);

  marker_array.markers.clear();
}

void DecisionMakerNode::update_msgs(void)
{
  if (ctx)
  {
    static std::string prevStateName;
    CurrentStateName = ctx-&gt;getCurrentStateName();

    if (prevStateName != CurrentStateName)
    {
      prevStateName = CurrentStateName;
      update_pubsub();
    }

    state_string_msg.data = CurrentStateName;
    state_text_msg.text = createStateMessageText();

    autoware_msgs::state state_msg;
    state_msg.main_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::MAIN_STATE);
    state_msg.acc_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::ACC_STATE);
    state_msg.str_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::STR_STATE);
    state_msg.behavior_state = ctx-&gt;getCurrentStateName(state_machine::StateKinds::BEHAVIOR_STATE);
    
    Pubs[&quot;states&quot;].publish(state_msg);
    Pubs[&quot;state&quot;].publish(state_string_msg);
    Pubs[&quot;state_overlay&quot;].publish(state_text_msg);
  }
  else
    std::cerr &lt;&lt; &quot;ctx is not found &quot; &lt;&lt; std::endl;
}

std::string DecisionMakerNode::createStateMessageText()
{
  return ctx-&gt;createStateMessageText();
}

void DecisionMakerNode::publishToVelocityArray()
{
  int count = 0;
  std_msgs::Float64MultiArray msg;

  for (const auto &amp;i : current_finalwaypoints_.waypoints)
  {
    msg.data.push_back(amathutils::mps2kmph(i.twist.twist.linear.x));
    if (++count &gt;= 10)
      break;
  }
  Pubs[&quot;target_velocity_array&quot;].publish(msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="a9fa5d7fcaee47e29921e8741ddb119ad8baf26e" fix_time="39,28446">
		<msg>minor fixes</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp">
				<diff>@@ -1,11 +1,11 @@
 #ifndef __STATE_HPP__
 #define __STATE_HPP__
 
+#include &lt;functional&gt;
 #include &lt;iostream&gt;
 #include &lt;memory&gt;
-#include &lt;vector&gt;
-#include &lt;functional&gt;
 #include &lt;state_flags.hpp&gt;
+#include &lt;vector&gt;
 
 namespace state_machine
 {
@@ -44,15 +44,16 @@ protected:
   BaseState()
   {
   }
+
 public:
   virtual void update(void) = 0;
   virtual void showStateName(void) = 0;
-  virtual unsigned long long getStateTransMask(void) = 0;
-  virtual unsigned long long getStateNum(void) = 0;
+  virtual uint64_t getStateTransMask(void) = 0;
+  virtual uint64_t getStateNum(void) = 0;
   virtual std::string getStateName(void) = 0;
-  virtual unsigned char getStateKind(void) = 0;
-  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)=0;
-  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)=0;
+  virtual uint8_t getStateKind(void) = 0;
+  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
+  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f) = 0;
 };
 
 // Interface
@@ -61,32 +62,35 @@ class State : public BaseState
 {
 protected:
   std::string StateName = &quot;Base&quot;;
-  unsigned long long StateNum;
-  unsigned long long StateTransMask;
-  unsigned char StateKind;
+  uint64_t StateNum;
+  uint64_t StateTransMask;
+  uint8_t StateKind;
 
   std::function&lt;void(void)&gt; StateUpdateFunc;
   std::function&lt;void(void)&gt; StateChangedFunc;
-  
+
   State()
   {
     StateNum = 0;
-    StateTransMask = (unsigned long long)STATE_END - 1;
+    StateTransMask = (uint64_t)STATE_END - 1;
     StateKind = UNKNOWN_STATE;
   }
 
 public:
-  virtual void update(void){
-	if(StateUpdateFunc)
-		StateUpdateFunc();
+  virtual void update(void)
+  {
+    if (StateUpdateFunc)
+      StateUpdateFunc();
   }
 
-  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f){
-	StateUpdateFunc = _f;
+  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)
+  {
+    StateUpdateFunc = _f;
   }
 
-  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f){
-	StateChangedFunc = _f;
+  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)
+  {
+    StateChangedFunc = _f;
   }
 
   void showStateName(void)
@@ -105,16 +109,16 @@ public:
     return std::string(StateName);
   }
 
-  unsigned char getStateKind(void)
+  uint8_t getStateKind(void)
   {
     return StateKind;
   }
 
-  unsigned long long getStateTransMask(void)
+  uint64_t getStateTransMask(void)
   {
     return StateTransMask;
   }
-  unsigned long long getStateNum(void)
+  uint64_t getStateNum(void)
   {
     return StateNum;
   }
</diff>
				<old_file>#ifndef __STATE_HPP__
#define __STATE_HPP__

#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;state_flags.hpp&gt;

namespace state_machine
{
class StartState;
class InitialState;
class LocateVehicleState;

class DriveState;
// Accel/Brake subState
class DriveAccAccelerationState;
class DriveAccDecelerationState;
class DriveAccKeepState;
class DriveAccStopState;
// Steering subState
class DriveStrStraightState;
class DriveStrLeftTurnState;
class DriveStrRightTurnState;

// Behavior subState
class DriveBehaviorLaneChangeLeftState;
class DriveBehaviorLaneChangeRightState;
class DriveBehaviorObstacleAvoidanceState;

// Perception subState
class DriveDetectObstacleState;
class DriveDetectStoplineState;
class DriveDetectTrafficlightRedState;

class MissionCompleteState;
class EmergencyState;

// base class
class BaseState
{
protected:
  BaseState()
  {
  }
public:
  virtual void update(void) = 0;
  virtual void showStateName(void) = 0;
  virtual unsigned long long getStateTransMask(void) = 0;
  virtual unsigned long long getStateNum(void) = 0;
  virtual std::string getStateName(void) = 0;
  virtual unsigned char getStateKind(void) = 0;
  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)=0;
  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)=0;
};

// Interface
template &lt;class T&gt;
class State : public BaseState
{
protected:
  std::string StateName = &quot;Base&quot;;
  unsigned long long StateNum;
  unsigned long long StateTransMask;
  unsigned char StateKind;

  std::function&lt;void(void)&gt; StateUpdateFunc;
  std::function&lt;void(void)&gt; StateChangedFunc;
  
  State()
  {
    StateNum = 0;
    StateTransMask = (unsigned long long)STATE_END - 1;
    StateKind = UNKNOWN_STATE;
  }

public:
  virtual void update(void){
	if(StateUpdateFunc)
		StateUpdateFunc();
  }

  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f){
	StateUpdateFunc = _f;
  }

  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f){
	StateChangedFunc = _f;
  }

  void showStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }

  static T* getInstance(void)
  {
    static T singleton;
    return &amp;singleton;
  }

  std::string getStateName(void)
  {
    return std::string(StateName);
  }

  unsigned char getStateKind(void)
  {
    return StateKind;
  }

  unsigned long long getStateTransMask(void)
  {
    return StateTransMask;
  }
  unsigned long long getStateNum(void)
  {
    return StateNum;
  }
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp">
				<diff>@@ -3,24 +3,23 @@
 
 #include &lt;atomic&gt;
 #include &lt;iostream&gt;
+#include &lt;map&gt;
+#include &lt;mutex&gt;
 #include &lt;queue&gt;
 #include &lt;thread&gt;
-#include &lt;mutex&gt;
 #include &lt;unordered_map&gt;
 #include &lt;utility&gt;
 
-
 #include &quot;state.hpp&quot;
-#include &quot;state_main.hpp&quot;
 #include &quot;state_drive.hpp&quot;
 #include &quot;state_emg.hpp&quot;
+#include &quot;state_main.hpp&quot;
 
 namespace state_machine
 {
 class StateContext
 {
 private:
-
   class StateHolder
   {
   public:
@@ -32,24 +31,22 @@ private:
     BaseState *OtherState;
   } current_state_;
 
-  std::vector&lt;BaseState **&gt; HolderList;
-
+  std::map&lt;uint8_t, BaseState **&gt; HolderMap;
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
 
   bool enableForceSetState;
-  std::queue&lt;unsigned long long&gt; ChangeStateFlags;
+  std::queue&lt;uint64_t&gt; ChangeStateFlags;
   std::atomic&lt;bool&gt; thread_loop;
 
   std::thread *thr_state_dec;
   std::mutex change_state_mutex;
 
-  void showStateMove(unsigned long long _state_num)
+  void showStateMove(uint64_t _state_num)
   {
     std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
   }
   bool setCurrentState(BaseState *state);
 
-
 public:
   StateContext(void)
   {
@@ -73,16 +70,16 @@ public:
     StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
     StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();
 
-    HolderList.push_back(&amp;current_state_.MainState);
-    HolderList.push_back(&amp;current_state_.AccState);
-    HolderList.push_back(&amp;current_state_.StrState);
-    HolderList.push_back(&amp;current_state_.BehaviorState);
-    HolderList.push_back(&amp;current_state_.PerceptionState);
-    HolderList.push_back(&amp;current_state_.OtherState);
+    HolderMap[MAIN_STATE] = &amp;current_state_.MainState;
+    HolderMap[ACC_STATE] = &amp;current_state_.AccState;
+    HolderMap[STR_STATE] = &amp;current_state_.StrState;
+    HolderMap[BEHAVIOR_STATE] = &amp;current_state_.BehaviorState;
+    HolderMap[PERCEPTION_STATE] = &amp;current_state_.PerceptionState;
+    HolderMap[OTHER_STATE] = &amp;current_state_.OtherState;
 
-    for (auto &amp;&amp;p : HolderList)
+    for (auto &amp;p : HolderMap)
     {
-      *p = nullptr;
+      *p.second = nullptr;
     }
     thread_loop = true;
 
@@ -97,32 +94,33 @@ public:
   void update(void);
   void stateDecider(void);
 
-  bool isState(BaseState *base, unsigned long long _state_num);
-  bool isCurrentState(unsigned long long _state_num);
-  bool isCurrentState(unsigned char _state_kind, unsigned long long _state_num);
-  bool inState(unsigned long long _state_num);
+  bool isState(BaseState *base, uint64_t _state_num);
+  bool isCurrentState(uint64_t _state_num);
+  bool isCurrentState(uint8_t _state_kind, uint64_t _state_num);
+  bool inState(uint64_t _state_num);
 
-  bool setCurrentState(StateFlags flag);
-  bool disableCurrentState(unsigned long long);
+  bool setCurrentState(uint64_t flag);
+  bool disableCurrentState(uint64_t);
 
   BaseState *getCurrentMainState(void);
   BaseState *getCurrentState(void);
   std::string getCurrentStateName(void);
   std::string getStateName(void);
-  BaseState **getCurrentStateHolderPtr(unsigned long long _state_num);
+  BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
   void showCurrentStateName(void);
   std::string createStateMessageText(void);
 
-  unsigned long long getStateStateNum(BaseState *_state);
-  unsigned long long getStateTransMask(BaseState *_state);
+  uint64_t getStateNum(BaseState *_state);
+  uint64_t getStateTransMask(BaseState *_state);
   bool isEmptyMainState(void);
   bool isDifferentState(BaseState *_state_a, BaseState *_state_b);
-  unsigned char getStateFlags(BaseState *_state);
+  uint8_t getStateKind(BaseState *_state);
+  bool isMainState(BaseState *_state);
 
-  std::string getCurrentStateName(StateKinds en);
+  std::string getCurrentStateName(uint8_t kind);
 
   bool setEnableForceSetState(bool force_flag);
-  BaseState *getStateObject(unsigned long long _state_num);
+  BaseState *getStateObject(uint64_t _state_num);
   void InitContext(void);
 
   bool TFInitialized(void);
</diff>
				<old_file>#ifndef __STATE_CONTEXT_HPP__
#define __STATE_CONTEXT_HPP__

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;mutex&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;


#include &quot;state.hpp&quot;
#include &quot;state_main.hpp&quot;
#include &quot;state_drive.hpp&quot;
#include &quot;state_emg.hpp&quot;

namespace state_machine
{
class StateContext
{
private:

  class StateHolder
  {
  public:
    BaseState *MainState;
    BaseState *AccState;
    BaseState *StrState;
    BaseState *BehaviorState;
    BaseState *PerceptionState;
    BaseState *OtherState;
  } current_state_;

  std::vector&lt;BaseState **&gt; HolderList;

  std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;

  bool enableForceSetState;
  std::queue&lt;unsigned long long&gt; ChangeStateFlags;
  std::atomic&lt;bool&gt; thread_loop;

  std::thread *thr_state_dec;
  std::mutex change_state_mutex;

  void showStateMove(unsigned long long _state_num)
  {
    std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }
  bool setCurrentState(BaseState *state);


public:
  StateContext(void)
  {
    StateStores[START_STATE] = StartState::getInstance();
    StateStores[INITIAL_STATE] = InitialState::getInstance();
    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
    StateStores[DRIVE_STATE] = DriveState::getInstance();
    StateStores[DRIVE_ACC_ACCELERATION_STATE] = DriveAccAccelerationState::getInstance();
    StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
    StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
    StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
    StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
    StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
    StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
    StateStores[DRIVE_DETECT_OBSTACLE_STATE] = DriveDetectObstacleState::getInstance();
    StateStores[DRIVE_DETECT_STOPLINE_STATE] = DriveDetectStoplineState::getInstance();
    StateStores[DRIVE_DETECT_TRAFFICLIGHT_RED_STATE] = DriveDetectTrafficlightRedState::getInstance();
    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
    StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();

    HolderList.push_back(&amp;current_state_.MainState);
    HolderList.push_back(&amp;current_state_.AccState);
    HolderList.push_back(&amp;current_state_.StrState);
    HolderList.push_back(&amp;current_state_.BehaviorState);
    HolderList.push_back(&amp;current_state_.PerceptionState);
    HolderList.push_back(&amp;current_state_.OtherState);

    for (auto &amp;&amp;p : HolderList)
    {
      *p = nullptr;
    }
    thread_loop = true;

    this-&gt;InitContext();
  }

  ~StateContext()
  {
    thread_loop = false;
  }

  void update(void);
  void stateDecider(void);

  bool isState(BaseState *base, unsigned long long _state_num);
  bool isCurrentState(unsigned long long _state_num);
  bool isCurrentState(unsigned char _state_kind, unsigned long long _state_num);
  bool inState(unsigned long long _state_num);

  bool setCurrentState(StateFlags flag);
  bool disableCurrentState(unsigned long long);

  BaseState *getCurrentMainState(void);
  BaseState *getCurrentState(void);
  std::string getCurrentStateName(void);
  std::string getStateName(void);
  BaseState **getCurrentStateHolderPtr(unsigned long long _state_num);
  void showCurrentStateName(void);
  std::string createStateMessageText(void);

  unsigned long long getStateStateNum(BaseState *_state);
  unsigned long long getStateTransMask(BaseState *_state);
  bool isEmptyMainState(void);
  bool isDifferentState(BaseState *_state_a, BaseState *_state_b);
  unsigned char getStateFlags(BaseState *_state);

  std::string getCurrentStateName(StateKinds en);

  bool setEnableForceSetState(bool force_flag);
  BaseState *getStateObject(unsigned long long _state_num);
  void InitContext(void);

  bool TFInitialized(void);

  void handleTrafficLight(uint32_t _light_color);
  bool handleCurrentPose(double x, double y, double z, double roll, double pitch, double yaw);
  bool handlePointsRaw(bool _hasLidarData);

  bool handleIntersection(bool _hasIntersection, double _angle);
  bool handleTwistCmd(bool _hasTwistCmd);
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_drive.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_drive.hpp">
				<diff>@@ -12,7 +12,6 @@
 
 namespace state_machine
 {
-
 // DriveState
 class DriveState : public State&lt;DriveState&gt;
 {
@@ -117,6 +116,7 @@ private:
     StateTransMask = DRIVE_STATE;
     StateKind = STR_STATE;
   }
+
 public:
 };
 class DriveStrRightState : public State&lt;DriveStrRightState&gt;
@@ -130,6 +130,7 @@ private:
     StateTransMask = DRIVE_STATE;
     StateKind = STR_STATE;
   }
+
 public:
 };
 class DriveStrStraightState : public State&lt;DriveStrStraightState&gt;
</diff>
				<old_file>#ifndef __STATE_DRIVE_HPP__
#define __STATE_DRIVE_HPP__

/**
 * @file state_drive.hpp
 * @brief Declaration drive state
 * @author Yusuke Fujii
 * @date 2017/07/27
 */

#include &quot;state.hpp&quot;

namespace state_machine
{

// DriveState
class DriveState : public State&lt;DriveState&gt;
{
private:
  friend class State&lt;DriveState&gt;;

  DriveState(void)
  {
    StateName = &quot;Drive&quot;;
    StateNum = StateTransMask = DRIVE_STATE;
    StateTransMask |= INITIAL_LOCATEVEHICLE_STATE;
    StateKind = MAIN_STATE;
  }

public:
};

class DriveAccAccelerationState : public State&lt;DriveAccAccelerationState&gt;
{
private:
  friend class State&lt;DriveAccAccelerationState&gt;;
  DriveAccAccelerationState(void)
  {
    StateName = &quot;Acceleration&quot;;
    StateNum = DRIVE_STATE | DRIVE_ACC_ACCELERATION_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = ACC_STATE;
  }

public:
  void ShowStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }
};

class DriveAccDecelerationState : public State&lt;DriveAccDecelerationState&gt;
{
private:
  friend class State&lt;DriveAccDecelerationState&gt;;
  DriveAccDecelerationState(void)
  {
    StateName = &quot;Deceleration&quot;;
    StateNum = DRIVE_STATE | DRIVE_ACC_DECELERATION_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = ACC_STATE;
  }

public:
  void ShowStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }
};

class DriveAccKeepState : public State&lt;DriveAccKeepState&gt;
{
private:
  friend class State&lt;DriveAccKeepState&gt;;
  DriveAccKeepState(void)
  {
    StateName = &quot;Keep&quot;;
    StateNum = DRIVE_STATE | DRIVE_ACC_KEEP_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = ACC_STATE;
  }

public:
  void ShowStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }
};

class DriveAccStopState : public State&lt;DriveAccStopState&gt;
{
private:
  friend class State&lt;DriveAccStopState&gt;;
  DriveAccStopState(void)
  {
    StateName = &quot;Stop&quot;;
    StateNum = DRIVE_STATE | DRIVE_ACC_STOP_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = ACC_STATE;
  }

public:
  void ShowStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }
};

class DriveStrLeftState : public State&lt;DriveStrLeftState&gt;
{
private:
  friend class State&lt;DriveStrLeftState&gt;;
  DriveStrLeftState(void)
  {
    StateName = &quot;Left Turn&quot;;
    StateNum = DRIVE_STATE | DRIVE_STR_LEFT_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = STR_STATE;
  }
public:
};
class DriveStrRightState : public State&lt;DriveStrRightState&gt;
{
private:
  friend class State&lt;DriveStrRightState&gt;;
  DriveStrRightState(void)
  {
    StateName = &quot;Right Turn&quot;;
    StateNum = DRIVE_STATE | DRIVE_STR_RIGHT_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = STR_STATE;
  }
public:
};
class DriveStrStraightState : public State&lt;DriveStrStraightState&gt;
{
private:
  friend class State&lt;DriveStrStraightState&gt;;
  DriveStrStraightState(void)
  {
    StateName = &quot;Straight&quot;;
    StateNum = DRIVE_STATE | DRIVE_STR_STRAIGHT_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = STR_STATE;
  }

public:
};

class DriveBehaviorLaneChangeLeftState : public State&lt;DriveBehaviorLaneChangeLeftState&gt;
{
private:
  friend class State&lt;DriveBehaviorLaneChangeLeftState&gt;;
  DriveBehaviorLaneChangeLeftState(void)
  {
    StateName = &quot;LaneChangeLeft&quot;;
    StateNum = DRIVE_STATE | DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = BEHAVIOR_STATE;
  }

public:
};

class DriveBehaviorLaneChangeRightState : public State&lt;DriveBehaviorLaneChangeRightState&gt;
{
private:
  friend class State&lt;DriveBehaviorLaneChangeRightState&gt;;
  DriveBehaviorLaneChangeRightState(void)
  {
    StateName = &quot;LaneChangeRight&quot;;
    StateNum = DRIVE_STATE | DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = BEHAVIOR_STATE;
  }

public:
};

class DriveBehaviorObstacleAvoidanceState : public State&lt;DriveBehaviorObstacleAvoidanceState&gt;
{
private:
  friend class State&lt;DriveBehaviorObstacleAvoidanceState&gt;;
  DriveBehaviorObstacleAvoidanceState(void)
  {
    StateName = &quot;ObstacleAvoidance&quot;;
    StateTransMask = DRIVE_STATE;
    StateKind = BEHAVIOR_STATE;
  }

public:
};

class DriveDetectObstacleState : public State&lt;DriveDetectObstacleState&gt;
{
private:
  friend class State&lt;DriveDetectObstacleState&gt;;
  DriveDetectObstacleState(void)
  {
    StateName = &quot;DetectObstacle&quot;;
    StateNum = DRIVE_STATE | DRIVE_DETECT_OBSTACLE_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = PERCEPTION_STATE;
  }

public:
};

class DriveDetectStoplineState : public State&lt;DriveDetectStoplineState&gt;
{
private:
  friend class State&lt;DriveDetectStoplineState&gt;;
  DriveDetectStoplineState(void)
  {
    StateName = &quot;DetectStopline&quot;;
    StateNum = DRIVE_STATE | DRIVE_DETECT_STOPLINE_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = PERCEPTION_STATE;
  }

public:
};

class DriveDetectTrafficlightRedState : public State&lt;DriveDetectTrafficlightRedState&gt;
{
private:
  friend class State&lt;DriveDetectTrafficlightRedState&gt;;
  DriveDetectTrafficlightRedState(void)
  {
    StateName = &quot;DetectTrafficLightRed&quot;;
    StateNum = DRIVE_STATE | DRIVE_DETECT_TRAFFICLIGHT_RED_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = PERCEPTION_STATE;
  }

public:
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_main.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_main.hpp">
				<diff>@@ -9,7 +9,6 @@
 
 namespace state_machine
 {
-
 // StartState
 class StartState : public State&lt;StartState&gt;
 {
@@ -19,11 +18,13 @@ private:
   {
     StateName = &quot;Start&quot;;
     StateNum = START_STATE;
-    StateTransMask = (unsigned long long)STATE_END - 1;
+    StateTransMask = (uint64_t)STATE_END - 1;
     StateKind = MAIN_STATE;
   }
+
 public:
-  virtual void update (void) override{
+  virtual void update(void) override
+  {
   }
 };
 
</diff>
				<old_file>#ifndef __STATE_MAIN_HPP__
#define __STATE_MAIN_HPP__

#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;vector&gt;

#include &lt;state.hpp&gt;

namespace state_machine
{

// StartState
class StartState : public State&lt;StartState&gt;
{
private:
  friend class State&lt;StartState&gt;;
  StartState(void)
  {
    StateName = &quot;Start&quot;;
    StateNum = START_STATE;
    StateTransMask = (unsigned long long)STATE_END - 1;
    StateKind = MAIN_STATE;
  }
public:
  virtual void update (void) override{
  }
};

// InitialState
class InitialState : public State&lt;InitialState&gt;
{
private:
  friend class State&lt;InitialState&gt;;
  InitialState(void)
  {
    StateName = &quot;Initial&quot;;
    StateNum = StateTransMask = INITIAL_STATE;
    StateTransMask |= START_STATE | EMERGENCY_STATE | MISSION_COMPLETE_STATE;
    StateKind = MAIN_STATE;
  }

public:
};
class LocateVehicleState : public State&lt;LocateVehicleState&gt;
{
private:
  friend class State&lt;LocateVehicleState&gt;;
  LocateVehicleState(void)
  {
    StateName = &quot;Locate Vehicle&quot;;
    StateNum = StateTransMask = INITIAL_LOCATEVEHICLE_STATE;
    StateTransMask |= INITIAL_STATE;
    StateKind = MAIN_STATE;
  }

public:
};
// MissionCompleteState
class MissionCompleteState : public State&lt;MissionCompleteState&gt;
{
private:
  friend class State&lt;MissionCompleteState&gt;;
  MissionCompleteState(void)
  {
    StateName = &quot;MissionComplete&quot;;
    StateNum = MISSION_COMPLETE_STATE;
    StateTransMask = DRIVE_STATE;
    StateKind = MAIN_STATE;
  }

public:
};

// EmergencyState
class EmergencyState : public State&lt;EmergencyState&gt;
{
private:
  friend class State&lt;EmergencyState&gt;;
  EmergencyState(void)
  {
    StateName = &quot;Emergency&quot;;
    StateTransMask = 0;
  }

public:
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp" new_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp">
				<diff>@@ -25,21 +25,22 @@ namespace state_machine
 {
 void StateContext::update(void)
 {
-	for(auto &amp;&amp;p : HolderList){
-		if(*p){
-			(*p)-&gt;update();
-		}
-	}
-
+  for (auto &amp;p : HolderMap)
+  {
+    if (*p.second)
+    {
+      (*p.second)-&gt;update();
+    }
+  }
 }
 
-
 void StateContext::showCurrentStateName(void)
 {
-  for (auto &amp;&amp;p : HolderList) {
-    if (*p)
+  for (auto &amp;p : HolderMap)
+  {
+    if (*p.second)
     {
-      (*p)-&gt;showStateName();
+      (*p.second)-&gt;showStateName();
     }
   }
 
@@ -52,172 +53,79 @@ void StateContext::showCurrentStateName(void)
   std::cout &lt;&lt; std::endl;
 }
 
-
 bool StateContext::isDifferentState(BaseState *_state_a, BaseState *_state_b)
 {
-	return _state_a == _state_b;
+  return _state_a == _state_b;
 }
 
-bool StateContext::isEmptyMainState(void){
-	if(current_state_.MainState)
-		return false;
-	return true;
+bool StateContext::isEmptyMainState(void)
+{
+  if (current_state_.MainState)
+    return false;
+  return true;
 }
 
-unsigned char StateContext::getStateFlags(BaseState *_state)
+uint8_t StateContext::getStateKind(BaseState *_state)
 {
-	if(_state)
-		return _state-&gt;getStateKind();
-	else
-		return NULL_STATE;
+  if (_state)
+    return _state-&gt;getStateKind();
+  else
+    return NULL_STATE;
 }
 
-unsigned long long StateContext::getStateTransMask(BaseState *_state)
+uint64_t StateContext::getStateTransMask(BaseState *_state)
 {
-	if(_state)
-		return _state-&gt;getStateTransMask();
-	else
-		return 0;
+  if (_state)
+    return _state-&gt;getStateTransMask();
+  else
+    return 0;
 }
 
-unsigned long long StateContext::getStateStateNum(BaseState *_state)
+uint64_t StateContext::getStateNum(BaseState *_state)
 {
-	if(_state)
-		return _state-&gt;getStateNum();
-	else
-		return 0;
+  if (_state)
+    return _state-&gt;getStateNum();
+  else
+    return 0;
 }
 
+bool StateContext::isMainState(BaseState *_state)
+{
+  return getStateKind(_state) == MAIN_STATE;
+}
 
 bool StateContext::setCurrentState(BaseState *_state)
 {
   change_state_mutex.lock();
 
-  BaseState *prevState = current_state_.MainState;
+  bool ret = true;
 
-  if (isEmptyMainState() &amp;&amp; _state )
+  if (isMainState(_state))
   {
-    current_state_.MainState = _state;
-    std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
-              &lt;&lt; &quot;NULL&quot;
-              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
-              &lt;&lt; &quot;NULL&quot;
-              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
-  }
-  else
-  {
-    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
+    if (isEmptyMainState() || enableForceSetState ||
+        (getStateTransMask(_state) &amp; getStateNum(current_state_.MainState)))
     {
-      switch (getStateFlags(_state))
-      {
-        case MAIN_STATE:
-          current_state_.MainState = _state;
-          current_state_.AccState = nullptr;
-          current_state_.StrState = nullptr;
-          current_state_.BehaviorState = nullptr;
-          current_state_.PerceptionState = nullptr;
-          current_state_.OtherState = nullptr;
-          break;
-        case ACC_STATE:
-          current_state_.AccState = _state;
-          break;
-        case STR_STATE:
-          current_state_.StrState = _state;
-          break;
-        case BEHAVIOR_STATE:
-          current_state_.BehaviorState = _state;
-          break;
-        case PERCEPTION_STATE:
-          current_state_.PerceptionState = _state;
-          break;
-        case OTHER_STATE:
-          current_state_.OtherState = _state;
-          break;
-      }
-      std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; prevState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName()
-                &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot; &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; &quot;-&quot;
-                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
+      current_state_.MainState = _state;
+      current_state_.AccState = nullptr;
+      current_state_.StrState = nullptr;
+      current_state_.BehaviorState = nullptr;
+      current_state_.PerceptionState = nullptr;
+      current_state_.OtherState = nullptr;
     }
     else
     {
-      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot;
-                &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
-                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
-      prevState = nullptr;
-      change_state_mutex.unlock();
-      return false;
+      ret = false;
     }
   }
-  change_state_mutex.unlock();
-  return true;
-}
-
-#if 0
-bool StateContext::setCurrentState(BaseState *_state)
-{
-  change_state_mutex.lock();
-
-  BaseState *prevState = current_state_.MainState;
-
-  if (!prevState)
-  {
-    current_state_.MainState = _state;
-    std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
-              &lt;&lt; &quot;NULL&quot;
-              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
-              &lt;&lt; &quot;NULL&quot;
-              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
-  }
   else
   {
-    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
-    {
-      switch (_state-&gt;getStateKind())
-      {
-        case MAIN_STATE:
-          current_state_.MainState = _state;
-          current_state_.AccState = nullptr;
-          current_state_.StrState = nullptr;
-          current_state_.BehaviorState = nullptr;
-          current_state_.PerceptionState = nullptr;
-          current_state_.OtherState = nullptr;
-          break;
-        case ACC_STATE:
-          current_state_.AccState = _state;
-          break;
-        case STR_STATE:
-          current_state_.StrState = _state;
-          break;
-        case BEHAVIOR_STATE:
-          current_state_.BehaviorState = _state;
-          break;
-        case PERCEPTION_STATE:
-          current_state_.PerceptionState = _state;
-          break;
-        case OTHER_STATE:
-          current_state_.OtherState = _state;
-          break;
-      }
-      std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; prevState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName()
-                &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot; &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; &quot;-&quot;
-                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
-    }
-    else
-    {
-      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot;
-                &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
-                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
-      prevState = nullptr;
-      change_state_mutex.unlock();
-      return false;
-    }
+    *HolderMap[getStateKind(_state)] = _state;
   }
   change_state_mutex.unlock();
-  return true;
+  return ret;
 }
-#endif
 
-bool StateContext::setCurrentState(StateFlags flag)
+bool StateContext::setCurrentState(uint64_t flag)
 {
   bool ret = this-&gt;setCurrentState(StateStores[flag]);
   return ret;
@@ -229,18 +137,15 @@ bool StateContext::setEnableForceSetState(bool force_flag)
   return true;
 }
 
-std::string StateContext::getCurrentStateName(StateKinds en)
+std::string StateContext::getCurrentStateName(uint8_t kind)
 {
-  for (auto &amp;&amp;p : HolderList)
-  {
-    if (*p &amp;&amp; (*p)-&gt;getStateKind() == en)
-	      return (*p)-&gt;getStateName();
-  }
+  if (*HolderMap[kind])
+    return (*HolderMap[kind])-&gt;getStateName();
   return std::string(&quot;&quot;);
 }
 std::string StateContext::getCurrentStateName(void)
 {
-	return this-&gt;getCurrentStateName(MAIN_STATE);
+  return this-&gt;getCurrentStateName(MAIN_STATE);
 }
 
 BaseState *StateContext::getCurrentMainState(void)
@@ -248,15 +153,15 @@ BaseState *StateContext::getCurrentMainState(void)
   return current_state_.MainState;
 }
 
-BaseState *StateContext::getStateObject(unsigned long long _state_num)
+BaseState *StateContext::getStateObject(uint64_t _state_num)
 {
   return StateStores[_state_num];
 }
 
-BaseState **StateContext::getCurrentStateHolderPtr(unsigned long long _state_num)
+BaseState **StateContext::getCurrentStateHolderPtr(uint64_t _state_num)
 {
   BaseState **state_ptr;
-  switch (getStateObject(_state_num)-&gt;getStateKind())
+  switch (getStateKind(getStateObject(_state_num)))
   {
     case MAIN_STATE:
       state_ptr = &amp;current_state_.MainState;
@@ -283,7 +188,7 @@ BaseState **StateContext::getCurrentStateHolderPtr(unsigned long long _state_num
   return state_ptr;
 }
 
-bool StateContext::disableCurrentState(unsigned long long _state_num)
+bool StateContext::disableCurrentState(uint64_t _state_num)
 {
   BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
   if (state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num))
@@ -297,18 +202,18 @@ bool StateContext::disableCurrentState(unsigned long long _state_num)
   }
 }
 
-bool StateContext::isCurrentState(unsigned long long _state_num)
+bool StateContext::isCurrentState(uint64_t _state_num)
 {
   BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
   return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
 }
 
-bool StateContext::isState(BaseState *base, unsigned long long _state_num)
+bool StateContext::isState(BaseState *base, uint64_t _state_num)
 {
   return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
 }
 
-bool StateContext::inState(unsigned long long _state_num)
+bool StateContext::inState(uint64_t _state_num)
 {
   if (current_state_.MainState)
   {
@@ -322,19 +227,19 @@ bool StateContext::inState(unsigned long long _state_num)
 
 bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
 {
-    /* deprecated */
-	return false;
+  /* deprecated */
+  return false;
 }
 
 std::string StateContext::createStateMessageText(void)
 {
   std::string ret;
 
-  for (auto &amp;&amp;p : HolderList)
+  for (auto &amp;p : HolderMap)
   {
-    if (*p)
+    if (*p.second)
     {
-      ret = ret + &quot;\n&quot; + (*p)-&gt;getStateName();
+      ret = ret + &quot;\n&quot; + (*p.second)-&gt;getStateName();
     }
   }
   return ret;
</diff>
				<old_file>#include &lt;sched.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

#include &lt;cassert&gt;
#include &lt;mutex&gt;

#include &lt;state_context.hpp&gt;

#include &lt;state.hpp&gt;
#include &lt;state_common.hpp&gt;

/**
 *
 * @file StateContext.cpp
 * @brief state context class
 * @author Yusuke Fujii
 * @date  2017/07/25
 *
 **/

namespace state_machine
{
void StateContext::update(void)
{
	for(auto &amp;&amp;p : HolderList){
		if(*p){
			(*p)-&gt;update();
		}
	}

}


void StateContext::showCurrentStateName(void)
{
  for (auto &amp;&amp;p : HolderList) {
    if (*p)
    {
      (*p)-&gt;showStateName();
    }
  }

#if 0
  if (sub_state)
    sub_state-&gt;showStateName();
  if (sub_sub_state)
    sub_sub_state-&gt;showStateName();
#endif
  std::cout &lt;&lt; std::endl;
}


bool StateContext::isDifferentState(BaseState *_state_a, BaseState *_state_b)
{
	return _state_a == _state_b;
}

bool StateContext::isEmptyMainState(void){
	if(current_state_.MainState)
		return false;
	return true;
}

unsigned char StateContext::getStateFlags(BaseState *_state)
{
	if(_state)
		return _state-&gt;getStateKind();
	else
		return NULL_STATE;
}

unsigned long long StateContext::getStateTransMask(BaseState *_state)
{
	if(_state)
		return _state-&gt;getStateTransMask();
	else
		return 0;
}

unsigned long long StateContext::getStateStateNum(BaseState *_state)
{
	if(_state)
		return _state-&gt;getStateNum();
	else
		return 0;
}


bool StateContext::setCurrentState(BaseState *_state)
{
  change_state_mutex.lock();

  BaseState *prevState = current_state_.MainState;

  if (isEmptyMainState() &amp;&amp; _state )
  {
    current_state_.MainState = _state;
    std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }
  else
  {
    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
    {
      switch (getStateFlags(_state))
      {
        case MAIN_STATE:
          current_state_.MainState = _state;
          current_state_.AccState = nullptr;
          current_state_.StrState = nullptr;
          current_state_.BehaviorState = nullptr;
          current_state_.PerceptionState = nullptr;
          current_state_.OtherState = nullptr;
          break;
        case ACC_STATE:
          current_state_.AccState = _state;
          break;
        case STR_STATE:
          current_state_.StrState = _state;
          break;
        case BEHAVIOR_STATE:
          current_state_.BehaviorState = _state;
          break;
        case PERCEPTION_STATE:
          current_state_.PerceptionState = _state;
          break;
        case OTHER_STATE:
          current_state_.OtherState = _state;
          break;
      }
      std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; prevState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName()
                &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot; &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; &quot;-&quot;
                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    }
    else
    {
      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot;
                &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
      prevState = nullptr;
      change_state_mutex.unlock();
      return false;
    }
  }
  change_state_mutex.unlock();
  return true;
}

#if 0
bool StateContext::setCurrentState(BaseState *_state)
{
  change_state_mutex.lock();

  BaseState *prevState = current_state_.MainState;

  if (!prevState)
  {
    current_state_.MainState = _state;
    std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
              &lt;&lt; &quot;NULL&quot;
              &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }
  else
  {
    if (_state &amp;&amp; (enableForceSetState || (_state-&gt;getStateTransMask() &amp; prevState-&gt;getStateNum())))
    {
      switch (_state-&gt;getStateKind())
      {
        case MAIN_STATE:
          current_state_.MainState = _state;
          current_state_.AccState = nullptr;
          current_state_.StrState = nullptr;
          current_state_.BehaviorState = nullptr;
          current_state_.PerceptionState = nullptr;
          current_state_.OtherState = nullptr;
          break;
        case ACC_STATE:
          current_state_.AccState = _state;
          break;
        case STR_STATE:
          current_state_.StrState = _state;
          break;
        case BEHAVIOR_STATE:
          current_state_.BehaviorState = _state;
          break;
        case PERCEPTION_STATE:
          current_state_.PerceptionState = _state;
          break;
        case OTHER_STATE:
          current_state_.OtherState = _state;
          break;
      }
      std::cout &lt;&lt; &quot;Successed to set state \&quot;&quot; &lt;&lt; prevState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot; &lt;&lt; _state-&gt;getStateName()
                &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot; &lt;&lt; prevState-&gt;getStateNum() &lt;&lt; &quot;-&quot;
                &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    }
    else
    {
      std::cerr &lt;&lt; &quot;Failed to set state \&quot;&quot; &lt;&lt; current_state_.MainState-&gt;getStateName() &lt;&lt; &quot;\&quot; to \&quot;&quot;
                &lt;&lt; _state-&gt;getStateName() &lt;&lt; &quot;\&quot; : Mask is [&quot; &lt;&lt; _state-&gt;getStateTransMask() &lt;&lt; &quot;/&quot;
                &lt;&lt; current_state_.MainState-&gt;getStateNum() &lt;&lt; &quot;-&quot; &lt;&lt; _state-&gt;getStateNum() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
      prevState = nullptr;
      change_state_mutex.unlock();
      return false;
    }
  }
  change_state_mutex.unlock();
  return true;
}
#endif

bool StateContext::setCurrentState(StateFlags flag)
{
  bool ret = this-&gt;setCurrentState(StateStores[flag]);
  return ret;
}

bool StateContext::setEnableForceSetState(bool force_flag)
{
  enableForceSetState = force_flag;
  return true;
}

std::string StateContext::getCurrentStateName(StateKinds en)
{
  for (auto &amp;&amp;p : HolderList)
  {
    if (*p &amp;&amp; (*p)-&gt;getStateKind() == en)
	      return (*p)-&gt;getStateName();
  }
  return std::string(&quot;&quot;);
}
std::string StateContext::getCurrentStateName(void)
{
	return this-&gt;getCurrentStateName(MAIN_STATE);
}

BaseState *StateContext::getCurrentMainState(void)
{
  return current_state_.MainState;
}

BaseState *StateContext::getStateObject(unsigned long long _state_num)
{
  return StateStores[_state_num];
}

BaseState **StateContext::getCurrentStateHolderPtr(unsigned long long _state_num)
{
  BaseState **state_ptr;
  switch (getStateObject(_state_num)-&gt;getStateKind())
  {
    case MAIN_STATE:
      state_ptr = &amp;current_state_.MainState;
      break;
    case ACC_STATE:
      state_ptr = &amp;current_state_.AccState;
      break;
    case STR_STATE:
      state_ptr = &amp;current_state_.StrState;
      break;
    case BEHAVIOR_STATE:
      state_ptr = &amp;current_state_.BehaviorState;
      break;
    case PERCEPTION_STATE:
      state_ptr = &amp;current_state_.PerceptionState;
      break;
    case OTHER_STATE:
      state_ptr = &amp;current_state_.OtherState;
      break;
    default:
      state_ptr = nullptr;
      break;
  }
  return state_ptr;
}

bool StateContext::disableCurrentState(unsigned long long _state_num)
{
  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
  if (state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num))
  {
    *state_ptr = nullptr;
    return true;
  }
  else
  {
    return false;
  }
}

bool StateContext::isCurrentState(unsigned long long _state_num)
{
  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
  return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
}

bool StateContext::isState(BaseState *base, unsigned long long _state_num)
{
  return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
}

bool StateContext::inState(unsigned long long _state_num)
{
  if (current_state_.MainState)
  {
    return ((current_state_.MainState-&gt;getStateNum() &amp; _state_num) != 0) ? true : false;
  }
  else
  {
    return false;
  }
}

bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
{
    /* deprecated */
	return false;
}

std::string StateContext::createStateMessageText(void)
{
  std::string ret;

  for (auto &amp;&amp;p : HolderList)
  {
    if (*p)
    {
      ret = ret + &quot;\n&quot; + (*p)-&gt;getStateName();
    }
  }
  return ret;
}

bool StateContext::handleTwistCmd(bool _hasTwistCmd)
{
  if (_hasTwistCmd)
    return this-&gt;setCurrentState(DRIVE_STATE);
  else
    return false;
}

void StateContext::stateDecider(void)
{
  // not running
}

void StateContext::InitContext(void)
{
  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
  thr_state_dec-&gt;detach();
  this-&gt;setCurrentState(START_STATE);
  return;
}
bool StateContext::TFInitialized(void)
{
  return this-&gt;setCurrentState(INITIAL_STATE);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="f5e79a823995ead09dff2606db4b6fa9da704a98" fix_time="0,5696">
		<msg>fix segv</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp">
				<diff>@@ -47,6 +47,7 @@ protected:
 
 public:
   virtual void update(void) = 0;
+  virtual void changed(void) = 0;
   virtual void showStateName(void) = 0;
   virtual uint64_t getStateTransMask(void) = 0;
   virtual uint64_t getStateNum(void) = 0;
@@ -83,6 +84,12 @@ public:
       StateUpdateFunc();
   }
 
+  virtual void changed(void)
+  {
+    if (StateChangedFunc)
+	    StateChangedFunc();
+  }
+
   virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)
   {
     StateUpdateFunc = _f;
</diff>
				<old_file>#ifndef __STATE_HPP__
#define __STATE_HPP__

#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;state_flags.hpp&gt;
#include &lt;vector&gt;

namespace state_machine
{
class StartState;
class InitialState;
class LocateVehicleState;

class DriveState;
// Accel/Brake subState
class DriveAccAccelerationState;
class DriveAccDecelerationState;
class DriveAccKeepState;
class DriveAccStopState;
// Steering subState
class DriveStrStraightState;
class DriveStrLeftTurnState;
class DriveStrRightTurnState;

// Behavior subState
class DriveBehaviorLaneChangeLeftState;
class DriveBehaviorLaneChangeRightState;
class DriveBehaviorObstacleAvoidanceState;

// Perception subState
class DriveDetectObstacleState;
class DriveDetectStoplineState;
class DriveDetectTrafficlightRedState;

class MissionCompleteState;
class EmergencyState;

// base class
class BaseState
{
protected:
  BaseState()
  {
  }

public:
  virtual void update(void) = 0;
  virtual void showStateName(void) = 0;
  virtual uint64_t getStateTransMask(void) = 0;
  virtual uint64_t getStateNum(void) = 0;
  virtual std::string getStateName(void) = 0;
  virtual uint8_t getStateKind(void) = 0;
  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f) = 0;
};

// Interface
template &lt;class T&gt;
class State : public BaseState
{
protected:
  std::string StateName = &quot;Base&quot;;
  uint64_t StateNum;
  uint64_t StateTransMask;
  uint8_t StateKind;

  std::function&lt;void(void)&gt; StateUpdateFunc;
  std::function&lt;void(void)&gt; StateChangedFunc;

  State()
  {
    StateNum = 0;
    StateTransMask = (uint64_t)STATE_END - 1;
    StateKind = UNKNOWN_STATE;
  }

public:
  virtual void update(void)
  {
    if (StateUpdateFunc)
      StateUpdateFunc();
  }

  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)
  {
    StateUpdateFunc = _f;
  }

  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)
  {
    StateChangedFunc = _f;
  }

  void showStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }

  static T* getInstance(void)
  {
    static T singleton;
    return &amp;singleton;
  }

  std::string getStateName(void)
  {
    return std::string(StateName);
  }

  uint8_t getStateKind(void)
  {
    return StateKind;
  }

  uint64_t getStateTransMask(void)
  {
    return StateTransMask;
  }
  uint64_t getStateNum(void)
  {
    return StateNum;
  }
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp">
				<diff>@@ -92,6 +92,7 @@ public:
   }
 
   void update(void);
+  void changed(uint8_t _kind);
   void stateDecider(void);
 
   bool isState(BaseState *base, uint64_t _state_num);
@@ -106,14 +107,17 @@ public:
   BaseState *getCurrentState(void);
   std::string getCurrentStateName(void);
   std::string getStateName(void);
+  
+  BaseState **getCurrentStateHolderPtr(uint8_t _kind);
   BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
+  BaseState **getCurrentStateHolderPtr(BaseState *_state);
   void showCurrentStateName(void);
   std::string createStateMessageText(void);
 
   uint64_t getStateNum(BaseState *_state);
   uint64_t getStateTransMask(BaseState *_state);
   bool isEmptyMainState(void);
-  bool isDifferentState(BaseState *_state_a, BaseState *_state_b);
+  bool isDifferentState(BaseState *_state_a, BaseState **_state_b);
   uint8_t getStateKind(BaseState *_state);
   bool isMainState(BaseState *_state);
 
</diff>
				<old_file>#ifndef __STATE_CONTEXT_HPP__
#define __STATE_CONTEXT_HPP__

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

#include &quot;state.hpp&quot;
#include &quot;state_drive.hpp&quot;
#include &quot;state_emg.hpp&quot;
#include &quot;state_main.hpp&quot;

namespace state_machine
{
class StateContext
{
private:
  class StateHolder
  {
  public:
    BaseState *MainState;
    BaseState *AccState;
    BaseState *StrState;
    BaseState *BehaviorState;
    BaseState *PerceptionState;
    BaseState *OtherState;
  } current_state_;

  std::map&lt;uint8_t, BaseState **&gt; HolderMap;
  std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;

  bool enableForceSetState;
  std::queue&lt;uint64_t&gt; ChangeStateFlags;
  std::atomic&lt;bool&gt; thread_loop;

  std::thread *thr_state_dec;
  std::mutex change_state_mutex;

  void showStateMove(uint64_t _state_num)
  {
    std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }
  bool setCurrentState(BaseState *state);

public:
  StateContext(void)
  {
    StateStores[START_STATE] = StartState::getInstance();
    StateStores[INITIAL_STATE] = InitialState::getInstance();
    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
    StateStores[DRIVE_STATE] = DriveState::getInstance();
    StateStores[DRIVE_ACC_ACCELERATION_STATE] = DriveAccAccelerationState::getInstance();
    StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
    StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
    StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
    StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
    StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
    StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
    StateStores[DRIVE_DETECT_OBSTACLE_STATE] = DriveDetectObstacleState::getInstance();
    StateStores[DRIVE_DETECT_STOPLINE_STATE] = DriveDetectStoplineState::getInstance();
    StateStores[DRIVE_DETECT_TRAFFICLIGHT_RED_STATE] = DriveDetectTrafficlightRedState::getInstance();
    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
    StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();

    HolderMap[MAIN_STATE] = &amp;current_state_.MainState;
    HolderMap[ACC_STATE] = &amp;current_state_.AccState;
    HolderMap[STR_STATE] = &amp;current_state_.StrState;
    HolderMap[BEHAVIOR_STATE] = &amp;current_state_.BehaviorState;
    HolderMap[PERCEPTION_STATE] = &amp;current_state_.PerceptionState;
    HolderMap[OTHER_STATE] = &amp;current_state_.OtherState;

    for (auto &amp;p : HolderMap)
    {
      *p.second = nullptr;
    }
    thread_loop = true;

    this-&gt;InitContext();
  }

  ~StateContext()
  {
    thread_loop = false;
  }

  void update(void);
  void stateDecider(void);

  bool isState(BaseState *base, uint64_t _state_num);
  bool isCurrentState(uint64_t _state_num);
  bool isCurrentState(uint8_t _state_kind, uint64_t _state_num);
  bool inState(uint64_t _state_num);

  bool setCurrentState(uint64_t flag);
  bool disableCurrentState(uint64_t);

  BaseState *getCurrentMainState(void);
  BaseState *getCurrentState(void);
  std::string getCurrentStateName(void);
  std::string getStateName(void);
  BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
  void showCurrentStateName(void);
  std::string createStateMessageText(void);

  uint64_t getStateNum(BaseState *_state);
  uint64_t getStateTransMask(BaseState *_state);
  bool isEmptyMainState(void);
  bool isDifferentState(BaseState *_state_a, BaseState *_state_b);
  uint8_t getStateKind(BaseState *_state);
  bool isMainState(BaseState *_state);

  std::string getCurrentStateName(uint8_t kind);

  bool setEnableForceSetState(bool force_flag);
  BaseState *getStateObject(uint64_t _state_num);
  void InitContext(void);

  bool TFInitialized(void);

  void handleTrafficLight(uint32_t _light_color);
  bool handleCurrentPose(double x, double y, double z, double roll, double pitch, double yaw);
  bool handlePointsRaw(bool _hasLidarData);

  bool handleIntersection(bool _hasIntersection, double _angle);
  bool handleTwistCmd(bool _hasTwistCmd);
};
}

#endif
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="13fff854ee881d153434777fdf4c1523eb3fee9f" fix_time="643,25238">
		<msg>fix pos_downloader temporary comp</msg>
		<modified_files>
			<file old_path="ros/src/data/packages/pos_db/nodes/pos_downloader/pos_downloader.cpp" new_path="ros/src/data/packages/pos_db/nodes/pos_downloader/pos_downloader.cpp">
				<diff>@@ -36,7 +36,6 @@ publish data as ractangular plane
 
 #include &quot;ros/ros.h&quot;
 #include &quot;std_msgs/String.h&quot;
-#include &lt;visualization_msgs/Marker.h&gt;
 #include &lt;jsk_rviz_plugins/Pictogram&gt;
 #include &lt;cstdio&gt;
 #include &lt;cstdlib&gt;
@@ -57,7 +56,7 @@ publish data as ractangular plane
 #include &lt;tf/transform_datatypes.h&gt;
 
 #define MYNAME		&quot;pos_downloader&quot;
-#define MARKERNAME	&quot;mo_marker&quot;
+#define PICTOGRAMNAME &quot;mo_pictogram&quot;
 #define STARTTIME	(0)		// sec since 1970-01-01 (0==now)
 #define DELAYSEC	(0)		// delay sec for pos_uploader
 #define POSUP_DZ	(40)		// z offset of PosUp
@@ -69,8 +68,8 @@ publish data as ractangular plane
 #define TYPE_CAR	(2)
 #define TYPE_PEDESTRIAN	(3)
 
-#define ANON_MARKER_ID_MIN	(2)
-#define ANON_MARKER_ID_MAX	(0x7f000000)
+#define ANON_MARKER_ID_MIN     (2)
+#define ANON_MARKER_ID_MAX     (0x7f000000)
 
 using namespace std;
 
@@ -109,11 +108,6 @@ static double alpha_percent(int diffmsec)
   return (1.0 - diffmsec/TOTAL_LIFETIME/1000.0);
 }
 
-static int create_markerid(geometry_msgs::Pose&amp; pose, int type)
-{
-  return (int)(pose.position.x*11 + pose.position.y*13 + pose.position.z + type*5) % ANON_MARKER_ID_MAX;
-}
-
 static std::vector&lt;std::string&gt; split(const string&amp; input, char delimiter)
 {
     std::istringstream stream(input);
@@ -126,10 +120,10 @@ static std::vector&lt;std::string&gt; split(const string&amp; input, char delimiter)
     return result;
 }
 
-static void dbg_out_marker(jsk_rviz_plugins::Pictogram pictogram)
+static void dbg_out_pictogram(jsk_rviz_plugins::Pictogram pictogram)
 {
 #ifdef POS_DB_VERBOSE
-  std::cout &lt;&lt; marker.id &lt;&lt; &quot; : &quot;
+  std::cout
 	&lt;&lt; pictogram.pose.position.x &lt;&lt; &quot;,&quot;
 	&lt;&lt; pictogram.pose.position.y &lt;&lt; &quot;,&quot;
 	&lt;&lt; pictogram.pose.position.z &lt;&lt; &quot; : &quot;
@@ -146,23 +140,17 @@ static void publish_car(int id, int is_current, ros::Time now,
   jsk_rviz_plugins::Pictogram pictogram;
   pictogram.header.frame_id = &quot;/map&quot;;
   pictogram.header.stamp = now;
-  marker.ns = MARKERNAME;
   pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
   pictogram.pose = pose;
   if (is_current) {
 #ifdef CURRENT_CAR_DIRECTLY
-    marker.id = id;
-    marker.type = visualization_msgs::Marker::MESH_RESOURCE;
-    marker.mesh_resource = &quot;package://pos_db/model/prius_model.dae&quot;;
-    marker.mesh_use_embedded_materials = true;
-    marker.lifetime = ros::Duration();
-    marker.color.r = 0.0;
-    marker.color.g = 0.0;
-    marker.color.b = 0.0;
-    marker.color.a = 0.0;
-    marker.scale.x = 1.0;
-    marker.scale.y = 1.0;
-    marker.scale.z = 1.0;
+    pictogram.character = &quot;fa-car&quot;;
+    // marker.lifetime = ros::Duration();
+    pictogram.color.r = 0.0;
+    pictogram.color.g = 0.0;
+    pictogram.color.b = 0.0;
+    pictogram.color.a = 0.0;
+    pictogram.size = 1.0;
 
     tf::Quaternion q1;
     q1.setRPY(M_PI/2, 0, M_PI);
@@ -176,8 +164,8 @@ static void publish_car(int id, int is_current, ros::Time now,
     pictogram.pose.orientation.z = q3.z();
     pictogram.pose.orientation.w = q3.w();
 
-    pub.publish(marker);
-    dbg_out_marker(marker);
+    pub.publish(pictogram);
+    dbg_out_pictogram(pictogram);
 #else /* CURRENT_CAR_DIRECTLY */
     ros::Time newnow = now - ros::Duration(diffmsec/1000.0);
     if (now_map.count(id) == 0 || newnow &gt;= now_map[id]) {
@@ -187,19 +175,18 @@ static void publish_car(int id, int is_current, ros::Time now,
 #endif /* CURRENT_CAR_DIRECTLY */
 
   } else {
-    marker.id = create_markerid(pose, 1);
-    marker.type = visualization_msgs::Marker::SPHERE;
-    marker.lifetime = ros::Duration(life_time);
-    marker.color.r = 1.0;
-    marker.color.g = 0.0;
-    marker.color.b = 0.0;
-    marker.color.a = alpha_percent(diffmsec);
-    marker.scale.x = 2.0;
-    marker.scale.y = 2.0;
-    marker.scale.z = 2.0;
+    //marker.type = visualization_msgs::Marker::SPHERE;
+    // marker.lifetime = ros::Duration(life_time);
+    pictogram.character = &quot;circle&quot;
+    pictogram.ttl = life_time;
+    pictogram.color.r = 1.0;
+    pictogram.color.g = 0.0;
+    pictogram.color.b = 0.0;
+    pictogram.color.a = alpha_percent(diffmsec);
+    pictogram.size = 2;
     pictogram.pose.position.z += 0.5; // == #1/2
-    pub.publish(marker);
-    dbg_out_marker(marker);
+    pub.publish(pictogram);
+    dbg_out_pictogram(pictogram);
   }
 }
 
@@ -218,22 +205,15 @@ static void publish_car_summary(ros::Time now)
     }
     pictogram.header.frame_id = &quot;/map&quot;;
     pictogram.header.stamp = cur;
-    marker.ns = MARKERNAME;
     pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
-    marker.id = id;
     pictogram.pose = pose;
-    marker.type = visualization_msgs::Marker::MESH_RESOURCE;
-    marker.mesh_resource = &quot;package://pos_db/model/prius_model.dae&quot;;
-    marker.mesh_use_embedded_materials = true;
-    marker.lifetime = ros::Duration();
-    marker.color.r = 0.0;
-    marker.color.g = 0.0;
-    marker.color.b = 0.0;
-    marker.color.a = 0.0;
-    marker.scale.x = 1.0;
-    marker.scale.y = 1.0;
-    marker.scale.z = 1.0;
-
+    pictogram.character = &quot;fa-car&quot;;
+    // marker.lifetime = ros::Duration();
+    pictogram.color.r = 0.0;
+    pictogram.color.g = 0.0;
+    pictogram.color.b = 0.0;
+    pictogram.color.a = 0.0;
+    pictogram.size = 1;
     tf::Quaternion q1;
     q1.setRPY(M_PI/2, 0, M_PI);
     tf::Quaternion q2(pictogram.pose.orientation.x, pictogram.pose.orientation.y, pictogram.pose.orientation.z, pictogram.pose.orientation.w);
@@ -246,8 +226,8 @@ static void publish_car_summary(ros::Time now)
     pictogram.pose.orientation.z = q3.z();
     pictogram.pose.orientation.w = q3.w();
 
-    pub.publish(marker);
-    dbg_out_marker(marker);
+    pub.publish(pictogram);
+    dbg_out_pictogram(pictogram);
     prev_map[id] = cur;
   }
   car_map.clear();
@@ -261,43 +241,45 @@ static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
   jsk_rviz_plugins::Pictogram pictogram;
   pictogram.header.frame_id = &quot;/map&quot;;
   pictogram.header.stamp = now;
-  marker.ns = MARKERNAME;
   pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
-  marker.type = visualization_msgs::Marker::CYLINDER;
-  marker.lifetime = ros::Duration(life_time);
-  marker.id = create_markerid(pose, 2);
+  //marker.type = visualization_msgs::Marker::CYLINDER;
+  pictogram.character = &quot;dot-circle-o&quot;
+  // marker.lifetime = ros::Duration(life_time);
+  pictogram.ttl = life_time;
   if (is_pedestrian) {
-    marker.color.r = 0.0;
-    marker.color.g = 1.0;
-    marker.color.b = 1.0;
+    pictogram.color.r = 0.0;
+    pictogram.color.g = 1.0;
+    pictogram.color.b = 1.0;
     pose.position.z += pedestrian_dz;
   } else {
-    marker.color.r = 1.0;
-    marker.color.g = 1.0;
-    marker.color.b = 1.0;
+    pictogram.color.r = 1.0;
+    pictogram.color.g = 1.0;
+    pictogram.color.b = 1.0;
     pose.position.z += posup_dz;
   }
-  marker.color.a = alpha_percent(diffmsec);
-  marker.scale.x = 0.6;
-  marker.scale.y = 0.6;
-  marker.scale.z = 1.2; // #1
+  pictogram.color.a = alpha_percent(diffmsec);
+  // marker.scale.x = 0.6;
+  // marker.scale.y = 0.6;
+  // marker.scale.z = 1.2; // #1
+  pictogram.size = 1;
   pictogram.pose = pose;
   pictogram.pose.position.z += 0.6; // == #1/2
-  pub.publish(marker);
-  dbg_out_marker(marker);
-
-  marker.id = 1 + create_markerid(pose, 2);
-  marker.type = visualization_msgs::Marker::SPHERE;
-  marker.scale.x = 0.6; // #2
-  marker.scale.y = 0.6;
-  marker.scale.z = 0.6;
+  pub.publish(pictogram);
+  dbg_out_pictogram(pictogram);
+
+  //marker.type = visualization_msgs::Marker::SPHERE;
+  pictogram.character = &quot;circle&quot;
+  // marker.scale.x = 0.6; // #2
+  // marker.scale.y = 0.6;
+  // marker.scale.z = 0.6;
+  pictogram.size = 1;
   pictogram.pose = pose;
   pictogram.pose.position.z += 1.2 + 0.3 + 0.1; // == #1 + #2/2 + alpha
-  pub.publish(marker);
-  dbg_out_marker(marker);
+  pub.publish(pictogram);
+  dbg_out_pictogram(pictogram);
 }
 
-static int result_to_marker(const string&amp; idstr, ros::Time now,
+static int result_to_pictogram(const string&amp; idstr, ros::Time now,
 			    geometry_msgs::Pose&amp; pose, int type,
 			    int diffmsec, int is_swap)
 {
@@ -369,7 +351,7 @@ static int get_timeval(const char *tstr, time_t *sp, int *np)
   return 0;
 }
 
-static void marker_publisher(const std_msgs::String&amp; msg, int is_swap)
+static void pictogram_publisher(const std_msgs::String&amp; msg, int is_swap)
 {
   std::vector&lt;std::string&gt; db_data = split(msg.data, '\n');
   std::vector&lt;std::string&gt; cols;
@@ -435,7 +417,7 @@ static void marker_publisher(const std_msgs::String&amp; msg, int is_swap)
     now_sec = now.toSec();
     now_nsec = now.toNSec()%(1000*1000*1000);
     get_timeval(cols[10].c_str(), &amp;prv_sec, &amp;prv_nsec);
-    result_to_marker(cols[0], now, pose, type,
+    result_to_pictogram(cols[0], now, pose, type,
       (now_sec-prv_sec)*1000+(now_nsec-prv_nsec)/1000/1000, is_swap);
   }
 
@@ -487,7 +469,7 @@ static void send_sql(time_t diff_sec)
     std::cout &lt;&lt; &quot;return data: \&quot;&quot; &lt;&lt; db_response &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
 #endif /* POS_DB_VERBOSE */
     msg.data = db_response.c_str();
-    marker_publisher(msg, 1);
+    pictogram_publisher(msg, 1);
   }
 }
 
@@ -533,7 +515,7 @@ int main(int argc, char **argv)
 
   string home_dir = getenv(&quot;HOME&quot;);
 
-  pub = nh.advertise&lt;visualization_msgs::Marker&gt;(MARKERNAME, 1);
+  pub = nh.advertise&lt;jsk_rviz_plugins::Pictogram&gt;(PICTOGRAMNAME, 1);
   nh.param&lt;double&gt;(MYNAME &quot;/time&quot;, args[0], STARTTIME);
   cout &lt;&lt; &quot;time=&quot; &lt;&lt; args[0] &lt;&lt; endl;
   nh.param&lt;double&gt;(MYNAME &quot;/delay&quot;, args[1], DELAYSEC);
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
pos_downloader
This node get location data from db server and
publish data as ractangular plane
*/

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/String.h&quot;
#include &lt;visualization_msgs/Marker.h&gt;
#include &lt;jsk_rviz_plugins/Pictogram&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;
#ifndef CURRENT_CAR_DIRECTLY
#include &lt;map&gt;
#endif /* ! CURRENT_CAR_DIRECTLY */
#include &lt;pthread.h&gt;

#include &lt;geo_pos_conv.hh&gt;
#include &lt;pos_db.h&gt;

#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;

#define MYNAME		&quot;pos_downloader&quot;
#define MARKERNAME	&quot;mo_marker&quot;
#define STARTTIME	(0)		// sec since 1970-01-01 (0==now)
#define DELAYSEC	(0)		// delay sec for pos_uploader
#define POSUP_DZ	(40)		// z offset of PosUp
#define PEDESTRIAN_DZ	(-2)		// z offset of pedestrian_pose
#define DOWNLOAD_PERIOD	(250)		// period (msec)
#define TOTAL_LIFETIME	(10.0)		// total lifetime (sec)

#define TYPE_OWN	(1)
#define TYPE_CAR	(2)
#define TYPE_PEDESTRIAN	(3)

#define ANON_MARKER_ID_MIN	(2)
#define ANON_MARKER_ID_MAX	(0x7f000000)

using namespace std;

static string db_host_name;
static int db_port;
static string sshpubkey;
static string sshprivatekey;
static int ssh_port;
static string sshtunnelhost;
static int sleep_msec = DOWNLOAD_PERIOD;	// period
static double life_time = 1.0;			// sec
static double posup_dz;
static double pedestrian_dz;

static ros::Publisher pub;

static SendData sd;

static char mac_addr[MAC_ADDRBUFSIZ];
static int ignore_my_pose = 1;

#ifndef CURRENT_CAR_DIRECTLY
static map&lt;int, geometry_msgs::Pose&gt; car_map;
static map&lt;int, ros::Time&gt; now_map;
static map&lt;int, ros::Time&gt; prev_map;
#endif /* ! CURRENT_CAR_DIRECTLY */

#ifdef NEVER
static double color_percent(int diffmsec)
{
  return (1.0 - diffmsec/TOTAL_LIFETIME/1000.0)*((256-48)/256.0) + (48/256.0);
}
#endif /* NEVER */
static double alpha_percent(int diffmsec)
{
  return (1.0 - diffmsec/TOTAL_LIFETIME/1000.0);
}

static int create_markerid(geometry_msgs::Pose&amp; pose, int type)
{
  return (int)(pose.position.x*11 + pose.position.y*13 + pose.position.z + type*5) % ANON_MARKER_ID_MAX;
}

static std::vector&lt;std::string&gt; split(const string&amp; input, char delimiter)
{
    std::istringstream stream(input);

    std::string field;
    std::vector&lt;std::string&gt; result;
    while (std::getline(stream, field, delimiter)) {
        result.push_back(field);
    }
    return result;
}

static void dbg_out_marker(jsk_rviz_plugins::Pictogram pictogram)
{
#ifdef POS_DB_VERBOSE
  std::cout &lt;&lt; marker.id &lt;&lt; &quot; : &quot;
	&lt;&lt; pictogram.pose.position.x &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.position.y &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.position.z &lt;&lt; &quot; : &quot;
	&lt;&lt; pictogram.pose.orientation.x &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.orientation.y &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.orientation.z &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.orientation.w &lt;&lt; std::endl;
#endif /* POS_DB_VERBOSE */
}

static void publish_car(int id, int is_current, ros::Time now,
		       geometry_msgs::Pose&amp; pose, int diffmsec)
{
  jsk_rviz_plugins::Pictogram pictogram;
  pictogram.header.frame_id = &quot;/map&quot;;
  pictogram.header.stamp = now;
  marker.ns = MARKERNAME;
  pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
  pictogram.pose = pose;
  if (is_current) {
#ifdef CURRENT_CAR_DIRECTLY
    marker.id = id;
    marker.type = visualization_msgs::Marker::MESH_RESOURCE;
    marker.mesh_resource = &quot;package://pos_db/model/prius_model.dae&quot;;
    marker.mesh_use_embedded_materials = true;
    marker.lifetime = ros::Duration();
    marker.color.r = 0.0;
    marker.color.g = 0.0;
    marker.color.b = 0.0;
    marker.color.a = 0.0;
    marker.scale.x = 1.0;
    marker.scale.y = 1.0;
    marker.scale.z = 1.0;

    tf::Quaternion q1;
    q1.setRPY(M_PI/2, 0, M_PI);
    tf::Quaternion q2(pictogram.pose.orientation.x, pictogram.pose.orientation.y, pictogram.pose.orientation.z, pictogram.pose.orientation.w);
    tf::Quaternion q3;
    q3 = q2 * q1;

    pictogram.pose.position.z -= 2.0;
    pictogram.pose.orientation.x = q3.x();
    pictogram.pose.orientation.y = q3.y();
    pictogram.pose.orientation.z = q3.z();
    pictogram.pose.orientation.w = q3.w();

    pub.publish(marker);
    dbg_out_marker(marker);
#else /* CURRENT_CAR_DIRECTLY */
    ros::Time newnow = now - ros::Duration(diffmsec/1000.0);
    if (now_map.count(id) == 0 || newnow &gt;= now_map[id]) {
      car_map[id] = pose;
      now_map[id] = newnow;
    }
#endif /* CURRENT_CAR_DIRECTLY */

  } else {
    marker.id = create_markerid(pose, 1);
    marker.type = visualization_msgs::Marker::SPHERE;
    marker.lifetime = ros::Duration(life_time);
    marker.color.r = 1.0;
    marker.color.g = 0.0;
    marker.color.b = 0.0;
    marker.color.a = alpha_percent(diffmsec);
    marker.scale.x = 2.0;
    marker.scale.y = 2.0;
    marker.scale.z = 2.0;
    pictogram.pose.position.z += 0.5; // == #1/2
    pub.publish(marker);
    dbg_out_marker(marker);
  }
}

#ifndef CURRENT_CAR_DIRECTLY
static void publish_car_summary(ros::Time now)
{
  jsk_rviz_plugins::Pictogram pictogram;
  map&lt;int, geometry_msgs::Pose&gt;::iterator itr;

  for(itr = car_map.begin(); itr != car_map.end(); itr++) {
    int id = itr-&gt;first;
    geometry_msgs::Pose pose = itr-&gt;second;
    ros::Time cur = now_map[id];
    if (prev_map.count(id) &gt; 0 &amp;&amp; cur &lt;= prev_map[id]) {
      continue;
    }
    pictogram.header.frame_id = &quot;/map&quot;;
    pictogram.header.stamp = cur;
    marker.ns = MARKERNAME;
    pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
    marker.id = id;
    pictogram.pose = pose;
    marker.type = visualization_msgs::Marker::MESH_RESOURCE;
    marker.mesh_resource = &quot;package://pos_db/model/prius_model.dae&quot;;
    marker.mesh_use_embedded_materials = true;
    marker.lifetime = ros::Duration();
    marker.color.r = 0.0;
    marker.color.g = 0.0;
    marker.color.b = 0.0;
    marker.color.a = 0.0;
    marker.scale.x = 1.0;
    marker.scale.y = 1.0;
    marker.scale.z = 1.0;

    tf::Quaternion q1;
    q1.setRPY(M_PI/2, 0, M_PI);
    tf::Quaternion q2(pictogram.pose.orientation.x, pictogram.pose.orientation.y, pictogram.pose.orientation.z, pictogram.pose.orientation.w);
    tf::Quaternion q3;
    q3 = q2 * q1;

    pictogram.pose.position.z -= 2.0;
    pictogram.pose.orientation.x = q3.x();
    pictogram.pose.orientation.y = q3.y();
    pictogram.pose.orientation.z = q3.z();
    pictogram.pose.orientation.w = q3.w();

    pub.publish(marker);
    dbg_out_marker(marker);
    prev_map[id] = cur;
  }
  car_map.clear();
  now_map.clear();
}
#endif /* ! CURRENT_CAR_DIRECTLY */

static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
			      geometry_msgs::Pose&amp; pose, int diffmsec)
{
  jsk_rviz_plugins::Pictogram pictogram;
  pictogram.header.frame_id = &quot;/map&quot;;
  pictogram.header.stamp = now;
  marker.ns = MARKERNAME;
  pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
  marker.type = visualization_msgs::Marker::CYLINDER;
  marker.lifetime = ros::Duration(life_time);
  marker.id = create_markerid(pose, 2);
  if (is_pedestrian) {
    marker.color.r = 0.0;
    marker.color.g = 1.0;
    marker.color.b = 1.0;
    pose.position.z += pedestrian_dz;
  } else {
    marker.color.r = 1.0;
    marker.color.g = 1.0;
    marker.color.b = 1.0;
    pose.position.z += posup_dz;
  }
  marker.color.a = alpha_percent(diffmsec);
  marker.scale.x = 0.6;
  marker.scale.y = 0.6;
  marker.scale.z = 1.2; // #1
  pictogram.pose = pose;
  pictogram.pose.position.z += 0.6; // == #1/2
  pub.publish(marker);
  dbg_out_marker(marker);

  marker.id = 1 + create_markerid(pose, 2);
  marker.type = visualization_msgs::Marker::SPHERE;
  marker.scale.x = 0.6; // #2
  marker.scale.y = 0.6;
  marker.scale.z = 0.6;
  pictogram.pose = pose;
  pictogram.pose.position.z += 1.2 + 0.3 + 0.1; // == #1 + #2/2 + alpha
  pub.publish(marker);
  dbg_out_marker(marker);
}

static int result_to_marker(const string&amp; idstr, ros::Time now,
			    geometry_msgs::Pose&amp; pose, int type,
			    int diffmsec, int is_swap)
{
  int nid;

  switch (type) {
  case TYPE_OWN:
    /* use lower 6 bytes */
    nid = ANON_MARKER_ID_MAX |
      (std::strtol(idstr.substr(6, 6).c_str(), NULL, 16)) &lt;&lt; 1;
    publish_car(nid, 1, now, pose, diffmsec);
    break;
  case TYPE_CAR:
    publish_car(0, 0, now, pose, diffmsec);
    break;
  case TYPE_PEDESTRIAN:
    publish_pedestrian(0, 1, now, pose, diffmsec);
    break;

  /* backward compatibility */
  default:
    if (idstr.find(&quot;current_pose&quot;, 0) != string::npos) {
      /* current_pose:DEF012345678 */
      if (idstr.length() &gt;= 25) {
	/* use lower 6 bytes */
	nid = ANON_MARKER_ID_MAX |
	  (std::strtol((idstr.substr(19, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
        publish_car(nid, 1, now, pose, diffmsec);
      }
    } else if (idstr.find(&quot;ndt_pose&quot;, 0) != string::npos) {
      /* ndt_pose:9ABCDEF01234 */
      if (idstr.length() &gt;= 21) {
	/* use lower 6 bytes */
	nid = ANON_MARKER_ID_MAX |
	  (std::strtol((idstr.substr(15, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
        publish_car(nid, 1, now, pose, diffmsec);
      }
    } else if (idstr.find(&quot;car_pose&quot;, 0) != string::npos) {
      publish_car(0, 0, now, pose, diffmsec);
    } else if (idstr.find(&quot;pedestrian_pose&quot;, 0) != string::npos) {
      publish_pedestrian(0, 1, now, pose, diffmsec);
    } else {
      publish_pedestrian(0, 0, now, pose, diffmsec); // PosUp
    }
  }

  return 0;
}

static int get_timeval(const char *tstr, time_t *sp, int *np)
{
  struct tm tm;
  const char *p;

  if (sscanf(tstr, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;tm.tm_year, &amp;tm.tm_mon,
	&amp;tm.tm_mday, &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec) != 6) {
    std::cerr &lt;&lt; &quot;Cannot convert time \&quot;&quot; &lt;&lt; tstr &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
    return -1;
  }
  if ((p = strchr(tstr, '.')) != NULL) {
    sscanf(++p, &quot;%d&quot;, np);
    for (int i = strlen(p); i &lt; 9; i++, *np*=10);
  } else {
    *np = 0;
  }
  tm.tm_year -= 1900;
  tm.tm_mon -= 1;
  *sp = mktime(&amp;tm);
  return 0;
}

static void marker_publisher(const std_msgs::String&amp; msg, int is_swap)
{
  std::vector&lt;std::string&gt; db_data = split(msg.data, '\n');
  std::vector&lt;std::string&gt; cols;
  ros::Time now = ros::Time::now();
  geometry_msgs::Pose pose;
  int type;
  time_t now_sec, prv_sec = 0;
  int now_nsec, prv_nsec;

  for (const std::string&amp; row : db_data) {
    if(row.empty())
      continue;
    cols = split(row, '\t');
    // id,x,y,z,or_x,or_y,or_z,or_w,lon,lat,tm,type
    if(cols.size() != 12)
      continue;

    type = std::stoi(cols[11]);
    if(ignore_my_pose &amp;&amp;
       (type == TYPE_OWN ||
	cols[0].find(&quot;current_pose&quot;, 0) != string::npos ||
	cols[0].find(&quot;ndt_pose&quot;, 0) != string::npos) &amp;&amp;
       cols[0].find(mac_addr, 0) != string::npos) {
      continue;	// don't publish Marker of my pose
    }

    if (is_swap) {
      pose.position.x = std::stod(cols[2]);
      pose.position.y = std::stod(cols[1]);
      pose.orientation.x = std::stod(cols[5]);
      pose.orientation.y = std::stod(cols[4]);
    } else {
      pose.position.x = std::stod(cols[1]);
      pose.position.y = std::stod(cols[2]);
      pose.orientation.x = std::stod(cols[4]);
      pose.orientation.y = std::stod(cols[5]);
    }
    pose.position.z = std::stod(cols[3]);
    pose.orientation.z = std::stod(cols[6]);
    pose.orientation.w = std::stod(cols[7]);
    // VoltDB returns not NULL but -1.7976931348623157E308
    if (pose.position.x &lt; -1.79E308 ||
	pose.position.y &lt; -1.79E308 ||
	pose.position.z &lt; -1.79E308) {
      geo_pos_conv geo;
      double lon = std::stod(cols[8]);
      double lat = std::stod(cols[9]);
      geo.set_plane(7); // Aichi-ken
      geo.llh_to_xyz(lat, lon, 0/*h*/);
      if (is_swap) {
	pose.position.x = geo.y();
	pose.position.y = geo.x();
      } else {
	pose.position.x = geo.x();
	pose.position.y = geo.y();
      }
      pose.position.z = geo.z();
      pose.orientation.x = 0;
      pose.orientation.y = 0;
      pose.orientation.z = 0;
      pose.orientation.w = 1;
    }
    now_sec = now.toSec();
    now_nsec = now.toNSec()%(1000*1000*1000);
    get_timeval(cols[10].c_str(), &amp;prv_sec, &amp;prv_nsec);
    result_to_marker(cols[0], now, pose, type,
      (now_sec-prv_sec)*1000+(now_nsec-prv_nsec)/1000/1000, is_swap);
  }

#ifndef CURRENT_CAR_DIRECTLY
  publish_car_summary(now);
#endif /* ! CURRENT_CAR_DIRECTLY */
}

// create &quot;YYYY-mm-dd HH:MM:SS.sss&quot;
static int create_timestr(time_t sec, int nsec, char *str, size_t size)
{
  std::tm *nowtm;

  nowtm = std::gmtime(&amp;sec);
  return std::snprintf(str, size, &quot;%04d-%02d-%02d %02d:%02d:%02d.%03d&quot;,
	nowtm-&gt;tm_year + 1900, nowtm-&gt;tm_mon + 1, nowtm-&gt;tm_mday,
	nowtm-&gt;tm_hour, nowtm-&gt;tm_min, nowtm-&gt;tm_sec, nsec/1000/1000);
}

//wrap SendData class
static void send_sql(time_t diff_sec)
{
  std::string data;
  string db_response;
  std_msgs::String msg;
  ros::Time now = ros::Time::now();
  time_t now_sec = now.toSec() - diff_sec;
  int now_nsec = now.toNSec()%(1000*1000*1000);
  char timestr[64]; // &quot;YYYY-mm-dd HH:MM:SS.sss...&quot;
  char prevstr[64]; // &quot;YYYY-mm-dd HH:MM:SS.sss...&quot;

  create_timestr(now_sec-TOTAL_LIFETIME, now_nsec, prevstr, sizeof(prevstr));
  create_timestr(now_sec, now_nsec, timestr, sizeof(timestr));

  data = make_header(1, 1);
  // select pos data between previous latest timestamp and now
  data += &quot;SELECT id,x,y,z,or_x,or_y,or_z,or_w,lon,lat,tm,type FROM POS &quot;
	&quot;WHERE tm &gt; '&quot;;
  data += prevstr;
  data += &quot;' AND tm &lt; '&quot;;
  data += timestr;
  data += &quot;' ORDER BY tm;\r\n&quot;;

  int ret = sd.Sender(data, db_response, 0);
  if (ret &lt; 0) {
    std::cerr &lt;&lt; &quot;sd.Sender() failed&quot; &lt;&lt; std::endl;
  } else {
#ifdef POS_DB_VERBOSE
    std::cout &lt;&lt; &quot;return data: \&quot;&quot; &lt;&lt; db_response &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
#endif /* POS_DB_VERBOSE */
    msg.data = db_response.c_str();
    marker_publisher(msg, 1);
  }
}

static void* intervalCall(void *unused)
{
  double *args = (double *)unused;
  double diff_sec = args[1];

  if (args[0] != 0)
    diff_sec += ros::Time::now().toSec() - args[0];
#ifdef POS_DB_VERBOSE
  cout &lt;&lt; &quot;diff=&quot; &lt;&lt; diff_sec &lt;&lt; endl;
#endif /* POS_DB_VERBOSE */

  while (1) {
    send_sql((time_t)diff_sec);
    usleep(sleep_msec*1000);
  }

  return nullptr;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, MYNAME) ;
  ros::NodeHandle nh;
  pthread_t th;
  double args[2];

  cout &lt;&lt; MYNAME &lt;&lt; endl;

  if(argc &lt; 2) {
    std::cerr &lt;&lt; &quot;usage : \n\trosrun &quot; &lt;&lt; MYNAME &lt;&lt; &quot; &lt;user name&gt; [show_my_pose]&quot; &lt;&lt; std::endl;
    return -1;
  }
  if(argc &gt; 2) {
    if(strncmp(argv[2], &quot;show_my_pose&quot;, 12) == 0) ignore_my_pose = 0;
  }
  std::cerr &lt;&lt; &quot;ignore_my_pose=&quot; &lt;&lt; ignore_my_pose &lt;&lt; std::endl;

  probe_mac_addr(mac_addr);
  std::cerr &lt;&lt;  &quot;mac_addr=&quot; &lt;&lt; mac_addr &lt;&lt; std::endl;

  string home_dir = getenv(&quot;HOME&quot;);

  pub = nh.advertise&lt;visualization_msgs::Marker&gt;(MARKERNAME, 1);
  nh.param&lt;double&gt;(MYNAME &quot;/time&quot;, args[0], STARTTIME);
  cout &lt;&lt; &quot;time=&quot; &lt;&lt; args[0] &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/delay&quot;, args[1], DELAYSEC);
  cout &lt;&lt; &quot;delay=&quot; &lt;&lt; args[1] &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/posup_dz&quot;, posup_dz, POSUP_DZ);
  cout &lt;&lt; &quot;posup_dz=&quot; &lt;&lt; posup_dz &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/pedestrian_dz&quot;, pedestrian_dz, PEDESTRIAN_DZ);
  cout &lt;&lt; &quot;pedestrian_dz=&quot; &lt;&lt; pedestrian_dz &lt;&lt; endl;

  nh.param&lt;string&gt;(&quot;pos_db/db_host_name&quot;, db_host_name, DB_HOSTNAME);
  cout &lt;&lt; &quot;db_host_name=&quot; &lt;&lt; db_host_name &lt;&lt; endl;
  nh.param&lt;int&gt;(&quot;pos_db/db_port&quot;, db_port, DB_PORT);
  cout &lt;&lt; &quot;db_port=&quot; &lt;&lt; db_port &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshpubkey&quot;, sshpubkey, home_dir+SSHPUBKEY);
  cout &lt;&lt; &quot;sshpubkey=&quot; &lt;&lt; sshpubkey &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshprivatekey&quot;, sshprivatekey, home_dir+SSHPRIVATEKEY);
  cout &lt;&lt; &quot;sshprivatekey=&quot; &lt;&lt; sshprivatekey &lt;&lt; endl;
  nh.param&lt;int&gt;(&quot;pos_db/ssh_port&quot;, ssh_port, SSHPORT);
  cout &lt;&lt; &quot;ssh_port=&quot; &lt;&lt; ssh_port &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshtunnelhost&quot;, sshtunnelhost, SSHTUNNELHOST);
  cout &lt;&lt; &quot;sshtunnelhost=&quot; &lt;&lt; sshtunnelhost &lt;&lt; endl;

  sd = SendData(db_host_name, db_port, argv[1], sshpubkey, sshprivatekey, ssh_port, sshtunnelhost);

  if (pthread_create(&amp;th, nullptr, intervalCall, (void *)args) != 0) {
    std::perror(&quot;pthread_create&quot;);
    std::exit(1);
  }

  pthread_detach(th);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="b446f05c33d111b4d4f41245dc39ae132e9f8fe8" fix_time="34,11553">
		<msg>Fix a state changing bug</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp" new_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp">
				<diff>@@ -36,7 +36,7 @@ void StateContext::update(void)
 
 void StateContext::changed(uint8_t _kind)
 {
-	if(_kind &gt;  NULL_STATE){
+	if(_kind &gt;  UNKNOWN_STATE){
 		return;
 	}
 
@@ -77,7 +77,7 @@ uint8_t StateContext::getStateKind(BaseState *_state)
   if (_state)
     return _state-&gt;getStateKind();
   else
-    return NULL_STATE;
+    return UNKNOWN_STATE;
 }
 
 uint64_t StateContext::getStateTransMask(BaseState *_state)
@@ -156,6 +156,7 @@ std::string StateContext::getCurrentStateName(uint8_t _kind)
 		return (*HolderMap[_kind])-&gt;getStateName();
 	return std::string(&quot;&quot;);
 }
+
 std::string StateContext::getCurrentStateName(void)
 {
   return this-&gt;getCurrentStateName(MAIN_STATE);
@@ -172,12 +173,13 @@ BaseState *StateContext::getStateObject(uint64_t _state_num)
 }
 
 
+
 BaseState **StateContext::getCurrentStateHolderPtr(uint8_t _kind)
 {
-	if(_kind &gt;  NULL_STATE){
+	if(_kind &gt;  UNKNOWN_STATE){
 		return nullptr;
 	}
-  return HolderMap[_kind];
+	return HolderMap[_kind];
 }
 
 BaseState **StateContext::getCurrentStateHolderPtr(uint64_t _state_num)
@@ -195,22 +197,21 @@ BaseState **StateContext::getCurrentStateHolderPtr(BaseState *_state)
 
 bool StateContext::disableCurrentState(uint64_t _state_num)
 {
-  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-  if (state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num))
-  {
-    *state_ptr = nullptr;
-    return true;
-  }
-  else
-  {
-    return false;
-  }
+	if(isMainState(getStateObject(_state_num))){
+		return false;
+	}
+	if(isCurrentState(_state_num)){
+		(*getCurrentStateHolderPtr(_state_num)) = nullptr;
+		return true;
+	}else{
+		return false;
+	}
 }
 
 bool StateContext::isCurrentState(uint64_t _state_num)
 {
-  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
-  return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
+	  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
+	  return  (state_ptr) ?isState(*state_ptr, _state_num):false;
 }
 
 bool StateContext::isState(BaseState *base, uint64_t _state_num)
</diff>
				<old_file>#include &lt;sched.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

#include &lt;cassert&gt;
#include &lt;mutex&gt;

#include &lt;state_context.hpp&gt;

#include &lt;state.hpp&gt;
#include &lt;state_common.hpp&gt;

/**
 *
 * @file StateContext.cpp
 * @brief state context class
 * @author Yusuke Fujii
 * @date  2017/07/25
 *
 **/

namespace state_machine
{
void StateContext::update(void)
{
  for (auto &amp;p : HolderMap)
  {
    if (*p.second)
    {
      (*p.second)-&gt;update();
    }
  }
}

void StateContext::changed(uint8_t _kind)
{
	if(_kind &gt;  NULL_STATE){
		return;
	}

	if(*HolderMap[_kind])
		(*HolderMap[_kind])-&gt;changed();
}


void StateContext::showCurrentStateName(void)
{
  for (auto &amp;p : HolderMap)
  {
    if (*p.second)
    {
      (*p.second)-&gt;showStateName();
    }
  }
}

bool StateContext::isDifferentState(BaseState *_state_a, BaseState **_state_b)
{
	if(_state_b){
		return _state_a == *_state_b;
	}else{
		return false;
	}
}

bool StateContext::isEmptyMainState(void)
{
  if (current_state_.MainState)
    return false;
  return true;
}

uint8_t StateContext::getStateKind(BaseState *_state)
{
  if (_state)
    return _state-&gt;getStateKind();
  else
    return NULL_STATE;
}

uint64_t StateContext::getStateTransMask(BaseState *_state)
{
  if (_state)
    return _state-&gt;getStateTransMask();
  else
    return 0;
}

uint64_t StateContext::getStateNum(BaseState *_state)
{
  if (_state)
    return _state-&gt;getStateNum();
  else
    return 0;
}

bool StateContext::isMainState(BaseState *_state)
{
  return getStateKind(_state) == MAIN_STATE;
}

bool StateContext::setCurrentState(BaseState *_state)
{
  change_state_mutex.lock();
  bool ret = true;
  if(_state){
	  bool diff = isDifferentState(_state, getCurrentStateHolderPtr(_state));
	  if (isMainState(_state))
	  {
		  if (isEmptyMainState() || enableForceSetState ||
				  (getStateTransMask(_state) &amp; getStateNum(current_state_.MainState)))
		  {
			  current_state_.MainState = _state;
			  current_state_.AccState = nullptr;
			  current_state_.StrState = nullptr;
			  current_state_.BehaviorState = nullptr;
			  current_state_.PerceptionState = nullptr;
			  current_state_.OtherState = nullptr;
		  }
		  else
		  {
			  ret = false;
		  }
	  }
	  else
	  {
		  *HolderMap[getStateKind(_state)] = _state;
	  }
	  change_state_mutex.unlock();
	  if(ret)
		  this-&gt;changed(getStateKind(_state));
  }else{
	  ret = false;
  }
  return ret;

}

bool StateContext::setCurrentState(uint64_t flag)
{
  bool ret = this-&gt;setCurrentState(StateStores[flag]);
  return ret;
}

bool StateContext::setEnableForceSetState(bool force_flag)
{
  enableForceSetState = force_flag;
  return true;
}

std::string StateContext::getCurrentStateName(uint8_t _kind)
{
	if (*HolderMap[_kind])
		return (*HolderMap[_kind])-&gt;getStateName();
	return std::string(&quot;&quot;);
}
std::string StateContext::getCurrentStateName(void)
{
  return this-&gt;getCurrentStateName(MAIN_STATE);
}

BaseState *StateContext::getCurrentMainState(void)
{
  return current_state_.MainState;
}

BaseState *StateContext::getStateObject(uint64_t _state_num)
{
  return StateStores[_state_num];
}


BaseState **StateContext::getCurrentStateHolderPtr(uint8_t _kind)
{
	if(_kind &gt;  NULL_STATE){
		return nullptr;
	}
  return HolderMap[_kind];
}

BaseState **StateContext::getCurrentStateHolderPtr(uint64_t _state_num)
{
  return getCurrentStateHolderPtr(getStateKind(getStateObject(_state_num)));
}

BaseState **StateContext::getCurrentStateHolderPtr(BaseState *_state)
{
	if(_state)
		return getCurrentStateHolderPtr(getStateKind(_state));
	else
		return nullptr;
}

bool StateContext::disableCurrentState(uint64_t _state_num)
{
  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
  if (state_ptr &amp;&amp; this-&gt;isState((*state_ptr), _state_num))
  {
    *state_ptr = nullptr;
    return true;
  }
  else
  {
    return false;
  }
}

bool StateContext::isCurrentState(uint64_t _state_num)
{
  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
  return (*state_ptr) ? (*state_ptr)-&gt;getStateNum() &amp; _state_num ? true : false : false;
}

bool StateContext::isState(BaseState *base, uint64_t _state_num)
{
  return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
}

bool StateContext::inState(uint64_t _state_num)
{
  if (current_state_.MainState)
  {
    return ((current_state_.MainState-&gt;getStateNum() &amp; _state_num) != 0) ? true : false;
  }
  else
  {
    return false;
  }
}

bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
{
  /* deprecated */
  return false;
}

std::string StateContext::createStateMessageText(void)
{
  std::string ret;

  for (auto &amp;p : HolderMap)
  {
    if (*p.second)
    {
      ret = ret + &quot;\n&quot; + (*p.second)-&gt;getStateName();
    }
  }
  return ret;
}

bool StateContext::handleTwistCmd(bool _hasTwistCmd)
{
  if (_hasTwistCmd)
    return this-&gt;setCurrentState(DRIVE_STATE);
  else
    return false;
}

void StateContext::stateDecider(void)
{
  // not running
}

void StateContext::InitContext(void)
{
  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
  thr_state_dec-&gt;detach();
  this-&gt;setCurrentState(START_STATE);
  return;
}
bool StateContext::TFInitialized(void)
{
  return this-&gt;setCurrentState(INITIAL_STATE);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -35,43 +35,6 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
   ctx-&gt;setEnableForceSetState(true);
   _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
   ctx-&gt;setEnableForceSetState(false);
-
-#if 0
-  if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE) ||
-      ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
-  {
-    int count = 0;
-    for (auto &amp;lane : current_controlled_lane_array_.lanes)
-    {
-      autoware_msgs::lane temp_lane = lane;
-      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
-      {
-        double v0 = temp_lane.waypoints.at(wpi - 1).twist.twist.linear.x;
-        double v = temp_lane.waypoints.at(wpi).twist.twist.linear.x;
-
-        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
-                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
-                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
-        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
-                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
-                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
-
-        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
-        double _weight = distance * 0.05;
-        if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE))
-        {
-          _weight *= 1;
-        }
-        else if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
-        {
-          _weight *= -1;
-        }
-        lane.waypoints.at(wpi).twist.twist.linear.x =
-            lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
-      }
-    }
-  }
-#endif
   return _ret;
 }
 
@@ -96,6 +59,7 @@ void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
     ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
   else
   {
+	  fprintf(stderr,&quot;disable lanechange\n&quot;);
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
   }
@@ -136,10 +100,8 @@ void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_
   {
     ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
   }
-  // ctx-&gt;handleTrafficLight(CurrentTrafficlight);
 }
 
-//
 void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
 {
   if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
@@ -326,23 +288,6 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
   }
 
-#if 0
-	// velocity
-	double _temp_sum = 0;
-	for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
-	{
-		_temp_sum += amathutils::mps2kmph(msg.waypoints[i].twist.twist.linear.x);
-	}
-	average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;
-
-	if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
-		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
-	else if (average_velocity_ - current_velocity_)
-		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
-	else
-		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
-#endif
-
   // for publish plan of velocity
   publishToVelocityArray();
 
@@ -389,9 +334,4 @@ void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistSt
 {
   current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
 }
-#if 0
-void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
-	ROS_INFO(&quot;Reconfigure Request: %d &quot;, config.TARGET_WAYPOINT_COUNT);
-}
-#endif
 }
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
  ctx-&gt;setEnableForceSetState(false);

#if 0
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE) ||
      ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
  {
    int count = 0;
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      autoware_msgs::lane temp_lane = lane;
      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
      {
        double v0 = temp_lane.waypoints.at(wpi - 1).twist.twist.linear.x;
        double v = temp_lane.waypoints.at(wpi).twist.twist.linear.x;

        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
        double _weight = distance * 0.05;
        if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE))
        {
          _weight *= 1;
        }
        else if (ctx-&gt;isCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE))
        {
          _weight *= -1;
        }
        lane.waypoints.at(wpi).twist.twist.linear.x =
            lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
      }
    }
  }
#endif
  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request&quot;);
  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
  if (msg.enable_force_state_change)
  {
    if (msg.MainState_ChangeFlag)
      handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
    if (msg.SubState_Acc_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
    if (msg.SubState_Str_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
    if (msg.SubState_Behavior_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
    if (msg.SubState_Perception_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
  }
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);
  const autoware_msgs::traffic_light *light = event.getMessage().get();

  current_traffic_light = light-&gt;traffic_light;
  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
  {
    ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  // ctx-&gt;handleTrafficLight(CurrentTrafficlight);
}

//
void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
	  }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;lane : lane_array.lanes)
      {
        for (auto &amp;wp : lane.waypoints)
        {
          if (area.area_id == wp.wpstate.aid)
          {
            wp.wpstate.steering_state = steering_state;
          }
        }
      }
    }
  }

  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) { 
        return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);});
  
  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
          geometry_msgs::Point bp =
              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
          geometry_msgs::Point fp =
              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
	 
          if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
          {
	    geometry_msgs::Point center_point;
	    center_point.x = (bp.x*2 + fp.x)/3;
	    center_point.y = (bp.y*2 + fp.y)/3;
	    if(amathutils::isPointLeftFromLine( 
				          center_point.x,
					  center_point.y,
           			          lane.waypoints.at(wp_idx).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y)){
		    lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
		    //lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
	    }
	  }
      }
    }
  }

}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int gid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      int lid = 0;
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  // steering
  size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
  if(idx){
	  ctx-&gt;setCurrentState(
			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
	  if(current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
  }

#if 0
	// velocity
	double _temp_sum = 0;
	for (int i = 0; i &lt; VEL_AVERAGE_COUNT; i++)
	{
		_temp_sum += amathutils::mps2kmph(msg.waypoints[i].twist.twist.linear.x);
	}
	average_velocity_ = _temp_sum / VEL_AVERAGE_COUNT;

	if (std::fabs(average_velocity_ - current_velocity_) &lt;= 2.0)
		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
	else if (average_velocity_ - current_velocity_)
		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_ACCELERATION_STATE);
	else
		ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_DECELERATION_STATE);
#endif

  // for publish plan of velocity
  publishToVelocityArray();

#ifdef DEBUG_PRINT
  std::cout &lt;&lt; &quot;Velocity: &quot; &lt;&lt; current_velocity_ &lt;&lt; &quot; to &quot; &lt;&lt; average_velocity_ &lt;&lt; std::endl;
#endif
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
#if 0
void DecisionMakerNode::callbackFromDynamicReconfigure(decision_maker::decision_makerConfig &amp;config, uint32_t level){
	ROS_INFO(&quot;Reconfigure Request: %d &quot;, config.TARGET_WAYPOINT_COUNT);
}
#endif
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_core.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_core.cpp">
				<diff>@@ -56,7 +56,7 @@ void DecisionMakerNode::update(void)
 
 void DecisionMakerNode::run(void)
 {
-  ros::Rate loop_rate(6);
+  ros::Rate loop_rate(1);
 
   // for subscribe callback function
   ros::AsyncSpinner spinner(1);
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;
//#include &lt;vector_map/vector_map.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
bool DecisionMakerNode::isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg,
                                                     const geometry_msgs::PoseStamped &amp;pose_msg)
{
#ifdef USE_VMAP_SERVER  // this is not successfully run
  cross_road_srv.request.pose = pose_msg;
  cross_road_srv.request.waypoints.waypoints.clear();

  for (int i = 0; i &lt; 50; i++)
  {
    cross_road_srv.request.waypoints.waypoints.push_back(lane_msg.waypoints[i]);
  }
  for (const auto &amp;wayp : lane_msg.waypoints)
    cross_road_srv.request.waypoints.waypoints.push_back(wayp);

  cross_road_cli.call(cross_road_srv);

  for (const auto &amp;cross_road_d : cross_road_srv.response.objects.data)
  {
    // for DEBUG
    //   std::cout &lt;&lt; &quot;DEBUG&quot; &lt;&lt; cross_road_d.linkid &lt;&lt; std::endl;
  }
#endif
}

void DecisionMakerNode::update(void)
{
  update_msgs();
  if (ctx)
    ctx-&gt;update();
}

void DecisionMakerNode::run(void)
{
  ros::Rate loop_rate(6);

  // for subscribe callback function
  ros::AsyncSpinner spinner(1);
  spinner.start();
  while (ros::ok())
  {
    ros::Time begin = ros::Time::now();
    update();
    if (enableDisplayMarker)
      displayMarker();

#ifdef DEBUG_PRINT
    // debug status
    ros::Duration exec_time = ros::Time::now() - begin;
    std_msgs::Float64 exec_time_sec;
    exec_time_sec.data = exec_time.toSec();
    Pubs[&quot;exectime&quot;].publish(exec_time_sec);
#endif

    loop_rate.sleep();
  }
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_init.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_init.cpp">
				<diff>@@ -45,16 +45,6 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs[&quot;change_flag&quot;] = nh_.subscribe(&quot;change_flag&quot;, 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
   Subs[&quot;state_cmd&quot;] = nh_.subscribe(&quot;state_cmd&quot;, 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
 
-//  // vector map subscriber
-//  Subs[&quot;vector_map_area&quot;] =
-//      nh_.subscribe(&quot;/vector_map_info/area&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
-//  Subs[&quot;vector_map_point&quot;] =
-//      nh_.subscribe(&quot;/vector_map_info/point&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
-//  Subs[&quot;vector_map_line&quot;] =
-//      nh_.subscribe(&quot;/vector_map_info/line&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
-//  Subs[&quot;vector_map_crossroad&quot;] =
-//      nh_.subscribe(&quot;/vector_map_info/cross_road&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
-//
   // Config subscriber
   Subs[&quot;config/decision_maker&quot;] =
       nh_.subscribe(&quot;/config/decision_maker&quot;, 3, &amp;DecisionMakerNode::callbackFromConfig, this);
@@ -92,13 +82,6 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   // setup a callback for state update();
   setupStateCallback();
 
-  // to move initial state from start state
-  // this part confirm broadcasting tf(map to world)
- // std::cout &lt;&lt; &quot;wait for tf of map to world&quot; &lt;&lt; std::endl;
- // tf::TransformListener tf;
- // tf.waitForTransform(&quot;map&quot;, &quot;world&quot;, ros::Time(), ros::Duration(15));
- // if (!ctx-&gt;TFInitialized())
- //	  std::cerr &lt;&lt; &quot;failed initialization &quot; &lt;&lt; std::endl;
   g_vmap.subscribe(nh_, 
 		  Category::POINT |  Category::LINE |  Category::VECTOR | Category::AREA | Category::POLE | //basic class
 		  Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;mutex&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;
//#include &lt;vector_map/vector_map.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/state.h&gt;
#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{

void DecisionMakerNode::initROS(int argc, char **argv)
{
  // status subscriber
  Subs[&quot;sim_pose&quot;] = nh_.subscribe(&quot;sim_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromSimPose, this);
  Subs[&quot;current_pose&quot;] = nh_.subscribe(&quot;current_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
  Subs[&quot;current_velocity&quot;] =
      nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
  Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
  Subs[&quot;light_color_managed&quot;] =
      nh_.subscribe(&quot;light_color_managed&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
  Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
  Subs[&quot;final_waypoints&quot;] = nh_.subscribe(&quot;final_waypoints&quot;, 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
  Subs[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
  Subs[&quot;change_flag&quot;] = nh_.subscribe(&quot;change_flag&quot;, 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
  Subs[&quot;state_cmd&quot;] = nh_.subscribe(&quot;state_cmd&quot;, 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);

//  // vector map subscriber
//  Subs[&quot;vector_map_area&quot;] =
//      nh_.subscribe(&quot;/vector_map_info/area&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapArea, this);
//  Subs[&quot;vector_map_point&quot;] =
//      nh_.subscribe(&quot;/vector_map_info/point&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapPoint, this);
//  Subs[&quot;vector_map_line&quot;] =
//      nh_.subscribe(&quot;/vector_map_info/line&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapLine, this);
//  Subs[&quot;vector_map_crossroad&quot;] =
//      nh_.subscribe(&quot;/vector_map_info/cross_road&quot;, 1, &amp;DecisionMakerNode::callbackFromVectorMapCrossRoad, this);
//
  // Config subscriber
  Subs[&quot;config/decision_maker&quot;] =
      nh_.subscribe(&quot;/config/decision_maker&quot;, 3, &amp;DecisionMakerNode::callbackFromConfig, this);

  // pub
  Pubs[&quot;state&quot;] = nh_.advertise&lt;std_msgs::String&gt;(&quot;state&quot;, 1);
  Pubs[&quot;lane_waypoints_array&quot;] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
  Pubs[&quot;states&quot;] = nh_.advertise&lt;autoware_msgs::state&gt;(&quot;/decisionmaker/states&quot;, 1, true);

  Pubs[&quot;lamp_cmd&quot;] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;(&quot;/lamp_cmd&quot;, 1);

  // for visualize
  Pubs[&quot;state_overlay&quot;] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;(&quot;/state/overlay_text&quot;, 1);
  Pubs[&quot;crossroad_marker&quot;] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;/state/cross_road_marker&quot;, 1);
  Pubs[&quot;crossroad_inside_marker&quot;] = nh_.advertise&lt;visualization_msgs::Marker&gt;(&quot;/state/cross_inside_marker&quot;, 1);
  Pubs[&quot;crossroad_bbox&quot;] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;/state/crossroad_bbox&quot;, 10);

  // for debug
  Pubs[&quot;target_velocity_array&quot;] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;(&quot;/target_velocity_array&quot;, 1);
  Pubs[&quot;state_local_diffdistance&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/val_diff_distance&quot;, 1);
  Pubs[&quot;exectime&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/exectime&quot;, 1);
  // message setup
  state_text_msg.text_size = 18;
  state_text_msg.line_width = 0;
  state_text_msg.font = &quot;DejaVu Sans Mono&quot;;
  state_text_msg.width = 500;
  state_text_msg.height = 50;
  state_text_msg.top = 10;
  state_text_msg.left = 10;
  state_text_msg.text = &quot;UNDEFINED&quot;;

  // initial publishing state message
  update_msgs();

  // setup a callback for state update();
  setupStateCallback();

  // to move initial state from start state
  // this part confirm broadcasting tf(map to world)
 // std::cout &lt;&lt; &quot;wait for tf of map to world&quot; &lt;&lt; std::endl;
 // tf::TransformListener tf;
 // tf.waitForTransform(&quot;map&quot;, &quot;world&quot;, ros::Time(), ros::Duration(15));
 // if (!ctx-&gt;TFInitialized())
 //	  std::cerr &lt;&lt; &quot;failed initialization &quot; &lt;&lt; std::endl;
  g_vmap.subscribe(nh_, 
		  Category::POINT |  Category::LINE |  Category::VECTOR | Category::AREA | Category::POLE | //basic class
		  Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
  initVectorMap();

  {
    if (enableDisplayMarker)
      displayMarker();
  }

  ROS_INFO(&quot;Initialized OUT\n&quot;);
  Subs[&quot;lane_waypoints_array&quot;] =
	  nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
}

void DecisionMakerNode::initVectorMap(void)
{
      int _index = 0;
      //if(vector_map_init)
	//      return;
      std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad){return true;});
      if(crossroads.empty()){
	      ROS_INFO(&quot;crossroad have not found\n&quot;);
	      return;
      }

      vector_map_init = true; //loaded flag
      for(const auto &amp;cross_road : crossroads)
      {
	Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
	CrossRoadArea carea;
	carea.id = _index++;
	carea.area_id = area.aid;
	
	double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
	double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
	double z = 0.0;
	int points_count = 0;

	std::vector&lt;Line&gt; lines = g_vmap.findByFilter([&amp;area](const Line &amp;line){return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid;});
	for (const auto &amp;line : lines)
	{
		geometry_msgs::Point _prev_point;
		std::vector&lt;Point&gt; points = g_vmap.findByFilter([&amp;line](const Point &amp;point){return line.bpid == point.pid || point.pid == line.fpid;});
		for (const auto &amp;point : points)
		{
			geometry_msgs::Point _point;
			_point.x = point.ly;
			_point.y = point.bx;
			_point.z = point.h;

			if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
				continue;

			_prev_point = _point;
			points_count++;
			carea.points.push_back(_point);

			// calc a centroid point and about intersects size
			x_avg += _point.x;
			y_avg += _point.y;
			x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
			x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
			y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
			y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
			z = _point.z;

		}    // points iter
	}        // line iter
	carea.bbox.pose.position.x = x_avg / (double)points_count;
	carea.bbox.pose.position.y = y_avg / (double)points_count;
	carea.bbox.pose.position.z = z;
	carea.bbox.dimensions.x = x_max - x_min;
	carea.bbox.dimensions.y = y_max - y_min;
	carea.bbox.dimensions.z = 2;
	carea.bbox.label = 1;
	intersects.push_back(carea);
      }

}

bool DecisionMakerNode::initVectorMapClient()
{
#ifdef USE_VMAP_SERVER  // This is not successfully run due to failing vmap
	// server

	vector_map::VectorMap vmap;
	vmap.subscribe(nh_, vector_map::Category::AREA, ros::Duration(0));

	cross_road_srv.request.pose = current_pose_;
	cross_road_srv.request.waypoints = current_finalwaypoints_;

	cross_road_cli = nh_.serviceClient&lt;vector_map_server::GetCrossRoad&gt;(&quot;vector_map_server/get_cross_road&quot;);

	return cross_road_cli.call(cross_road_srv);
#endif
	return false;
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_publish.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_publish.cpp">
				<diff>@@ -108,8 +108,6 @@ void DecisionMakerNode::update_msgs(void)
       update_pubsub();
     }
 
-    state_string_msg.data = CurrentStateName;
-    state_text_msg.text = createStateMessageText();
 
     autoware_msgs::state state_msg;
     state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
@@ -117,6 +115,15 @@ void DecisionMakerNode::update_msgs(void)
     state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
     state_msg.behavior_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::BEHAVIOR_STATE);
     
+    state_string_msg.data = CurrentStateName;
+    //state_text_msg.text = createStateMessageText();
+    state_text_msg.text = state_msg.main_state + &quot;\n&quot;
+	    		 + state_msg.acc_state + &quot;\n&quot;
+	    		 + state_msg.str_state + &quot;\n&quot;
+	    		 + state_msg.behavior_state + &quot;\n&quot;;
+
+    
+
     Pubs[&quot;states&quot;].publish(state_msg);
     //Pubs[&quot;state&quot;].publish(state_string_msg);
     Pubs[&quot;state_overlay&quot;].publish(state_text_msg);
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/state.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
void DecisionMakerNode::update_pubsub(void)
{
  // if state machine require to re-subscribe topic,
  // this function will re-definition subscriber.
}

int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale)
{
  crossroad_marker.header.frame_id = &quot;/map&quot;;
  crossroad_marker.header.stamp = ros::Time();
  crossroad_marker.id = 1;
  crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
  crossroad_marker.action = visualization_msgs::Marker::ADD;
  crossroad_marker.ns = &quot;crossroad&quot;;

  crossroad_marker.scale.x = scale;
  crossroad_marker.scale.y = scale;
  crossroad_marker.scale.z = 0.5;
  crossroad_marker.color.a = 0.15;
  crossroad_marker.color.r = 1.0;
  crossroad_marker.color.g = 0.0;
  crossroad_marker.color.b = 0.0;
  crossroad_marker.frame_locked = true;
  crossroad_marker.lifetime = ros::Duration(0.3);
}

void DecisionMakerNode::displayMarker(void)
{
  // vector_map init
  // parse vectormap
  jsk_recognition_msgs::BoundingBoxArray bbox_array;

  static visualization_msgs::MarkerArray marker_array;
  static visualization_msgs::Marker crossroad_marker;
  static visualization_msgs::Marker inside_marker;

  double scale = 3.0;
  createCrossRoadAreaMarker(crossroad_marker, scale);

  inside_marker = crossroad_marker;
  inside_marker.scale.x = scale / 3;
  inside_marker.scale.y = scale / 3;
  inside_marker.scale.z = 0.5;
  inside_marker.color.a = 0.5;
  inside_marker.color.r = 1.0;
  inside_marker.color.g = 0.0;
  inside_marker.color.b = 0.0;
  inside_marker.ns = &quot;inside&quot;;
  inside_marker.lifetime = ros::Duration();

  bbox_array.header = crossroad_marker.header;

  inside_marker.points.clear();

  for (auto &amp;area : intersects)
  {
    area.bbox.header = crossroad_marker.header;
    bbox_array.boxes.push_back(area.bbox);
    for (const auto &amp;p : area.insideWaypoint_points)
    {
      inside_marker.points.push_back(p);
    }
  }

  Pubs[&quot;crossroad_bbox&quot;].publish(bbox_array);
  bbox_array.boxes.clear();
  Pubs[&quot;crossroad_inside_marker&quot;].publish(inside_marker);

  marker_array.markers.clear();
}

void DecisionMakerNode::update_msgs(void)
{
  if (ctx)
  {
    static std::string prevStateName;
    CurrentStateName = ctx-&gt;getCurrentStateName();

    if (prevStateName != CurrentStateName)
    {
      prevStateName = CurrentStateName;
      update_pubsub();
    }

    state_string_msg.data = CurrentStateName;
    state_text_msg.text = createStateMessageText();

    autoware_msgs::state state_msg;
    state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
    state_msg.acc_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::ACC_STATE);
    state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
    state_msg.behavior_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::BEHAVIOR_STATE);
    
    Pubs[&quot;states&quot;].publish(state_msg);
    //Pubs[&quot;state&quot;].publish(state_string_msg);
    Pubs[&quot;state_overlay&quot;].publish(state_text_msg);
  }
  else
    std::cerr &lt;&lt; &quot;ctx is not found &quot; &lt;&lt; std::endl;
}

std::string DecisionMakerNode::createStateMessageText()
{
  return ctx-&gt;createStateMessageText();
}

void DecisionMakerNode::publishToVelocityArray()
{
  int count = 0;
  std_msgs::Float64MultiArray msg;

  for (const auto &amp;i : current_finalwaypoints_.waypoints)
  {
    msg.data.push_back(amathutils::mps2kmph(i.twist.twist.linear.x));
    if (++count &gt;= 10)
      break;
  }
  Pubs[&quot;target_velocity_array&quot;].publish(msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="cca1b6a8f9bad3954cab4bd7eb3b5cc50b09569e" fix_time="17,48104">
		<msg>fix a judge left/right</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -170,19 +170,20 @@ void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
       else
         steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;
 
-      for (auto &amp;lane : lane_array.lanes)
+      for (auto &amp;wp_lane : laneinArea.waypoints)
       {
-        for (auto &amp;wp : lane.waypoints)
-        {
-          if (area.area_id == wp.wpstate.aid)
-          {
-            wp.wpstate.steering_state = steering_state;
-          }
-        }
+	      for (auto &amp;lane : lane_array.lanes)
+	      {
+		      for(auto &amp;wp : lane.waypoints){
+			      if(wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id){
+				      wp.wpstate.steering_state = steering_state;
+			      }
+		      }
+		      //lane.waypoints.at(wp_lane.lid).wpstate.steering_state = steering_state;
+	      }
       }
     }
   }
-
   // STOP
   std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) { 
         return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);});
@@ -229,12 +230,12 @@ void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray
   ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
   current_based_lane_array_ = msg;  // cached based path
   // indexing
+  int gid = 0;
   for (auto &amp;lane : current_based_lane_array_.lanes)
   {
-    int gid = 0;
+    int lid = 0;
     for (auto &amp;wp : lane.waypoints)
     {
-      int lid = 0;
       wp.gid = gid++;
       wp.lid = lid++;
       wp.wpstate.aid = 0;
@@ -282,8 +283,15 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
 	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
   if(idx){
-	  ctx-&gt;setCurrentState(
+	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE)){
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
+	  }
+	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE)){
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
+	  }else{ 
+		  ctx-&gt;setCurrentState(
 			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
+	  }
 	  if(current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
   }
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
  ctx-&gt;setEnableForceSetState(false);
  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request&quot;);
  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  else
  {
	  fprintf(stderr,&quot;disable lanechange\n&quot;);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
  if (msg.enable_force_state_change)
  {
    if (msg.MainState_ChangeFlag)
      handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
    if (msg.SubState_Acc_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
    if (msg.SubState_Str_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
    if (msg.SubState_Behavior_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
    if (msg.SubState_Perception_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
  }
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);
  const autoware_msgs::traffic_light *light = event.getMessage().get();

  current_traffic_light = light-&gt;traffic_light;
  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
  {
    ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
	  }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;lane : lane_array.lanes)
      {
        for (auto &amp;wp : lane.waypoints)
        {
          if (area.area_id == wp.wpstate.aid)
          {
            wp.wpstate.steering_state = steering_state;
          }
        }
      }
    }
  }

  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) { 
        return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);});
  
  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
          geometry_msgs::Point bp =
              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
          geometry_msgs::Point fp =
              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
	 
          if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
          {
	    geometry_msgs::Point center_point;
	    center_point.x = (bp.x*2 + fp.x)/3;
	    center_point.y = (bp.y*2 + fp.y)/3;
	    if(amathutils::isPointLeftFromLine( 
				          center_point.x,
					  center_point.y,
           			          lane.waypoints.at(wp_idx).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y)){
		    lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
		    //lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
	    }
	  }
      }
    }
  }

}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int gid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      int lid = 0;
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  // steering
  size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
  if(idx){
	  ctx-&gt;setCurrentState(
			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
	  if(current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
  }

  // for publish plan of velocity
  publishToVelocityArray();

#ifdef DEBUG_PRINT
  std::cout &lt;&lt; &quot;Velocity: &quot; &lt;&lt; current_velocity_ &lt;&lt; &quot; to &quot; &lt;&lt; average_velocity_ &lt;&lt; std::endl;
#endif
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_publish.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_publish.cpp">
				<diff>@@ -55,10 +55,10 @@ void DecisionMakerNode::displayMarker(void)
   // vector_map init
   // parse vectormap
   jsk_recognition_msgs::BoundingBoxArray bbox_array;
-
-  static visualization_msgs::MarkerArray marker_array;
-  static visualization_msgs::Marker crossroad_marker;
-  static visualization_msgs::Marker inside_marker;
+  visualization_msgs::MarkerArray marker_array;
+  visualization_msgs::Marker crossroad_marker;
+  visualization_msgs::Marker inside_marker;
+  visualization_msgs::Marker inside_line_marker;
 
   double scale = 3.0;
   createCrossRoadAreaMarker(crossroad_marker, scale);
@@ -75,8 +75,10 @@ void DecisionMakerNode::displayMarker(void)
   inside_marker.lifetime = ros::Duration();
 
   bbox_array.header = crossroad_marker.header;
-
   inside_marker.points.clear();
+  
+  inside_line_marker = inside_marker;
+  inside_line_marker.type = visualization_msgs::Marker::LINE_STRIP;
 
   for (auto &amp;area : intersects)
   {
@@ -86,13 +88,26 @@ void DecisionMakerNode::displayMarker(void)
     {
       inside_marker.points.push_back(p);
     }
-  }
 
+    for (const auto &amp;lane : area.insideLanes)
+    {
+	    inside_line_marker.points.clear();
+	    inside_line_marker.id +=1;
+	    int id = inside_line_marker.id;
+	    inside_line_marker.color.r = std::fmod(0.12345 * (id), 1.0);
+	    inside_line_marker.color.g = std::fmod(0.32345 * (5 - (id%5)), 1.0);
+	    inside_line_marker.color.b = std::fmod(0.52345 * (10- (id % 10)), 1.0);
+	    for(const auto &amp;wp : lane.waypoints){
+		    inside_line_marker.points.push_back(wp.pose.pose.position);
+	    } 
+	    marker_array.markers.push_back(inside_line_marker);
+    }
+  }
   Pubs[&quot;crossroad_bbox&quot;].publish(bbox_array);
+  Pubs[&quot;crossroad_marker&quot;].publish(marker_array);
   bbox_array.boxes.clear();
-  Pubs[&quot;crossroad_inside_marker&quot;].publish(inside_marker);
-
-  marker_array.markers.clear();
+  //Pubs[&quot;crossroad_inside_marker&quot;].publish(inside_marker);
+  Pubs[&quot;crossroad_inside_marker&quot;].publish(inside_line_marker);
 }
 
 void DecisionMakerNode::update_msgs(void)
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/state.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
void DecisionMakerNode::update_pubsub(void)
{
  // if state machine require to re-subscribe topic,
  // this function will re-definition subscriber.
}

int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale)
{
  crossroad_marker.header.frame_id = &quot;/map&quot;;
  crossroad_marker.header.stamp = ros::Time();
  crossroad_marker.id = 1;
  crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
  crossroad_marker.action = visualization_msgs::Marker::ADD;
  crossroad_marker.ns = &quot;crossroad&quot;;

  crossroad_marker.scale.x = scale;
  crossroad_marker.scale.y = scale;
  crossroad_marker.scale.z = 0.5;
  crossroad_marker.color.a = 0.15;
  crossroad_marker.color.r = 1.0;
  crossroad_marker.color.g = 0.0;
  crossroad_marker.color.b = 0.0;
  crossroad_marker.frame_locked = true;
  crossroad_marker.lifetime = ros::Duration(0.3);
}

void DecisionMakerNode::displayMarker(void)
{
  // vector_map init
  // parse vectormap
  jsk_recognition_msgs::BoundingBoxArray bbox_array;

  static visualization_msgs::MarkerArray marker_array;
  static visualization_msgs::Marker crossroad_marker;
  static visualization_msgs::Marker inside_marker;

  double scale = 3.0;
  createCrossRoadAreaMarker(crossroad_marker, scale);

  inside_marker = crossroad_marker;
  inside_marker.scale.x = scale / 3;
  inside_marker.scale.y = scale / 3;
  inside_marker.scale.z = 0.5;
  inside_marker.color.a = 0.5;
  inside_marker.color.r = 1.0;
  inside_marker.color.g = 0.0;
  inside_marker.color.b = 0.0;
  inside_marker.ns = &quot;inside&quot;;
  inside_marker.lifetime = ros::Duration();

  bbox_array.header = crossroad_marker.header;

  inside_marker.points.clear();

  for (auto &amp;area : intersects)
  {
    area.bbox.header = crossroad_marker.header;
    bbox_array.boxes.push_back(area.bbox);
    for (const auto &amp;p : area.insideWaypoint_points)
    {
      inside_marker.points.push_back(p);
    }
  }

  Pubs[&quot;crossroad_bbox&quot;].publish(bbox_array);
  bbox_array.boxes.clear();
  Pubs[&quot;crossroad_inside_marker&quot;].publish(inside_marker);

  marker_array.markers.clear();
}

void DecisionMakerNode::update_msgs(void)
{
  if (ctx)
  {
    static std::string prevStateName;
    CurrentStateName = ctx-&gt;getCurrentStateName();

    if (prevStateName != CurrentStateName)
    {
      prevStateName = CurrentStateName;
      update_pubsub();
    }


    autoware_msgs::state state_msg;
    state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
    state_msg.acc_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::ACC_STATE);
    state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
    state_msg.behavior_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::BEHAVIOR_STATE);
    
    state_string_msg.data = CurrentStateName;
    //state_text_msg.text = createStateMessageText();
    state_text_msg.text = state_msg.main_state + &quot;\n&quot;
	    		 + state_msg.acc_state + &quot;\n&quot;
	    		 + state_msg.str_state + &quot;\n&quot;
	    		 + state_msg.behavior_state + &quot;\n&quot;;

    

    Pubs[&quot;states&quot;].publish(state_msg);
    //Pubs[&quot;state&quot;].publish(state_string_msg);
    Pubs[&quot;state_overlay&quot;].publish(state_text_msg);
  }
  else
    std::cerr &lt;&lt; &quot;ctx is not found &quot; &lt;&lt; std::endl;
}

std::string DecisionMakerNode::createStateMessageText()
{
  return ctx-&gt;createStateMessageText();
}

void DecisionMakerNode::publishToVelocityArray()
{
  int count = 0;
  std_msgs::Float64MultiArray msg;

  for (const auto &amp;i : current_finalwaypoints_.waypoints)
  {
    msg.data.push_back(amathutils::mps2kmph(i.twist.twist.linear.x));
    if (++count &gt;= 10)
      break;
  }
  Pubs[&quot;target_velocity_array&quot;].publish(msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="be16dc58cd6ef7fdbe2601bd009598b26905cbae" fix_time="288,79849">
		<msg>fix a segv bug when currentpose was changed a lot</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/mission/packages/lane_planner/nodes/lane_select/lane_select_core.cpp" new_path="ros/src/computing/planning/mission/packages/lane_planner/nodes/lane_select/lane_select_core.cpp">
				<diff>@@ -170,16 +170,23 @@ void LaneSelectNode::processing()
 
   if (current_state_ == &quot;LANE_CHANGE&quot;)
   {
-    changeLane();
-    std::get&lt;1&gt;(lane_for_change_) =
-        getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
-                                 std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
-    std::get&lt;2&gt;(lane_for_change_) =
-        static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
-    ROS_INFO(&quot;closest: %d&quot;, std::get&lt;1&gt;(lane_for_change_));
-    publishLane(std::get&lt;0&gt;(lane_for_change_));
-    publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
-    publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
+    try
+    {
+	    changeLane();
+	    std::get&lt;1&gt;(lane_for_change_) =
+		    getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
+				    std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
+	    std::get&lt;2&gt;(lane_for_change_) =
+		    static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
+	    ROS_INFO(&quot;closest: %d&quot;, std::get&lt;1&gt;(lane_for_change_));
+	    publishLane(std::get&lt;0&gt;(lane_for_change_));
+	    publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
+	    publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
+    }
+    catch (std::out_of_range)
+    {
+      ROS_WARN(&quot;Failed to get closest waypoint num\n&quot;);
+    }
   }
   else
   {
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University

 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;lane_select_core.h&quot;

namespace lane_planner
{
// Constructor
LaneSelectNode::LaneSelectNode()
  : private_nh_(&quot;~&quot;)
  , current_lane_idx_(-1)
  , right_lane_idx_(-1)
  , left_lane_idx_(-1)
  , is_lane_array_subscribed_(false)
  , is_current_pose_subscribed_(false)
  , is_current_velocity_subscribed_(false)
  , is_current_state_subscribed_(false)
  , is_config_subscribed_(false)
  , distance_threshold_(3.0)
  , lane_change_interval_(10.0)
  , lane_change_target_ratio_(2.0)
  , lane_change_target_minimum_(5.0)
  , vlength_hermite_curve_(10)
  , current_state_(&quot;UNKNOWN&quot;)
{
  initForROS();
}

// Destructor
LaneSelectNode::~LaneSelectNode()
{
}

void LaneSelectNode::initForROS()
{
  // setup subscriber
  sub1_ = nh_.subscribe(&quot;traffic_waypoints_array&quot;, 1, &amp;LaneSelectNode::callbackFromLaneArray, this);
  sub2_ = nh_.subscribe(&quot;current_pose&quot;, 1, &amp;LaneSelectNode::callbackFromPoseStamped, this);
  sub3_ = nh_.subscribe(&quot;current_velocity&quot;, 1, &amp;LaneSelectNode::callbackFromTwistStamped, this);
  sub4_ = nh_.subscribe(&quot;state&quot;, 1, &amp;LaneSelectNode::callbackFromState, this);
  sub5_ = nh_.subscribe(&quot;/config/lane_select&quot;, 1, &amp;LaneSelectNode::callbackFromConfig, this);
  sub6_ = nh_.subscribe(&quot;/decisionmaker/states&quot;, 1, &amp;LaneSelectNode::callbackFromStates, this);

  
  bool enablePlannerDynamicSwitch;
  private_nh_.param&lt;bool&gt;(&quot;enablePlannerDynamicSwitch&quot;, enablePlannerDynamicSwitch, false);
  // setup publisher
  
  pub1_ = nh_.advertise&lt;autoware_msgs::lane&gt;(&quot;base_waypoints&quot;, 1);
  
  if(enablePlannerDynamicSwitch){
	  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;/astar/closest_waypoint&quot;, 1);
  }else{
	  pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;closest_waypoint&quot;, 1);
  }
  
  pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;change_flag&quot;, 1);
  vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;lane_select_marker&quot;, 1);

  // get from rosparam
  private_nh_.param&lt;double&gt;(&quot;lane_change_interval&quot;, lane_change_interval_, double(2));
  private_nh_.param&lt;double&gt;(&quot;distance_threshold&quot;, distance_threshold_, double(3.0));
}

bool LaneSelectNode::isAllTopicsSubscribed()
{
  if (!is_current_pose_subscribed_ || !is_lane_array_subscribed_ || !is_current_velocity_subscribed_)
  {
    ROS_WARN(&quot;Necessary topics are not subscribed yet. Waiting...&quot;);
    return false;
  }
  return true;
}

void LaneSelectNode::initForLaneSelect()
{
  if(!isAllTopicsSubscribed())
    return;

  // search closest waypoint number for each lanes
  if (!getClosestWaypointNumberForEachLanes())
  {
    publishClosestWaypoint(-1);
    resetLaneIdx();
    return;
  }

  findCurrentLane();
  findNeighborLanes();
  updateChangeFlag();
  createLaneForChange();

  publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)));
  publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
  publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
  publishVisualizer();

  resetSubscriptionFlag();
  return;
}

void LaneSelectNode::resetLaneIdx()
{
  current_lane_idx_ = -1;
  right_lane_idx_ = -1;
  left_lane_idx_ = -1;
  publishVisualizer();
}

void LaneSelectNode::resetSubscriptionFlag()
{
  is_current_pose_subscribed_ = false;
  is_current_velocity_subscribed_ = false;
  is_current_state_subscribed_ = false;
}

void LaneSelectNode::processing()
{
  if(!isAllTopicsSubscribed())
    return;

  // search closest waypoint number for each lanes
  if (!getClosestWaypointNumberForEachLanes())
  {
    publishClosestWaypoint(-1);
    resetLaneIdx();
    return;
  }

  // if closest waypoint on current lane is -1,
  if (std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) == -1)
  {
    publishClosestWaypoint(-1);
    resetLaneIdx();
    return;
  }

  findNeighborLanes();
  ROS_INFO(&quot;current_lane_idx: %d&quot;, current_lane_idx_);
  ROS_INFO(&quot;right_lane_idx: %d&quot;, right_lane_idx_);
  ROS_INFO(&quot;left_lane_idx: %d&quot;, left_lane_idx_);

  if (current_state_ == &quot;LANE_CHANGE&quot;)
  {
    changeLane();
    std::get&lt;1&gt;(lane_for_change_) =
        getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
                                 std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
    std::get&lt;2&gt;(lane_for_change_) =
        static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
    ROS_INFO(&quot;closest: %d&quot;, std::get&lt;1&gt;(lane_for_change_));
    publishLane(std::get&lt;0&gt;(lane_for_change_));
    publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
    publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
  }
  else
  {
    updateChangeFlag();
    createLaneForChange();

    publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)));
    publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
    publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
  }
  publishVisualizer();
  resetSubscriptionFlag();
}

int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps, int32_t cl_wp)
{

  for (uint32_t i = cl_wp; i &lt; wps.size(); i++)
  {
    if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::right ||
      static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
    {
      return i;
    }
  }
  return -1;
}

void LaneSelectNode::createLaneForChange()
{
  std::get&lt;0&gt;(lane_for_change_).waypoints.clear();
  std::get&lt;0&gt;(lane_for_change_).waypoints.shrink_to_fit();
  std::get&lt;1&gt;(lane_for_change_) = -1;

  const autoware_msgs::lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
  const int32_t &amp;clst_wp = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));

  int32_t num_lane_change = getClosestLaneChangeWaypointNumber(cur_lane.waypoints, clst_wp);
  ROS_INFO(&quot;num_lane_change: %d&quot;, num_lane_change);
  if (num_lane_change &lt; 0 || num_lane_change &gt;= static_cast&lt;int32_t&gt;(cur_lane.waypoints.size()))
  {
    ROS_WARN(&quot;current lane doesn't have change flag&quot;);
    return;
  }

  if ((static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right &amp;&amp;
       right_lane_idx_ &lt; 0) ||
      (static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::left &amp;&amp;
       left_lane_idx_ &lt; 0))
  {
    ROS_WARN(&quot;current lane doesn't have the lane for lane change&quot;);
    return;
  }

  double dt = getTwoDimensionalDistance(cur_lane.waypoints.at(num_lane_change).pose.pose.position,
                                        cur_lane.waypoints.at(clst_wp).pose.pose.position);
  double dt_by_vel = current_velocity_.twist.linear.x * lane_change_target_ratio_ &gt; lane_change_target_minimum_
                         ? current_velocity_.twist.linear.x * lane_change_target_ratio_
                         : lane_change_target_minimum_;
  ROS_INFO(&quot;dt : %lf, dt_by_vel : %lf&quot;, dt, dt_by_vel);
  autoware_msgs::lane &amp;nghbr_lane =
      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
          ? std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_))
          : std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
  const int32_t &amp;nghbr_clst_wp =
      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right
          ? std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_))
          : std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_));

  int32_t target_num = -1;
  for (uint32_t i = nghbr_clst_wp; i &lt; nghbr_lane.waypoints.size(); i++)
  {
    if (i == nghbr_lane.waypoints.size() - 1 ||
        dt + dt_by_vel &lt; getTwoDimensionalDistance(nghbr_lane.waypoints.at(nghbr_clst_wp).pose.pose.position,
                                                   nghbr_lane.waypoints.at(i).pose.pose.position))
    {
      target_num = i;
      break;
    }
  }

  ROS_INFO(&quot;target_num : %d&quot;, target_num);
  if (target_num &lt; 0)
    return;

  std::get&lt;0&gt;(lane_for_change_).header.stamp = nghbr_lane.header.stamp;
  std::vector&lt;autoware_msgs::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
      cur_lane.waypoints.at(num_lane_change).pose.pose, nghbr_lane.waypoints.at(target_num).pose.pose,
      cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, vlength_hermite_curve_);

  for (auto &amp;&amp;el : hermite_wps)
    el.change_flag = cur_lane.waypoints.at(num_lane_change).change_flag;

  std::get&lt;0&gt;(lane_for_change_).waypoints.reserve(nghbr_lane.waypoints.size() + hermite_wps.size());
  std::move(hermite_wps.begin(), hermite_wps.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
  auto itr = nghbr_lane.waypoints.begin();
  std::advance(itr, target_num);
  for (auto i = itr; i != nghbr_lane.waypoints.end(); i++)
  {
    if (getTwoDimensionalDistance(itr-&gt;pose.pose.position, i-&gt;pose.pose.position) &lt; lane_change_interval_)
      i-&gt;change_flag = enumToInteger(ChangeFlag::straight);
    else
      break;
  }
  std::copy(itr, nghbr_lane.waypoints.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
}

void LaneSelectNode::updateChangeFlag()
{
  for (auto &amp;el : tuple_vec_)
  {
    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1)
                          ? static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag)
                          : ChangeFlag::unknown;

    if(std::get&lt;2&gt;(el) == ChangeFlag::right &amp;&amp; right_lane_idx_ == -1)
      std::get&lt;2&gt;(el) = ChangeFlag::unknown;
    else if(std::get&lt;2&gt;(el) == ChangeFlag::left &amp;&amp; left_lane_idx_ == -1)
      std::get&lt;2&gt;(el) = ChangeFlag::unknown;

    ROS_INFO(&quot;change_flag: %d&quot;, enumToInteger(std::get&lt;2&gt;(el)));
  }
}

void LaneSelectNode::changeLane()
{
  if (std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)) == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1 &amp;&amp;
      std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) != -1)
  {
    current_lane_idx_ = right_lane_idx_;
  }
  else if (std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)) == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1 &amp;&amp;
           std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) != -1)
  {
    current_lane_idx_ = left_lane_idx_;
  }

  findNeighborLanes();
  return;
}

bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
{
  for (auto &amp;el : tuple_vec_)
  {
    std::get&lt;1&gt;(el) = getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist,
                                               std::get&lt;1&gt;(el), distance_threshold_);
    ROS_INFO(&quot;closest: %d&quot;, std::get&lt;1&gt;(el));
  }

  // confirm if all closest waypoint numbers are -1. If so, output warning
  int32_t accum = 0;
  for (const auto &amp;el : tuple_vec_)
  {
    accum += std::get&lt;1&gt;(el);
  }
  if (accum == (-1) * static_cast&lt;int32_t&gt;(tuple_vec_.size()))
  {
    ROS_WARN(&quot;Cannot get closest waypoints. All closest waypoints are changed to -1...&quot;);
    return false;
  }

  return true;
}

void LaneSelectNode::findCurrentLane()
{
  std::vector&lt;uint32_t&gt; idx_vec;
  idx_vec.reserve(tuple_vec_.size());
  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
  {
    if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
      continue;
    idx_vec.push_back(i);
  }
  current_lane_idx_ = findMostClosestLane(idx_vec, current_pose_.pose.position);
}

int32_t LaneSelectNode::findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p)
{
  std::vector&lt;double&gt; dist_vec;
  dist_vec.reserve(idx_vec.size());
  for (const auto &amp;el : idx_vec)
  {
    int32_t closest_number = std::get&lt;1&gt;(tuple_vec_.at(el));
    dist_vec.push_back(
        getTwoDimensionalDistance(p, std::get&lt;0&gt;(tuple_vec_.at(el)).waypoints.at(closest_number).pose.pose.position));
  }
  std::vector&lt;double&gt;::iterator itr = std::min_element(dist_vec.begin(), dist_vec.end());
  return idx_vec.at(std::distance(dist_vec.begin(), itr));
}

void LaneSelectNode::findNeighborLanes()
{
  int32_t current_closest_num = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
  const geometry_msgs::Pose &amp;current_closest_pose =
      std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.at(current_closest_num).pose.pose;

  std::vector&lt;uint32_t&gt; left_lane_idx_vec;
  left_lane_idx_vec.reserve(tuple_vec_.size());
  std::vector&lt;uint32_t&gt; right_lane_idx_vec;
  right_lane_idx_vec.reserve(tuple_vec_.size());
  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
  {
    if (i == static_cast&lt;uint32_t&gt;(current_lane_idx_) || std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
      continue;

    int32_t target_num = std::get&lt;1&gt;(tuple_vec_.at(i));
    const geometry_msgs::Point &amp;target_p = std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(target_num).pose.pose.position;

    geometry_msgs::Point converted_p = convertPointIntoRelativeCoordinate(target_p, current_closest_pose);

    ROS_INFO(&quot;distance: %lf&quot;, converted_p.y);
    if (fabs(converted_p.y) &gt; distance_threshold_)
    {
      ROS_INFO(&quot;%d lane is far from current lane...&quot;, i);
      continue;
    }

    if (converted_p.y &gt; 0)
      left_lane_idx_vec.push_back(i);
    else
      right_lane_idx_vec.push_back(i);
  }

  if (!left_lane_idx_vec.empty())
    left_lane_idx_ = findMostClosestLane(left_lane_idx_vec, current_closest_pose.position);
  else
    left_lane_idx_ = -1;

  if (!right_lane_idx_vec.empty())
    right_lane_idx_ = findMostClosestLane(right_lane_idx_vec, current_closest_pose.position);
  else
    right_lane_idx_ = -1;
}
visualization_msgs::Marker LaneSelectNode::createCurrentLaneMarker()
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;current_lane_marker&quot;;

  if (current_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
  {
    marker.action = visualization_msgs::Marker::DELETE;
    return marker;
  }

  marker.type = visualization_msgs::Marker::LINE_STRIP;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.05;

  std_msgs::ColorRGBA color_current;
  color_current.b = 1.0;
  color_current.g = 0.7;
  color_current.a = 1.0;
  marker.color = color_current;

  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints)
    marker.points.push_back(em.pose.pose.position);

  return marker;
}

visualization_msgs::Marker LaneSelectNode::createRightLaneMarker()
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;right_lane_marker&quot;;

  if (right_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
  {
    marker.action = visualization_msgs::Marker::DELETE;
    return marker;
  }

  marker.type = visualization_msgs::Marker::LINE_STRIP;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.05;

  std_msgs::ColorRGBA color_neighbor;
  color_neighbor.r = 0.5;
  color_neighbor.b = 0.5;
  color_neighbor.g = 0.5;
  color_neighbor.a = 1.0;

  std_msgs::ColorRGBA color_neighbor_change;
  color_neighbor_change.b = 0.7;
  color_neighbor_change.g = 1.0;
  color_neighbor_change.a = 1.0;

  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
  marker.color = change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;

  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)).waypoints)
    marker.points.push_back(em.pose.pose.position);

  return marker;
}

visualization_msgs::Marker LaneSelectNode::createLeftLaneMarker()
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;left_lane_marker&quot;;

  if (left_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
  {
    marker.action = visualization_msgs::Marker::DELETE;
    return marker;
  }

  marker.type = visualization_msgs::Marker::LINE_STRIP;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.05;

  std_msgs::ColorRGBA color_neighbor;
  color_neighbor.r = 0.5;
  color_neighbor.b = 0.5;
  color_neighbor.g = 0.5;
  color_neighbor.a = 1.0;

  std_msgs::ColorRGBA color_neighbor_change;
  color_neighbor_change.b = 0.7;
  color_neighbor_change.g = 1.0;
  color_neighbor_change.a = 1.0;

  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
  marker.color = change_flag == ChangeFlag::left ? color_neighbor_change : color_neighbor;

  for(const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at((left_lane_idx_))).waypoints)
    marker.points.push_back(em.pose.pose.position);

  return marker;
}

visualization_msgs::Marker LaneSelectNode::createChangeLaneMarker()
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;change_lane_marker&quot;;

  if (std::get&lt;0&gt;(lane_for_change_).waypoints.empty())
  {
    marker.action = visualization_msgs::Marker::DELETE;
    return marker;
  }

  marker.type = visualization_msgs::Marker::LINE_STRIP;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.05;

  std_msgs::ColorRGBA color;
  color.r = 1.0;
  color.a = 1.0;

  std_msgs::ColorRGBA color_current;
  color_current.b = 1.0;
  color_current.g = 0.7;
  color_current.a = 1.0;

  marker.color = current_state_ == &quot;LANE_CHANGE&quot; ? color_current : color;
  for(const auto &amp;em : std::get&lt;0&gt;(lane_for_change_).waypoints)
    marker.points.push_back(em.pose.pose.position);

  return marker;
}

visualization_msgs::Marker LaneSelectNode::createClosestWaypointsMarker()
{
  visualization_msgs::Marker marker;
  std_msgs::ColorRGBA color_closest_wp;
  color_closest_wp.r = 1.0;
  color_closest_wp.b = 1.0;
  color_closest_wp.g = 1.0;
  color_closest_wp.a = 1.0;

  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;closest_waypoints_marker&quot;;
  marker.type = visualization_msgs::Marker::POINTS;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.5;
  marker.color = color_closest_wp;

  marker.points.reserve(tuple_vec_.size());
  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
  {
    if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
      continue;

    marker.points.push_back(
        std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(i))).pose.pose.position);
  }

  return marker;
}

void LaneSelectNode::publishVisualizer()
{
  visualization_msgs::MarkerArray marker_array;
  marker_array.markers.push_back(createChangeLaneMarker());
  marker_array.markers.push_back(createCurrentLaneMarker());
  marker_array.markers.push_back(createRightLaneMarker());
  marker_array.markers.push_back(createLeftLaneMarker());
  marker_array.markers.push_back(createClosestWaypointsMarker());

  vis_pub1_.publish(marker_array);
}

void LaneSelectNode::publishLane(const autoware_msgs::lane &amp;lane)
{
  // publish global lane
  pub1_.publish(lane);
}

void LaneSelectNode::publishClosestWaypoint(const int32_t clst_wp)
{
  // publish closest waypoint
  std_msgs::Int32 closest_waypoint;
  closest_waypoint.data = clst_wp;
  pub2_.publish(closest_waypoint);
}

void LaneSelectNode::publishChangeFlag(const ChangeFlag flag)
{
  std_msgs::Int32 change_flag;
  change_flag.data = enumToInteger(flag);
  pub3_.publish(change_flag);
}

void LaneSelectNode::callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr &amp;msg)
{
  tuple_vec_.clear();
  tuple_vec_.shrink_to_fit();
  tuple_vec_.reserve(msg-&gt;lanes.size());
  for (const auto &amp;el : msg-&gt;lanes)
  {
    auto t = std::make_tuple(el, -1, ChangeFlag::unknown);
    tuple_vec_.push_back(t);
  }

  current_lane_idx_ = -1;
  right_lane_idx_ = -1;
  left_lane_idx_ = -1;
  is_lane_array_subscribed_ = true;

  if(current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg)
{
  current_pose_ = *msg;
  is_current_pose_subscribed_ = true;

  if(current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg)
{
  current_velocity_ = *msg;
  is_current_velocity_subscribed_ = true;

  if(current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
{
  current_state_ = msg-&gt;data;
  is_current_state_subscribed_ = true;

  if(current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}
void LaneSelectNode::callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg)
{
  is_current_state_subscribed_ = true;
  
  if(msg-&gt;behavior_state == &quot;LaneChangeRight&quot; || 
		  msg-&gt;behavior_state == &quot;LaneChangeLeft&quot;) 
  {
	  current_state_ = std::string(&quot;LANE_CHANGE&quot;);;
  }else{
	  current_state_ = msg-&gt;main_state;
  }

  if(current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}


void LaneSelectNode::callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg)
{
  distance_threshold_ = msg-&gt; distance_threshold_neighbor_lanes;
  lane_change_interval_= msg-&gt;lane_change_interval;
    lane_change_target_ratio_ = msg-&gt;lane_change_target_ratio;
  lane_change_target_minimum_ = msg-&gt;lane_change_target_minimum;
    vlength_hermite_curve_= msg-&gt;vector_length_hermite_curve;
  is_config_subscribed_ = true;

  if(current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::run()
{
  ros::spin();
}

// distance between target 1 and target2 in 2-D
double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2)
{
  double distance = sqrt(pow(target1.x - target2.x, 2) + pow(target1.y - target2.y, 2));
  return distance;
}

geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point, const geometry_msgs::Pose &amp;pose)
{
  tf::Transform inverse;
  tf::poseMsgToTF(pose, inverse);
  tf::Transform transform = inverse.inverse();

  tf::Point p;
  pointMsgToTF(input_point, p);
  tf::Point tf_p = transform * p;
  geometry_msgs::Point tf_point_msg;
  pointTFToMsg(tf_p, tf_point_msg);
  return tf_point_msg;
}

geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
                                                                      const geometry_msgs::Pose &amp;pose)
{
  tf::Transform inverse;
  tf::poseMsgToTF(pose, inverse);

  tf::Point p;
  pointMsgToTF(input_point, p);
  tf::Point tf_p = inverse * p;

  geometry_msgs::Point tf_point_msg;
  pointTFToMsg(tf_p, tf_point_msg);
  return tf_point_msg;
}

double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose)
{
  tf::Vector3 x_axis(1, 0, 0);
  tf::Transform waypoint_tfpose;
  tf::poseMsgToTF(waypoint_pose, waypoint_tfpose);
  tf::Vector3 waypoint_v = waypoint_tfpose.getBasis() * x_axis;
  tf::Transform current_tfpose;
  tf::poseMsgToTF(current_pose, current_tfpose);
  tf::Vector3 current_v = current_tfpose.getBasis() * x_axis;

  return current_v.angle(waypoint_v) * 180 / M_PI;
}

// get closest waypoint from current pose
int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
                                 const double distance_threshold)
{
  if (current_lane.waypoints.empty())
    return -1;

  std::vector&lt;uint32_t&gt; idx_vec;
  // if previous number is -1, search closest waypoint from waypoints in front of current pose
  if (previous_number == -1)
  {
    idx_vec.reserve(current_lane.waypoints.size());
    for (uint32_t i = 0; i &lt; current_lane.waypoints.size(); i++)
    {
      geometry_msgs::Point converted_p =
          convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
      double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
      if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
        idx_vec.push_back(i);
    }
  }
  else
  {
    if (distance_threshold &lt;
        getTwoDimensionalDistance(current_lane.waypoints.at(previous_number).pose.pose.position, current_pose.position))
    {
      ROS_WARN(&quot;Current_pose is far away from previous closest waypoint. Initilized...&quot;);
      return -1;
    }

    double ratio = 3;
    double minimum_dt = 2.0;
    double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;

    auto range_max = static_cast&lt;uint32_t&gt;(previous_number + dt) &lt; current_lane.waypoints.size()
                         ? static_cast&lt;uint32_t&gt;(previous_number + dt)
                         : current_lane.waypoints.size();
    for (uint32_t i = static_cast&lt;uint32_t&gt;(previous_number); i &lt; range_max; i++)
    {
      geometry_msgs::Point converted_p =
          convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
      double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
      if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
        idx_vec.push_back(i);
    }
  }

  if (idx_vec.empty())
    return -1;

  std::vector&lt;double&gt; dist_vec;
  dist_vec.reserve(idx_vec.size());
  for (const auto &amp;el : idx_vec)
  {
    double dt = getTwoDimensionalDistance(current_pose.position, current_lane.waypoints.at(el).pose.pose.position);
    dist_vec.push_back(dt);
  }
  std::vector&lt;double&gt;::iterator itr = std::min_element(dist_vec.begin(), dist_vec.end());
  int32_t found_number = idx_vec.at(static_cast&lt;uint32_t&gt;(std::distance(dist_vec.begin(), itr)));
  return found_number;
}

// let the linear equation be &quot;ax + by + c = 0&quot;
// if there are two points (x1,y1) , (x2,y2), a = &quot;y2-y1, b = &quot;(-1) * x2 - x1&quot; ,c = &quot;(-1) * (y2-y1)x1 + (x2-x1)y1&quot;
bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c)
{
  //(x1, y1) = (start.x, star.y), (x2, y2) = (end.x, end.y)
  double sub_x = fabs(start.x - end.x);
  double sub_y = fabs(start.y - end.y);
  double error = pow(10, -5);  // 0.00001

  if (sub_x &lt; error &amp;&amp; sub_y &lt; error)
  {
    ROS_INFO(&quot;two points are the same point!!&quot;);
    return false;
  }

  *a = end.y - start.y;
  *b = (-1) * (end.x - start.x);
  *c = (-1) * (end.y - start.y) * start.x + (end.x - start.x) * start.y;

  return true;
}
double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double a, double b, double c)
{
  double d = fabs(a * point.x + b * point.y + c) / sqrt(pow(a, 2) + pow(b, 2));

  return d;
}

}  // lane_planner
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="7b7262c9ab08eba6771666056990beb24025ef22" fix_time="0,86345">
		<msg>fix</msg>
		<modified_files>
			<file old_path="ros/src/data/packages/pos_db/nodes/pos_downloader/pos_downloader.cpp" new_path="ros/src/data/packages/pos_db/nodes/pos_downloader/pos_downloader.cpp">
				<diff>@@ -36,7 +36,7 @@ publish data as ractangular plane
 
 #include &quot;ros/ros.h&quot;
 #include &quot;std_msgs/String.h&quot;
-#include &lt;jsk_rviz_plugins/Pictogram&gt;
+#include &lt;jsk_rviz_plugins/Pictogram.h&gt;
 #include &lt;cstdio&gt;
 #include &lt;cstdlib&gt;
 #include &lt;vector&gt;
@@ -177,7 +177,7 @@ static void publish_car(int id, int is_current, ros::Time now,
   } else {
     //marker.type = visualization_msgs::Marker::SPHERE;
     // marker.lifetime = ros::Duration(life_time);
-    pictogram.character = &quot;circle&quot;
+    pictogram.character = &quot;circle&quot;;
     pictogram.ttl = life_time;
     pictogram.color.r = 1.0;
     pictogram.color.g = 0.0;
@@ -243,7 +243,7 @@ static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
   pictogram.header.stamp = now;
   pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
   //marker.type = visualization_msgs::Marker::CYLINDER;
-  pictogram.character = &quot;dot-circle-o&quot;
+  pictogram.character = &quot;dot-circle-o&quot;;
   // marker.lifetime = ros::Duration(life_time);
   pictogram.ttl = life_time;
   if (is_pedestrian) {
@@ -268,7 +268,7 @@ static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
   dbg_out_pictogram(pictogram);
 
   //marker.type = visualization_msgs::Marker::SPHERE;
-  pictogram.character = &quot;circle&quot;
+  pictogram.character = &quot;circle&quot;;
   // marker.scale.x = 0.6; // #2
   // marker.scale.y = 0.6;
   // marker.scale.z = 0.6;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
pos_downloader
This node get location data from db server and
publish data as ractangular plane
*/

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/String.h&quot;
#include &lt;jsk_rviz_plugins/Pictogram&gt;
#include &lt;cstdio&gt;
#include &lt;cstdlib&gt;
#include &lt;vector&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;ctime&gt;
#ifndef CURRENT_CAR_DIRECTLY
#include &lt;map&gt;
#endif /* ! CURRENT_CAR_DIRECTLY */
#include &lt;pthread.h&gt;

#include &lt;geo_pos_conv.hh&gt;
#include &lt;pos_db.h&gt;

#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;

#define MYNAME		&quot;pos_downloader&quot;
#define PICTOGRAMNAME &quot;mo_pictogram&quot;
#define STARTTIME	(0)		// sec since 1970-01-01 (0==now)
#define DELAYSEC	(0)		// delay sec for pos_uploader
#define POSUP_DZ	(40)		// z offset of PosUp
#define PEDESTRIAN_DZ	(-2)		// z offset of pedestrian_pose
#define DOWNLOAD_PERIOD	(250)		// period (msec)
#define TOTAL_LIFETIME	(10.0)		// total lifetime (sec)

#define TYPE_OWN	(1)
#define TYPE_CAR	(2)
#define TYPE_PEDESTRIAN	(3)

#define ANON_MARKER_ID_MIN     (2)
#define ANON_MARKER_ID_MAX     (0x7f000000)

using namespace std;

static string db_host_name;
static int db_port;
static string sshpubkey;
static string sshprivatekey;
static int ssh_port;
static string sshtunnelhost;
static int sleep_msec = DOWNLOAD_PERIOD;	// period
static double life_time = 1.0;			// sec
static double posup_dz;
static double pedestrian_dz;

static ros::Publisher pub;

static SendData sd;

static char mac_addr[MAC_ADDRBUFSIZ];
static int ignore_my_pose = 1;

#ifndef CURRENT_CAR_DIRECTLY
static map&lt;int, geometry_msgs::Pose&gt; car_map;
static map&lt;int, ros::Time&gt; now_map;
static map&lt;int, ros::Time&gt; prev_map;
#endif /* ! CURRENT_CAR_DIRECTLY */

#ifdef NEVER
static double color_percent(int diffmsec)
{
  return (1.0 - diffmsec/TOTAL_LIFETIME/1000.0)*((256-48)/256.0) + (48/256.0);
}
#endif /* NEVER */
static double alpha_percent(int diffmsec)
{
  return (1.0 - diffmsec/TOTAL_LIFETIME/1000.0);
}

static std::vector&lt;std::string&gt; split(const string&amp; input, char delimiter)
{
    std::istringstream stream(input);

    std::string field;
    std::vector&lt;std::string&gt; result;
    while (std::getline(stream, field, delimiter)) {
        result.push_back(field);
    }
    return result;
}

static void dbg_out_pictogram(jsk_rviz_plugins::Pictogram pictogram)
{
#ifdef POS_DB_VERBOSE
  std::cout
	&lt;&lt; pictogram.pose.position.x &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.position.y &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.position.z &lt;&lt; &quot; : &quot;
	&lt;&lt; pictogram.pose.orientation.x &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.orientation.y &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.orientation.z &lt;&lt; &quot;,&quot;
	&lt;&lt; pictogram.pose.orientation.w &lt;&lt; std::endl;
#endif /* POS_DB_VERBOSE */
}

static void publish_car(int id, int is_current, ros::Time now,
		       geometry_msgs::Pose&amp; pose, int diffmsec)
{
  jsk_rviz_plugins::Pictogram pictogram;
  pictogram.header.frame_id = &quot;/map&quot;;
  pictogram.header.stamp = now;
  pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
  pictogram.pose = pose;
  if (is_current) {
#ifdef CURRENT_CAR_DIRECTLY
    pictogram.character = &quot;fa-car&quot;;
    // marker.lifetime = ros::Duration();
    pictogram.color.r = 0.0;
    pictogram.color.g = 0.0;
    pictogram.color.b = 0.0;
    pictogram.color.a = 0.0;
    pictogram.size = 1.0;

    tf::Quaternion q1;
    q1.setRPY(M_PI/2, 0, M_PI);
    tf::Quaternion q2(pictogram.pose.orientation.x, pictogram.pose.orientation.y, pictogram.pose.orientation.z, pictogram.pose.orientation.w);
    tf::Quaternion q3;
    q3 = q2 * q1;

    pictogram.pose.position.z -= 2.0;
    pictogram.pose.orientation.x = q3.x();
    pictogram.pose.orientation.y = q3.y();
    pictogram.pose.orientation.z = q3.z();
    pictogram.pose.orientation.w = q3.w();

    pub.publish(pictogram);
    dbg_out_pictogram(pictogram);
#else /* CURRENT_CAR_DIRECTLY */
    ros::Time newnow = now - ros::Duration(diffmsec/1000.0);
    if (now_map.count(id) == 0 || newnow &gt;= now_map[id]) {
      car_map[id] = pose;
      now_map[id] = newnow;
    }
#endif /* CURRENT_CAR_DIRECTLY */

  } else {
    //marker.type = visualization_msgs::Marker::SPHERE;
    // marker.lifetime = ros::Duration(life_time);
    pictogram.character = &quot;circle&quot;
    pictogram.ttl = life_time;
    pictogram.color.r = 1.0;
    pictogram.color.g = 0.0;
    pictogram.color.b = 0.0;
    pictogram.color.a = alpha_percent(diffmsec);
    pictogram.size = 2;
    pictogram.pose.position.z += 0.5; // == #1/2
    pub.publish(pictogram);
    dbg_out_pictogram(pictogram);
  }
}

#ifndef CURRENT_CAR_DIRECTLY
static void publish_car_summary(ros::Time now)
{
  jsk_rviz_plugins::Pictogram pictogram;
  map&lt;int, geometry_msgs::Pose&gt;::iterator itr;

  for(itr = car_map.begin(); itr != car_map.end(); itr++) {
    int id = itr-&gt;first;
    geometry_msgs::Pose pose = itr-&gt;second;
    ros::Time cur = now_map[id];
    if (prev_map.count(id) &gt; 0 &amp;&amp; cur &lt;= prev_map[id]) {
      continue;
    }
    pictogram.header.frame_id = &quot;/map&quot;;
    pictogram.header.stamp = cur;
    pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
    pictogram.pose = pose;
    pictogram.character = &quot;fa-car&quot;;
    // marker.lifetime = ros::Duration();
    pictogram.color.r = 0.0;
    pictogram.color.g = 0.0;
    pictogram.color.b = 0.0;
    pictogram.color.a = 0.0;
    pictogram.size = 1;
    tf::Quaternion q1;
    q1.setRPY(M_PI/2, 0, M_PI);
    tf::Quaternion q2(pictogram.pose.orientation.x, pictogram.pose.orientation.y, pictogram.pose.orientation.z, pictogram.pose.orientation.w);
    tf::Quaternion q3;
    q3 = q2 * q1;

    pictogram.pose.position.z -= 2.0;
    pictogram.pose.orientation.x = q3.x();
    pictogram.pose.orientation.y = q3.y();
    pictogram.pose.orientation.z = q3.z();
    pictogram.pose.orientation.w = q3.w();

    pub.publish(pictogram);
    dbg_out_pictogram(pictogram);
    prev_map[id] = cur;
  }
  car_map.clear();
  now_map.clear();
}
#endif /* ! CURRENT_CAR_DIRECTLY */

static void publish_pedestrian(int id, int is_pedestrian, ros::Time now,
			      geometry_msgs::Pose&amp; pose, int diffmsec)
{
  jsk_rviz_plugins::Pictogram pictogram;
  pictogram.header.frame_id = &quot;/map&quot;;
  pictogram.header.stamp = now;
  pictogram.action = jsk_rviz_plugins::Pictogram::ADD;
  //marker.type = visualization_msgs::Marker::CYLINDER;
  pictogram.character = &quot;dot-circle-o&quot;
  // marker.lifetime = ros::Duration(life_time);
  pictogram.ttl = life_time;
  if (is_pedestrian) {
    pictogram.color.r = 0.0;
    pictogram.color.g = 1.0;
    pictogram.color.b = 1.0;
    pose.position.z += pedestrian_dz;
  } else {
    pictogram.color.r = 1.0;
    pictogram.color.g = 1.0;
    pictogram.color.b = 1.0;
    pose.position.z += posup_dz;
  }
  pictogram.color.a = alpha_percent(diffmsec);
  // marker.scale.x = 0.6;
  // marker.scale.y = 0.6;
  // marker.scale.z = 1.2; // #1
  pictogram.size = 1;
  pictogram.pose = pose;
  pictogram.pose.position.z += 0.6; // == #1/2
  pub.publish(pictogram);
  dbg_out_pictogram(pictogram);

  //marker.type = visualization_msgs::Marker::SPHERE;
  pictogram.character = &quot;circle&quot;
  // marker.scale.x = 0.6; // #2
  // marker.scale.y = 0.6;
  // marker.scale.z = 0.6;
  pictogram.size = 1;
  pictogram.pose = pose;
  pictogram.pose.position.z += 1.2 + 0.3 + 0.1; // == #1 + #2/2 + alpha
  pub.publish(pictogram);
  dbg_out_pictogram(pictogram);
}

static int result_to_pictogram(const string&amp; idstr, ros::Time now,
			    geometry_msgs::Pose&amp; pose, int type,
			    int diffmsec, int is_swap)
{
  int nid;

  switch (type) {
  case TYPE_OWN:
    /* use lower 6 bytes */
    nid = ANON_MARKER_ID_MAX |
      (std::strtol(idstr.substr(6, 6).c_str(), NULL, 16)) &lt;&lt; 1;
    publish_car(nid, 1, now, pose, diffmsec);
    break;
  case TYPE_CAR:
    publish_car(0, 0, now, pose, diffmsec);
    break;
  case TYPE_PEDESTRIAN:
    publish_pedestrian(0, 1, now, pose, diffmsec);
    break;

  /* backward compatibility */
  default:
    if (idstr.find(&quot;current_pose&quot;, 0) != string::npos) {
      /* current_pose:DEF012345678 */
      if (idstr.length() &gt;= 25) {
	/* use lower 6 bytes */
	nid = ANON_MARKER_ID_MAX |
	  (std::strtol((idstr.substr(19, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
        publish_car(nid, 1, now, pose, diffmsec);
      }
    } else if (idstr.find(&quot;ndt_pose&quot;, 0) != string::npos) {
      /* ndt_pose:9ABCDEF01234 */
      if (idstr.length() &gt;= 21) {
	/* use lower 6 bytes */
	nid = ANON_MARKER_ID_MAX |
	  (std::strtol((idstr.substr(15, 6)).c_str(), NULL, 16)) &lt;&lt; 1;
        publish_car(nid, 1, now, pose, diffmsec);
      }
    } else if (idstr.find(&quot;car_pose&quot;, 0) != string::npos) {
      publish_car(0, 0, now, pose, diffmsec);
    } else if (idstr.find(&quot;pedestrian_pose&quot;, 0) != string::npos) {
      publish_pedestrian(0, 1, now, pose, diffmsec);
    } else {
      publish_pedestrian(0, 0, now, pose, diffmsec); // PosUp
    }
  }

  return 0;
}

static int get_timeval(const char *tstr, time_t *sp, int *np)
{
  struct tm tm;
  const char *p;

  if (sscanf(tstr, &quot;%d-%d-%d %d:%d:%d&quot;, &amp;tm.tm_year, &amp;tm.tm_mon,
	&amp;tm.tm_mday, &amp;tm.tm_hour, &amp;tm.tm_min, &amp;tm.tm_sec) != 6) {
    std::cerr &lt;&lt; &quot;Cannot convert time \&quot;&quot; &lt;&lt; tstr &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
    return -1;
  }
  if ((p = strchr(tstr, '.')) != NULL) {
    sscanf(++p, &quot;%d&quot;, np);
    for (int i = strlen(p); i &lt; 9; i++, *np*=10);
  } else {
    *np = 0;
  }
  tm.tm_year -= 1900;
  tm.tm_mon -= 1;
  *sp = mktime(&amp;tm);
  return 0;
}

static void pictogram_publisher(const std_msgs::String&amp; msg, int is_swap)
{
  std::vector&lt;std::string&gt; db_data = split(msg.data, '\n');
  std::vector&lt;std::string&gt; cols;
  ros::Time now = ros::Time::now();
  geometry_msgs::Pose pose;
  int type;
  time_t now_sec, prv_sec = 0;
  int now_nsec, prv_nsec;

  for (const std::string&amp; row : db_data) {
    if(row.empty())
      continue;
    cols = split(row, '\t');
    // id,x,y,z,or_x,or_y,or_z,or_w,lon,lat,tm,type
    if(cols.size() != 12)
      continue;

    type = std::stoi(cols[11]);
    if(ignore_my_pose &amp;&amp;
       (type == TYPE_OWN ||
	cols[0].find(&quot;current_pose&quot;, 0) != string::npos ||
	cols[0].find(&quot;ndt_pose&quot;, 0) != string::npos) &amp;&amp;
       cols[0].find(mac_addr, 0) != string::npos) {
      continue;	// don't publish Marker of my pose
    }

    if (is_swap) {
      pose.position.x = std::stod(cols[2]);
      pose.position.y = std::stod(cols[1]);
      pose.orientation.x = std::stod(cols[5]);
      pose.orientation.y = std::stod(cols[4]);
    } else {
      pose.position.x = std::stod(cols[1]);
      pose.position.y = std::stod(cols[2]);
      pose.orientation.x = std::stod(cols[4]);
      pose.orientation.y = std::stod(cols[5]);
    }
    pose.position.z = std::stod(cols[3]);
    pose.orientation.z = std::stod(cols[6]);
    pose.orientation.w = std::stod(cols[7]);
    // VoltDB returns not NULL but -1.7976931348623157E308
    if (pose.position.x &lt; -1.79E308 ||
	pose.position.y &lt; -1.79E308 ||
	pose.position.z &lt; -1.79E308) {
      geo_pos_conv geo;
      double lon = std::stod(cols[8]);
      double lat = std::stod(cols[9]);
      geo.set_plane(7); // Aichi-ken
      geo.llh_to_xyz(lat, lon, 0/*h*/);
      if (is_swap) {
	pose.position.x = geo.y();
	pose.position.y = geo.x();
      } else {
	pose.position.x = geo.x();
	pose.position.y = geo.y();
      }
      pose.position.z = geo.z();
      pose.orientation.x = 0;
      pose.orientation.y = 0;
      pose.orientation.z = 0;
      pose.orientation.w = 1;
    }
    now_sec = now.toSec();
    now_nsec = now.toNSec()%(1000*1000*1000);
    get_timeval(cols[10].c_str(), &amp;prv_sec, &amp;prv_nsec);
    result_to_pictogram(cols[0], now, pose, type,
      (now_sec-prv_sec)*1000+(now_nsec-prv_nsec)/1000/1000, is_swap);
  }

#ifndef CURRENT_CAR_DIRECTLY
  publish_car_summary(now);
#endif /* ! CURRENT_CAR_DIRECTLY */
}

// create &quot;YYYY-mm-dd HH:MM:SS.sss&quot;
static int create_timestr(time_t sec, int nsec, char *str, size_t size)
{
  std::tm *nowtm;

  nowtm = std::gmtime(&amp;sec);
  return std::snprintf(str, size, &quot;%04d-%02d-%02d %02d:%02d:%02d.%03d&quot;,
	nowtm-&gt;tm_year + 1900, nowtm-&gt;tm_mon + 1, nowtm-&gt;tm_mday,
	nowtm-&gt;tm_hour, nowtm-&gt;tm_min, nowtm-&gt;tm_sec, nsec/1000/1000);
}

//wrap SendData class
static void send_sql(time_t diff_sec)
{
  std::string data;
  string db_response;
  std_msgs::String msg;
  ros::Time now = ros::Time::now();
  time_t now_sec = now.toSec() - diff_sec;
  int now_nsec = now.toNSec()%(1000*1000*1000);
  char timestr[64]; // &quot;YYYY-mm-dd HH:MM:SS.sss...&quot;
  char prevstr[64]; // &quot;YYYY-mm-dd HH:MM:SS.sss...&quot;

  create_timestr(now_sec-TOTAL_LIFETIME, now_nsec, prevstr, sizeof(prevstr));
  create_timestr(now_sec, now_nsec, timestr, sizeof(timestr));

  data = make_header(1, 1);
  // select pos data between previous latest timestamp and now
  data += &quot;SELECT id,x,y,z,or_x,or_y,or_z,or_w,lon,lat,tm,type FROM POS &quot;
	&quot;WHERE tm &gt; '&quot;;
  data += prevstr;
  data += &quot;' AND tm &lt; '&quot;;
  data += timestr;
  data += &quot;' ORDER BY tm;\r\n&quot;;

  int ret = sd.Sender(data, db_response, 0);
  if (ret &lt; 0) {
    std::cerr &lt;&lt; &quot;sd.Sender() failed&quot; &lt;&lt; std::endl;
  } else {
#ifdef POS_DB_VERBOSE
    std::cout &lt;&lt; &quot;return data: \&quot;&quot; &lt;&lt; db_response &lt;&lt; &quot;\&quot;&quot; &lt;&lt; std::endl;
#endif /* POS_DB_VERBOSE */
    msg.data = db_response.c_str();
    pictogram_publisher(msg, 1);
  }
}

static void* intervalCall(void *unused)
{
  double *args = (double *)unused;
  double diff_sec = args[1];

  if (args[0] != 0)
    diff_sec += ros::Time::now().toSec() - args[0];
#ifdef POS_DB_VERBOSE
  cout &lt;&lt; &quot;diff=&quot; &lt;&lt; diff_sec &lt;&lt; endl;
#endif /* POS_DB_VERBOSE */

  while (1) {
    send_sql((time_t)diff_sec);
    usleep(sleep_msec*1000);
  }

  return nullptr;
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, MYNAME) ;
  ros::NodeHandle nh;
  pthread_t th;
  double args[2];

  cout &lt;&lt; MYNAME &lt;&lt; endl;

  if(argc &lt; 2) {
    std::cerr &lt;&lt; &quot;usage : \n\trosrun &quot; &lt;&lt; MYNAME &lt;&lt; &quot; &lt;user name&gt; [show_my_pose]&quot; &lt;&lt; std::endl;
    return -1;
  }
  if(argc &gt; 2) {
    if(strncmp(argv[2], &quot;show_my_pose&quot;, 12) == 0) ignore_my_pose = 0;
  }
  std::cerr &lt;&lt; &quot;ignore_my_pose=&quot; &lt;&lt; ignore_my_pose &lt;&lt; std::endl;

  probe_mac_addr(mac_addr);
  std::cerr &lt;&lt;  &quot;mac_addr=&quot; &lt;&lt; mac_addr &lt;&lt; std::endl;

  string home_dir = getenv(&quot;HOME&quot;);

  pub = nh.advertise&lt;jsk_rviz_plugins::Pictogram&gt;(PICTOGRAMNAME, 1);
  nh.param&lt;double&gt;(MYNAME &quot;/time&quot;, args[0], STARTTIME);
  cout &lt;&lt; &quot;time=&quot; &lt;&lt; args[0] &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/delay&quot;, args[1], DELAYSEC);
  cout &lt;&lt; &quot;delay=&quot; &lt;&lt; args[1] &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/posup_dz&quot;, posup_dz, POSUP_DZ);
  cout &lt;&lt; &quot;posup_dz=&quot; &lt;&lt; posup_dz &lt;&lt; endl;
  nh.param&lt;double&gt;(MYNAME &quot;/pedestrian_dz&quot;, pedestrian_dz, PEDESTRIAN_DZ);
  cout &lt;&lt; &quot;pedestrian_dz=&quot; &lt;&lt; pedestrian_dz &lt;&lt; endl;

  nh.param&lt;string&gt;(&quot;pos_db/db_host_name&quot;, db_host_name, DB_HOSTNAME);
  cout &lt;&lt; &quot;db_host_name=&quot; &lt;&lt; db_host_name &lt;&lt; endl;
  nh.param&lt;int&gt;(&quot;pos_db/db_port&quot;, db_port, DB_PORT);
  cout &lt;&lt; &quot;db_port=&quot; &lt;&lt; db_port &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshpubkey&quot;, sshpubkey, home_dir+SSHPUBKEY);
  cout &lt;&lt; &quot;sshpubkey=&quot; &lt;&lt; sshpubkey &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshprivatekey&quot;, sshprivatekey, home_dir+SSHPRIVATEKEY);
  cout &lt;&lt; &quot;sshprivatekey=&quot; &lt;&lt; sshprivatekey &lt;&lt; endl;
  nh.param&lt;int&gt;(&quot;pos_db/ssh_port&quot;, ssh_port, SSHPORT);
  cout &lt;&lt; &quot;ssh_port=&quot; &lt;&lt; ssh_port &lt;&lt; endl;
  nh.param&lt;string&gt;(&quot;pos_db/sshtunnelhost&quot;, sshtunnelhost, SSHTUNNELHOST);
  cout &lt;&lt; &quot;sshtunnelhost=&quot; &lt;&lt; sshtunnelhost &lt;&lt; endl;

  sd = SendData(db_host_name, db_port, argv[1], sshpubkey, sshprivatekey, ssh_port, sshtunnelhost);

  if (pthread_create(&amp;th, nullptr, intervalCall, (void *)args) != 0) {
    std::perror(&quot;pthread_create&quot;);
    std::exit(1);
  }

  pthread_detach(th);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="1296beaa0319114c3ebdc8e4fecd13fea2aaeb34" fix_time="0,0">
		<msg>Fixed mirrored images on Ladybug camera (#906)</msg>
		<modified_files>
			<file old_path="ros/src/sensing/drivers/camera/packages/pointgrey/nodes/ladybug/ladybug.cpp" new_path="ros/src/sensing/drivers/camera/packages/pointgrey/nodes/ladybug/ladybug.cpp">
				<diff>@@ -363,6 +363,7 @@ int main (int argc, char **argv)
 			cv::resize(image,image,cv::Size(size.width*image_scale/100, size.height*image_scale/100));
 			//
 			cv::transpose(image, image);
+			cv::flip(image, image, 1);
 
 			if (i==0)
 				image.copyTo(full_size);
</diff>
				<old_file>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;sstream&gt;
#include &quot;ladybug.h&quot;
#include &quot;ladybugstream.h&quot;
#include &lt;stdexcept&gt;
#include &lt;unistd.h&gt;
#include &lt;signal.h&gt;

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/image_encodings.h&gt;
#include &lt;sensor_msgs/Image.h&gt;

#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;

#include &quot;opencv2/core/core.hpp&quot;
#include &quot;opencv2/highgui/highgui.hpp&quot;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;

#include &quot;ladybug.h&quot;

using namespace std;

static volatile int running_ = 1;


LadybugContext m_context;
LadybugDataFormat m_dataFormat;
//camera config settings
float m_frameRate;
bool m_isFrameRateAuto;
unsigned int m_jpegQualityPercentage;

ros::Publisher pub[LADYBUG_NUM_CAMERAS + 1];

static void signalHandler(int)
{
	running_ = 0;
	ros::shutdown();
}

void parseCameraInfo(const cv::Mat  &amp;camMat,
						const cv::Mat  &amp;disCoeff,
						const cv::Size &amp;imgSize,
						sensor_msgs::CameraInfo &amp;msg)
{
	msg.header.frame_id = &quot;camera&quot;;

	msg.height = imgSize.height;
	msg.width  = imgSize.width;

	for (int row=0; row&lt;3; row++)
	{
		for (int col=0; col&lt;3; col++)
		{
			msg.K[row * 3 + col] = camMat.at&lt;double&gt;(row, col);
		}
	}

	for (int row=0; row&lt;3; row++)
	{
		for (int col=0; col&lt;4; col++)
		{
			if (col == 3)
			{
				msg.P[row * 4 + col] = 0.0f;
			} else
			{
				msg.P[row * 4 + col] = camMat.at&lt;double&gt;(row, col);
			}
		}
	}

	for (int row=0; row&lt;disCoeff.rows; row++)
	{
		for (int col=0; col&lt;disCoeff.cols; col++)
		{
			msg.D.push_back(disCoeff.at&lt;double&gt;(row, col));
		}
	}
}

void GetMatricesFromFile(ros::NodeHandle nh, sensor_msgs::CameraInfo &amp;camerainfo_msg)
{
	//////////////////CAMERA INFO/////////////////////////////////////////
	cv::Mat  cameraExtrinsicMat;
	cv::Mat  cameraMat;
	cv::Mat  distCoeff;
	cv::Size imageSize;
	std::string filename;

	if (nh.getParam(&quot;calibrationfile&quot;, filename) &amp;&amp; filename!=&quot;&quot;)
	{
		ROS_INFO(&quot;Trying to parse calibrationfile :&quot;);
		ROS_INFO(&quot;&gt; %s&quot;, filename.c_str());
	}
	else
	{
		ROS_INFO(&quot;No calibrationfile param was received&quot;);
		return;
	}

	cv::FileStorage fs(filename, cv::FileStorage::READ);
	if (!fs.isOpened())
	{
		ROS_INFO(&quot;Cannot open %s&quot;, filename.c_str());;
		return;
	}
	else
	{
		fs[&quot;CameraMat&quot;] &gt;&gt; cameraMat;
		fs[&quot;DistCoeff&quot;] &gt;&gt; distCoeff;
		fs[&quot;ImageSize&quot;] &gt;&gt; imageSize;
	}
	parseCameraInfo(cameraMat, distCoeff, imageSize, camerainfo_msg);
}

void publishImage(cv::Mat&amp; image, ros::Publisher&amp; image_pub, long int&amp; count)
{
	sensor_msgs::Image msg;
	//publish*******************
	msg.header.seq = count;
	msg.header.frame_id = &quot;camera&quot;;
	msg.header.stamp.sec = ros::Time::now().sec; msg.header.stamp.nsec = ros::Time::now().nsec;
	msg.height = image.size().height; msg.width  = image.size().width;
	msg.encoding = &quot;rgb8&quot;;
	msg.step = image.cols * image.elemSize();
	size_t image_size = image.rows * image.cols * image.elemSize();

	msg.data.resize(image_size);
	memcpy(msg.data.data(), image.data, image_size);

	image_pub.publish(msg);
}

LadybugError init_camera()
{
	LadybugError error;
	error = ladybugCreateContext(&amp;m_context);
	if (error != LADYBUG_OK)
	{
		throw std::runtime_error(&quot;Unable to create Ladybug context.&quot;);
	}

	LadybugCameraInfo enumeratedCameras[16];
	unsigned int numCameras = 16;

	error = ladybugBusEnumerateCameras(m_context, enumeratedCameras, &amp;numCameras);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	cout &lt;&lt; &quot;Cameras detected: &quot; &lt;&lt; numCameras &lt;&lt; endl &lt;&lt; endl;

	if (numCameras == 0)
	{
		ROS_INFO(&quot;Insufficient number of cameras detected. &quot;);
		return LADYBUG_FAILED;
	}

	error = ladybugInitializeFromIndex(m_context, 0);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	LadybugCameraInfo camInfo;
	error = ladybugGetCameraInfo(m_context, &amp;camInfo);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	ROS_INFO(&quot;Camera information: &quot;);

	ROS_INFO(&quot;Base s/n: %d&quot;, camInfo.serialBase );
	ROS_INFO(&quot;Head s/n: %d&quot;, camInfo.serialHead );
	ROS_INFO(&quot;Model: %s&quot;, camInfo.pszModelName );
	ROS_INFO(&quot;Sensor: %s&quot;, camInfo.pszSensorInfo);
	ROS_INFO(&quot;Vendor: %s&quot;, camInfo.pszVendorName);
	ROS_INFO(&quot;Bus / Node: %d ,%d&quot; , camInfo.iBusNum , camInfo.iNodeNum );

	switch (camInfo.deviceType)
	{
		case LADYBUG_DEVICE_LADYBUG3:
		{
			m_dataFormat = LADYBUG_DATAFORMAT_RAW8;
			m_frameRate = 16.0f;
			m_isFrameRateAuto = true;
			m_jpegQualityPercentage = 80;
		}
		break;

		case LADYBUG_DEVICE_LADYBUG5:
		{
			m_dataFormat = LADYBUG_DATAFORMAT_RAW8;
			m_frameRate = 10.0f;
			m_isFrameRateAuto = true;
			m_jpegQualityPercentage = 80;
		}
		break;

		default: assert(false); break;
	}

	return error;
}

LadybugError start_camera()
{
	LadybugError error;
	error = ladybugStartLockNext(m_context, m_dataFormat);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	error = ladybugSetAbsPropertyEx(m_context, LADYBUG_FRAME_RATE, false, true, m_isFrameRateAuto, m_frameRate);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	error = ladybugSetJPEGQuality(m_context, m_jpegQualityPercentage);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	// Perform a quick test to make sure images can be successfully acquired
	for (int i=0; i &lt; 10; i++)
	{
		LadybugImage tempImage;
		error = ladybugLockNext(m_context, &amp;tempImage);
	}

	error = ladybugUnlockAll(m_context);
	if (error != LADYBUG_OK)
	{
		return error;
	}

	return error;
}

LadybugError stop_camera()
{
    const LadybugError cameraError = ladybugStop(m_context);
    if (cameraError != LADYBUG_OK)
    {
        ROS_INFO(&quot;Error: Unable to stop camera (%s)&quot;, ladybugErrorToString(cameraError) );
    }
    return cameraError;
}

LadybugError acquire_image( LadybugImage&amp; image )
{
    return ladybugLockNext(m_context, &amp;image);
}

LadybugError unlock_image( unsigned int bufferIndex )
{
    return ladybugUnlock(m_context, bufferIndex);
}

int main (int argc, char **argv)
{
	////ROS STUFF
	ros::init(argc, argv, &quot;ladybug_camera&quot;);
	ros::NodeHandle n;
	ros::NodeHandle private_nh(&quot;~&quot;);

	signal(SIGTERM, signalHandler);//detect closing

	/////////////////////////////
	//Config camera
	m_dataFormat = LADYBUG_DATAFORMAT_RAW8;
	m_frameRate = 10;
	m_isFrameRateAuto = true;
	m_jpegQualityPercentage = 80;

	// Initialize ladybug camera
	const LadybugError grabberInitError = init_camera();
	if (LADYBUG_OK != init_camera())
	{
		ROS_INFO(&quot;Error: Failed to initialize camera (%s). Terminating...&quot;, ladybugErrorToString(grabberInitError) );
		return -1;
	}

	LadybugCameraInfo camInfo;
	if (LADYBUG_OK != ladybugGetCameraInfo(m_context, &amp;camInfo))
	{
		ROS_INFO(&quot;Error: Failed to get camera information. Terminating...&quot;);
		return -1;
	}

	const LadybugError startError = start_camera();
	if (startError != LADYBUG_OK)
	{
		ROS_INFO(&quot;Error: Failed to start camera (%s). Terminating...&quot;, ladybugErrorToString(startError) );
		return -1;
	}
	/////////////////////
	//ROS
	// Get the camera information
	///////calibration data
	sensor_msgs::CameraInfo camerainfo_msg;
	GetMatricesFromFile(private_nh, camerainfo_msg);
	int image_scale = 100;
	if (private_nh.getParam(&quot;scale&quot;, image_scale) &amp;&amp; image_scale&gt;0 &amp;&amp; image_scale&lt;100)
	{
		ROS_INFO(&quot;Ladybug ImageScale &gt; %i%%&quot;, image_scale);
	}
	else
	{
		ROS_INFO(&quot;Ladybug ImageScale scale must be (0,100]. Defaulting to 20 &quot;);
		image_scale=20;
	}

	ros::Publisher camera_info_pub;

	camera_info_pub = n.advertise&lt;sensor_msgs::CameraInfo&gt;(&quot;/camera/camera_info&quot;, 1, true);
	ROS_INFO(&quot;Successfully started ladybug camera and stream&quot;);
	for (int i = 0; i &lt; LADYBUG_NUM_CAMERAS + 1; i++) {
		std::string topic(std::string(&quot;image_raw&quot;));

			topic = &quot;camera&quot; + std::to_string(i) + &quot;/&quot; + topic;

		pub[i] = n.advertise&lt;sensor_msgs::Image&gt;(topic, 100);
		ROS_INFO(&quot;Publishing.. %s&quot;, topic.c_str());
	}
	//////////////////

	//start camera
	ros::Rate loop_rate(10); // Hz Ladybug works at 10fps
	long int count = 0;
	while (running_ &amp;&amp; ros::ok())
	{
		LadybugImage currentImage;

		const LadybugError acquisitionError = acquire_image(currentImage);
		if (acquisitionError != LADYBUG_OK)
		{
			ROS_INFO(&quot;Failed to acquire image. Error (%s). Trying to continue..&quot;, ladybugErrorToString(acquisitionError) );
			continue;
		}

		// convert to OpenCV Mat
		//receive Bayer Image, convert to Color 3 channels
		cv::Size size(currentImage.uiFullCols, currentImage.uiFullRows);

		cv::Mat full_size;
		for(size_t i =0;i&lt;LADYBUG_NUM_CAMERAS; i++)
		{
			std::ostringstream out;
			out &lt;&lt; &quot;image&quot; &lt;&lt; i;
			cv::Mat rawImage(size, CV_8UC1, currentImage.pData + (i * size.width*size.height));
			cv::Mat image(size, CV_8UC3);
			cv::cvtColor(rawImage, image, cv::COLOR_BayerBG2RGB);
			cv::resize(image,image,cv::Size(size.width*image_scale/100, size.height*image_scale/100));
			//
			cv::transpose(image, image);

			if (i==0)
				image.copyTo(full_size);
			else
				cv::hconcat(image, full_size, full_size);

			unlock_image(currentImage.uiBufferIndex);

			publishImage(image, pub[LADYBUG_NUM_CAMERAS - i], count);

		}
		//publish stitched one
		publishImage(full_size, pub[0], count);
		ros::spinOnce();
		loop_rate.sleep();
		count++;
	}

	cout &lt;&lt; &quot;Stopping ladybug_camera...&quot; &lt;&lt; endl;

	// Shutdown
	stop_camera();

	ROS_INFO(&quot;ladybug_camera stopped&quot;);

	return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="53cc0a9b89e9875531e72c36354491c703f614d9" fix_time="3,83148">
		<msg>fix a build error</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_param.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_param.hpp">
				<diff>@@ -15,6 +15,10 @@ namespace decision_maker
 #define DOUBLE_MAX 1.7976931348623158e308
 #define DEFAULT_TARGET_WAYPOINT 14
 
+
+#define DEFAULT_STOP_DECELERATION 0.2
+#define DEFAULT_STOP_TIME 1 
+
 #define ANGLE_NEUTRAL 0
 #define ANGLE_CURVE 40
 #define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
</diff>
				<old_file>#ifndef __DECISION_MAKER_PARAM_HPP__
#define __DECISION_MAKER_PARAM_HPP__

namespace decision_maker
{
//#define DEBUG_PRINT

#define DEFAULT_DISPLAY_FLAG false
#define DEFAULT_FORCE_STATE_CHANGE true

#define VEL_AVERAGE_COUNT 10
#define DEFAULT_CONVERGENCE_COUNT 5
#define DEFAULT_CONVERGENCE_THRESHOLD 0.01

#define DOUBLE_MAX 1.7976931348623158e308
#define DEFAULT_TARGET_WAYPOINT 14

#define ANGLE_NEUTRAL 0
#define ANGLE_CURVE 40
#define ANGLE_LEFT  (ANGLE_NEUTRAL - ANGLE_CURVE)
#define ANGLE_RIGHT (ANGLE_NEUTRAL + ANGLE_CURVE)

#define TPNAME_BASED_LANE_WAYPOINTS_ARRAY &quot;/based/lane_waypoints_array&quot;
#define TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY &quot;/lane_waypoints_array&quot;
#define LAMP_EMPTY  0
#define LAMP_LEFT   1
#define LAMP_RIGHT  2
#define LAMP_HAZARD 3
#define LAMP_ON 1
#define LAMP_OFF 0
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -283,16 +283,17 @@ void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg
   size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
 	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
   if(idx){
-	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE)){
+	  if(ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE)){
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
 	  }
-	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE)){
+	  if(ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE)){
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
 	  }else{ 
 		  ctx-&gt;setCurrentState(
 			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
 	  }
-	  if(current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
+
+	  if(current_finalwaypoints_.waypoints.at((int)idx/2).wpstate.stopline_state)
 		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
   }
 
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
  ctx-&gt;setEnableForceSetState(false);
  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request&quot;);
  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  else
  {
	  fprintf(stderr,&quot;disable lanechange\n&quot;);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);
  if (msg.enable_force_state_change)
  {
    if (msg.MainState_ChangeFlag)
      handleStateCmd((unsigned long long)1 &lt;&lt; msg.MainState_ChangeFlag);
    if (msg.SubState_Acc_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_ACC_ACCELERATION_STATE &lt;&lt; (msg.SubState_Acc_ChangeFlag - 1));
    if (msg.SubState_Str_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_STR_STRAIGHT_STATE &lt;&lt; (msg.SubState_Str_ChangeFlag - 1));
    if (msg.SubState_Behavior_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE &lt;&lt; (msg.SubState_Behavior_ChangeFlag - 1));
    if (msg.SubState_Perception_ChangeFlag)
      handleStateCmd(state_machine::DRIVE_DETECT_OBSTACLE_STATE &lt;&lt; (msg.SubState_Perception_ChangeFlag - 1));
  }
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);
  const autoware_msgs::traffic_light *light = event.getMessage().get();

  current_traffic_light = light-&gt;traffic_light;
  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
  {
    ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
	  }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;wp_lane : laneinArea.waypoints)
      {
	      for (auto &amp;lane : lane_array.lanes)
	      {
		      for(auto &amp;wp : lane.waypoints){
			      if(wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id){
				      wp.wpstate.steering_state = steering_state;
			      }
		      }
		      //lane.waypoints.at(wp_lane.lid).wpstate.steering_state = steering_state;
	      }
      }
    }
  }
  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) { 
        return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);});
  
  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
          geometry_msgs::Point bp =
              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
          geometry_msgs::Point fp =
              to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));
	 
          if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
          {
	    geometry_msgs::Point center_point;
	    center_point.x = (bp.x*2 + fp.x)/3;
	    center_point.y = (bp.y*2 + fp.y)/3;
	    if(amathutils::isPointLeftFromLine( 
				          center_point.x,
					  center_point.y,
           			          lane.waypoints.at(wp_idx).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx).pose.pose.position.y,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                          lane.waypoints.at(wp_idx + 1).pose.pose.position.y)){
		    lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
		    //lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
	    }
	  }
      }
    }
  }

}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  int gid = 0;
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int lid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  // steering
  size_t idx = current_finalwaypoints_.waypoints.size()-1 &gt; param_target_waypoint_?
	  param_target_waypoint_ : current_finalwaypoints_.waypoints.size()-1; 
  if(idx){
	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE)){
		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
	  }
	  if(isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE)){
		  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
	  }else{ 
		  ctx-&gt;setCurrentState(
			  getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
	  }
	  if(current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
		  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOP_STATE);
  }

  // for publish plan of velocity
  publishToVelocityArray();

#ifdef DEBUG_PRINT
  std::cout &lt;&lt; &quot;Velocity: &quot; &lt;&lt; current_velocity_ &lt;&lt; &quot; to &quot; &lt;&lt; average_velocity_ &lt;&lt; std::endl;
#endif
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -36,11 +36,13 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
 	current_stopped_lane_array_ = current_controlled_lane_array_;
 	for(auto &amp;lane : current_stopped_lane_array_.lanes)
+	{
+
 		for(auto &amp;wp: lane.waypoints){
 			wp.twist.twist.linear.x = 0.0;
 			wp.wpstate.stopline_state = 0;
 		}
-
+	}
 }
 
 void DecisionMakerNode::publishControlledLaneArray(void)
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;
#include &lt;autoware_msgs/lamp_cmd.h&gt;

namespace decision_maker
{

void DecisionMakerNode::setupStateCallback(void)
{
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)
      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)
      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)
      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
  
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_KEEP_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_ACCELERATION_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_DECELERATION_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));
}


void DecisionMakerNode::updateLaneWaypointsArray(void)
{
	current_stopped_lane_array_ = current_controlled_lane_array_;
	for(auto &amp;lane : current_stopped_lane_array_.lanes)
		for(auto &amp;wp: lane.waypoints){
			wp.twist.twist.linear.x = 0.0;
			wp.wpstate.stopline_state = 0;
		}

}

void DecisionMakerNode::publishControlledLaneArray(void)
{
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
	current_controlled_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
	for (auto &amp;lane : current_controlled_lane_array_.lanes)
	{
		autoware_msgs::lane temp_lane = lane;
		for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
		{
			double v0 = temp_lane.waypoints.at(wpi - 1).twist.twist.linear.x;
			double v = temp_lane.waypoints.at(wpi).twist.twist.linear.x;

			amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
					temp_lane.waypoints.at(wpi).pose.pose.position.y,
					temp_lane.waypoints.at(wpi).pose.pose.position.z);
			amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
					temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
					temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

			double distance = amathutils::find_distance(&amp;p0, &amp;p1);
			double _weight = distance * 0.05 * dir;
			lane.waypoints.at(wpi).twist.twist.linear.x =
				lane.waypoints.at(wpi).twist.twist.linear.x + lane.waypoints.at(wpi).twist.twist.linear.x * _weight;
		}
	}
}

void DecisionMakerNode::changedStateKeep(int status)
{
	changeVelocityBasedLane();
	publishControlledLaneArray();
}

void DecisionMakerNode::changedStateAcc(int status)
{
	changeVelocityLane(status);
	publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
	static ros::Timer stopping_timer;
	static bool timerflag = false;
	if(current_velocity_ == 0.0 &amp;&amp; !timerflag){
		stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE); ROS_INFO(&quot;Change state to keep from stop\n&quot;);timerflag=false; }, this, true);
		timerflag = true;
	}

}

void DecisionMakerNode::changedStateStop(int status)
{
	publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch(status){
	  case LAMP_LEFT:
		  lamp_msg.l = LAMP_ON;
		  lamp_msg.r = LAMP_OFF;
		  break;
	  case LAMP_RIGHT:
		  lamp_msg.l = LAMP_OFF;
		  lamp_msg.r = LAMP_ON;
		  break;
	  case LAMP_HAZARD:
		  lamp_msg.l = LAMP_ON;
		  lamp_msg.r = LAMP_ON;
		  break;
	  case LAMP_EMPTY:
	  default:
		  lamp_msg.l = LAMP_OFF;
		  lamp_msg.r = LAMP_OFF;
		  break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="df63fd03969b3d9583e4121e028e1e42bbb237fc" fix_time="2,12227">
		<msg>Fix not working changed callback</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp" new_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp">
				<diff>@@ -129,7 +129,7 @@ bool StateContext::setCurrentState(BaseState *_state)
 		  *HolderMap[getStateKind(_state)] = _state;
 	  }
 	  change_state_mutex.unlock();
-	  if(ret &amp;&amp; diff)
+	  if(ret &amp;&amp; !diff)
 		  this-&gt;changed(getStateKind(_state));
   }else{
 	  change_state_mutex.unlock();
</diff>
				<old_file>#include &lt;sched.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

#include &lt;cassert&gt;
#include &lt;mutex&gt;

#include &lt;state_context.hpp&gt;

#include &lt;state.hpp&gt;
#include &lt;state_common.hpp&gt;

/**
 *
 * @file StateContext.cpp
 * @brief state context class
 * @author Yusuke Fujii
 * @date  2017/07/25
 *
 **/

namespace state_machine
{
void StateContext::update(void)
{
  for (auto &amp;p : HolderMap)
  {
    if (*p.second)
    {
      (*p.second)-&gt;update();
    }
  }
}

void StateContext::changed(uint8_t _kind)
{
	if(_kind &gt;  UNKNOWN_STATE){
		return;
	}

	if(*HolderMap[_kind])
		(*HolderMap[_kind])-&gt;changed();
}


void StateContext::showCurrentStateName(void)
{
  for (auto &amp;p : HolderMap)
  {
    if (*p.second)
    {
      (*p.second)-&gt;showStateName();
    }
  }
}

bool StateContext::isDifferentState(BaseState *_state_a, BaseState **_state_b)
{
	if(_state_b){
		return _state_a == *_state_b;
	}else{
		return false;
	}
}

bool StateContext::isEmptyMainState(void)
{
  if (current_state_.MainState)
    return false;
  return true;
}

uint8_t StateContext::getStateKind(BaseState *_state)
{
  if (_state)
    return _state-&gt;getStateKind();
  else
    return UNKNOWN_STATE;
}

uint64_t StateContext::getStateTransMask(BaseState *_state)
{
  if (_state)
    return _state-&gt;getStateTransMask();
  else
    return 0;
}

uint64_t StateContext::getStateNum(BaseState *_state)
{
  if (_state)
    return _state-&gt;getStateNum();
  else
    return 0;
}

bool StateContext::isMainState(BaseState *_state)
{
  return getStateKind(_state) == MAIN_STATE;
}

bool StateContext::setCurrentState(BaseState *_state)
{
  change_state_mutex.lock();
  bool ret = true;
  if(_state){
	  bool diff = isDifferentState(_state, getCurrentStateHolderPtr(_state));
	  if (isMainState(_state))
	  {
		  if (isEmptyMainState() || enableForceSetState ||
				  (getStateTransMask(_state) &amp; getStateNum(current_state_.MainState)))
		  {
			  current_state_.MainState = _state;
			  current_state_.AccState = nullptr;
			  current_state_.StrState = nullptr;
			  current_state_.BehaviorState = nullptr;
			  current_state_.PerceptionState = nullptr;
			  current_state_.OtherState = nullptr;
		  }
		  else
		  {
			  ret = false;
		  }
	  }
	  else
	  {
		  *HolderMap[getStateKind(_state)] = _state;
	  }
	  change_state_mutex.unlock();
	  if(ret &amp;&amp; diff)
		  this-&gt;changed(getStateKind(_state));
  }else{
	  change_state_mutex.unlock();
	  ret = false;
  }
  return ret;
}

bool StateContext::setCurrentState(uint64_t flag)
{
  bool ret = this-&gt;setCurrentState(StateStores[flag]);
  return ret;
}

bool StateContext::setEnableForceSetState(bool force_flag)
{
  enableForceSetState = force_flag;
  return true;
}

std::string StateContext::getCurrentStateName(uint8_t _kind)
{
	if (*HolderMap[_kind])
		return (*HolderMap[_kind])-&gt;getStateName();
	return std::string(&quot;&quot;);
}

std::string StateContext::getCurrentStateName(void)
{
  return this-&gt;getCurrentStateName(MAIN_STATE);
}

BaseState *StateContext::getCurrentMainState(void)
{
  return current_state_.MainState;
}

BaseState *StateContext::getStateObject(uint64_t _state_num)
{
  return StateStores[_state_num];
}



BaseState **StateContext::getCurrentStateHolderPtr(uint8_t _kind)
{
	if(_kind &gt;  UNKNOWN_STATE){
		return nullptr;
	}
	return HolderMap[_kind];
}

BaseState **StateContext::getCurrentStateHolderPtr(uint64_t _state_num)
{
  return getCurrentStateHolderPtr(getStateKind(getStateObject(_state_num)));
}

BaseState **StateContext::getCurrentStateHolderPtr(BaseState *_state)
{
	if(_state)
		return getCurrentStateHolderPtr(getStateKind(_state));
	else
		return nullptr;
}

bool StateContext::disableCurrentState(uint64_t _state_num)
{
	if(isMainState(getStateObject(_state_num))){
		return false;
	}
	if(isCurrentState(_state_num)){
		(*getCurrentStateHolderPtr(_state_num)) = nullptr;
		return true;
	}else{
		return false;
	}
}

bool StateContext::isCurrentState(uint64_t _state_num)
{
	  BaseState **state_ptr = getCurrentStateHolderPtr(_state_num);
	  return  (state_ptr) ?isState(*state_ptr, _state_num):false;
}

bool StateContext::isState(BaseState *base, uint64_t _state_num)
{
  return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
}

bool StateContext::inState(uint64_t _state_num)
{
  if (current_state_.MainState)
  {
    return ((current_state_.MainState-&gt;getStateNum() &amp; _state_num) != 0) ? true : false;
  }
  else
  {
    return false;
  }
}

bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
{
  /* deprecated */
  return false;
}

std::string StateContext::createStateMessageText(void)
{
  std::string ret;

  for (auto &amp;p : HolderMap)
  {
    if (*p.second)
    {
      ret = ret + &quot;\n&quot; + (*p.second)-&gt;getStateName();
    }
  }
  return ret;
}

bool StateContext::handleTwistCmd(bool _hasTwistCmd)
{
  if (_hasTwistCmd)
    return this-&gt;setCurrentState(DRIVE_STATE);
  else
    return false;
}

void StateContext::stateDecider(void)
{
  // not running
}

void StateContext::InitContext(void)
{
  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
  thr_state_dec-&gt;detach();
  this-&gt;setCurrentState(START_STATE);
  return;
}
bool StateContext::TFInitialized(void)
{
  return this-&gt;setCurrentState(INITIAL_STATE);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -99,9 +99,9 @@ void DecisionMakerNode::changedStateAcc(int status)
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
+	static ros::Timer stopping_timer;
+	static bool timerflag = false;
 	if(status){
-		static ros::Timer stopping_timer;
-		static bool timerflag = false;
 		if(current_velocity_ == 0.0 &amp;&amp; !timerflag){
 			stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE); ROS_INFO(&quot;Change state to keep from stop\n&quot;);timerflag=false; }, this, true);
 			timerflag = true;
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;
#include &lt;autoware_msgs/lamp_cmd.h&gt;

namespace decision_maker
{


void DecisionMakerNode::setupStateCallback(void)
{
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_LEFT_STATE)
      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_RIGHT_STATE)
      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
  ctx-&gt;getStateObject(state_machine::DRIVE_STR_STRAIGHT_STATE)
      -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOPLINE_STATE)
       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOPLINE_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
       -&gt;setUpdateFunc(std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_STOP_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateStop, this, 0));
  
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_KEEP_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_ACCELERATION_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
  ctx-&gt;getStateObject(state_machine::DRIVE_ACC_DECELERATION_STATE)
       -&gt;setChangedFunc(std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));
}


void DecisionMakerNode::updateLaneWaypointsArray(void)
{
	current_stopped_lane_array_ = current_controlled_lane_array_;
	for(auto &amp;lane : current_stopped_lane_array_.lanes)
	{
		for(auto &amp;wp: lane.waypoints){
			wp.twist.twist.linear.x = 0.0;
			wp.wpstate.stopline_state = 0;
		}
	}
}

void DecisionMakerNode::publishControlledLaneArray(void)
{
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
	current_controlled_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
	for (auto &amp;lane : current_controlled_lane_array_.lanes)
	{
		autoware_msgs::lane temp_lane = lane;
		for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
		{
			amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
					temp_lane.waypoints.at(wpi).pose.pose.position.y,
					temp_lane.waypoints.at(wpi).pose.pose.position.z);
			amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
					temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
					temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

			double distance = amathutils::find_distance(&amp;p0, &amp;p1);
			double _weight = distance * 0.05 * dir;
			lane.waypoints.at(wpi).twist.twist.linear.x =
				lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
		}
	}
}

void DecisionMakerNode::changedStateKeep(int status)
{
	changeVelocityBasedLane();
	publishControlledLaneArray();
}

void DecisionMakerNode::changedStateAcc(int status)
{
	changeVelocityLane(status);
	publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
	if(status){
		static ros::Timer stopping_timer;
		static bool timerflag = false;
		if(current_velocity_ == 0.0 &amp;&amp; !timerflag){
			stopping_timer = nh_.createTimer(ros::Duration(1), [&amp;](const ros::TimerEvent&amp;){ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE); ROS_INFO(&quot;Change state to keep from stop\n&quot;);timerflag=false; }, this, true);
			timerflag = true;
		}
	}
}

void DecisionMakerNode::changedStateStop(int status)
{
	publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch(status){
	  case LAMP_LEFT:
		  lamp_msg.l = LAMP_ON;
		  lamp_msg.r = LAMP_OFF;
		  break;
	  case LAMP_RIGHT:
		  lamp_msg.l = LAMP_OFF;
		  lamp_msg.r = LAMP_ON;
		  break;
	  case LAMP_HAZARD:
		  lamp_msg.l = LAMP_ON;
		  lamp_msg.r = LAMP_ON;
		  break;
	  case LAMP_EMPTY:
	  default:
		  lamp_msg.l = LAMP_OFF;
		  lamp_msg.r = LAMP_OFF;
		  break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="df4b95593f10d2a0db5070afdd76ed61e71dbde6" fix_time="39,82920">
		<msg>fixed CMakeLists and compile error</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp">
				<diff>@@ -39,6 +39,7 @@
 #include &lt;iostream&gt;
 #include &lt;sstream&gt;
 #include &lt;string&gt;
+#include &lt;memory&gt;
 #include &lt;pthread.h&gt;
 
 #include &lt;ros/ros.h&gt;
@@ -115,7 +116,7 @@ static int _use_gnss = 1;
 static int init_pos_set = 0;
 
 #ifdef CUDA_FOUND
-static gpu::GNormalDistributionsTransform gpu_ndt;
+static std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
 #endif
 static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;
 
@@ -260,7 +261,7 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setResolution(ndt_res);
+      gpu_ndt_ptr-&gt;setResolution(ndt_res);
     }
     else
     {
@@ -276,7 +277,7 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setStepSize(step_size);
+      gpu_ndt_ptr-&gt;setStepSize(step_size);
     }
     else
     {
@@ -292,7 +293,7 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setTransformationEpsilon(trans_eps);
+      gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
     }
     else
     {
@@ -308,7 +309,7 @@ static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setMaximumIterations(max_iter);
+      gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
     }
     else
     {
@@ -426,19 +427,27 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_gpu_ndt;
-      new_gpu_ndt.setInputTarget(map_ptr);
-      new_gpu_ndt.setMaximumIterations(max_iter);
-      new_gpu_ndt.setResolution(ndt_res);
-      new_gpu_ndt.setStepSize(step_size);
-      new_gpu_ndt.setTransformationEpsilon(trans_eps);
-      new_gpu_ndt.align(Eigen::Matrix4f::Identity());
+      std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
+      new_gpu_ndt_ptr-&gt;setInputTarget(map_ptr);
+      new_gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
+      new_gpu_ndt_ptr-&gt;setResolution(ndt_res);
+      new_gpu_ndt_ptr-&gt;setStepSize(step_size);
+      new_gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
+
+      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr dummy_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;());
+      pcl::PointXYZ dummy_point;
+      dummy_scan_ptr-&gt;push_back(dummy_point);
+      new_gpu_ndt_ptr-&gt;setInputSource(dummy_scan_ptr);
+
+      new_gpu_ndt_ptr-&gt;align(Eigen::Matrix4f::Identity());
+
       pthread_mutex_lock(&amp;mutex);
-      gpu_ndt = new_gpu_ndt;
+      gpu_ndt_ptr = new_gpu_ndt_ptr;
       pthread_mutex_unlock(&amp;mutex);
+    }
     else
-    {
 #endif
+    {
       pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;
       pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
       new_ndt.setInputTarget(map_ptr);
@@ -456,9 +465,7 @@ static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
       pthread_mutex_lock(&amp;mutex);
       ndt = new_ndt;
       pthread_mutex_unlock(&amp;mutex);
-#ifdef CUDA_FOUND
     }
-#endif
 
     map_loaded = 1;
   }
@@ -844,7 +851,7 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
 #ifdef CUDA_FOUND
     if (_use_gpu == true)
     {
-      gpu_ndt.setInputSource(filtered_scan_ptr);
+      gpu_ndt_ptr-&gt;setInputSource(filtered_scan_ptr);
     }
     else
     {
@@ -891,19 +898,19 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
     if (_use_gpu == true)
     {
       align_start = std::chrono::system_clock::now();
-      gpu_ndt.align(init_guess);
+      gpu_ndt_ptr-&gt;align(init_guess);
       align_end = std::chrono::system_clock::now();
 
-      has_converged = gpu_ndt.hasConverged();
+      has_converged = gpu_ndt_ptr-&gt;hasConverged();
 
-      t = gpu_ndt.getFinalTransformation();
-      iteration = gpu_ndt.getFinalNumIteration();
+      t = gpu_ndt_ptr-&gt;getFinalTransformation();
+      iteration = gpu_ndt_ptr-&gt;getFinalNumIteration();
 
       getFitnessScore_start = std::chrono::system_clock::now();
-      fitness_score = gpu_ndt.getFitnessScore();
+      fitness_score = gpu_ndt_ptr-&gt;getFitnessScore();
       getFitnessScore_end = std::chrono::system_clock::now();
 
-      trans_probability = gpu_ndt.getTransformationProbability();
+      trans_probability = gpu_ndt_ptr-&gt;getTransformationProbability();
     }
 #ifdef USE_FAST_PCL
     else if (_use_openmp == true)
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;pthread.h&gt;

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;

#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;tf/transform_listener.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#ifdef USE_FAST_PCL
  #include &lt;fast_pcl/registration/ndt.h&gt;
#else
  #include &lt;pcl/registration/ndt.h&gt;
#endif
#ifdef CUDA_FOUND
  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
#endif

#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_ros/transforms.h&gt;

#include &lt;autoware_msgs/ConfigNdt.h&gt;

#include &lt;autoware_msgs/ndt_stat.h&gt;

#define PREDICT_POSE_THRESHOLD 0.5

#define Wa 0.4
#define Wb 0.3
#define Wc 0.3

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose,
    ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose,
    previous_gnss_pose, current_gnss_pose;

static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
    offset_imu_odom_yaw;

// Can't load if typed &quot;pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;&quot;
static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;

// If the map is loaded, map_loaded will be 1.
static int map_loaded = 0;
static int _use_gnss = 1;
static int init_pos_set = 0;

#ifdef CUDA_FOUND
static gpu::GNormalDistributionsTransform gpu_ndt;
#endif
static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;

// Default values
static int max_iter = 30;        // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

static ros::Publisher predict_pose_pub;
static geometry_msgs::PoseStamped predict_pose_msg;

static ros::Publisher predict_pose_imu_pub;
static geometry_msgs::PoseStamped predict_pose_imu_msg;

static ros::Publisher predict_pose_odom_pub;
static geometry_msgs::PoseStamped predict_pose_odom_msg;

static ros::Publisher predict_pose_imu_odom_pub;
static geometry_msgs::PoseStamped predict_pose_imu_odom_msg;

static ros::Publisher ndt_pose_pub;
static geometry_msgs::PoseStamped ndt_pose_msg;

// current_pose is published by vel_pose_mux
/*
static ros::Publisher current_pose_pub;
static geometry_msgs::PoseStamped current_pose_msg;
*/

static ros::Publisher localizer_pose_pub;
static geometry_msgs::PoseStamped localizer_pose_msg;

static ros::Publisher estimate_twist_pub;
static geometry_msgs::TwistStamped estimate_twist_msg;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double exe_time = 0.0;
static bool has_converged;
static int iteration = 0;
static double fitness_score = 0.0;
static double trans_probability = 0.0;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;

static double current_velocity = 0.0, previous_velocity = 0.0, previous_previous_velocity = 0.0;  // [m/s]
static double current_velocity_x = 0.0, previous_velocity_x = 0.0;
static double current_velocity_y = 0.0, previous_velocity_y = 0.0;
static double current_velocity_z = 0.0, previous_velocity_z = 0.0;
// static double current_velocity_yaw = 0.0, previous_velocity_yaw = 0.0;
static double current_velocity_smooth = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static double current_accel = 0.0, previous_accel = 0.0;  // [m/s^2]
static double current_accel_x = 0.0;
static double current_accel_y = 0.0;
static double current_accel_z = 0.0;
// static double current_accel_yaw = 0.0;

static double angular_velocity = 0.0;

static int use_predict_pose = 0;

static ros::Publisher estimated_vel_mps_pub, estimated_vel_kmph_pub, estimated_vel_pub;
static std_msgs::Float32 estimated_vel_mps, estimated_vel_kmph, previous_estimated_vel_kmph;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; matching_start, matching_end;

static ros::Publisher time_ndt_matching_pub;
static std_msgs::Float32 time_ndt_matching;

static int _queue_size = 1000;

static ros::Publisher ndt_stat_pub;
static autoware_msgs::ndt_stat ndt_stat_msg;

static double predict_pose_error = 0.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol;

static std::string _localizer = &quot;velodyne&quot;;
static std::string _offset = &quot;linear&quot;;  // linear, zero, quadratic

static ros::Publisher ndt_reliability_pub;
static std_msgs::Float32 ndt_reliability;

#ifdef CUDA_FOUND
static bool _use_gpu = false;
#endif
#ifdef USE_FAST_PCL
static bool _use_openmp = false;
#endif

static bool _get_height = false;
static bool _use_local_transform = false;
static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;

static std::ofstream ofs;
static std::string filename;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;

// static tf::TransformListener local_transform_listener;
static tf::StampedTransform local_transform;

static int points_map_num = 0;

pthread_mutex_t mutex;

static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
{
  if (_use_gnss != input-&gt;init_pos_gnss)
  {
    init_pos_set = 0;
  }
  else if (_use_gnss == 0 &amp;&amp;
           (initial_pose.x != input-&gt;x || initial_pose.y != input-&gt;y || initial_pose.z != input-&gt;z ||
            initial_pose.roll != input-&gt;roll || initial_pose.pitch != input-&gt;pitch || initial_pose.yaw != input-&gt;yaw))
  {
    init_pos_set = 0;
  }

  _use_gnss = input-&gt;init_pos_gnss;

  // Setting parameters
  if (input-&gt;resolution != ndt_res)
  {
    ndt_res = input-&gt;resolution;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setResolution(ndt_res);
    }
    else
    {
#endif
      ndt.setResolution(ndt_res);
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;step_size != step_size)
  {
    step_size = input-&gt;step_size;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setStepSize(step_size);
    }
    else
    {
#endif
      ndt.setStepSize(step_size);
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;trans_epsilon != trans_eps)
  {
    trans_eps = input-&gt;trans_epsilon;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setTransformationEpsilon(trans_eps);
    }
    else
    {
#endif
      ndt.setTransformationEpsilon(trans_eps);
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;max_iterations != max_iter)
  {
    max_iter = input-&gt;max_iterations;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setMaximumIterations(max_iter);
    }
    else
    {
#endif
      ndt.setMaximumIterations(max_iter);
#ifdef CUDA_FOUND
    }
#endif
  }

  if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
  {
    initial_pose.x = input-&gt;x;
    initial_pose.y = input-&gt;y;
    initial_pose.z = input-&gt;z;
    initial_pose.roll = input-&gt;roll;
    initial_pose.pitch = input-&gt;pitch;
    initial_pose.yaw = input-&gt;yaw;

    if (_use_local_transform == true)
    {
      tf::Vector3 v(input-&gt;x, input-&gt;y, input-&gt;z);
      tf::Quaternion q;
      q.setRPY(input-&gt;roll, input-&gt;pitch, input-&gt;yaw);
      tf::Transform transform(q, v);
      initial_pose.x = (local_transform.inverse() * transform).getOrigin().getX();
      initial_pose.y = (local_transform.inverse() * transform).getOrigin().getY();
      initial_pose.z = (local_transform.inverse() * transform).getOrigin().getZ();

      tf::Matrix3x3 m(q);
      m.getRPY(initial_pose.roll, initial_pose.pitch, initial_pose.yaw);

      std::cout &lt;&lt; &quot;initial_pose.x: &quot; &lt;&lt; initial_pose.x &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.y: &quot; &lt;&lt; initial_pose.y &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.z: &quot; &lt;&lt; initial_pose.z &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.roll: &quot; &lt;&lt; initial_pose.roll &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.pitch: &quot; &lt;&lt; initial_pose.pitch &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.yaw: &quot; &lt;&lt; initial_pose.yaw &lt;&lt; std::endl;
    }

    // Setting position and posture for the first time.
    localizer_pose.x = initial_pose.x;
    localizer_pose.y = initial_pose.y;
    localizer_pose.z = initial_pose.z;
    localizer_pose.roll = initial_pose.roll;
    localizer_pose.pitch = initial_pose.pitch;
    localizer_pose.yaw = initial_pose.yaw;

    previous_pose.x = initial_pose.x;
    previous_pose.y = initial_pose.y;
    previous_pose.z = initial_pose.z;
    previous_pose.roll = initial_pose.roll;
    previous_pose.pitch = initial_pose.pitch;
    previous_pose.yaw = initial_pose.yaw;

    current_pose.x = initial_pose.x;
    current_pose.y = initial_pose.y;
    current_pose.z = initial_pose.z;
    current_pose.roll = initial_pose.roll;
    current_pose.pitch = initial_pose.pitch;
    current_pose.yaw = initial_pose.yaw;

    current_velocity = 0;
    current_velocity_x = 0;
    current_velocity_y = 0;
    current_velocity_z = 0;
    angular_velocity = 0;

    current_pose_imu.x = 0;
    current_pose_imu.y = 0;
    current_pose_imu.z = 0;
    current_pose_imu.roll = 0;
    current_pose_imu.pitch = 0;
    current_pose_imu.yaw = 0;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;
    init_pos_set = 1;
  }
}

static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  // if (map_loaded == 0)
  if (points_map_num != input-&gt;width)
  {
    std::cout &lt;&lt; &quot;Update points_map.&quot; &lt;&lt; std::endl;

    points_map_num = input-&gt;width;

    // Convert the data type(from sensor_msgs to pcl).
    pcl::fromROSMsg(*input, map);

    if (_use_local_transform == true)
    {
      tf::TransformListener local_transform_listener;
      try
      {
        ros::Time now = ros::Time(0);
        local_transform_listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
        local_transform_listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, local_transform);
      }
      catch (tf::TransformException&amp; ex)
      {
        ROS_ERROR(&quot;%s&quot;, ex.what());
      }

      pcl_ros::transformPointCloud(map, map, local_transform.inverse());
    }

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));

// Setting point cloud to be aligned to.
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_gpu_ndt;
      new_gpu_ndt.setInputTarget(map_ptr);
      new_gpu_ndt.setMaximumIterations(max_iter);
      new_gpu_ndt.setResolution(ndt_res);
      new_gpu_ndt.setStepSize(step_size);
      new_gpu_ndt.setTransformationEpsilon(trans_eps);
      new_gpu_ndt.align(Eigen::Matrix4f::Identity());
      pthread_mutex_lock(&amp;mutex);
      gpu_ndt = new_gpu_ndt;
      pthread_mutex_unlock(&amp;mutex);
    else
    {
#endif
      pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;
      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
      new_ndt.setInputTarget(map_ptr);
      new_ndt.setMaximumIterations(max_iter);
      new_ndt.setResolution(ndt_res);
      new_ndt.setStepSize(step_size);
      new_ndt.setTransformationEpsilon(trans_eps);
      #ifdef USE_FAST_PCL
          if (_use_openmp == true)
              new_ndt.omp_align(*output_cloud, Eigen::Matrix4f::Identity());
          else
      #endif
              new_ndt.align(*output_cloud, Eigen::Matrix4f::Identity());

      pthread_mutex_lock(&amp;mutex);
      ndt = new_ndt;
      pthread_mutex_unlock(&amp;mutex);
#ifdef CUDA_FOUND
    }
#endif

    map_loaded = 1;
  }
}

static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
{
  tf::Quaternion gnss_q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z,
                        input-&gt;pose.orientation.w);
  tf::Matrix3x3 gnss_m(gnss_q);
  current_gnss_pose.x = input-&gt;pose.position.x;
  current_gnss_pose.y = input-&gt;pose.position.y;
  current_gnss_pose.z = input-&gt;pose.position.z;
  gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);

  if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= 500.0)
  {
    previous_pose.x = previous_gnss_pose.x;
    previous_pose.y = previous_gnss_pose.y;
    previous_pose.z = previous_gnss_pose.z;
    previous_pose.roll = previous_gnss_pose.roll;
    previous_pose.pitch = previous_gnss_pose.pitch;
    previous_pose.yaw = previous_gnss_pose.yaw;

    current_pose.x = current_gnss_pose.x;
    current_pose.y = current_gnss_pose.y;
    current_pose.z = current_gnss_pose.z;
    current_pose.roll = current_gnss_pose.roll;
    current_pose.pitch = current_gnss_pose.pitch;
    current_pose.yaw = current_gnss_pose.yaw;

    current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;

    offset_x = current_pose.x - previous_pose.x;
    offset_y = current_pose.y - previous_pose.y;
    offset_z = current_pose.z - previous_pose.z;
    offset_yaw = current_pose.yaw - previous_pose.yaw;

    init_pos_set = 1;
  }

  previous_gnss_pose.x = current_gnss_pose.x;
  previous_gnss_pose.y = current_gnss_pose.y;
  previous_gnss_pose.z = current_gnss_pose.z;
  previous_gnss_pose.roll = current_gnss_pose.roll;
  previous_gnss_pose.pitch = current_gnss_pose.pitch;
  previous_gnss_pose.yaw = current_gnss_pose.yaw;
}

static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
{
  tf::TransformListener listener;
  tf::StampedTransform transform;
  try
  {
    ros::Time now = ros::Time(0);
    listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
    listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, transform);
  }
  catch (tf::TransformException&amp; ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
  }

  tf::Quaternion q(input-&gt;pose.pose.orientation.x, input-&gt;pose.pose.orientation.y, input-&gt;pose.pose.orientation.z,
                   input-&gt;pose.pose.orientation.w);
  tf::Matrix3x3 m(q);

  if (_use_local_transform == true)
  {
    current_pose.x = input-&gt;pose.pose.position.x;
    current_pose.y = input-&gt;pose.pose.position.y;
    current_pose.z = input-&gt;pose.pose.position.z;
  }
  else
  {
    current_pose.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
    current_pose.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
    current_pose.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
  }
  m.getRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);

  if (_get_height == true &amp;&amp; map_loaded == 1)
  {
    double min_distance = DBL_MAX;
    double nearest_z = current_pose.z;
    for (const auto&amp; p : map)
    {
      double distance = hypot(current_pose.x - p.x, current_pose.y - p.y);
      if (distance &lt; min_distance)
      {
        min_distance = distance;
        nearest_z = p.z;
      }
    }
    current_pose.z = nearest_z;
  }

  current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  offset_x = 0.0;
  offset_y = 0.0;
  offset_z = 0.0;
  offset_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;
}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw += diff_imu_yaw;

  predict_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
  predict_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
  predict_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
  predict_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
  predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  predict_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;

  previous_time = current_time;
}

static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);

  offset_odom_roll += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw += diff_odom_yaw;

  predict_pose_odom.x = previous_pose.x + offset_odom_x;
  predict_pose_odom.y = previous_pose.y + offset_odom_y;
  predict_pose_odom.z = previous_pose.z + offset_odom_z;
  predict_pose_odom.roll = previous_pose.roll + offset_odom_roll;
  predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  predict_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;

  previous_time = current_time;
}

static void imu_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw += diff_imu_yaw;

  predict_pose_imu.x = previous_pose.x + offset_imu_x;
  predict_pose_imu.y = previous_pose.y + offset_imu_y;
  predict_pose_imu.z = previous_pose.z + offset_imu_z;
  predict_pose_imu.roll = previous_pose.roll + offset_imu_roll;
  predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  predict_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;

  previous_time = current_time;
}

static const double wrapToPm(double a_num, const double a_max)
{
  if (a_num &gt;= a_max)
  {
    a_num -= 2.0 * a_max;
  }
  return a_num;
}

static const double wrapToPmPi(double a_angle_rad)
{
  return wrapToPm(a_angle_rad, M_PI);
}

static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}

static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll *= -1;
  input_pitch *= -1;
  input_yaw *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}

static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if (_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time = (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll = imu_roll - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if (imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
    else
      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
  }
  else
    diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if (diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw = imu_yaw;
}

static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
  {
    matching_start = std::chrono::system_clock::now();

    static tf::TransformBroadcaster br;
    tf::Transform transform;
    tf::Quaternion predict_q, ndt_q, current_q, localizer_q;

    pcl::PointXYZ p;
    pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;

    current_scan_time = input-&gt;header.stamp;

    pcl::fromROSMsg(*input, filtered_scan);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan));
    int scan_points_num = filtered_scan_ptr-&gt;size();

    Eigen::Matrix4f t(Eigen::Matrix4f::Identity());   // base_link
    Eigen::Matrix4f t2(Eigen::Matrix4f::Identity());  // localizer

    std::chrono::time_point&lt;std::chrono::system_clock&gt; align_start, align_end, getFitnessScore_start,
        getFitnessScore_end;
    static double align_time, getFitnessScore_time = 0.0;

    pthread_mutex_lock(&amp;mutex);
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt.setInputSource(filtered_scan_ptr);
    }
    else
    {
#endif
      ndt.setInputSource(filtered_scan_ptr);
#ifdef CUDA_FOUND
    }
#endif

    // Guess the initial gross estimation of the transformation
    predict_pose.x = previous_pose.x + offset_x;
    predict_pose.y = previous_pose.y + offset_y;
    predict_pose.z = previous_pose.z + offset_z;
    predict_pose.roll = previous_pose.roll;
    predict_pose.pitch = previous_pose.pitch;
    predict_pose.yaw = previous_pose.yaw + offset_yaw;

    if (_use_imu == true &amp;&amp; _use_odom == true)
      imu_odom_calc(current_scan_time);
    if (_use_imu == true &amp;&amp; _use_odom == false)
      imu_calc(current_scan_time);
    if (_use_imu == false &amp;&amp; _use_odom == true)
      odom_calc(current_scan_time);

    pose predict_pose_for_ndt;
    if (_use_imu == true &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_imu_odom;
    else if (_use_imu == true &amp;&amp; _use_odom == false)
      predict_pose_for_ndt = predict_pose_imu;
    else if (_use_imu == false &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_odom;
    else
      predict_pose_for_ndt = predict_pose;

    Eigen::Translation3f init_translation(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z);
    Eigen::AngleAxisf init_rotation_x(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
    Eigen::AngleAxisf init_rotation_y(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
    Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);

#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      align_start = std::chrono::system_clock::now();
      gpu_ndt.align(init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = gpu_ndt.hasConverged();

      t = gpu_ndt.getFinalTransformation();
      iteration = gpu_ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = gpu_ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = gpu_ndt.getTransformationProbability();
    }
#ifdef USE_FAST_PCL
    else if (_use_openmp == true)
    {
      align_start = std::chrono::system_clock::now();
      ndt.omp_align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.omp_getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
    }
#endif
    else
    {
      align_start = std::chrono::system_clock::now();
      ndt.align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
    }
#else
#ifdef USE_FAST_PCL
    if (_use_openmp == true)
    {
      align_start = std::chrono::system_clock::now();
      ndt.omp_align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.omp_getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
    }
    else
    {
#endif
      align_start = std::chrono::system_clock::now();
      ndt.align(*output_cloud, init_guess);
      align_end = std::chrono::system_clock::now();

      has_converged = ndt.hasConverged();

      t = ndt.getFinalTransformation();
      iteration = ndt.getFinalNumIteration();

      getFitnessScore_start = std::chrono::system_clock::now();
      fitness_score = ndt.getFitnessScore();
      getFitnessScore_end = std::chrono::system_clock::now();

      trans_probability = ndt.getTransformationProbability();
#ifdef USE_FAST_PCL
    }
#endif
#endif

    align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;

    t2 = t * tf_btol.inverse();

    getFitnessScore_time =
        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() /
        1000.0;

    pthread_mutex_unlock(&amp;mutex);

    tf::Matrix3x3 mat_l;  // localizer
    mat_l.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)),
                   static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)),
                   static_cast&lt;double&gt;(t(2, 0)), static_cast&lt;double&gt;(t(2, 1)), static_cast&lt;double&gt;(t(2, 2)));

    // Update localizer_pose
    localizer_pose.x = t(0, 3);
    localizer_pose.y = t(1, 3);
    localizer_pose.z = t(2, 3);
    mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

    tf::Matrix3x3 mat_b;  // base_link
    mat_b.setValue(static_cast&lt;double&gt;(t2(0, 0)), static_cast&lt;double&gt;(t2(0, 1)), static_cast&lt;double&gt;(t2(0, 2)),
                   static_cast&lt;double&gt;(t2(1, 0)), static_cast&lt;double&gt;(t2(1, 1)), static_cast&lt;double&gt;(t2(1, 2)),
                   static_cast&lt;double&gt;(t2(2, 0)), static_cast&lt;double&gt;(t2(2, 1)), static_cast&lt;double&gt;(t2(2, 2)));

    // Update ndt_pose
    ndt_pose.x = t2(0, 3);
    ndt_pose.y = t2(1, 3);
    ndt_pose.z = t2(2, 3);
    mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

    // Calculate the difference between ndt_pose and predict_pose
    predict_pose_error = sqrt((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) +
                              (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) +
                              (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));

    if (predict_pose_error &lt;= PREDICT_POSE_THRESHOLD)
    {
      use_predict_pose = 0;
    }
    else
    {
      use_predict_pose = 1;
    }
    use_predict_pose = 0;

    if (use_predict_pose == 0)
    {
      current_pose.x = ndt_pose.x;
      current_pose.y = ndt_pose.y;
      current_pose.z = ndt_pose.z;
      current_pose.roll = ndt_pose.roll;
      current_pose.pitch = ndt_pose.pitch;
      current_pose.yaw = ndt_pose.yaw;
    }
    else
    {
      current_pose.x = predict_pose_for_ndt.x;
      current_pose.y = predict_pose_for_ndt.y;
      current_pose.z = predict_pose_for_ndt.z;
      current_pose.roll = predict_pose_for_ndt.roll;
      current_pose.pitch = predict_pose_for_ndt.pitch;
      current_pose.yaw = predict_pose_for_ndt.yaw;
    }

    // Compute the velocity and acceleration
    scan_duration = current_scan_time - previous_scan_time;
    double secs = scan_duration.toSec();
    diff_x = current_pose.x - previous_pose.x;
    diff_y = current_pose.y - previous_pose.y;
    diff_z = current_pose.z - previous_pose.z;
    diff_yaw = current_pose.yaw - previous_pose.yaw;
    diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

    current_velocity = diff / secs;
    current_velocity_x = diff_x / secs;
    current_velocity_y = diff_y / secs;
    current_velocity_z = diff_z / secs;
    angular_velocity = diff_yaw / secs;

    current_pose_imu.x = current_pose.x;
    current_pose_imu.y = current_pose.y;
    current_pose_imu.z = current_pose.z;
    current_pose_imu.roll = current_pose.roll;
    current_pose_imu.pitch = current_pose.pitch;
    current_pose_imu.yaw = current_pose.yaw;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;

    current_pose_odom.x = current_pose.x;
    current_pose_odom.y = current_pose.y;
    current_pose_odom.z = current_pose.z;
    current_pose_odom.roll = current_pose.roll;
    current_pose_odom.pitch = current_pose.pitch;
    current_pose_odom.yaw = current_pose.yaw;

    current_pose_imu_odom.x = current_pose.x;
    current_pose_imu_odom.y = current_pose.y;
    current_pose_imu_odom.z = current_pose.z;
    current_pose_imu_odom.roll = current_pose.roll;
    current_pose_imu_odom.pitch = current_pose.pitch;
    current_pose_imu_odom.yaw = current_pose.yaw;

    current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
    if (current_velocity_smooth &lt; 0.2)
    {
      current_velocity_smooth = 0.0;
    }

    current_accel = (current_velocity - previous_velocity) / secs;
    current_accel_x = (current_velocity_x - previous_velocity_x) / secs;
    current_accel_y = (current_velocity_y - previous_velocity_y) / secs;
    current_accel_z = (current_velocity_z - previous_velocity_z) / secs;

    estimated_vel_mps.data = current_velocity;
    estimated_vel_kmph.data = current_velocity * 3.6;

    estimated_vel_mps_pub.publish(estimated_vel_mps);
    estimated_vel_kmph_pub.publish(estimated_vel_kmph);

    // Set values for publishing pose
    predict_q.setRPY(predict_pose.roll, predict_pose.pitch, predict_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(predict_pose.x, predict_pose.y, predict_pose.z);
      tf::Transform transform(predict_q, v);
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      predict_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      predict_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      predict_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      predict_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      predict_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      predict_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = predict_pose.x;
      predict_pose_msg.pose.position.y = predict_pose.y;
      predict_pose_msg.pose.position.z = predict_pose.z;
      predict_pose_msg.pose.orientation.x = predict_q.x();
      predict_pose_msg.pose.orientation.y = predict_q.y();
      predict_pose_msg.pose.orientation.z = predict_q.z();
      predict_pose_msg.pose.orientation.w = predict_q.w();
    }

    tf::Quaternion predict_q_imu;
    predict_q_imu.setRPY(predict_pose_imu.roll, predict_pose_imu.pitch, predict_pose_imu.yaw);
    predict_pose_imu_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_msg.pose.position.x = predict_pose_imu.x;
    predict_pose_imu_msg.pose.position.y = predict_pose_imu.y;
    predict_pose_imu_msg.pose.position.z = predict_pose_imu.z;
    predict_pose_imu_msg.pose.orientation.x = predict_q_imu.x();
    predict_pose_imu_msg.pose.orientation.y = predict_q_imu.y();
    predict_pose_imu_msg.pose.orientation.z = predict_q_imu.z();
    predict_pose_imu_msg.pose.orientation.w = predict_q_imu.w();
    predict_pose_imu_pub.publish(predict_pose_imu_msg);

    tf::Quaternion predict_q_odom;
    predict_q_odom.setRPY(predict_pose_odom.roll, predict_pose_odom.pitch, predict_pose_odom.yaw);
    predict_pose_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_odom_msg.pose.position.x = predict_pose_odom.x;
    predict_pose_odom_msg.pose.position.y = predict_pose_odom.y;
    predict_pose_odom_msg.pose.position.z = predict_pose_odom.z;
    predict_pose_odom_msg.pose.orientation.x = predict_q_odom.x();
    predict_pose_odom_msg.pose.orientation.y = predict_q_odom.y();
    predict_pose_odom_msg.pose.orientation.z = predict_q_odom.z();
    predict_pose_odom_msg.pose.orientation.w = predict_q_odom.w();
    predict_pose_odom_pub.publish(predict_pose_odom_msg);

    tf::Quaternion predict_q_imu_odom;
    predict_q_imu_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
    predict_pose_imu_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_odom_msg.pose.position.x = predict_pose_imu_odom.x;
    predict_pose_imu_odom_msg.pose.position.y = predict_pose_imu_odom.y;
    predict_pose_imu_odom_msg.pose.position.z = predict_pose_imu_odom.z;
    predict_pose_imu_odom_msg.pose.orientation.x = predict_q_imu_odom.x();
    predict_pose_imu_odom_msg.pose.orientation.y = predict_q_imu_odom.y();
    predict_pose_imu_odom_msg.pose.orientation.z = predict_q_imu_odom.z();
    predict_pose_imu_odom_msg.pose.orientation.w = predict_q_imu_odom.w();
    predict_pose_imu_odom_pub.publish(predict_pose_imu_odom_msg);

    ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(ndt_pose.x, ndt_pose.y, ndt_pose.z);
      tf::Transform transform(ndt_q, v);
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      ndt_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      ndt_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      ndt_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      ndt_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      ndt_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      ndt_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = ndt_pose.x;
      ndt_pose_msg.pose.position.y = ndt_pose.y;
      ndt_pose_msg.pose.position.z = ndt_pose.z;
      ndt_pose_msg.pose.orientation.x = ndt_q.x();
      ndt_pose_msg.pose.orientation.y = ndt_q.y();
      ndt_pose_msg.pose.orientation.z = ndt_q.z();
      ndt_pose_msg.pose.orientation.w = ndt_q.w();
    }

    current_q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
    // current_pose is published by vel_pose_mux
    /*
    current_pose_msg.header.frame_id = &quot;/map&quot;;
    current_pose_msg.header.stamp = current_scan_time;
    current_pose_msg.pose.position.x = current_pose.x;
    current_pose_msg.pose.position.y = current_pose.y;
    current_pose_msg.pose.position.z = current_pose.z;
    current_pose_msg.pose.orientation.x = current_q.x();
    current_pose_msg.pose.orientation.y = current_q.y();
    current_pose_msg.pose.orientation.z = current_q.z();
    current_pose_msg.pose.orientation.w = current_q.w();
    */

    localizer_q.setRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(localizer_pose.x, localizer_pose.y, localizer_pose.z);
      tf::Transform transform(localizer_q, v);
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      localizer_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      localizer_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      localizer_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      localizer_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      localizer_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      localizer_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = localizer_pose.x;
      localizer_pose_msg.pose.position.y = localizer_pose.y;
      localizer_pose_msg.pose.position.z = localizer_pose.z;
      localizer_pose_msg.pose.orientation.x = localizer_q.x();
      localizer_pose_msg.pose.orientation.y = localizer_q.y();
      localizer_pose_msg.pose.orientation.z = localizer_q.z();
      localizer_pose_msg.pose.orientation.w = localizer_q.w();
    }

    predict_pose_pub.publish(predict_pose_msg);
    ndt_pose_pub.publish(ndt_pose_msg);
    // current_pose is published by vel_pose_mux
    //    current_pose_pub.publish(current_pose_msg);
    localizer_pose_pub.publish(localizer_pose_msg);

    // Send TF &quot;/base_link&quot; to &quot;/map&quot;
    transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
    transform.setRotation(current_q);
    //    br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    if (_use_local_transform == true)
    {
      br.sendTransform(tf::StampedTransform(local_transform * transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }
    else
    {
      br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }

    matching_end = std::chrono::system_clock::now();
    exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
    time_ndt_matching.data = exe_time;
    time_ndt_matching_pub.publish(time_ndt_matching);

    // Set values for /estimate_twist
    estimate_twist_msg.header.stamp = current_scan_time;
    estimate_twist_msg.header.frame_id = &quot;/base_link&quot;;
    estimate_twist_msg.twist.linear.x = current_velocity;
    estimate_twist_msg.twist.linear.y = 0.0;
    estimate_twist_msg.twist.linear.z = 0.0;
    estimate_twist_msg.twist.angular.x = 0.0;
    estimate_twist_msg.twist.angular.y = 0.0;
    estimate_twist_msg.twist.angular.z = angular_velocity;

    estimate_twist_pub.publish(estimate_twist_msg);

    geometry_msgs::Vector3Stamped estimate_vel_msg;
    estimate_vel_msg.header.stamp = current_scan_time;
    estimate_vel_msg.vector.x = current_velocity;
    estimated_vel_pub.publish(estimate_vel_msg);

    // Set values for /ndt_stat
    ndt_stat_msg.header.stamp = current_scan_time;
    ndt_stat_msg.exe_time = time_ndt_matching.data;
    ndt_stat_msg.iteration = iteration;
    ndt_stat_msg.score = fitness_score;
    ndt_stat_msg.velocity = current_velocity;
    ndt_stat_msg.acceleration = current_accel;
    ndt_stat_msg.use_predict_pose = 0;

    ndt_stat_pub.publish(ndt_stat_msg);
    /* Compute NDT_Reliability */
    ndt_reliability.data = Wa * (exe_time / 100.0) * 100.0 + Wb * (iteration / 10.0) * 100.0 +
                           Wc * ((2.0 - trans_probability) / 2.0) * 100.0;
    ndt_reliability_pub.publish(ndt_reliability);

    // Write log
    if (!ofs)
    {
      std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      exit(1);
    }
    static ros::Time start_time = input-&gt;header.stamp;

    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; &quot;,&quot; &lt;&lt; scan_points_num &lt;&lt; &quot;,&quot; &lt;&lt; step_size &lt;&lt; &quot;,&quot; &lt;&lt; trans_eps &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed
        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.pitch
        &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.y &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.z &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose_error &lt;&lt; &quot;,&quot; &lt;&lt; iteration &lt;&lt; &quot;,&quot; &lt;&lt; fitness_score &lt;&lt; &quot;,&quot; &lt;&lt; trans_probability &lt;&lt; &quot;,&quot;
        &lt;&lt; ndt_reliability.data &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity_smooth &lt;&lt; &quot;,&quot; &lt;&lt; current_accel
        &lt;&lt; &quot;,&quot; &lt;&lt; angular_velocity &lt;&lt; &quot;,&quot; &lt;&lt; time_ndt_matching.data &lt;&lt; &quot;,&quot; &lt;&lt; align_time &lt;&lt; &quot;,&quot; &lt;&lt; getFitnessScore_time
        &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Sequence: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Timestamp: &quot; &lt;&lt; input-&gt;header.stamp &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Frame ID: &quot; &lt;&lt; input-&gt;header.frame_id &lt;&lt; std::endl;
    //		std::cout &lt;&lt; &quot;Number of Scan Points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Filtered Scan Points: &quot; &lt;&lt; scan_points_num &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; has_converged &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Fitness Score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Probability: &quot; &lt;&lt; trans_probability &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Execution Time: &quot; &lt;&lt; exe_time &lt;&lt; &quot; ms.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Iterations: &quot; &lt;&lt; iteration &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT Reliability: &quot; &lt;&lt; ndt_reliability.data &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw): &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
              &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Matrix: &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; t &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Align time: &quot; &lt;&lt; align_time &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Get fitness score time: &quot; &lt;&lt; getFitnessScore_time &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

    // Update offset
    if (_offset == &quot;linear&quot;)
    {
      offset_x = diff_x;
      offset_y = diff_y;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;quadratic&quot;)
    {
      offset_x = (current_velocity_x + current_accel_x * secs) * secs;
      offset_y = (current_velocity_y + current_accel_y * secs) * secs;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;zero&quot;)
    {
      offset_x = 0.0;
      offset_y = 0.0;
      offset_z = 0.0;
      offset_yaw = 0.0;
    }

    offset_imu_x = 0.0;
    offset_imu_y = 0.0;
    offset_imu_z = 0.0;
    offset_imu_roll = 0.0;
    offset_imu_pitch = 0.0;
    offset_imu_yaw = 0.0;

    offset_odom_x = 0.0;
    offset_odom_y = 0.0;
    offset_odom_z = 0.0;
    offset_odom_roll = 0.0;
    offset_odom_pitch = 0.0;
    offset_odom_yaw = 0.0;

    offset_imu_odom_x = 0.0;
    offset_imu_odom_y = 0.0;
    offset_imu_odom_z = 0.0;
    offset_imu_odom_roll = 0.0;
    offset_imu_odom_pitch = 0.0;
    offset_imu_odom_yaw = 0.0;

    // Update previous_***
    previous_pose.x = current_pose.x;
    previous_pose.y = current_pose.y;
    previous_pose.z = current_pose.z;
    previous_pose.roll = current_pose.roll;
    previous_pose.pitch = current_pose.pitch;
    previous_pose.yaw = current_pose.yaw;

    previous_scan_time.sec = current_scan_time.sec;
    previous_scan_time.nsec = current_scan_time.nsec;

    previous_previous_velocity = previous_velocity;
    previous_velocity = current_velocity;
    previous_velocity_x = current_velocity_x;
    previous_velocity_y = current_velocity_y;
    previous_velocity_z = current_velocity_z;
    previous_accel = current_accel;

    previous_estimated_vel_kmph.data = estimated_vel_kmph.data;
  }
}

void* thread_func(void* args)
{
  ros::NodeHandle nh_map;
  ros::CallbackQueue map_callback_queue;
  nh_map.setCallbackQueue(&amp;map_callback_queue);

  ros::Subscriber map_sub = nh_map.subscribe(&quot;points_map&quot;, 10, map_callback);
  ros::Rate ros_rate(10);
  while (nh_map.ok())
  {
    map_callback_queue.callAvailable(ros::WallDuration());
    ros_rate.sleep();
  }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;ndt_matching&quot;);
  pthread_mutex_init(&amp;mutex, NULL);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  // Set log file name.
  char buffer[80];
  std::time_t now = std::time(NULL);
  std::tm* pnow = std::localtime(&amp;now);
  std::strftime(buffer, 80, &quot;%Y%m%d_%H%M%S&quot;, pnow);
  filename = &quot;ndt_matching_&quot; + std::string(buffer) + &quot;.csv&quot;;
  ofs.open(filename.c_str(), std::ios::app);

  // Geting parameters
  private_nh.getParam(&quot;use_gnss&quot;, _use_gnss);
  private_nh.getParam(&quot;queue_size&quot;, _queue_size);
  private_nh.getParam(&quot;offset&quot;, _offset);
#ifdef USE_FAST_PCL
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
#endif
#ifdef CUDA_FOUND
  private_nh.getParam(&quot;use_gpu&quot;, _use_gpu);
#endif
  private_nh.getParam(&quot;get_height&quot;, _get_height);
  private_nh.getParam(&quot;use_local_transform&quot;, _use_local_transform);
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
  if (_use_gpu == true &amp;&amp; _use_openmp == true)
  {
    std::cout &lt;&lt; &quot;use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false.&quot; &lt;&lt; std::endl;
    _use_openmp = false;
  }
#endif

  if (nh.getParam(&quot;localizer&quot;, _localizer) == false)
  {
    std::cout &lt;&lt; &quot;localizer is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Log file: &quot; &lt;&lt; filename &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_gnss: &quot; &lt;&lt; _use_gnss &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;queue_size: &quot; &lt;&lt; _queue_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;offset: &quot; &lt;&lt; _offset &lt;&lt; std::endl;
#ifdef CUDA_FOUND
  std::cout &lt;&lt; &quot;use_gpu: &quot; &lt;&lt; _use_gpu &lt;&lt; std::endl;
#endif
#ifdef USE_FAST_PCL
  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
#endif
  std::cout &lt;&lt; &quot;get_height: &quot; &lt;&lt; _get_height &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_local_transform: &quot; &lt;&lt; _use_local_transform &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;localizer: &quot; &lt;&lt; _localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  // Updated in initialpose_callback or gnss_callback
  initial_pose.x = 0.0;
  initial_pose.y = 0.0;
  initial_pose.z = 0.0;
  initial_pose.roll = 0.0;
  initial_pose.pitch = 0.0;
  initial_pose.yaw = 0.0;

  // Publishers
  predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose&quot;, 1000);
  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu&quot;, 1000);
  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_odom&quot;, 1000);
  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu_odom&quot;, 1000);
  ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/ndt_pose&quot;, 1000);
  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);
  localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/localizer_pose&quot;, 1000);
  estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;/estimate_twist&quot;, 1000);
  estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_mps&quot;, 1000);
  estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_kmph&quot;, 1000);
  estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;(&quot;/estimated_vel&quot;, 1000);
  time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/time_ndt_matching&quot;, 1000);
  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;(&quot;/ndt_stat&quot;, 1000);
  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/ndt_reliability&quot;, 1000);

  // Subscribers
  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt&quot;, 10, param_callback);
  ros::Subscriber gnss_sub = nh.subscribe(&quot;gnss_pose&quot;, 10, gnss_callback);
  //  ros::Subscriber map_sub = nh.subscribe(&quot;points_map&quot;, 10, map_callback);
  ros::Subscriber initialpose_sub = nh.subscribe(&quot;initialpose&quot;, 1000, initialpose_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;filtered_points&quot;, _queue_size, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, _queue_size * 10, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size * 10, imu_callback);

  pthread_t thread;
  pthread_create(&amp;thread, NULL, thread_func, NULL);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="b49bb5c01b6553c6f5954a6703587b2729107e11" fix_time="30,47168">
		<msg>Fixed:
- callback
- laneshift
Added:
- publisher for laneid
- new lanechange flag
- new param for decisionMaker</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state.hpp">
				<diff>@@ -47,14 +47,16 @@ protected:
 
 public:
   virtual void update(void) = 0;
-  virtual void changed(void) = 0;
+  virtual void inState(void) = 0;
+  virtual void outState(void) = 0;
   virtual void showStateName(void) = 0;
   virtual uint64_t getStateTransMask(void) = 0;
   virtual uint64_t getStateNum(void) = 0;
   virtual std::string getStateName(void) = 0;
   virtual uint8_t getStateKind(void) = 0;
-  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
-  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f) = 0;
+  virtual void setCallbackUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
+  virtual void setCallbackInFunc(std::function&lt;void(void)&gt; _f) = 0;
+  virtual void setCallbackOutFunc(std::function&lt;void(void)&gt; _f) = 0;
 };
 
 // Interface
@@ -67,8 +69,9 @@ protected:
   uint64_t StateTransMask;
   uint8_t StateKind;
 
-  std::function&lt;void(void)&gt; StateUpdateFunc;
-  std::function&lt;void(void)&gt; StateChangedFunc;
+  std::function&lt;void(void)&gt; StateCallbackUpdateFunc;
+  std::function&lt;void(void)&gt; StateCallbackInFunc;
+  std::function&lt;void(void)&gt; StateCallbackOutFunc;
 
   State()
   {
@@ -80,24 +83,33 @@ protected:
 public:
   virtual void update(void)
   {
-    if (StateUpdateFunc)
-      StateUpdateFunc();
+    if (StateCallbackUpdateFunc)
+      StateCallbackUpdateFunc();
   }
 
-  virtual void changed(void)
+  virtual void inState(void)
   {
-    if (StateChangedFunc)
-	    StateChangedFunc();
+    if (StateCallbackInFunc)
+	    StateCallbackInFunc();
+  }
+  virtual void outState(void)
+  {
+    if (StateCallbackOutFunc)
+	    StateCallbackOutFunc();
+  }
+  virtual void setCallbackUpdateFunc(std::function&lt;void(void)&gt; _f)
+  {
+    StateCallbackUpdateFunc = _f;
   }
 
-  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)
+  virtual void setCallbackOutFunc(std::function&lt;void(void)&gt; _f)
   {
-    StateUpdateFunc = _f;
+    StateCallbackOutFunc = _f;
   }
 
-  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)
+  virtual void setCallbackInFunc(std::function&lt;void(void)&gt; _f)
   {
-    StateChangedFunc = _f;
+    StateCallbackInFunc = _f;
   }
 
   void showStateName(void)
</diff>
				<old_file>#ifndef __STATE_HPP__
#define __STATE_HPP__

#include &lt;functional&gt;
#include &lt;iostream&gt;
#include &lt;memory&gt;
#include &lt;state_flags.hpp&gt;
#include &lt;vector&gt;

namespace state_machine
{
class StartState;
class InitialState;
class LocateVehicleState;

class DriveState;
// Accel/Brake subState
class DriveAccAccelerationState;
class DriveAccDecelerationState;
class DriveAccKeepState;
class DriveAccStopState;
// Steering subState
class DriveStrStraightState;
class DriveStrLeftTurnState;
class DriveStrRightTurnState;

// Behavior subState
class DriveBehaviorLaneChangeLeftState;
class DriveBehaviorLaneChangeRightState;
class DriveBehaviorObstacleAvoidanceState;

// Perception subState
class DriveDetectObstacleState;
class DriveDetectStoplineState;
class DriveDetectTrafficlightRedState;

class MissionCompleteState;
class EmergencyState;

// base class
class BaseState
{
protected:
  BaseState()
  {
  }

public:
  virtual void update(void) = 0;
  virtual void changed(void) = 0;
  virtual void showStateName(void) = 0;
  virtual uint64_t getStateTransMask(void) = 0;
  virtual uint64_t getStateNum(void) = 0;
  virtual std::string getStateName(void) = 0;
  virtual uint8_t getStateKind(void) = 0;
  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f) = 0;
  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f) = 0;
};

// Interface
template &lt;class T&gt;
class State : public BaseState
{
protected:
  std::string StateName = &quot;Base&quot;;
  uint64_t StateNum;
  uint64_t StateTransMask;
  uint8_t StateKind;

  std::function&lt;void(void)&gt; StateUpdateFunc;
  std::function&lt;void(void)&gt; StateChangedFunc;

  State()
  {
    StateNum = 0;
    StateTransMask = (uint64_t)STATE_END - 1;
    StateKind = UNKNOWN_STATE;
  }

public:
  virtual void update(void)
  {
    if (StateUpdateFunc)
      StateUpdateFunc();
  }

  virtual void changed(void)
  {
    if (StateChangedFunc)
	    StateChangedFunc();
  }

  virtual void setUpdateFunc(std::function&lt;void(void)&gt; _f)
  {
    StateUpdateFunc = _f;
  }

  virtual void setChangedFunc(std::function&lt;void(void)&gt; _f)
  {
    StateChangedFunc = _f;
  }

  void showStateName(void)
  {
    std::cout &lt;&lt; StateName &lt;&lt; &quot;-&quot;;
  }

  static T* getInstance(void)
  {
    static T singleton;
    return &amp;singleton;
  }

  std::string getStateName(void)
  {
    return std::string(StateName);
  }

  uint8_t getStateKind(void)
  {
    return StateKind;
  }

  uint64_t getStateTransMask(void)
  {
    return StateTransMask;
  }
  uint64_t getStateNum(void)
  {
    return StateNum;
  }
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp" new_path="ros/src/computing/planning/decision/libs/libstate/include/state_context.hpp">
				<diff>@@ -20,19 +20,7 @@ namespace state_machine
 class StateContext
 {
 private:
-#if 0
-  class StateHolder
-  {
-  public:
-	  uint64_t MainState;
-	  uint64_t AccState;
-	  uint64_t StrState;
-	  uint64_t BehaviorState;
-	  uint64_t PerceptionState;
-	  uint64_t OtherState;
-  } current_state_;
-#endif
-  //std::map&lt;uint8_t, BaseState **&gt; HolderMap;
+  
   std::map&lt;uint8_t, uint64_t&gt; HolderMap;
   std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;
 
@@ -89,13 +77,13 @@ public:
   }
 
   void update(void);
-  void changed(uint8_t _kind);
+  void inState(uint8_t _kind, uint64_t _prev_state_num);
+  void OutState(uint8_t _kind);
   void stateDecider(void);
 
   bool isState(BaseState *base, uint64_t _state_num);
   bool isCurrentState(uint64_t _state_num);
   bool isCurrentState(uint8_t _state_kind, uint64_t _state_num);
-  bool inState(uint64_t _state_num);
   bool isDifferentState(uint64_t _state_a, uint64_t _state_b);
 
   bool setCurrentState(uint64_t flag);
@@ -110,8 +98,12 @@ public:
   std::string getCurrentStateName(void);
   std::string getStateName(void);
 
-  bool setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
-  bool setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
+
+  std::vector&lt;BaseState*&gt; getMultipleStates(uint64_t _state_num_set);
+
+  bool setCallbackInFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
+  bool setCallbackOutFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
+  bool setCallbackUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
   
   
   BaseState **getCurrentStateHolderPtr(uint8_t _kind);
</diff>
				<old_file>#ifndef __STATE_CONTEXT_HPP__
#define __STATE_CONTEXT_HPP__

#include &lt;atomic&gt;
#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;mutex&gt;
#include &lt;queue&gt;
#include &lt;thread&gt;
#include &lt;unordered_map&gt;
#include &lt;utility&gt;

#include &quot;state.hpp&quot;
#include &quot;state_drive.hpp&quot;
#include &quot;state_emg.hpp&quot;
#include &quot;state_main.hpp&quot;

namespace state_machine
{
class StateContext
{
private:
#if 0
  class StateHolder
  {
  public:
	  uint64_t MainState;
	  uint64_t AccState;
	  uint64_t StrState;
	  uint64_t BehaviorState;
	  uint64_t PerceptionState;
	  uint64_t OtherState;
  } current_state_;
#endif
  //std::map&lt;uint8_t, BaseState **&gt; HolderMap;
  std::map&lt;uint8_t, uint64_t&gt; HolderMap;
  std::unordered_map&lt;uint64_t, BaseState *&gt; StateStores;

  bool enableForceSetState;
  std::queue&lt;uint64_t&gt; ChangeStateFlags;
  std::atomic&lt;bool&gt; thread_loop;

  std::thread *thr_state_dec;
  std::mutex change_state_mutex;

  void showStateMove(uint64_t _state_num)
  {
    std::cout &lt;&lt; &quot;State will be [&quot; &lt;&lt; StateStores[_state_num]-&gt;getStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
  }
  bool setCurrentState(BaseState *state);

public:
  StateContext(void)
  {

    StateStores[START_STATE] = StartState::getInstance();
    StateStores[INITIAL_STATE] = InitialState::getInstance();
    StateStores[INITIAL_LOCATEVEHICLE_STATE] = LocateVehicleState::getInstance();
    StateStores[DRIVE_STATE] = DriveState::getInstance();
    StateStores[DRIVE_ACC_ACCELERATION_STATE] = DriveAccAccelerationState::getInstance();
    StateStores[DRIVE_ACC_DECELERATION_STATE] = DriveAccDecelerationState::getInstance();
    StateStores[DRIVE_ACC_KEEP_STATE] = DriveAccKeepState::getInstance();
    StateStores[DRIVE_ACC_STOP_STATE] = DriveAccStopState::getInstance();
    StateStores[DRIVE_ACC_STOPLINE_STATE] = DriveAccStopLineState::getInstance();
    StateStores[DRIVE_STR_STRAIGHT_STATE] = DriveStrStraightState::getInstance();
    StateStores[DRIVE_STR_LEFT_STATE] = DriveStrLeftState::getInstance();
    StateStores[DRIVE_STR_RIGHT_STATE] = DriveStrRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE] = DriveBehaviorLaneChangeLeftState::getInstance();
    StateStores[DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE] = DriveBehaviorLaneChangeRightState::getInstance();
    StateStores[DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE] = DriveBehaviorObstacleAvoidanceState::getInstance();
    StateStores[MISSION_COMPLETE_STATE] = MissionCompleteState::getInstance();
    StateStores[EMERGENCY_STATE] = EmergencyState::getInstance();

    HolderMap[MAIN_STATE] 	=  0ULL;
    HolderMap[ACC_STATE] 	=  0ULL;
    HolderMap[STR_STATE] 	=  0ULL;
    HolderMap[BEHAVIOR_STATE] 	=  0ULL;
    HolderMap[PERCEPTION_STATE] =  0ULL;
    HolderMap[OTHER_STATE] 	=  0ULL;

    thread_loop = true;

    this-&gt;InitContext();
  }

  ~StateContext()
  {
    thread_loop = false;
  }

  void update(void);
  void changed(uint8_t _kind);
  void stateDecider(void);

  bool isState(BaseState *base, uint64_t _state_num);
  bool isCurrentState(uint64_t _state_num);
  bool isCurrentState(uint8_t _state_kind, uint64_t _state_num);
  bool inState(uint64_t _state_num);
  bool isDifferentState(uint64_t _state_a, uint64_t _state_b);

  bool setCurrentState(uint64_t flag);
  bool disableCurrentState(uint64_t);

  BaseState *getStateObject(const uint64_t &amp;_state_num);
  std::string getStateName(const uint64_t &amp;_state_num); 
  uint8_t getStateKind(const uint64_t &amp;_state_num );

  BaseState *getCurrentMainState(void);
  BaseState *getCurrentState(void);
  std::string getCurrentStateName(void);
  std::string getStateName(void);

  bool setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
  bool setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f);
  
  
  BaseState **getCurrentStateHolderPtr(uint8_t _kind);
  BaseState **getCurrentStateHolderPtr(uint64_t _state_num);
  BaseState **getCurrentStateHolderPtr(BaseState *_state);
  void showCurrentStateName(void);
  std::string createStateMessageText(void);

  uint64_t getStateNum(BaseState *_state);
  uint64_t getStateTransMask(BaseState *_state);
  bool isEmptyMainState(void);
  uint8_t getStateKind(BaseState *_state);
  bool isMainState(BaseState *_state);

  std::string getCurrentStateName(uint8_t kind);

  bool setEnableForceSetState(bool force_flag);
  void InitContext(void);

  bool TFInitialized(void);

  void handleTrafficLight(uint32_t _light_color);
  bool handleCurrentPose(double x, double y, double z, double roll, double pitch, double yaw);
  bool handlePointsRaw(bool _hasLidarData);

  bool handleIntersection(bool _hasIntersection, double _angle);
  bool handleTwistCmd(bool _hasTwistCmd);
};
}

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp" new_path="ros/src/computing/planning/decision/libs/libstate/src/state_context.cpp">
				<diff>@@ -24,24 +24,47 @@
 namespace state_machine
 {
 
+std::vector&lt;BaseState *&gt; StateContext::getMultipleStates(uint64_t _state_num_set)
+{
+	std::vector&lt;BaseState *&gt; ret;
+	for(uint64_t mask = STATE_SUB_END; _state_num_set!= 0 &amp;&amp; mask != 0; mask &gt;&gt;=1){
+		if(mask &amp; _state_num_set){
+			ret.push_back(getStateObject(mask));
+			_state_num_set &amp;= ~mask;
+		}
+	}
+	return ret;
+}
 
 void StateContext::update(void)
 {
   for (auto &amp;p : HolderMap)
   {
-    if (p.second)
-	    if(getStateObject(p.second))
-		    getStateObject(p.second)-&gt;update();
+    if (p.first == BEHAVIOR_STATE){
+	    for(auto &amp;&amp;state :  getMultipleStates(p.second)){
+			state-&gt;update();
+	    }
+    }else{
+	    if (p.second)
+		    if(getStateObject(p.second))
+			    getStateObject(p.second)-&gt;update();
+    }
   }
 }
 
-void StateContext::changed(uint8_t _kind)
+void StateContext::inState(uint8_t _kind, uint64_t _prev_state_num)
 {
 	if(_kind &gt;  UNKNOWN_STATE){
 		return;
+	}else if(_kind == BEHAVIOR_STATE){
+	    for(auto &amp;&amp;state :  getMultipleStates(HolderMap[_kind])){
+	    	if(!(_prev_state_num &amp; getStateNum(state)))
+		    state-&gt;inState();
+	    }
+	}else{
+		if(getStateObject(HolderMap[_kind]))
+			getStateObject(HolderMap[_kind])-&gt;inState();
 	}
-	if(getStateObject(HolderMap[_kind]))
-		getStateObject(HolderMap[_kind])-&gt;changed();
 }
 
 
@@ -55,17 +78,23 @@ BaseState *StateContext::getStateObject(const uint64_t &amp;_state_num)
 	return nullptr;
 }
 
-bool StateContext::setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
+bool StateContext::setCallbackUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
+{
+	if(getStateObject(_state_num))
+			getStateObject(_state_num)-&gt;setCallbackUpdateFunc(_f);
+}
+bool StateContext::setCallbackInFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
 {
 	if(getStateObject(_state_num))
-			getStateObject(_state_num)-&gt;setUpdateFunc(_f);
+			getStateObject(_state_num)-&gt;setCallbackInFunc(_f);
 }
-bool StateContext::setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
+bool StateContext::setCallbackOutFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
 {
 	if(getStateObject(_state_num))
-			getStateObject(_state_num)-&gt;setChangedFunc(_f);
+			getStateObject(_state_num)-&gt;setCallbackOutFunc(_f);
 }
 
+
 std::string StateContext::getStateName(const uint64_t &amp;_state_num)
 {
 	if(getStateObject(_state_num)){
@@ -111,7 +140,7 @@ void StateContext::showCurrentStateName(void)
 
 bool StateContext::isDifferentState(uint64_t _state_a, uint64_t _state_b)
 {
-	return _state_a == _state_b;
+	return !(_state_a &amp; _state_b);
 }
 
 bool StateContext::isEmptyMainState(void)
@@ -139,7 +168,8 @@ bool StateContext::setCurrentState(BaseState *_state)
   change_state_mutex.lock();
   bool ret = true;
   if(_state){
-	  bool diff = isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
+	  uint64_t prev_state = HolderMap[getStateKind(_state)];
+	  bool diff =  isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
 	  if (isMainState(_state))
 	  {
 		  if (isEmptyMainState() || enableForceSetState ||
@@ -167,8 +197,14 @@ bool StateContext::setCurrentState(BaseState *_state)
 		  }
 	  }
 	  change_state_mutex.unlock();
-	  if(ret &amp;&amp; !diff)
-		  this-&gt;changed(getStateKind(_state));
+	  if(ret &amp;&amp; diff){
+		  this-&gt;inState(getStateKind(_state), prev_state);
+		  
+		  if(getStateKind(_state) == getStateKind(prev_state) &amp;&amp; 
+				  getStateKind(_state)!= BEHAVIOR_STATE)
+			  if(getStateObject(prev_state))
+					  getStateObject(prev_state)-&gt;outState();
+	  }
   }else{
 	  change_state_mutex.unlock();
 	  ret = false;
@@ -203,9 +239,7 @@ std::string StateContext::getCurrentStateName(uint8_t _kind)
 				if(mask &amp; _current_state){
 					ret += &quot;\n&quot; + getStateName(mask);
 					_current_state &amp;= ~mask;
-					fprintf(stderr,&quot;[%s]:::::%s\n&quot;,__func__,getStateName(mask).c_str());
 				}
-				fprintf(stderr,&quot;[%s]:%lx:%lx\n&quot;,__func__,_current_state, mask);
 			}
 			return ret;
 
@@ -228,6 +262,8 @@ bool StateContext::disableCurrentState(uint64_t _state_num)
 	}
 	if(isCurrentState(_state_num)){
 		HolderMap[getStateKind(_state_num)] &amp;= ~_state_num;
+		getStateObject(_state_num)-&gt;outState();
+		fprintf(stderr,&quot;[%s]:%d:%lx\n&quot;,__func__,__LINE__,_state_num);
 		return true;
 	}else{
 		return false;
@@ -247,18 +283,6 @@ bool StateContext::isState(BaseState *base, uint64_t _state_num)
   return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
 }
 
-bool StateContext::inState(uint64_t _state_num)
-{
-  if (HolderMap[MAIN_STATE])
-  {
-    return ((HolderMap[MAIN_STATE] &amp; _state_num) != 0) ? true : false;
-  }
-  else
-  {
-    return false;
-  }
-}
-
 bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
 {
   /* deprecated */
</diff>
				<old_file>#include &lt;sched.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;thread&gt;
#include &lt;vector&gt;

#include &lt;cassert&gt;
#include &lt;mutex&gt;

#include &lt;state_context.hpp&gt;

#include &lt;state.hpp&gt;
#include &lt;state_common.hpp&gt;

/**
 *
 * @file StateContext.cpp
 * @brief state context class
 * @author Yusuke Fujii
 * @date  2017/07/25
 *
 **/

namespace state_machine
{


void StateContext::update(void)
{
  for (auto &amp;p : HolderMap)
  {
    if (p.second)
	    if(getStateObject(p.second))
		    getStateObject(p.second)-&gt;update();
  }
}

void StateContext::changed(uint8_t _kind)
{
	if(_kind &gt;  UNKNOWN_STATE){
		return;
	}
	if(getStateObject(HolderMap[_kind]))
		getStateObject(HolderMap[_kind])-&gt;changed();
}


BaseState *StateContext::getStateObject(const uint64_t &amp;_state_num)
{
	if(_state_num){
		if(StateStores[_state_num]){
			return StateStores[_state_num];
		}
	}
	return nullptr;
}

bool StateContext::setUpdateFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
{
	if(getStateObject(_state_num))
			getStateObject(_state_num)-&gt;setUpdateFunc(_f);
}
bool StateContext::setChangedFunc(const uint64_t &amp;_state_num, const std::function&lt;void(void)&gt; &amp;_f)
{
	if(getStateObject(_state_num))
			getStateObject(_state_num)-&gt;setChangedFunc(_f);
}

std::string StateContext::getStateName(const uint64_t &amp;_state_num)
{
	if(getStateObject(_state_num)){
		return getStateObject(_state_num)-&gt;getStateName();
	}else 
		return &quot;&quot;;
}

uint64_t StateContext::getStateNum(BaseState *_state)
{
  if (_state){
	  return _state-&gt;getStateNum();
  }else
	  return 0;
}

uint8_t StateContext::getStateKind(BaseState *_state)
{
	if (_state){
		return _state-&gt;getStateKind();
	}else
		return UNKNOWN_STATE;
}

uint8_t StateContext::getStateKind(const uint64_t &amp;_state_num)
{
	if (_state_num){
		return getStateKind(getStateObject(_state_num));
	}
	return UNKNOWN_STATE;
}


void StateContext::showCurrentStateName(void)
{
  for (auto &amp;p : HolderMap)
  {
    if (p.second)
	    if(getStateObject(p.second))
		    getStateObject(p.second)-&gt;showStateName();
  }
}

bool StateContext::isDifferentState(uint64_t _state_a, uint64_t _state_b)
{
	return _state_a == _state_b;
}

bool StateContext::isEmptyMainState(void)
{
  if (HolderMap[MAIN_STATE])
    return false;
  return true;
}

uint64_t StateContext::getStateTransMask(BaseState *_state)
{
  if (_state)
    return _state-&gt;getStateTransMask();
  else
    return 0;
}

bool StateContext::isMainState(BaseState *_state)
{
  return getStateKind(_state) == MAIN_STATE;
}

bool StateContext::setCurrentState(BaseState *_state)
{
  change_state_mutex.lock();
  bool ret = true;
  if(_state){
	  bool diff = isDifferentState(getStateNum(_state), HolderMap[getStateKind(_state)]);
	  if (isMainState(_state))
	  {
		  if (isEmptyMainState() || enableForceSetState ||
				  (getStateTransMask(_state) &amp; HolderMap[MAIN_STATE]))
		  {
			  for(auto &amp;state : HolderMap){
				  if(state.first == MAIN_STATE){
					  state.second = getStateNum(_state);
				  }else{
					  state.second = 0ULL;
				  }
			  }
		  }
		  else
		  {
			  ret = false;
		  }
	  }
	  else
	  {
		  if(getStateKind(_state) == BEHAVIOR_STATE){
			  HolderMap[getStateKind(_state)] |= getStateNum(_state);
		  }else{
			  HolderMap[getStateKind(_state)] = getStateNum(_state);
		  }
	  }
	  change_state_mutex.unlock();
	  if(ret &amp;&amp; !diff)
		  this-&gt;changed(getStateKind(_state));
  }else{
	  change_state_mutex.unlock();
	  ret = false;
  }
  return ret;
}

bool StateContext::setCurrentState(uint64_t flag)
{
	bool ret = this-&gt;setCurrentState(getStateObject(flag));
	return ret;
}

bool StateContext::setEnableForceSetState(bool force_flag)
{
  enableForceSetState = force_flag;
  return true;
}

std::string StateContext::getCurrentStateName(void)
{
  return this-&gt;getCurrentStateName(MAIN_STATE);
}

std::string StateContext::getCurrentStateName(uint8_t _kind)
{
	if (HolderMap[_kind]){
		if(_kind == BEHAVIOR_STATE){
			uint64_t _current_state = HolderMap[_kind];
			std::string ret = &quot;&quot;;
			for(uint64_t mask = STATE_SUB_END; _current_state != 0 &amp;&amp; mask != 0; mask &gt;&gt;=1){
				if(mask &amp; _current_state){
					ret += &quot;\n&quot; + getStateName(mask);
					_current_state &amp;= ~mask;
					fprintf(stderr,&quot;[%s]:::::%s\n&quot;,__func__,getStateName(mask).c_str());
				}
				fprintf(stderr,&quot;[%s]:%lx:%lx\n&quot;,__func__,_current_state, mask);
			}
			return ret;

		}else{
			return getStateName(HolderMap[_kind]);
		}
	}
	return std::string(&quot;&quot;);
}

BaseState *StateContext::getCurrentMainState(void)
{
	return getStateObject(HolderMap[MAIN_STATE]);
}

bool StateContext::disableCurrentState(uint64_t _state_num)
{
	if(isMainState(getStateObject(_state_num))){
		return false;
	}
	if(isCurrentState(_state_num)){
		HolderMap[getStateKind(_state_num)] &amp;= ~_state_num;
		return true;
	}else{
		return false;
	}
}

bool StateContext::isCurrentState(uint64_t _state_num)
{
	if(_state_num)
	  return HolderMap[getStateKind(_state_num)] &amp; _state_num;
	else
	  return false;
}

bool StateContext::isState(BaseState *base, uint64_t _state_num)
{
  return base ? base-&gt;getStateNum() &amp; _state_num ? true : false : false;
}

bool StateContext::inState(uint64_t _state_num)
{
  if (HolderMap[MAIN_STATE])
  {
    return ((HolderMap[MAIN_STATE] &amp; _state_num) != 0) ? true : false;
  }
  else
  {
    return false;
  }
}

bool StateContext::handleIntersection(bool _hasIntersection, double _angle)
{
  /* deprecated */
  return false;
}

std::string StateContext::createStateMessageText(void)
{
  std::string ret;

  for (auto &amp;p : HolderMap)
  {
    if (p.second)
    {
      ret = ret + &quot;\n&quot; + getStateName(p.second);
    }
  }
  return ret;
}

bool StateContext::handleTwistCmd(bool _hasTwistCmd)
{
  if (_hasTwistCmd)
    return this-&gt;setCurrentState(DRIVE_STATE);
  else
    return false;
}

void StateContext::stateDecider(void)
{
  // not running
}

void StateContext::InitContext(void)
{
  thr_state_dec = new std::thread(&amp;StateContext::stateDecider, this);
  thr_state_dec-&gt;detach();
  this-&gt;setCurrentState(START_STATE);
  return;
}
bool StateContext::TFInitialized(void)
{
  return this-&gt;setCurrentState(INITIAL_STATE);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp">
				<diff>@@ -97,6 +97,7 @@ private:
   autoware_msgs::LaneArray current_stopped_lane_array_; // 0velocity
 
 
+
   // Current way/behavior status
   double current_velocity_;
   double average_velocity_;
@@ -128,6 +129,7 @@ private:
   bool vMap_CrossRoads_flag;
   bool SimulationMode;
   std::mutex vMap_mutex;
+  bool created_shift_lane_flag_;
 
   // initialization method
   void initROS(int argc, char **argv);
@@ -167,15 +169,19 @@ private:
   void changeVelocityBasedLane(void);
   void changeVelocityLane(int dir);
   void createShiftLane(void);
+  void changeShiftLane(void);
+  void removeShiftLane(void);
   
-  void changedStateObstacleAvoid(int status);
+  void callbackInStateObstacleAvoid(int status);
+  void callbackOutStateObstacleAvoid(int status);
+  void updateStateObstacleAvoid(int status);
   
   void updateStateSTR(int status);
   void updateStateStop(int status);
-  void changedStateStop(int status);
-  void changedStateAcc(int status);
-  void changedStateDec(int status);
-  void changedStateKeep(int status);
+  void callbackInStateStop(int status);
+  void callbackInStateAcc(int status);
+  void callbackInStateDec(int status);
+  void callbackInStateKeep(int status);
   void setupStateCallback(void);
   // callback by topic subscribing
   void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
@@ -213,6 +219,7 @@ public:
     this-&gt;initROS(argc, argv);
 
     vector_map_init = false;
+    created_shift_lane_flag_ = false;
 
     vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;
 
</diff>
				<old_file>#ifndef __DECISION_MAKER_NODE__
#define __DECISION_MAKER_NODE__

#include &lt;mutex&gt;
#include &lt;unordered_map&gt;

#include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/LaneArray.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;

#include &lt;visualization_msgs/MarkerArray.h&gt;

#include &lt;vector_map_msgs/AreaArray.h&gt;
#include &lt;vector_map_msgs/CrossRoadArray.h&gt;
#include &lt;vector_map_msgs/LineArray.h&gt;
#include &lt;vector_map_msgs/PointArray.h&gt;

#include &lt;vector_map/vector_map.h&gt;

#include &lt;geometry_msgs/Point.h&gt;

// lib
#include &lt;cross_road_area.hpp&gt;
#include &lt;amathutils.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;
#include &lt;decision_maker_param.hpp&gt;

namespace decision_maker
{
using namespace vector_map;

enum class EControl : int32_t
{
  KEEP = -1,
  STOP = 1,
  DECELERATE = 2,
  ACCELERATE = 3,
  OTHERS = 4,
};

enum class E_ChangeFlags : int32_t
{
  STRAIGHT,
  RIGHT,
  LEFT,

  UNKNOWN = -1,
};

inline bool hasvMap(void)
{
  return true;
}

template &lt;class T&gt;
typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
{
  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
}

class DecisionMakerNode
{
private:
  ros::NodeHandle nh_;
  // Publishers
  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
  // Subscribers
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;

  // ROS Messages
  std_msgs::String state_string_msg;
  geometry_msgs::PoseStamped current_pose_;

  jsk_rviz_plugins::OverlayText state_text_msg;

  // ROS Messages(Autoware)
  autoware_msgs::lane current_finalwaypoints_;
  vector_map_msgs::AreaArray vMap_Areas;
  vector_map_msgs::PointArray vMap_Points;
  vector_map_msgs::LineArray vMap_Lines;
  vector_map_msgs::CrossRoadArray vMap_CrossRoads;

  std::vector&lt;geometry_msgs::Point&gt; inside_points_;

  autoware_msgs::LaneArray current_based_lane_array_; // with wpstate
  autoware_msgs::LaneArray current_shifted_lane_array_; // with shiftedLane
  autoware_msgs::LaneArray current_controlled_lane_array_; // modified lane
  autoware_msgs::LaneArray current_stopped_lane_array_; // 0velocity


  // Current way/behavior status
  double current_velocity_;
  double average_velocity_;
  int current_traffic_light;
  CrossRoadArea *ClosestArea_;
  std::string CurrentStateName;
  std::string TextOffset;
  std::vector&lt;CrossRoadArea&gt; intersects;
  double displacement_from_path_;

  // Param
  bool enableDisplayMarker;
  bool enableForceStateChange;
  uint32_t param_convergence_count_;
  uint32_t param_target_waypoint_;
  double param_convergence_threshold_;
  uint32_t param_stopline_target_waypoint_;
  double param_shift_width_;

  // for vectormap server
  // ros::ServiceClient cross_road_cli;
  // vector_map_server::GetCrossRoad cross_road_srv;

  // initialization flags for initialized by callback
  bool vector_map_init;
  bool vMap_Areas_flag;
  bool vMap_Points_flag;
  bool vMap_Lines_flag;
  bool vMap_CrossRoads_flag;
  bool SimulationMode;
  std::mutex vMap_mutex;

  // initialization method
  void initROS(int argc, char **argv);
  void initVectorMap(void);
  void initStateMsgs(void);
  bool initVectorMapClient(void);

  // looping method
  void update(void);
  void update_msgs(void);
  void update_pubsub(void);
  void displayMarker(void);

  void publishToVelocityArray();
  std::string createStateMessageText();
  int createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale);


  // judge method
  // in near future, these methods will be deprecate to decision_maker library
  bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
  bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
  bool handleStateCmd(const unsigned long long _state_num);
  //double calcIntersectWayAngle(const CrossRoadArea&amp; area);
  double calcIntersectWayAngle(const autoware_msgs::lane&amp; laneinArea);

  void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);

  void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
  double calcPosesAngleDiff(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to);
  double calcPosesAngleDiffN(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to);
  double getPoseAngle(const geometry_msgs::Pose &amp;p);

  void publishStoppedLaneArray(void);
  void publishControlledLaneArray(void);
  void updateLaneWaypointsArray(void);
  void changeVelocityBasedLane(void);
  void changeVelocityLane(int dir);
  void createShiftLane(void);
  
  void changedStateObstacleAvoid(int status);
  
  void updateStateSTR(int status);
  void updateStateStop(int status);
  void changedStateStop(int status);
  void changedStateAcc(int status);
  void changedStateDec(int status);
  void changedStateKeep(int status);
  void setupStateCallback(void);
  // callback by topic subscribing
  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event);
  void callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg);
  void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
  void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
  void callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg);
  void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromStateCmd(const std_msgs::Int32 &amp;msg);
  void callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg);

  void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
  void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
  void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
  void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);

public:
  state_machine::StateContext *ctx;
  VectorMap g_vmap;

  DecisionMakerNode(int argc, char **argv)
  {
    SimulationMode = false;
    enableDisplayMarker = DEFAULT_DISPLAY_FLAG;
    param_convergence_threshold_ = DEFAULT_CONVERGENCE_THRESHOLD;
    param_convergence_count_ = DEFAULT_CONVERGENCE_COUNT;
    param_target_waypoint_ = DEFAULT_TARGET_WAYPOINT;
    param_shift_width_ = DEFAULT_SHIFT_WIDTH;
    param_stopline_target_waypoint_ = DEFAULT_STOPLINE_TARGET_WAYPOINT;

    ctx = new state_machine::StateContext();
    this-&gt;initROS(argc, argv);

    vector_map_init = false;

    vMap_Areas_flag = vMap_Lines_flag = vMap_Points_flag = vMap_CrossRoads_flag = false;

    ClosestArea_ = nullptr;
    displacement_from_path_ = 0.0;
  }

  void run(void);
};

}  // namespace decision_maker

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -33,7 +33,11 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
   bool _ret;
   ctx-&gt;setEnableForceSetState(true);
-  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  if(!ctx-&gt;isCurrentState(_state_num)){
+	  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  }else{
+	  _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
+  }
   ctx-&gt;setEnableForceSetState(false);
   return _ret;
 }
@@ -47,21 +51,25 @@ void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;ms
 
 void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 {
-  ROS_INFO(&quot;Received forcing state changing request&quot;);
-  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
+  ROS_INFO(&quot;Received forcing state changing request: %lx&quot;, 1ULL &lt;&lt; (uint64_t)msg.data);
+  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
 }
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-  else
-  {
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-  }
+	if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT)){
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+	}
+	else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT)){
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+	}
+	else
+	{
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+	}
 }
 
 void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
  ctx-&gt;setEnableForceSetState(false);
  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request&quot;);
  handleStateCmd((unsigned long long)1 &lt;&lt; msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);

  param_target_waypoint_ = msg.target_waypoint;
  // param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
  param_shift_width_ = msg.shift_width;
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);
  const autoware_msgs::traffic_light *light = event.getMessage().get();

  current_traffic_light = light-&gt;traffic_light;
  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
  {
    // ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  else
  {
    // ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
          }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;wp_lane : laneinArea.waypoints)
      {
        for (auto &amp;lane : lane_array.lanes)
        {
          for (auto &amp;wp : lane.waypoints)
          {
            if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
            {
              wp.wpstate.steering_state = steering_state;
            }
          }
          // lane.waypoints.at(wp_lane.lid).wpstate.steering_state = steering_state;
        }
      }
    }
  }
  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);
  });

  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
            // lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  int gid = 0;
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int lid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
                   param_stopline_target_waypoint_ :
                   current_finalwaypoints_.waypoints.size() - 1;
  if (idx &gt;= 0)
  {
    if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
      ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
  }
  // steering
  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
            param_target_waypoint_ :
            current_finalwaypoints_.waypoints.size() - 1;
  if (idx &gt;= 0)
  {
    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
    {
      ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
    }
    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
    {
      ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
    }
    else
    {
      ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
    }
  }

  // for publish plan of velocity
  publishToVelocityArray();
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_publish.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_publish.cpp">
				<diff>@@ -108,8 +108,8 @@ void DecisionMakerNode::displayMarker(void)
       marker_array.markers.push_back(inside_line_marker);
     }
   }
-  inside_line_marker.scale.x = 0.1;  // 0.3;
-  inside_line_marker.scale.y = 0.1;  // 0.3;
+  inside_line_marker.scale.x = 0.2;  // 0.3;
+  inside_line_marker.scale.y = 0.2;  // 0.3;
   int id = inside_line_marker.id;
   inside_line_marker.color.r = 0;
   inside_line_marker.color.g = 1;
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/state.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
void DecisionMakerNode::update_pubsub(void)
{
  // if state machine require to re-subscribe topic,
  // this function will re-definition subscriber.
}

int DecisionMakerNode::createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale)
{
  crossroad_marker.header.frame_id = &quot;/map&quot;;
  crossroad_marker.header.stamp = ros::Time();
  crossroad_marker.id = 1;
  crossroad_marker.type = visualization_msgs::Marker::SPHERE_LIST;
  crossroad_marker.action = visualization_msgs::Marker::ADD;
  crossroad_marker.ns = &quot;crossroad&quot;;

  crossroad_marker.scale.x = scale;
  crossroad_marker.scale.y = scale;
  crossroad_marker.scale.z = 0.5;
  crossroad_marker.color.a = 0.15;
  crossroad_marker.color.r = 1.0;
  crossroad_marker.color.g = 0.0;
  crossroad_marker.color.b = 0.0;
  crossroad_marker.frame_locked = true;
  crossroad_marker.lifetime = ros::Duration(0.3);

  return 0;
}

void DecisionMakerNode::displayMarker(void)
{
  // vector_map init
  // parse vectormap
  jsk_recognition_msgs::BoundingBoxArray bbox_array;
  visualization_msgs::MarkerArray marker_array;
  visualization_msgs::Marker crossroad_marker;
  visualization_msgs::Marker inside_marker;
  visualization_msgs::Marker inside_line_marker;

  double scale = 3.0;
  createCrossRoadAreaMarker(crossroad_marker, scale);

  inside_marker = crossroad_marker;
  inside_marker.scale.x = scale / 3;
  inside_marker.scale.y = scale / 3;
  inside_marker.scale.z = 0.5;
  inside_marker.color.a = 0.5;
  inside_marker.color.r = 1.0;
  inside_marker.color.g = 0.0;
  inside_marker.color.b = 0.0;
  inside_marker.ns = &quot;inside&quot;;
  inside_marker.lifetime = ros::Duration();

  bbox_array.header = crossroad_marker.header;
  inside_marker.points.clear();

  inside_line_marker = inside_marker;
  inside_line_marker.type = visualization_msgs::Marker::LINE_STRIP;

  for (auto &amp;area : intersects)
  {
    area.bbox.header = crossroad_marker.header;
    bbox_array.boxes.push_back(area.bbox);
    for (const auto &amp;p : area.insideWaypoint_points)
    {
      inside_marker.points.push_back(p);
    }

    for (const auto &amp;lane : area.insideLanes)
    {
      inside_line_marker.points.clear();
      int id = inside_line_marker.id;
      inside_line_marker.id += 1;
      inside_marker.scale.x = scale / 3;
      inside_marker.scale.y = scale / 3;
      inside_line_marker.color.r = std::fmod(0.12345 * (id), 1.0);
      inside_line_marker.color.g = std::fmod(0.32345 * (5 - (id % 5)), 1.0);
      inside_line_marker.color.b = std::fmod(0.52345 * (10 - (id % 10)), 1.0);
      for (const auto &amp;wp : lane.waypoints)
      {
        inside_line_marker.points.push_back(wp.pose.pose.position);
      }
      marker_array.markers.push_back(inside_line_marker);
    }
  }
  inside_line_marker.scale.x = 0.1;  // 0.3;
  inside_line_marker.scale.y = 0.1;  // 0.3;
  int id = inside_line_marker.id;
  inside_line_marker.color.r = 0;
  inside_line_marker.color.g = 1;
  inside_line_marker.color.b = 0.3;
  inside_line_marker.color.a = 1;
  inside_line_marker.ns = &quot;shiftline&quot;;
  for (const auto &amp;lane : current_controlled_lane_array_.lanes)
  {
    inside_line_marker.points.clear();
    for (size_t idx = 0; idx &lt; lane.waypoints.size(); idx++)
    {
      inside_line_marker.id += 1;

      geometry_msgs::Pose shift_p = lane.waypoints.at(idx).pose.pose;

      double current_angle = getPoseAngle(shift_p);

      shift_p.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
      shift_p.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);

      inside_line_marker.points.push_back(shift_p.position);
    }
    marker_array.markers.push_back(inside_line_marker);
  }
  Pubs[&quot;crossroad_bbox&quot;].publish(bbox_array);
  Pubs[&quot;crossroad_marker&quot;].publish(marker_array);
  bbox_array.boxes.clear();
  // Pubs[&quot;crossroad_inside_marker&quot;].publish(inside_marker);
  Pubs[&quot;crossroad_inside_marker&quot;].publish(inside_line_marker);
}

void DecisionMakerNode::update_msgs(void)
{
  if (ctx)
  {
    static std::string prevStateName;
    CurrentStateName = ctx-&gt;getCurrentStateName();

    if (prevStateName != CurrentStateName)
    {
      prevStateName = CurrentStateName;
      update_pubsub();
    }

    autoware_msgs::state state_msg;
    state_msg.main_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::MAIN_STATE);
    state_msg.acc_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::ACC_STATE);
    state_msg.str_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::STR_STATE);
    state_msg.behavior_state = ctx-&gt;getCurrentStateName((uint8_t)state_machine::StateKinds::BEHAVIOR_STATE);

    state_string_msg.data = CurrentStateName;
    // state_text_msg.text = createStateMessageText();
    state_text_msg.text = state_msg.main_state + &quot;\n&quot; + state_msg.acc_state + &quot;\n&quot; + state_msg.str_state + &quot;\n&quot; +
                          state_msg.behavior_state + &quot;\n&quot;;

    Pubs[&quot;states&quot;].publish(state_msg);
    // Pubs[&quot;state&quot;].publish(state_string_msg);
    Pubs[&quot;state_overlay&quot;].publish(state_text_msg);
  }
  else
    std::cerr &lt;&lt; &quot;ctx is not found &quot; &lt;&lt; std::endl;
}

std::string DecisionMakerNode::createStateMessageText()
{
  return ctx-&gt;createStateMessageText();
}

void DecisionMakerNode::publishToVelocityArray()
{
  int count = 0;
  std_msgs::Float64MultiArray msg;

  for (const auto &amp;i : current_finalwaypoints_.waypoints)
  {
    msg.data.push_back(amathutils::mps2kmph(i.twist.twist.linear.x));
    if (++count &gt;= 10)
      break;
  }
  Pubs[&quot;target_velocity_array&quot;].publish(msg);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -11,67 +11,89 @@ namespace decision_maker
 {
 void DecisionMakerNode::setupStateCallback(void)
 {
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
-  ctx-&gt;setUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
 
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
-                      std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::changedStateStop, this, 0));
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
-                      std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
-                      std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
 
-  ctx-&gt;setChangedFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                      std::bind(&amp;DecisionMakerNode::changedStateObstacleAvoid, this, -1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
+                      std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
+  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
+                      std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
 }
 
 void DecisionMakerNode::createShiftLane(void)
 {
-  autoware_msgs::lane shift_lane;
-  if (!current_shifted_lane_array_.lanes.empty())
+  if(!created_shift_lane_flag_)
   {
-    shift_lane = current_shifted_lane_array_.lanes.at(0);
-    size_t idx = 0;
-    for (auto &amp;wp : shift_lane.waypoints)
-    {
-      double current_angle = getPoseAngle(wp.pose.pose);
-      wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
-      wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
-      wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
-    }
-    auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
+	  created_shift_lane_flag_ = true;
+	  autoware_msgs::lane shift_lane;
+	  current_shifted_lane_array_ = current_based_lane_array_;
+	  if (!current_shifted_lane_array_.lanes.empty())
+	  {
+		  shift_lane = current_shifted_lane_array_.lanes.at(0);
+		  size_t idx = 0;
+		  for (auto &amp;wp : shift_lane.waypoints)
+		  {
+			  double current_angle = getPoseAngle(wp.pose.pose);
+			  wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
+			  wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+			  wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
+		  }
+		  auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
 
-    for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
-    {
-      wp.change_flag = 1;
-    }
+		  for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
+		  {
+			  wp.change_flag = 1;
+		  }
+	  }
   }
 }
 
+void DecisionMakerNode::changeShiftLane(void){
+	try{
+		for(size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx+=2){
+			for(size_t wp_idx; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++){
+				current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag = current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag;
+				current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag = 2;
+			}
+		}
+	}
+	catch(std::out_of_range){
+		fprintf(stderr,&quot;out\n&quot;);
+	}
+}
+
+void DecisionMakerNode::removeShiftLane(void){
+	current_shifted_lane_array_ = current_based_lane_array_;
+	created_shift_lane_flag_ = false;
+#if 0
+	if(created_shift_lane_flag_){
+		if(!current_shifted_lane_array_.lanes.size()&gt;=2){
+			for(auto it = begin(current_shifted_lane_array_.lanes)+1; it!=end(current_shifted_lane_array_.lanes); it+=2)
+				current_shifted_lane_array_.lanes.erase(it);
+		}
+		created_shift_lane_flag_ = false;
+	}
+#endif
+}
+
 void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
   // current_stopped_lane_array_ = current_controlled_lane_array_;
   current_stopped_lane_array_ = current_controlled_lane_array_;
-#if 0
-	size_t idx	= current_finalwaypoints_.waypoints.at(0).gid;
-	for(auto &amp;lane : current_stopped_lane_array_.lanes)
-	{
-		for(auto &amp;wp: lane.waypoints){
-			fprintf(stderr,&quot;%d:%d\n&quot;,idx, wp.gid);
-			if(idx - 5 &lt;= wp.gid &amp;&amp;  wp.gid  &lt; idx){
-				wp.twist.twist.linear.x /= 5 - (idx-wp.gid);
-			}else{
-				wp.twist.twist.linear.x = 0;
-			}
-			wp.wpstate.stopline_state = 0;
-		}
-	}
-#else
 
   for (auto &amp;lane : current_stopped_lane_array_.lanes)
   {
@@ -81,27 +103,29 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
       wp.wpstate.stopline_state = 0;
     }
   }
-#endif
 }
 
 void DecisionMakerNode::publishControlledLaneArray(void)
 {
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
 }
 void DecisionMakerNode::publishStoppedLaneArray(void)
 {
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   updateLaneWaypointsArray();
   Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
 }
 
 void DecisionMakerNode::changeVelocityBasedLane(void)
 {
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   current_controlled_lane_array_ = current_shifted_lane_array_;
-  // current_controlled_lane_array_ = current_based_lane_array_;
 }
 
 void DecisionMakerNode::changeVelocityLane(int dir)
 {
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   for (auto &amp;lane : current_controlled_lane_array_.lanes)
   {
     autoware_msgs::lane temp_lane = lane;
@@ -122,19 +146,22 @@ void DecisionMakerNode::changeVelocityLane(int dir)
   }
 }
 
-void DecisionMakerNode::changedStateKeep(int status)
+void DecisionMakerNode::callbackInStateKeep(int status)
 {
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   changeVelocityBasedLane();
   publishControlledLaneArray();
 }
 
-void DecisionMakerNode::changedStateAcc(int status)
+void DecisionMakerNode::callbackInStateAcc(int status)
 {
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   changeVelocityLane(status);
   publishControlledLaneArray();
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   static ros::Timer stopping_timer;
   static bool timerflag = false;
   if (status)
@@ -152,22 +179,61 @@ void DecisionMakerNode::updateStateStop(int status)
     }
   }
 }
-void DecisionMakerNode::changedStateObstacleAvoid(int status)
+
+void DecisionMakerNode::updateStateObstacleAvoid(int status)
 {
-  createShiftLane();
-  publishControlledLaneArray();
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
+  static ros::Timer avoidance_timer;
+  static bool stopped_flag = false;
 
-  static ros::Timer stopping_timer;
-  static bool timerflag = false;
-  stopping_timer = nh_.createTimer(ros::Duration(1),
-                                   [&amp;](const ros::TimerEvent &amp;) {
-                                     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE);
-                                     ROS_INFO(&quot;Change state to null from obstacle avoid\n&quot;);
-                                   },
-                                   this, true);
+  if(current_velocity_ == 0.0){
+	stopped_flag = true;
+  }
+}
+
+void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
+{
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
+	static ros::Timer avoidance_timer_2;
+	ROS_INFO(&quot;End of Avoidance\n&quot;);
+	changeShiftLane();
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
+
+	ros::Rate loop_rate(1);
+	//blocking
+	
+	
+	do{
+		ros::spinOnce();
+		loop_rate.sleep();
+	}
+	while(!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
+				       	!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
+	do{
+		ros::spinOnce();
+		loop_rate.sleep();
+	}
+	while((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
+				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
+				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE) )&amp;&amp; ros::ok() );
+
+	removeShiftLane();
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
+	return;
+}
+
+void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
+{
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
+  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
+  createShiftLane();
+  changeVelocityBasedLane();
 }
-void DecisionMakerNode::changedStateStop(int status)
+void DecisionMakerNode::callbackInStateStop(int status)
 {
+	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   publishStoppedLaneArray();
 }
 
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;decision_maker_node.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::setupStateCallback(void)
{
  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
  ctx-&gt;setUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;setUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;setUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));

  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                      std::bind(&amp;DecisionMakerNode::changedStateStop, this, 1));
  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::changedStateStop, this, 0));
  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::changedStateKeep, this, 1));
  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                      std::bind(&amp;DecisionMakerNode::changedStateAcc, this, 1));
  ctx-&gt;setChangedFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                      std::bind(&amp;DecisionMakerNode::changedStateAcc, this, -1));

  ctx-&gt;setChangedFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                      std::bind(&amp;DecisionMakerNode::changedStateObstacleAvoid, this, -1));
}

void DecisionMakerNode::createShiftLane(void)
{
  autoware_msgs::lane shift_lane;
  if (!current_shifted_lane_array_.lanes.empty())
  {
    shift_lane = current_shifted_lane_array_.lanes.at(0);
    size_t idx = 0;
    for (auto &amp;wp : shift_lane.waypoints)
    {
      double current_angle = getPoseAngle(wp.pose.pose);
      wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
      wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
      wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
    }
    auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);

    for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
    {
      wp.change_flag = 1;
    }
  }
}

void DecisionMakerNode::updateLaneWaypointsArray(void)
{
  // current_stopped_lane_array_ = current_controlled_lane_array_;
  current_stopped_lane_array_ = current_controlled_lane_array_;
#if 0
	size_t idx	= current_finalwaypoints_.waypoints.at(0).gid;
	for(auto &amp;lane : current_stopped_lane_array_.lanes)
	{
		for(auto &amp;wp: lane.waypoints){
			fprintf(stderr,&quot;%d:%d\n&quot;,idx, wp.gid);
			if(idx - 5 &lt;= wp.gid &amp;&amp;  wp.gid  &lt; idx){
				wp.twist.twist.linear.x /= 5 - (idx-wp.gid);
			}else{
				wp.twist.twist.linear.x = 0;
			}
			wp.wpstate.stopline_state = 0;
		}
	}
#else

  for (auto &amp;lane : current_stopped_lane_array_.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      wp.twist.twist.linear.x = 0.0;
      wp.wpstate.stopline_state = 0;
    }
  }
#endif
}

void DecisionMakerNode::publishControlledLaneArray(void)
{
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
  current_controlled_lane_array_ = current_shifted_lane_array_;
  // current_controlled_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
  for (auto &amp;lane : current_controlled_lane_array_.lanes)
  {
    autoware_msgs::lane temp_lane = lane;
    for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
    {
      amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                           temp_lane.waypoints.at(wpi).pose.pose.position.y,
                           temp_lane.waypoints.at(wpi).pose.pose.position.z);
      amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                           temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                           temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

      double distance = amathutils::find_distance(&amp;p0, &amp;p1);
      double _weight = distance * 0.05 * dir;
      lane.waypoints.at(wpi).twist.twist.linear.x =
          lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
    }
  }
}

void DecisionMakerNode::changedStateKeep(int status)
{
  changeVelocityBasedLane();
  publishControlledLaneArray();
}

void DecisionMakerNode::changedStateAcc(int status)
{
  changeVelocityLane(status);
  publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
  static ros::Timer stopping_timer;
  static bool timerflag = false;
  if (status)
  {
    if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
    {
      stopping_timer = nh_.createTimer(ros::Duration(1),
                                       [&amp;](const ros::TimerEvent &amp;) {
                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
                                         ROS_INFO(&quot;Change state to keep from stop\n&quot;);
                                         timerflag = false;
                                       },
                                       this, true);
      timerflag = true;
    }
  }
}
void DecisionMakerNode::changedStateObstacleAvoid(int status)
{
  createShiftLane();
  publishControlledLaneArray();

  static ros::Timer stopping_timer;
  static bool timerflag = false;
  stopping_timer = nh_.createTimer(ros::Duration(1),
                                   [&amp;](const ros::TimerEvent &amp;) {
                                     ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE);
                                     ROS_INFO(&quot;Change state to null from obstacle avoid\n&quot;);
                                   },
                                   this, true);
}
void DecisionMakerNode::changedStateStop(int status)
{
  publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch (status)
  {
    case LAMP_LEFT:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_OFF;
      break;
    case LAMP_RIGHT:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_HAZARD:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_EMPTY:
    default:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_OFF;
      break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/mission/packages/lane_planner/nodes/lane_select/lane_select_core.cpp" new_path="ros/src/computing/planning/mission/packages/lane_planner/nodes/lane_select/lane_select_core.cpp">
				<diff>@@ -85,6 +85,8 @@ void LaneSelectNode::initForROS()
   }
 
   pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;change_flag&quot;, 1);
+  pub4_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;/current_lane_id&quot;,1);
+
   vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;lane_select_marker&quot;, 1);
 
   // get from rosparam
@@ -182,6 +184,7 @@ void LaneSelectNode::processing()
           std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
       ROS_INFO(&quot;closest: %d&quot;, std::get&lt;1&gt;(lane_for_change_));
       publishLane(std::get&lt;0&gt;(lane_for_change_));
+      publishLaneID(std::get&lt;0&gt;(lane_for_change_));
       publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
       publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
     }
@@ -608,6 +611,13 @@ void LaneSelectNode::publishLane(const autoware_msgs::lane &amp;lane)
   pub1_.publish(lane);
 }
 
+void LaneSelectNode::publishLaneID(const autoware_msgs::lane &amp;lane)
+{
+  std_msgs::Int32 msg;
+  msg.data = lane.lane_id;
+  pub4_.publish(msg);
+}
+
 void LaneSelectNode::publishClosestWaypoint(const int32_t clst_wp)
 {
   // publish closest waypoint
@@ -681,7 +691,7 @@ void LaneSelectNode::callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg)
 {
   is_current_state_subscribed_ = true;
 
-  if (msg-&gt;behavior_state == &quot;LaneChangeRight&quot; || msg-&gt;behavior_state == &quot;LaneChangeLeft&quot;)
+  if (msg-&gt;behavior_state.find(&quot;LaneChange&quot;) != std::string::npos)
   {
     current_state_ = std::string(&quot;LANE_CHANGE&quot;);
     ;
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University

 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#include &quot;lane_select_core.h&quot;

namespace lane_planner
{
// Constructor
LaneSelectNode::LaneSelectNode()
  : private_nh_(&quot;~&quot;)
  , current_lane_idx_(-1)
  , right_lane_idx_(-1)
  , left_lane_idx_(-1)
  , is_lane_array_subscribed_(false)
  , is_current_pose_subscribed_(false)
  , is_current_velocity_subscribed_(false)
  , is_current_state_subscribed_(false)
  , is_config_subscribed_(false)
  , distance_threshold_(3.0)
  , lane_change_interval_(10.0)
  , lane_change_target_ratio_(2.0)
  , lane_change_target_minimum_(5.0)
  , vlength_hermite_curve_(10)
  , current_state_(&quot;UNKNOWN&quot;)
{
  initForROS();
}

// Destructor
LaneSelectNode::~LaneSelectNode()
{
}

void LaneSelectNode::initForROS()
{
  // setup subscriber
  sub1_ = nh_.subscribe(&quot;traffic_waypoints_array&quot;, 1, &amp;LaneSelectNode::callbackFromLaneArray, this);
  sub2_ = nh_.subscribe(&quot;current_pose&quot;, 1, &amp;LaneSelectNode::callbackFromPoseStamped, this);
  sub3_ = nh_.subscribe(&quot;current_velocity&quot;, 1, &amp;LaneSelectNode::callbackFromTwistStamped, this);
  sub4_ = nh_.subscribe(&quot;state&quot;, 1, &amp;LaneSelectNode::callbackFromState, this);
  sub5_ = nh_.subscribe(&quot;/config/lane_select&quot;, 1, &amp;LaneSelectNode::callbackFromConfig, this);
  sub6_ = nh_.subscribe(&quot;/decisionmaker/states&quot;, 1, &amp;LaneSelectNode::callbackFromStates, this);

  bool enablePlannerDynamicSwitch;
  private_nh_.param&lt;bool&gt;(&quot;enablePlannerDynamicSwitch&quot;, enablePlannerDynamicSwitch, false);
  // setup publisher

  pub1_ = nh_.advertise&lt;autoware_msgs::lane&gt;(&quot;base_waypoints&quot;, 1);

  if (enablePlannerDynamicSwitch)
  {
    pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;/astar/closest_waypoint&quot;, 1);
  }
  else
  {
    pub2_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;closest_waypoint&quot;, 1);
  }

  pub3_ = nh_.advertise&lt;std_msgs::Int32&gt;(&quot;change_flag&quot;, 1);
  vis_pub1_ = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;lane_select_marker&quot;, 1);

  // get from rosparam
  private_nh_.param&lt;double&gt;(&quot;lane_change_interval&quot;, lane_change_interval_, double(2));
  private_nh_.param&lt;double&gt;(&quot;distance_threshold&quot;, distance_threshold_, double(3.0));
}

bool LaneSelectNode::isAllTopicsSubscribed()
{
  if (!is_current_pose_subscribed_ || !is_lane_array_subscribed_ || !is_current_velocity_subscribed_)
  {
    ROS_WARN(&quot;Necessary topics are not subscribed yet. Waiting...&quot;);
    return false;
  }
  return true;
}

void LaneSelectNode::initForLaneSelect()
{
  if (!isAllTopicsSubscribed())
    return;

  // search closest waypoint number for each lanes
  if (!getClosestWaypointNumberForEachLanes())
  {
    publishClosestWaypoint(-1);
    resetLaneIdx();
    return;
  }

  findCurrentLane();
  findNeighborLanes();
  updateChangeFlag();
  createLaneForChange();

  publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)));
  publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
  publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
  publishVisualizer();

  resetSubscriptionFlag();
  return;
}

void LaneSelectNode::resetLaneIdx()
{
  current_lane_idx_ = -1;
  right_lane_idx_ = -1;
  left_lane_idx_ = -1;
  publishVisualizer();
}

void LaneSelectNode::resetSubscriptionFlag()
{
  is_current_pose_subscribed_ = false;
  is_current_velocity_subscribed_ = false;
  is_current_state_subscribed_ = false;
}

void LaneSelectNode::processing()
{
  if (!isAllTopicsSubscribed())
    return;

  // search closest waypoint number for each lanes
  if (!getClosestWaypointNumberForEachLanes())
  {
    publishClosestWaypoint(-1);
    resetLaneIdx();
    return;
  }

  // if closest waypoint on current lane is -1,
  if (std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)) == -1)
  {
    publishClosestWaypoint(-1);
    resetLaneIdx();
    return;
  }

  findNeighborLanes();
  ROS_INFO(&quot;current_lane_idx: %d&quot;, current_lane_idx_);
  ROS_INFO(&quot;right_lane_idx: %d&quot;, right_lane_idx_);
  ROS_INFO(&quot;left_lane_idx: %d&quot;, left_lane_idx_);

  if (current_state_ == &quot;LANE_CHANGE&quot;)
  {
    try
    {
      changeLane();
      std::get&lt;1&gt;(lane_for_change_) =
          getClosestWaypointNumber(std::get&lt;0&gt;(lane_for_change_), current_pose_.pose, current_velocity_.twist,
                                   std::get&lt;1&gt;(lane_for_change_), distance_threshold_);
      std::get&lt;2&gt;(lane_for_change_) = static_cast&lt;ChangeFlag&gt;(
          std::get&lt;0&gt;(lane_for_change_).waypoints.at(std::get&lt;1&gt;(lane_for_change_)).change_flag);
      ROS_INFO(&quot;closest: %d&quot;, std::get&lt;1&gt;(lane_for_change_));
      publishLane(std::get&lt;0&gt;(lane_for_change_));
      publishClosestWaypoint(std::get&lt;1&gt;(lane_for_change_));
      publishChangeFlag(std::get&lt;2&gt;(lane_for_change_));
    }
    catch (std::out_of_range)
    {
      ROS_WARN(&quot;Failed to get closest waypoint num\n&quot;);
    }
  }
  else
  {
    updateChangeFlag();
    createLaneForChange();

    publishLane(std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)));
    publishClosestWaypoint(std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_)));
    publishChangeFlag(std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)));
  }
  publishVisualizer();
  resetSubscriptionFlag();
}

int32_t LaneSelectNode::getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps,
                                                           int32_t cl_wp)
{
  for (uint32_t i = cl_wp; i &lt; wps.size(); i++)
  {
    if (static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::right ||
        static_cast&lt;ChangeFlag&gt;(wps.at(i).change_flag) == ChangeFlag::left)
    {
      return i;
    }
  }
  return -1;
}

void LaneSelectNode::createLaneForChange()
{
  std::get&lt;0&gt;(lane_for_change_).waypoints.clear();
  std::get&lt;0&gt;(lane_for_change_).waypoints.shrink_to_fit();
  std::get&lt;1&gt;(lane_for_change_) = -1;

  const autoware_msgs::lane &amp;cur_lane = std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_));
  const int32_t &amp;clst_wp = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));

  int32_t num_lane_change = getClosestLaneChangeWaypointNumber(cur_lane.waypoints, clst_wp);
  ROS_INFO(&quot;num_lane_change: %d&quot;, num_lane_change);
  if (num_lane_change &lt; 0 || num_lane_change &gt;= static_cast&lt;int32_t&gt;(cur_lane.waypoints.size()))
  {
    ROS_WARN(&quot;current lane doesn't have change flag&quot;);
    return;
  }

  if ((static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right &amp;&amp;
       right_lane_idx_ &lt; 0) ||
      (static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::left &amp;&amp;
       left_lane_idx_ &lt; 0))
  {
    ROS_WARN(&quot;current lane doesn't have the lane for lane change&quot;);
    return;
  }

  double dt = getTwoDimensionalDistance(cur_lane.waypoints.at(num_lane_change).pose.pose.position,
                                        cur_lane.waypoints.at(clst_wp).pose.pose.position);
  double dt_by_vel = current_velocity_.twist.linear.x * lane_change_target_ratio_ &gt; lane_change_target_minimum_ ?
                         current_velocity_.twist.linear.x * lane_change_target_ratio_ :
                         lane_change_target_minimum_;
  ROS_INFO(&quot;dt : %lf, dt_by_vel : %lf&quot;, dt, dt_by_vel);
  autoware_msgs::lane &amp;nghbr_lane =
      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right ?
          std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)) :
          std::get&lt;0&gt;(tuple_vec_.at(left_lane_idx_));
  const int32_t &amp;nghbr_clst_wp =
      static_cast&lt;ChangeFlag&gt;(cur_lane.waypoints.at(num_lane_change).change_flag) == ChangeFlag::right ?
          std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) :
          std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_));

  int32_t target_num = -1;
  for (uint32_t i = nghbr_clst_wp; i &lt; nghbr_lane.waypoints.size(); i++)
  {
    if (i == nghbr_lane.waypoints.size() - 1 ||
        dt + dt_by_vel &lt; getTwoDimensionalDistance(nghbr_lane.waypoints.at(nghbr_clst_wp).pose.pose.position,
                                                   nghbr_lane.waypoints.at(i).pose.pose.position))
    {
      target_num = i;
      break;
    }
  }

  ROS_INFO(&quot;target_num : %d&quot;, target_num);
  if (target_num &lt; 0)
    return;

  std::get&lt;0&gt;(lane_for_change_).header.stamp = nghbr_lane.header.stamp;
  std::vector&lt;autoware_msgs::waypoint&gt; hermite_wps = generateHermiteCurveForROS(
      cur_lane.waypoints.at(num_lane_change).pose.pose, nghbr_lane.waypoints.at(target_num).pose.pose,
      cur_lane.waypoints.at(num_lane_change).twist.twist.linear.x, vlength_hermite_curve_);

  for (auto &amp;&amp;el : hermite_wps)
    el.change_flag = cur_lane.waypoints.at(num_lane_change).change_flag;

  std::get&lt;0&gt;(lane_for_change_).waypoints.reserve(nghbr_lane.waypoints.size() + hermite_wps.size());
  std::move(hermite_wps.begin(), hermite_wps.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
  auto itr = nghbr_lane.waypoints.begin();
  std::advance(itr, target_num);
  for (auto i = itr; i != nghbr_lane.waypoints.end(); i++)
  {
    if (getTwoDimensionalDistance(itr-&gt;pose.pose.position, i-&gt;pose.pose.position) &lt; lane_change_interval_)
      i-&gt;change_flag = enumToInteger(ChangeFlag::straight);
    else
      break;
  }
  std::copy(itr, nghbr_lane.waypoints.end(), std::back_inserter(std::get&lt;0&gt;(lane_for_change_).waypoints));
}

void LaneSelectNode::updateChangeFlag()
{
  for (auto &amp;el : tuple_vec_)
  {
    std::get&lt;2&gt;(el) = (std::get&lt;1&gt;(el) != -1) ?
                          static_cast&lt;ChangeFlag&gt;(std::get&lt;0&gt;(el).waypoints.at(std::get&lt;1&gt;(el)).change_flag) :
                          ChangeFlag::unknown;

    if (std::get&lt;2&gt;(el) == ChangeFlag::right &amp;&amp; right_lane_idx_ == -1)
      std::get&lt;2&gt;(el) = ChangeFlag::unknown;
    else if (std::get&lt;2&gt;(el) == ChangeFlag::left &amp;&amp; left_lane_idx_ == -1)
      std::get&lt;2&gt;(el) = ChangeFlag::unknown;

    ROS_INFO(&quot;change_flag: %d&quot;, enumToInteger(std::get&lt;2&gt;(el)));
  }
}

void LaneSelectNode::changeLane()
{
  if (std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)) == ChangeFlag::right &amp;&amp; right_lane_idx_ != -1 &amp;&amp;
      std::get&lt;1&gt;(tuple_vec_.at(right_lane_idx_)) != -1)
  {
    current_lane_idx_ = right_lane_idx_;
  }
  else if (std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_)) == ChangeFlag::left &amp;&amp; left_lane_idx_ != -1 &amp;&amp;
           std::get&lt;1&gt;(tuple_vec_.at(left_lane_idx_)) != -1)
  {
    current_lane_idx_ = left_lane_idx_;
  }

  findNeighborLanes();
  return;
}

bool LaneSelectNode::getClosestWaypointNumberForEachLanes()
{
  for (auto &amp;el : tuple_vec_)
  {
    std::get&lt;1&gt;(el) = getClosestWaypointNumber(std::get&lt;0&gt;(el), current_pose_.pose, current_velocity_.twist,
                                               std::get&lt;1&gt;(el), distance_threshold_);
    ROS_INFO(&quot;closest: %d&quot;, std::get&lt;1&gt;(el));
  }

  // confirm if all closest waypoint numbers are -1. If so, output warning
  int32_t accum = 0;
  for (const auto &amp;el : tuple_vec_)
  {
    accum += std::get&lt;1&gt;(el);
  }
  if (accum == (-1) * static_cast&lt;int32_t&gt;(tuple_vec_.size()))
  {
    ROS_WARN(&quot;Cannot get closest waypoints. All closest waypoints are changed to -1...&quot;);
    return false;
  }

  return true;
}

void LaneSelectNode::findCurrentLane()
{
  std::vector&lt;uint32_t&gt; idx_vec;
  idx_vec.reserve(tuple_vec_.size());
  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
  {
    if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
      continue;
    idx_vec.push_back(i);
  }
  current_lane_idx_ = findMostClosestLane(idx_vec, current_pose_.pose.position);
}

int32_t LaneSelectNode::findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p)
{
  std::vector&lt;double&gt; dist_vec;
  dist_vec.reserve(idx_vec.size());
  for (const auto &amp;el : idx_vec)
  {
    int32_t closest_number = std::get&lt;1&gt;(tuple_vec_.at(el));
    dist_vec.push_back(
        getTwoDimensionalDistance(p, std::get&lt;0&gt;(tuple_vec_.at(el)).waypoints.at(closest_number).pose.pose.position));
  }
  std::vector&lt;double&gt;::iterator itr = std::min_element(dist_vec.begin(), dist_vec.end());
  return idx_vec.at(std::distance(dist_vec.begin(), itr));
}

void LaneSelectNode::findNeighborLanes()
{
  int32_t current_closest_num = std::get&lt;1&gt;(tuple_vec_.at(current_lane_idx_));
  const geometry_msgs::Pose &amp;current_closest_pose =
      std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.at(current_closest_num).pose.pose;

  std::vector&lt;uint32_t&gt; left_lane_idx_vec;
  left_lane_idx_vec.reserve(tuple_vec_.size());
  std::vector&lt;uint32_t&gt; right_lane_idx_vec;
  right_lane_idx_vec.reserve(tuple_vec_.size());
  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
  {
    if (i == static_cast&lt;uint32_t&gt;(current_lane_idx_) || std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
      continue;

    int32_t target_num = std::get&lt;1&gt;(tuple_vec_.at(i));
    const geometry_msgs::Point &amp;target_p = std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(target_num).pose.pose.position;

    geometry_msgs::Point converted_p = convertPointIntoRelativeCoordinate(target_p, current_closest_pose);

    ROS_INFO(&quot;distance: %lf&quot;, converted_p.y);
    if (fabs(converted_p.y) &gt; distance_threshold_)
    {
      ROS_INFO(&quot;%d lane is far from current lane...&quot;, i);
      continue;
    }

    if (converted_p.y &gt; 0)
      left_lane_idx_vec.push_back(i);
    else
      right_lane_idx_vec.push_back(i);
  }

  if (!left_lane_idx_vec.empty())
    left_lane_idx_ = findMostClosestLane(left_lane_idx_vec, current_closest_pose.position);
  else
    left_lane_idx_ = -1;

  if (!right_lane_idx_vec.empty())
    right_lane_idx_ = findMostClosestLane(right_lane_idx_vec, current_closest_pose.position);
  else
    right_lane_idx_ = -1;
}
visualization_msgs::Marker LaneSelectNode::createCurrentLaneMarker()
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;current_lane_marker&quot;;

  if (current_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
  {
    marker.action = visualization_msgs::Marker::DELETE;
    return marker;
  }

  marker.type = visualization_msgs::Marker::LINE_STRIP;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.05;

  std_msgs::ColorRGBA color_current;
  color_current.b = 1.0;
  color_current.g = 0.7;
  color_current.a = 1.0;
  marker.color = color_current;

  for (const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints)
    marker.points.push_back(em.pose.pose.position);

  return marker;
}

visualization_msgs::Marker LaneSelectNode::createRightLaneMarker()
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;right_lane_marker&quot;;

  if (right_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
  {
    marker.action = visualization_msgs::Marker::DELETE;
    return marker;
  }

  marker.type = visualization_msgs::Marker::LINE_STRIP;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.05;

  std_msgs::ColorRGBA color_neighbor;
  color_neighbor.r = 0.5;
  color_neighbor.b = 0.5;
  color_neighbor.g = 0.5;
  color_neighbor.a = 1.0;

  std_msgs::ColorRGBA color_neighbor_change;
  color_neighbor_change.b = 0.7;
  color_neighbor_change.g = 1.0;
  color_neighbor_change.a = 1.0;

  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
  marker.color = change_flag == ChangeFlag::right ? color_neighbor_change : color_neighbor;

  for (const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at(right_lane_idx_)).waypoints)
    marker.points.push_back(em.pose.pose.position);

  return marker;
}

visualization_msgs::Marker LaneSelectNode::createLeftLaneMarker()
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;left_lane_marker&quot;;

  if (left_lane_idx_ == -1 || std::get&lt;0&gt;(tuple_vec_.at(current_lane_idx_)).waypoints.empty())
  {
    marker.action = visualization_msgs::Marker::DELETE;
    return marker;
  }

  marker.type = visualization_msgs::Marker::LINE_STRIP;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.05;

  std_msgs::ColorRGBA color_neighbor;
  color_neighbor.r = 0.5;
  color_neighbor.b = 0.5;
  color_neighbor.g = 0.5;
  color_neighbor.a = 1.0;

  std_msgs::ColorRGBA color_neighbor_change;
  color_neighbor_change.b = 0.7;
  color_neighbor_change.g = 1.0;
  color_neighbor_change.a = 1.0;

  const ChangeFlag &amp;change_flag = std::get&lt;2&gt;(tuple_vec_.at(current_lane_idx_));
  marker.color = change_flag == ChangeFlag::left ? color_neighbor_change : color_neighbor;

  for (const auto &amp;em : std::get&lt;0&gt;(tuple_vec_.at((left_lane_idx_))).waypoints)
    marker.points.push_back(em.pose.pose.position);

  return marker;
}

visualization_msgs::Marker LaneSelectNode::createChangeLaneMarker()
{
  visualization_msgs::Marker marker;
  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;change_lane_marker&quot;;

  if (std::get&lt;0&gt;(lane_for_change_).waypoints.empty())
  {
    marker.action = visualization_msgs::Marker::DELETE;
    return marker;
  }

  marker.type = visualization_msgs::Marker::LINE_STRIP;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.05;

  std_msgs::ColorRGBA color;
  color.r = 1.0;
  color.a = 1.0;

  std_msgs::ColorRGBA color_current;
  color_current.b = 1.0;
  color_current.g = 0.7;
  color_current.a = 1.0;

  marker.color = current_state_ == &quot;LANE_CHANGE&quot; ? color_current : color;
  for (const auto &amp;em : std::get&lt;0&gt;(lane_for_change_).waypoints)
    marker.points.push_back(em.pose.pose.position);

  return marker;
}

visualization_msgs::Marker LaneSelectNode::createClosestWaypointsMarker()
{
  visualization_msgs::Marker marker;
  std_msgs::ColorRGBA color_closest_wp;
  color_closest_wp.r = 1.0;
  color_closest_wp.b = 1.0;
  color_closest_wp.g = 1.0;
  color_closest_wp.a = 1.0;

  marker.header.frame_id = &quot;map&quot;;
  marker.header.stamp = ros::Time();
  marker.ns = &quot;closest_waypoints_marker&quot;;
  marker.type = visualization_msgs::Marker::POINTS;
  marker.action = visualization_msgs::Marker::ADD;
  marker.scale.x = 0.5;
  marker.color = color_closest_wp;

  marker.points.reserve(tuple_vec_.size());
  for (uint32_t i = 0; i &lt; tuple_vec_.size(); i++)
  {
    if (std::get&lt;1&gt;(tuple_vec_.at(i)) == -1)
      continue;

    marker.points.push_back(
        std::get&lt;0&gt;(tuple_vec_.at(i)).waypoints.at(std::get&lt;1&gt;(tuple_vec_.at(i))).pose.pose.position);
  }

  return marker;
}

void LaneSelectNode::publishVisualizer()
{
  visualization_msgs::MarkerArray marker_array;
  marker_array.markers.push_back(createChangeLaneMarker());
  marker_array.markers.push_back(createCurrentLaneMarker());
  marker_array.markers.push_back(createRightLaneMarker());
  marker_array.markers.push_back(createLeftLaneMarker());
  marker_array.markers.push_back(createClosestWaypointsMarker());

  vis_pub1_.publish(marker_array);
}

void LaneSelectNode::publishLane(const autoware_msgs::lane &amp;lane)
{
  // publish global lane
  pub1_.publish(lane);
}

void LaneSelectNode::publishClosestWaypoint(const int32_t clst_wp)
{
  // publish closest waypoint
  std_msgs::Int32 closest_waypoint;
  closest_waypoint.data = clst_wp;
  pub2_.publish(closest_waypoint);
}

void LaneSelectNode::publishChangeFlag(const ChangeFlag flag)
{
  std_msgs::Int32 change_flag;
  change_flag.data = enumToInteger(flag);
  pub3_.publish(change_flag);
}

void LaneSelectNode::callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr &amp;msg)
{
  tuple_vec_.clear();
  tuple_vec_.shrink_to_fit();
  tuple_vec_.reserve(msg-&gt;lanes.size());
  for (const auto &amp;el : msg-&gt;lanes)
  {
    auto t = std::make_tuple(el, -1, ChangeFlag::unknown);
    tuple_vec_.push_back(t);
  }

  current_lane_idx_ = -1;
  right_lane_idx_ = -1;
  left_lane_idx_ = -1;
  is_lane_array_subscribed_ = true;

  if (current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg)
{
  current_pose_ = *msg;
  is_current_pose_subscribed_ = true;

  if (current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg)
{
  current_velocity_ = *msg;
  is_current_velocity_subscribed_ = true;

  if (current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::callbackFromState(const std_msgs::StringConstPtr &amp;msg)
{
  current_state_ = msg-&gt;data;
  is_current_state_subscribed_ = true;

  if (current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}
void LaneSelectNode::callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg)
{
  is_current_state_subscribed_ = true;

  if (msg-&gt;behavior_state == &quot;LaneChangeRight&quot; || msg-&gt;behavior_state == &quot;LaneChangeLeft&quot;)
  {
    current_state_ = std::string(&quot;LANE_CHANGE&quot;);
    ;
  }
  else
  {
    current_state_ = msg-&gt;main_state;
  }

  if (current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg)
{
  distance_threshold_ = msg-&gt;distance_threshold_neighbor_lanes;
  lane_change_interval_ = msg-&gt;lane_change_interval;
  lane_change_target_ratio_ = msg-&gt;lane_change_target_ratio;
  lane_change_target_minimum_ = msg-&gt;lane_change_target_minimum;
  vlength_hermite_curve_ = msg-&gt;vector_length_hermite_curve;
  is_config_subscribed_ = true;

  if (current_lane_idx_ == -1)
    initForLaneSelect();
  else
    processing();
}

void LaneSelectNode::run()
{
  ros::spin();
}

// distance between target 1 and target2 in 2-D
double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2)
{
  double distance = sqrt(pow(target1.x - target2.x, 2) + pow(target1.y - target2.y, 2));
  return distance;
}

geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
                                                        const geometry_msgs::Pose &amp;pose)
{
  tf::Transform inverse;
  tf::poseMsgToTF(pose, inverse);
  tf::Transform transform = inverse.inverse();

  tf::Point p;
  pointMsgToTF(input_point, p);
  tf::Point tf_p = transform * p;
  geometry_msgs::Point tf_point_msg;
  pointTFToMsg(tf_p, tf_point_msg);
  return tf_point_msg;
}

geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
                                                     const geometry_msgs::Pose &amp;pose)
{
  tf::Transform inverse;
  tf::poseMsgToTF(pose, inverse);

  tf::Point p;
  pointMsgToTF(input_point, p);
  tf::Point tf_p = inverse * p;

  geometry_msgs::Point tf_point_msg;
  pointTFToMsg(tf_p, tf_point_msg);
  return tf_point_msg;
}

double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose)
{
  tf::Vector3 x_axis(1, 0, 0);
  tf::Transform waypoint_tfpose;
  tf::poseMsgToTF(waypoint_pose, waypoint_tfpose);
  tf::Vector3 waypoint_v = waypoint_tfpose.getBasis() * x_axis;
  tf::Transform current_tfpose;
  tf::poseMsgToTF(current_pose, current_tfpose);
  tf::Vector3 current_v = current_tfpose.getBasis() * x_axis;

  return current_v.angle(waypoint_v) * 180 / M_PI;
}

// get closest waypoint from current pose
int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
                                 const double distance_threshold)
{
  if (current_lane.waypoints.empty())
    return -1;

  std::vector&lt;uint32_t&gt; idx_vec;
  // if previous number is -1, search closest waypoint from waypoints in front of current pose
  if (previous_number == -1)
  {
    idx_vec.reserve(current_lane.waypoints.size());
    for (uint32_t i = 0; i &lt; current_lane.waypoints.size(); i++)
    {
      geometry_msgs::Point converted_p =
          convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
      double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
      if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
        idx_vec.push_back(i);
    }
  }
  else
  {
    if (distance_threshold &lt;
        getTwoDimensionalDistance(current_lane.waypoints.at(previous_number).pose.pose.position, current_pose.position))
    {
      ROS_WARN(&quot;Current_pose is far away from previous closest waypoint. Initilized...&quot;);
      return -1;
    }

    double ratio = 3;
    double minimum_dt = 2.0;
    double dt = current_velocity.linear.x * ratio &gt; minimum_dt ? current_velocity.linear.x * ratio : minimum_dt;

    auto range_max = static_cast&lt;uint32_t&gt;(previous_number + dt) &lt; current_lane.waypoints.size() ?
                         static_cast&lt;uint32_t&gt;(previous_number + dt) :
                         current_lane.waypoints.size();
    for (uint32_t i = static_cast&lt;uint32_t&gt;(previous_number); i &lt; range_max; i++)
    {
      geometry_msgs::Point converted_p =
          convertPointIntoRelativeCoordinate(current_lane.waypoints.at(i).pose.pose.position, current_pose);
      double angle = getRelativeAngle(current_lane.waypoints.at(i).pose.pose, current_pose);
      if (converted_p.x &gt; 0 &amp;&amp; angle &lt; 90)
        idx_vec.push_back(i);
    }
  }

  if (idx_vec.empty())
    return -1;

  std::vector&lt;double&gt; dist_vec;
  dist_vec.reserve(idx_vec.size());
  for (const auto &amp;el : idx_vec)
  {
    double dt = getTwoDimensionalDistance(current_pose.position, current_lane.waypoints.at(el).pose.pose.position);
    dist_vec.push_back(dt);
  }
  std::vector&lt;double&gt;::iterator itr = std::min_element(dist_vec.begin(), dist_vec.end());
  int32_t found_number = idx_vec.at(static_cast&lt;uint32_t&gt;(std::distance(dist_vec.begin(), itr)));
  return found_number;
}

// let the linear equation be &quot;ax + by + c = 0&quot;
// if there are two points (x1,y1) , (x2,y2), a = &quot;y2-y1, b = &quot;(-1) * x2 - x1&quot; ,c = &quot;(-1) * (y2-y1)x1 + (x2-x1)y1&quot;
bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c)
{
  //(x1, y1) = (start.x, star.y), (x2, y2) = (end.x, end.y)
  double sub_x = fabs(start.x - end.x);
  double sub_y = fabs(start.y - end.y);
  double error = pow(10, -5);  // 0.00001

  if (sub_x &lt; error &amp;&amp; sub_y &lt; error)
  {
    ROS_INFO(&quot;two points are the same point!!&quot;);
    return false;
  }

  *a = end.y - start.y;
  *b = (-1) * (end.x - start.x);
  *c = (-1) * (end.y - start.y) * start.x + (end.x - start.x) * start.y;

  return true;
}
double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double a, double b, double c)
{
  double d = fabs(a * point.x + b * point.y + c) / sqrt(pow(a, 2) + pow(b, 2));

  return d;
}

}  // lane_planner
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/mission/packages/lane_planner/nodes/lane_select/lane_select_core.h" new_path="ros/src/computing/planning/mission/packages/lane_planner/nodes/lane_select/lane_select_core.h">
				<diff>@@ -82,7 +82,7 @@ private:
   ros::NodeHandle private_nh_;
 
   // publisher
-  ros::Publisher pub1_, pub2_, pub3_;
+  ros::Publisher pub1_, pub2_, pub3_, pub4_;
   ros::Publisher vis_pub1_;
 
   // subscriber
@@ -133,6 +133,7 @@ private:
   bool isAllTopicsSubscribed();
   void processing();
   void publishLane(const autoware_msgs::lane &amp;lane);
+  void publishLaneID(const autoware_msgs::lane &amp;lane);
   void publishClosestWaypoint(const int32_t clst_wp);
   void publishChangeFlag(const ChangeFlag flag);
   bool getClosestWaypointNumberForEachLanes();
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University

 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef LANE_SELECT_CORE_H
#define LANE_SELECT_CORE_H

// ROS includes
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;

// C++ includes
#include &lt;iostream&gt;
#include &lt;numeric&gt;
#include &lt;tuple&gt;

// User defined includes
#include &quot;autoware_msgs/ConfigLaneSelect.h&quot;
#include &quot;autoware_msgs/LaneArray.h&quot;
#include &quot;autoware_msgs/state.h&quot;
#include &quot;hermite_curve.h&quot;
#include &quot;waypoint_follower/libwaypoint_follower.h&quot;

namespace lane_planner
{
enum class ChangeFlag : int32_t
{
  straight,
  right,
  left,

  unknown = -1,
};

template &lt;class T&gt;
typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
{
  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
}

class LaneSelectNode
{
public:
  LaneSelectNode();
  ~LaneSelectNode();

  void run();

private:
  // handle
  ros::NodeHandle nh_;
  ros::NodeHandle private_nh_;

  // publisher
  ros::Publisher pub1_, pub2_, pub3_;
  ros::Publisher vis_pub1_;

  // subscriber
  ros::Subscriber sub1_, sub2_, sub3_, sub4_, sub5_, sub6_;

  // variables
  int32_t current_lane_idx_;  // the index of the lane we are driving
  int32_t right_lane_idx_;
  int32_t left_lane_idx_;
  std::vector&lt;std::tuple&lt;autoware_msgs::lane, int32_t, ChangeFlag&gt;&gt; tuple_vec_;  // lane, closest_waypoint,
                                                                                 // change_flag
  std::tuple&lt;autoware_msgs::lane, int32_t, ChangeFlag&gt; lane_for_change_;
  bool is_lane_array_subscribed_, is_current_pose_subscribed_, is_current_velocity_subscribed_,
      is_current_state_subscribed_, is_config_subscribed_;

  // parameter from runtime manager
  double distance_threshold_, lane_change_interval_, lane_change_target_ratio_, lane_change_target_minimum_,
      vlength_hermite_curve_;

  // topics
  geometry_msgs::PoseStamped current_pose_;
  geometry_msgs::TwistStamped current_velocity_;
  std::string current_state_;

  // callbacks
  void callbackFromLaneArray(const autoware_msgs::LaneArrayConstPtr &amp;msg);
  void callbackFromPoseStamped(const geometry_msgs::PoseStampedConstPtr &amp;msg);
  void callbackFromTwistStamped(const geometry_msgs::TwistStampedConstPtr &amp;msg);
  void callbackFromState(const std_msgs::StringConstPtr &amp;msg);
  void callbackFromStates(const autoware_msgs::stateConstPtr &amp;msg);
  void callbackFromConfig(const autoware_msgs::ConfigLaneSelectConstPtr &amp;msg);

  // initializer
  void initForROS();
  void initForLaneSelect();

  // visualizer
  void publishVisualizer();
  visualization_msgs::Marker createCurrentLaneMarker();
  visualization_msgs::Marker createRightLaneMarker();
  visualization_msgs::Marker createLeftLaneMarker();
  visualization_msgs::Marker createClosestWaypointsMarker();
  visualization_msgs::Marker createChangeLaneMarker();

  // functions
  void resetLaneIdx();
  void resetSubscriptionFlag();
  bool isAllTopicsSubscribed();
  void processing();
  void publishLane(const autoware_msgs::lane &amp;lane);
  void publishClosestWaypoint(const int32_t clst_wp);
  void publishChangeFlag(const ChangeFlag flag);
  bool getClosestWaypointNumberForEachLanes();
  int32_t findMostClosestLane(const std::vector&lt;uint32_t&gt; idx_vec, const geometry_msgs::Point p);
  void findCurrentLane();
  void findNeighborLanes();
  void changeLane();
  void updateChangeFlag();
  void createLaneForChange();
  int32_t getClosestLaneChangeWaypointNumber(const std::vector&lt;autoware_msgs::waypoint&gt; &amp;wps, int32_t cl_wp);
};

int32_t getClosestWaypointNumber(const autoware_msgs::lane &amp;current_lane, const geometry_msgs::Pose &amp;current_pose,
                                 const geometry_msgs::Twist &amp;current_velocity, const int32_t previous_number,
                                 const double distance_threshold);

double getTwoDimensionalDistance(const geometry_msgs::Point &amp;target1, const geometry_msgs::Point &amp;target2);

geometry_msgs::Point convertPointIntoRelativeCoordinate(const geometry_msgs::Point &amp;input_point,
                                                        const geometry_msgs::Pose &amp;pose);

geometry_msgs::Point convertPointIntoWorldCoordinate(const geometry_msgs::Point &amp;input_point,
                                                     const geometry_msgs::Pose &amp;pose);
double getRelativeAngle(const geometry_msgs::Pose &amp;waypoint_pose, const geometry_msgs::Pose &amp;current_pose);
bool getLinearEquation(geometry_msgs::Point start, geometry_msgs::Point end, double *a, double *b, double *c);
double getDistanceBetweenLineAndPoint(geometry_msgs::Point point, double sa, double b, double c);
}
#endif  // LANE_SELECT_CORE_H
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="e477ffb9d18e938432658a5e9199b3707fca5a07" fix_time="27,72291">
		<msg>Remove debug code and apply clang format</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -33,10 +33,13 @@ bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
 {
   bool _ret;
   ctx-&gt;setEnableForceSetState(true);
-  if(!ctx-&gt;isCurrentState(_state_num)){
-	  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-  }else{
-	  _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
+  if (!ctx-&gt;isCurrentState(_state_num))
+  {
+    _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+  }
+  else
+  {
+    _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
   }
   ctx-&gt;setEnableForceSetState(false);
   return _ret;
@@ -57,19 +60,21 @@ void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
 
 void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
 {
-	if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT)){
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-	}
-	else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT)){
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-	}
-	else
-	{
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
-		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
-	}
+  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+  }
+  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+  }
+  else
+  {
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
+    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
+  }
 }
 
 void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const unsigned long long _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  if(!ctx-&gt;isCurrentState(_state_num)){
	  _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
  }else{
	  _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
  }
  ctx-&gt;setEnableForceSetState(false);
  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request: %lx&quot;, 1ULL &lt;&lt; (uint64_t)msg.data);
  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
	if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT)){
		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
	}
	else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT)){
		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
		ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
	}
	else
	{
		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
		ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
	}
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);

  param_target_waypoint_ = msg.target_waypoint;
  // param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
  param_shift_width_ = msg.shift_width;
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{
  const ros::M_string &amp;header = event.getConnectionHeader();
  std::string topic = header.at(&quot;topic&quot;);
  const autoware_msgs::traffic_light *light = event.getMessage().get();

  current_traffic_light = light-&gt;traffic_light;
  if (current_traffic_light == state_machine::E_RED || current_traffic_light == state_machine::E_YELLOW)
  {
    // ctx-&gt;setCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
  else
  {
    // ctx-&gt;disableCurrentState(state_machine::DRIVE_DETECT_TRAFFICLIGHT_RED_STATE);
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
          }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;wp_lane : laneinArea.waypoints)
      {
        for (auto &amp;lane : lane_array.lanes)
        {
          for (auto &amp;wp : lane.waypoints)
          {
            if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
            {
              wp.wpstate.steering_state = steering_state;
            }
          }
          // lane.waypoints.at(wp_lane.lid).wpstate.steering_state = steering_state;
        }
      }
    }
  }
  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);
  });

  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
            // lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  int gid = 0;
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int lid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
                   param_stopline_target_waypoint_ :
                   current_finalwaypoints_.waypoints.size() - 1;
  if (idx &gt;= 0)
  {
    if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
      ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
  }
  // steering
  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
            param_target_waypoint_ :
            current_finalwaypoints_.waypoints.size() - 1;
  if (idx &gt;= 0)
  {
    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
    {
      ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
    }
    if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
    {
      ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
    }
    else
    {
      ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
    }
  }

  // for publish plan of velocity
  publishToVelocityArray();
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  vMap_Areas = msg;
  vMap_Areas_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  vMap_Points = msg;
  vMap_Points_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  vMap_Lines = msg;
  vMap_Lines_flag = true;
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  vMap_CrossRoads = msg;
  vMap_CrossRoads_flag = true;
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -11,88 +11,92 @@ namespace decision_maker
 {
 void DecisionMakerNode::setupStateCallback(void)
 {
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
-  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
+  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
+                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
 
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
-  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
+                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
+                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
+  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
+                         std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
+                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
+                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));
 
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                      std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
+                             std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
+                         std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
   ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
-                      std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
+                          std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
 }
 
 void DecisionMakerNode::createShiftLane(void)
 {
-  if(!created_shift_lane_flag_)
+  if (!created_shift_lane_flag_)
   {
-	  created_shift_lane_flag_ = true;
-	  autoware_msgs::lane shift_lane;
-	  current_shifted_lane_array_ = current_based_lane_array_;
-	  if (!current_shifted_lane_array_.lanes.empty())
-	  {
-		  shift_lane = current_shifted_lane_array_.lanes.at(0);
-		  size_t idx = 0;
-		  for (auto &amp;wp : shift_lane.waypoints)
-		  {
-			  double current_angle = getPoseAngle(wp.pose.pose);
-			  wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
-			  wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
-			  wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
-		  }
-		  auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
-
-		  for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
-		  {
-			  wp.change_flag = 1;
-		  }
-	  }
+    created_shift_lane_flag_ = true;
+    autoware_msgs::lane shift_lane;
+    current_shifted_lane_array_ = current_based_lane_array_;
+    if (!current_shifted_lane_array_.lanes.empty())
+    {
+      shift_lane = current_shifted_lane_array_.lanes.at(0);
+      size_t idx = 0;
+      for (auto &amp;wp : shift_lane.waypoints)
+      {
+        double current_angle = getPoseAngle(wp.pose.pose);
+        wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
+        wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
+        wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
+      }
+      auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);
+
+      for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
+      {
+        wp.change_flag = 1;
+      }
+    }
   }
 }
 
-void DecisionMakerNode::changeShiftLane(void){
-	try{
-		for(size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx+=2){
-			for(size_t wp_idx; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++){
-				current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag = current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag;
-				current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag = 2;
-			}
-		}
-	}
-	catch(std::out_of_range){
-		fprintf(stderr,&quot;out\n&quot;);
-	}
+void DecisionMakerNode::changeShiftLane(void)
+{
+  try
+  {
+    for (size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx += 2)
+    {
+      for (size_t wp_idx; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++)
+      {
+        current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag =
+            current_shifted_lane_array_.lanes.at(idx + 1).waypoints.at(wp_idx).change_flag;
+        current_shifted_lane_array_.lanes.at(idx + 1).waypoints.at(wp_idx).change_flag = 2;
+      }
+    }
+  }
+  catch (std::out_of_range)
+  {
+    fprintf(stderr, &quot;out\n&quot;);
+  }
 }
 
-void DecisionMakerNode::removeShiftLane(void){
-	current_shifted_lane_array_ = current_based_lane_array_;
-	created_shift_lane_flag_ = false;
-#if 0
-	if(created_shift_lane_flag_){
-		if(!current_shifted_lane_array_.lanes.size()&gt;=2){
-			for(auto it = begin(current_shifted_lane_array_.lanes)+1; it!=end(current_shifted_lane_array_.lanes); it+=2)
-				current_shifted_lane_array_.lanes.erase(it);
-		}
-		created_shift_lane_flag_ = false;
-	}
-#endif
+void DecisionMakerNode::removeShiftLane(void)
+{
+  current_shifted_lane_array_ = current_based_lane_array_;
+  created_shift_lane_flag_ = false;
 }
 
 void DecisionMakerNode::updateLaneWaypointsArray(void)
 {
-  // current_stopped_lane_array_ = current_controlled_lane_array_;
   current_stopped_lane_array_ = current_controlled_lane_array_;
 
   for (auto &amp;lane : current_stopped_lane_array_.lanes)
@@ -107,25 +111,21 @@ void DecisionMakerNode::updateLaneWaypointsArray(void)
 
 void DecisionMakerNode::publishControlledLaneArray(void)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
 }
 void DecisionMakerNode::publishStoppedLaneArray(void)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   updateLaneWaypointsArray();
   Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
 }
 
 void DecisionMakerNode::changeVelocityBasedLane(void)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   current_controlled_lane_array_ = current_shifted_lane_array_;
 }
 
 void DecisionMakerNode::changeVelocityLane(int dir)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   for (auto &amp;lane : current_controlled_lane_array_.lanes)
   {
     autoware_msgs::lane temp_lane = lane;
@@ -139,7 +139,8 @@ void DecisionMakerNode::changeVelocityLane(int dir)
                            temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);
 
       double distance = amathutils::find_distance(&amp;p0, &amp;p1);
-      double _weight = distance * 0.05 * dir;
+      double _rate = 0.2;                       // accelerated/decelerated rate
+      double _weight = distance * _rate * dir;  //
       lane.waypoints.at(wpi).twist.twist.linear.x =
           lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
     }
@@ -148,20 +149,17 @@ void DecisionMakerNode::changeVelocityLane(int dir)
 
 void DecisionMakerNode::callbackInStateKeep(int status)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   changeVelocityBasedLane();
   publishControlledLaneArray();
 }
 
 void DecisionMakerNode::callbackInStateAcc(int status)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   changeVelocityLane(status);
   publishControlledLaneArray();
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   static ros::Timer stopping_timer;
   static bool timerflag = false;
   if (status)
@@ -171,7 +169,7 @@ void DecisionMakerNode::updateStateStop(int status)
       stopping_timer = nh_.createTimer(ros::Duration(1),
                                        [&amp;](const ros::TimerEvent &amp;) {
                                          ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
-                                         ROS_INFO(&quot;Change state to keep from stop\n&quot;);
+                                         ROS_INFO(&quot;Change state to [KEEP] from [STOP]\n&quot;);
                                          timerflag = false;
                                        },
                                        this, true);
@@ -182,58 +180,47 @@ void DecisionMakerNode::updateStateStop(int status)
 
 void DecisionMakerNode::updateStateObstacleAvoid(int status)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
-  static ros::Timer avoidance_timer;
-  static bool stopped_flag = false;
-
-  if(current_velocity_ == 0.0){
-	stopped_flag = true;
-  }
 }
 
 void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
-	static ros::Timer avoidance_timer_2;
-	ROS_INFO(&quot;End of Avoidance\n&quot;);
-	changeShiftLane();
-	changeVelocityBasedLane();
-	publishControlledLaneArray();
-
-	ros::Rate loop_rate(1);
-	//blocking
-	
-	
-	do{
-		ros::spinOnce();
-		loop_rate.sleep();
-	}
-	while(!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
-				       	!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
-	do{
-		ros::spinOnce();
-		loop_rate.sleep();
-	}
-	while((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
-				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
-				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE) )&amp;&amp; ros::ok() );
+  static ros::Timer avoidance_timer_2;
+  changeShiftLane();
+  changeVelocityBasedLane();
+  publishControlledLaneArray();
 
-	removeShiftLane();
-	changeVelocityBasedLane();
-	publishControlledLaneArray();
-	return;
+  ros::Rate loop_rate(1);
+  // wait for the start of lane change to the original lane
+  do
+  {
+    ros::spinOnce();
+    loop_rate.sleep();
+  } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
+           !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
+  // wait for the end of lane change
+  do
+  {
+    ros::spinOnce();
+    loop_rate.sleep();
+  } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
+            ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
+            ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
+           ros::ok());
+
+  removeShiftLane();
+  changeVelocityBasedLane();  // rebased controlled lane
+  publishControlledLaneArray();
+  return;
 }
 
 void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
   createShiftLane();
   changeVelocityBasedLane();
 }
 void DecisionMakerNode::callbackInStateStop(int status)
 {
-	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
   publishStoppedLaneArray();
 }
 
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;decision_maker_node.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::setupStateCallback(void)
{
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE, std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));

  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                      std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE, std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                      std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));

  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                      std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                      std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                      std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));
}

void DecisionMakerNode::createShiftLane(void)
{
  if(!created_shift_lane_flag_)
  {
	  created_shift_lane_flag_ = true;
	  autoware_msgs::lane shift_lane;
	  current_shifted_lane_array_ = current_based_lane_array_;
	  if (!current_shifted_lane_array_.lanes.empty())
	  {
		  shift_lane = current_shifted_lane_array_.lanes.at(0);
		  size_t idx = 0;
		  for (auto &amp;wp : shift_lane.waypoints)
		  {
			  double current_angle = getPoseAngle(wp.pose.pose);
			  wp.pose.pose.position.x -= param_shift_width_ * cos(current_angle + M_PI / 2);
			  wp.pose.pose.position.y -= param_shift_width_ * sin(current_angle + M_PI / 2);
			  wp.change_flag = current_based_lane_array_.lanes.at(0).waypoints.at(idx++).change_flag;
		  }
		  auto it = current_shifted_lane_array_.lanes.insert(current_shifted_lane_array_.lanes.begin() + 1, shift_lane);

		  for (auto &amp;wp : current_shifted_lane_array_.lanes.at(0).waypoints)
		  {
			  wp.change_flag = 1;
		  }
	  }
  }
}

void DecisionMakerNode::changeShiftLane(void){
	try{
		for(size_t idx = 0; idx &lt; current_shifted_lane_array_.lanes.size(); idx+=2){
			for(size_t wp_idx; wp_idx &lt; current_shifted_lane_array_.lanes.at(idx).waypoints.size(); wp_idx++){
				current_shifted_lane_array_.lanes.at(idx).waypoints.at(wp_idx).change_flag = current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag;
				current_shifted_lane_array_.lanes.at(idx+1).waypoints.at(wp_idx).change_flag = 2;
			}
		}
	}
	catch(std::out_of_range){
		fprintf(stderr,&quot;out\n&quot;);
	}
}

void DecisionMakerNode::removeShiftLane(void){
	current_shifted_lane_array_ = current_based_lane_array_;
	created_shift_lane_flag_ = false;
#if 0
	if(created_shift_lane_flag_){
		if(!current_shifted_lane_array_.lanes.size()&gt;=2){
			for(auto it = begin(current_shifted_lane_array_.lanes)+1; it!=end(current_shifted_lane_array_.lanes); it+=2)
				current_shifted_lane_array_.lanes.erase(it);
		}
		created_shift_lane_flag_ = false;
	}
#endif
}

void DecisionMakerNode::updateLaneWaypointsArray(void)
{
  // current_stopped_lane_array_ = current_controlled_lane_array_;
  current_stopped_lane_array_ = current_controlled_lane_array_;

  for (auto &amp;lane : current_stopped_lane_array_.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      wp.twist.twist.linear.x = 0.0;
      wp.wpstate.stopline_state = 0;
    }
  }
}

void DecisionMakerNode::publishControlledLaneArray(void)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  current_controlled_lane_array_ = current_shifted_lane_array_;
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  for (auto &amp;lane : current_controlled_lane_array_.lanes)
  {
    autoware_msgs::lane temp_lane = lane;
    for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
    {
      amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                           temp_lane.waypoints.at(wpi).pose.pose.position.y,
                           temp_lane.waypoints.at(wpi).pose.pose.position.z);
      amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                           temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                           temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

      double distance = amathutils::find_distance(&amp;p0, &amp;p1);
      double _weight = distance * 0.05 * dir;
      lane.waypoints.at(wpi).twist.twist.linear.x =
          lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
    }
  }
}

void DecisionMakerNode::callbackInStateKeep(int status)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  changeVelocityBasedLane();
  publishControlledLaneArray();
}

void DecisionMakerNode::callbackInStateAcc(int status)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  changeVelocityLane(status);
  publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  static ros::Timer stopping_timer;
  static bool timerflag = false;
  if (status)
  {
    if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
    {
      stopping_timer = nh_.createTimer(ros::Duration(1),
                                       [&amp;](const ros::TimerEvent &amp;) {
                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
                                         ROS_INFO(&quot;Change state to keep from stop\n&quot;);
                                         timerflag = false;
                                       },
                                       this, true);
      timerflag = true;
    }
  }
}

void DecisionMakerNode::updateStateObstacleAvoid(int status)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  static ros::Timer avoidance_timer;
  static bool stopped_flag = false;

  if(current_velocity_ == 0.0){
	stopped_flag = true;
  }
}

void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
	static ros::Timer avoidance_timer_2;
	ROS_INFO(&quot;End of Avoidance\n&quot;);
	changeShiftLane();
	changeVelocityBasedLane();
	publishControlledLaneArray();

	ros::Rate loop_rate(1);
	//blocking
	
	
	do{
		ros::spinOnce();
		loop_rate.sleep();
	}
	while(!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
				       	!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
	do{
		ros::spinOnce();
		loop_rate.sleep();
	}
	while((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
				       	ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE) )&amp;&amp; ros::ok() );

	removeShiftLane();
	changeVelocityBasedLane();
	publishControlledLaneArray();
	return;
}

void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
  createShiftLane();
  changeVelocityBasedLane();
}
void DecisionMakerNode::callbackInStateStop(int status)
{
	fprintf(stderr,&quot;[%s]:%d:\n&quot;,__func__,__LINE__);
  publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch (status)
  {
    case LAMP_LEFT:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_OFF;
      break;
    case LAMP_RIGHT:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_HAZARD:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_EMPTY:
    default:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_OFF;
      break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="3c1313317842c848729560f52a873bf3b85ea847" fix_time="0,0">
		<msg>fix audion function and add confirm function when reload and move page</msg>
		<modified_files>
			<file old_path="ui/web/remote_monitor/template/demo_operator_window.html" new_path="ui/web/remote_monitor/template/demo_operator_window.html">
				<diff>@@ -22,6 +22,11 @@
   &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;/js/gamepad.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;/js/vehicle_button.js&quot;&gt;&lt;/script&gt;
+  &lt;script&gt;
+    window.addEventListener('beforeunload', function(e) {
+      e.returnValue = 'Do you want to leave this page?';
+    }, false);
+  &lt;/script&gt;
 &lt;/head&gt;
 
 &lt;body&gt;
</diff>
				<old_file>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot; /&gt;
  &lt;title&gt;Autoware&lt;/title&gt;
  &lt;link rel=&quot;shortcut icon&quot; href=&quot;/img/autoware_icon.ico&quot;&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.min.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/speed_meters.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bar.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/button.css&quot; /&gt;

  &lt;script src=&quot;/js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/webrtc_polyfill.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/utility.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/gamepad.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/vehicle_button.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;!-- Header --&gt;
  &lt;header class=&quot;navbar-static-top bs-docs-nav&quot;&gt;
    &lt;div class=&quot;navbar-inner&quot;&gt;
      &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;navbar-header&quot;&gt;
          &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;
          &lt;li class=&quot;dropdown&quot; id=&quot;ddJoinRoom&quot;&gt;
            &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; id=&quot;btnJoinRoom&quot;&gt;CONNECT&lt;b class=&quot;caret&quot;&gt;&lt;/b&gt;&lt;/a&gt;
            &lt;ul class=&quot;dropdown-menu&quot; id=&quot;ddmJoinRoom&quot; style=&quot;padding: 15px;min-width: 350px; height: 150px&quot;&gt;
              &lt;li&gt;
                &lt;div class=&quot;row&quot;&gt;
                  &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;form class=&quot;form&quot; role=&quot;form&quot; id=&quot;formJoinRoom&quot;&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;txtRoomName&quot; class=&quot;control-label&quot;&gt;CONNECT VEHICLE (Set Vehicle ID)&lt;/label&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;txtRoomName&quot; required&gt;
                      &lt;/div&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-block&quot;&gt;CONNECT&lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/form&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;div id=&quot;maskPanel&quot;&gt;&lt;/div&gt;

  &lt;!-- UI --&gt;
  &lt;div class=&quot;container&quot; id=&quot;container&quot;&gt;
    &lt;!-- First row --&gt;
    &lt;div class=&quot;row row-eq-height row-top&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 5px&quot;&gt;
          &lt;h2&gt;&lt;u&gt;Vehicle Info&lt;/u&gt;&lt;h2&gt;
          &lt;h3 id=&quot;text_speed&quot;&gt;Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_target_speed&quot;&gt;Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_next_target_speed&quot;&gt;Next Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_state&quot;&gt;State: -&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView2&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView5&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView6&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Second row --&gt;
    &lt;div class=&quot;row row-eq-height row-center&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView3&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView1&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView4&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream1&quot; data-no=&quot;1&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream1&quot; data-no=&quot;1&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Operator Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView1&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Third row --&gt;
    &lt;div class=&quot;row row-eq-height row-bottom&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;img id=&quot;vehicle_steering&quot; src=&quot;/img/steering.png&quot;&gt;&lt;/img&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;dashboard&quot;&gt;
          &lt;div class=&quot;meter meter--rpm meter--big-label&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;meter meter--gear&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt;
          &lt;div class=&quot;meter meter--speed&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 10px&quot;&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Accel&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Brake&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Vehicle Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;fill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Accel&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;controller_accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Brake&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;controller_brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;cfill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&quot;select-wrap select-circle&quot;&gt;
            &lt;h4 class=&quot;operator&quot;&gt;Gear&lt;/h4&gt;
            &lt;select name=&quot;gear&quot; id=&quot;gear&quot; onChange=&quot;select_gear(this);&quot;&gt;
              &lt;option value=&quot;0&quot;&gt;P&lt;/option&gt;
              &lt;option value=&quot;1&quot;&gt;D&lt;/option&gt;
              &lt;option value=&quot;2&quot;&gt;R&lt;/option&gt;
              &lt;option value=&quot;3&quot;&gt;N&lt;/option&gt;
              &lt;option value=&quot;3&quot;&gt;B&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;onoffswitch&quot;&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;emergencyswitch&quot; checked onchange=&quot;select_emergency_button();&quot;&gt;
            &lt;label class=&quot;onoffswitch-label&quot; for=&quot;emergencyswitch&quot;&gt;
                &lt;span class=&quot;emergencyswitch-inner&quot;&gt;&lt;/span&gt;
            &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;onoffswitch&quot;&gt;
          &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;modeswitch&quot; checked onchange=&quot;select_mode_button();&quot;&gt;
          &lt;label class=&quot;onoffswitch-label&quot; for=&quot;modeswitch&quot;&gt;
              &lt;span class=&quot;modeswitch-inner&quot;&gt;&lt;/span&gt;
          &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;row&quot;&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_left&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;◁&quot; onclick=&quot;pushBlinker(1)&quot;&gt;
          &lt;/div&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_hazard&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;△&quot; onclick=&quot;pushBlinker(3)&quot;&gt;
          &lt;/div&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_right&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;▷&quot; onclick=&quot;pushBlinker(2)&quot;&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Select Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;selectDeviceDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
          &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;Select Capture Device&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;othorSelectDevice&quot;&gt;
            &lt;label for=&quot;ddDevices&quot; class=&quot;control-label&quot;&gt;Device&lt;/label&gt;
            &lt;select class=&quot;input-large form-control&quot; id=&quot;deviceList&quot;&gt;&lt;/select&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;firefoxSelectDevice&quot;&gt;
            &lt;span id=&quot;ffMessage&quot; class=&quot;control-label&quot;&gt;Click the Select Device.&lt;br /&gt;&lt;button id=&quot;btnFfSelectDevice&quot;&gt;Select Device&lt;/button&gt;&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;streamPreview control-label&quot;&gt;Preview&lt;/label&gt;
            &lt;div class=&quot;form-control&quot; id=&quot;devicePreview&quot;&gt;
              &lt;video id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot;&gt;
          &lt;button type=&quot;button&quot; id=&quot;btnDialogAddStream&quot; class=&quot;btn btn-primary&quot;&gt;Add Stream&lt;/button&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Message Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;messageDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; data-backdrop=&quot;static&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          VEHICLE ID: &lt;input type=&quot;text&quot; id=&quot;dialogRoomName&quot; size=&quot;36&quot; readonly /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;p id=&quot;messageText&quot;&gt;&lt;/p&gt;
          &lt;span id=&quot;waitingIcon&quot; class=&quot;glyphicon glyphicon-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot; id=&quot;messageDialogFooter&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;CLOSE&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</old_file>
			</file>
			<file old_path="ui/web/remote_monitor/template/demo_vehicle_window.html" new_path="ui/web/remote_monitor/template/demo_vehicle_window.html">
				<diff>@@ -20,6 +20,11 @@
   &lt;script src=&quot;/js/webrtc_polyfill.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;/js/utility.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
+  &lt;script&gt;
+    window.addEventListener('beforeunload', function(e) {
+      e.returnValue = 'Do you want to leave this page?';
+    }, false);
+  &lt;/script&gt;
 &lt;/head&gt;
 
 &lt;body&gt;
</diff>
				<old_file>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot; /&gt;
  &lt;title&gt;Autoware&lt;/title&gt;
  &lt;link rel=&quot;shortcut icon&quot; href=&quot;/img/autoware_icon.ico&quot;&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.min.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/speed_meters.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bar.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/button.css&quot; /&gt;

  &lt;script src=&quot;/js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/webrtc_polyfill.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/utility.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;!-- Header --&gt;
  &lt;header class=&quot;navbar-static-top bs-docs-nav&quot;&gt;
    &lt;div class=&quot;navbar-inner&quot;&gt;
      &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;navbar-header&quot;&gt;
          &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;
          &lt;li class=&quot;dropdown&quot; id=&quot;ddJoinRoom&quot;&gt;
            &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; id=&quot;btnJoinRoom&quot;&gt;CONNECT&lt;b class=&quot;caret&quot;&gt;&lt;/b&gt;&lt;/a&gt;
            &lt;ul class=&quot;dropdown-menu&quot; id=&quot;ddmJoinRoom&quot; style=&quot;padding: 15px;min-width: 350px; height: 150px&quot;&gt;
              &lt;li&gt;
                &lt;div class=&quot;row&quot;&gt;
                  &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;form class=&quot;form&quot; role=&quot;form&quot; id=&quot;formJoinRoom&quot;&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;txtRoomName&quot; class=&quot;control-label&quot;&gt;CONNECT VEHICLE (Set Vehicle ID)&lt;/label&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;txtRoomName&quot; required&gt;
                      &lt;/div&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-block&quot;&gt;CONNECT&lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/form&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;div id=&quot;maskPanel&quot;&gt;&lt;/div&gt;

  &lt;!-- UI --&gt;
  &lt;div class=&quot;container&quot; id=&quot;container&quot;&gt;
    &lt;!-- First row --&gt;
    &lt;div class=&quot;row row-eq-height row-top&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 5px&quot;&gt;
          &lt;h2&gt;&lt;u&gt;Vehicle Info&lt;/u&gt;&lt;h2&gt;
          &lt;h3 id=&quot;text_speed&quot;&gt;Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_target_speed&quot;&gt;Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_next_target_speed&quot;&gt;Next Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_state&quot;&gt;State: -&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream2&quot; data-no=&quot;2&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream2&quot; data-no=&quot;2&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView2&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream5&quot; data-no=&quot;5&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream5&quot; data-no=&quot;5&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Dashboard Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView5&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream6&quot; data-no=&quot;6&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream6&quot; data-no=&quot;6&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Internal Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView6&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;

    &lt;!-- UI Second row --&gt;
    &lt;div class=&quot;row row-eq-height row-center&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream3&quot; data-no=&quot;3&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream3&quot; data-no=&quot;3&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Left Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView3&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream1&quot; data-no=&quot;1&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream1&quot; data-no=&quot;1&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Front Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView1&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream4&quot; data-no=&quot;4&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream4&quot; data-no=&quot;4&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Right Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView4&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView1&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Third row --&gt;
    &lt;div class=&quot;row row-eq-height row-bottom&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;img id=&quot;vehicle_steering&quot; src=&quot;/img/steering.png&quot;&gt;&lt;/img&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;dashboard&quot;&gt;
        	&lt;div class=&quot;meter meter--rpm meter--big-label&quot;&gt;&lt;/div&gt;
        	&lt;div class=&quot;meter meter--gear&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt;
        	&lt;div class=&quot;meter meter--speed&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 10px&quot;&gt;
          &lt;h4&gt;Accel&lt;/h4&gt;
          &lt;progress id=&quot;accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4&gt;Brake&lt;/h4&gt;
          &lt;progress id=&quot;brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4&gt;Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;fill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&quot;select-wrap select-circle&quot;&gt;
            &lt;h4&gt;Gear&lt;/h4&gt;
            &lt;select name=&quot;gear&quot; id=&quot;gear&quot; onChange=&quot;select_gear(this);&quot;&gt;
              &lt;option value=&quot;0&quot;&gt;P&lt;/option&gt;
              &lt;option value=&quot;1&quot;&gt;N&lt;/option&gt;
              &lt;option value=&quot;2&quot;&gt;D&lt;/option&gt;
              &lt;option value=&quot;3&quot;&gt;R&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;onoffswitch&quot;&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;emergencyswitch&quot; checked onchange=&quot;select_emergency_button();&quot;&gt;
            &lt;label class=&quot;onoffswitch-label&quot; for=&quot;emergencyswitch&quot;&gt;
                &lt;span class=&quot;emergencyswitch-inner&quot;&gt;&lt;/span&gt;
            &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;onoffswitch&quot;&gt;
          &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;modeswitch&quot; checked onchange=&quot;select_mode_button();&quot;&gt;
          &lt;label class=&quot;onoffswitch-label&quot; for=&quot;modeswitch&quot;&gt;
              &lt;span class=&quot;modeswitch-inner&quot;&gt;&lt;/span&gt;
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Select Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;selectDeviceDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
          &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;Select Capture Device&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;othorSelectDevice&quot;&gt;
            &lt;label for=&quot;ddDevices&quot; class=&quot;control-label&quot;&gt;Device&lt;/label&gt;
            &lt;select class=&quot;input-large form-control&quot; id=&quot;deviceList&quot;&gt;&lt;/select&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;firefoxSelectDevice&quot;&gt;
            &lt;span id=&quot;ffMessage&quot; class=&quot;control-label&quot;&gt;Click the Select Device.&lt;br /&gt;&lt;button id=&quot;btnFfSelectDevice&quot;&gt;Select Device&lt;/button&gt;&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;streamPreview control-label&quot;&gt;Preview&lt;/label&gt;
            &lt;div class=&quot;form-control&quot; id=&quot;devicePreview&quot;&gt;
              &lt;video id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot;&gt;
          &lt;button type=&quot;button&quot; id=&quot;btnDialogAddStream&quot; class=&quot;btn btn-primary&quot;&gt;Add Stream&lt;/button&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Message Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;messageDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; data-backdrop=&quot;static&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          VEHICLE ID: &lt;input type=&quot;text&quot; id=&quot;dialogRoomName&quot; size=&quot;36&quot; readonly /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;p id=&quot;messageText&quot;&gt;&lt;/p&gt;
          &lt;span id=&quot;waitingIcon&quot; class=&quot;glyphicon glyphicon-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot; id=&quot;messageDialogFooter&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;CLOSE&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</old_file>
			</file>
			<file old_path="ui/web/remote_monitor/template/operator_window.html" new_path="ui/web/remote_monitor/template/operator_window.html">
				<diff>@@ -22,6 +22,11 @@
   &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;/js/gamepad.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;/js/vehicle_button.js&quot;&gt;&lt;/script&gt;
+  &lt;script&gt;
+    window.addEventListener('beforeunload', function(e) {
+      e.returnValue = 'Do you want to leave this page?';
+    }, false);
+  &lt;/script&gt;
 &lt;/head&gt;
 
 &lt;body&gt;
</diff>
				<old_file>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot; /&gt;
  &lt;title&gt;Autoware&lt;/title&gt;
  &lt;link rel=&quot;shortcut icon&quot; href=&quot;/img/autoware_icon.ico&quot;&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.min.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/speed_meters.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bar.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/button.css&quot; /&gt;

  &lt;script src=&quot;/js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/webrtc_polyfill.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/utility.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/gamepad.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/vehicle_button.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;!-- Header --&gt;
  &lt;header class=&quot;navbar-static-top bs-docs-nav&quot;&gt;
    &lt;div class=&quot;navbar-inner&quot;&gt;
      &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;navbar-header&quot;&gt;
          &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;
          &lt;li class=&quot;dropdown&quot; id=&quot;ddJoinRoom&quot;&gt;
            &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; id=&quot;btnJoinRoom&quot;&gt;CONNECT&lt;b class=&quot;caret&quot;&gt;&lt;/b&gt;&lt;/a&gt;
            &lt;ul class=&quot;dropdown-menu&quot; id=&quot;ddmJoinRoom&quot; style=&quot;padding: 15px;min-width: 350px; height: 150px&quot;&gt;
              &lt;li&gt;
                &lt;div class=&quot;row&quot;&gt;
                  &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;form class=&quot;form&quot; role=&quot;form&quot; id=&quot;formJoinRoom&quot;&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;txtRoomName&quot; class=&quot;control-label&quot;&gt;CONNECT VEHICLE (Set Vehicle ID)&lt;/label&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;txtRoomName&quot; required&gt;
                      &lt;/div&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-block&quot;&gt;CONNECT&lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/form&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;div id=&quot;maskPanel&quot;&gt;&lt;/div&gt;

  &lt;!-- UI --&gt;
  &lt;div class=&quot;container&quot; id=&quot;container&quot;&gt;
    &lt;!-- First row --&gt;
    &lt;div class=&quot;row row-eq-height row-top&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 5px&quot;&gt;
          &lt;h2&gt;&lt;u&gt;Vehicle Info&lt;/u&gt;&lt;h2&gt;
          &lt;h3 id=&quot;text_speed&quot;&gt;Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_target_speed&quot;&gt;Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_next_target_speed&quot;&gt;Next Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_state&quot;&gt;State: -&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-6 col-md-6 col-sm-6 col-xs-6&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView2&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView5&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Second row --&gt;
    &lt;div class=&quot;row row-eq-height row-center&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView3&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-6 col-md-6 col-sm-6 col-xs-6&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView1&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView4&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Third row --&gt;
    &lt;div class=&quot;row row-eq-height row-bottom&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;img id=&quot;vehicle_steering&quot; src=&quot;/img/steering.png&quot;&gt;&lt;/img&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;dashboard&quot;&gt;
          &lt;div class=&quot;meter meter--rpm meter--big-label&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;meter meter--gear&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt;
          &lt;div class=&quot;meter meter--speed&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 10px&quot;&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Accel&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Brake&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Vehicle Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;fill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Accel&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;controller_accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Brake&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;controller_brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;cfill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&quot;select-wrap select-circle&quot;&gt;
            &lt;h4 class=&quot;operator&quot;&gt;Gear&lt;/h4&gt;
            &lt;select name=&quot;gear&quot; id=&quot;gear&quot; onChange=&quot;select_gear(this);&quot;&gt;
              &lt;option value=&quot;0&quot;&gt;P&lt;/option&gt;
              &lt;option value=&quot;1&quot;&gt;D&lt;/option&gt;
              &lt;option value=&quot;2&quot;&gt;R&lt;/option&gt;
              &lt;option value=&quot;3&quot;&gt;N&lt;/option&gt;
              &lt;option value=&quot;4&quot;&gt;B&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;onoffswitch&quot;&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;emergencyswitch&quot; checked onchange=&quot;select_emergency_button();&quot;&gt;
            &lt;label class=&quot;onoffswitch-label&quot; for=&quot;emergencyswitch&quot;&gt;
                &lt;span class=&quot;emergencyswitch-inner&quot;&gt;&lt;/span&gt;
            &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;onoffswitch&quot;&gt;
          &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;modeswitch&quot; checked onchange=&quot;select_mode_button();&quot;&gt;
          &lt;label class=&quot;onoffswitch-label&quot; for=&quot;modeswitch&quot;&gt;
              &lt;span class=&quot;modeswitch-inner&quot;&gt;&lt;/span&gt;
          &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;row&quot;&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_left&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;◁&quot; onclick=&quot;pushBlinker(1)&quot;&gt;
          &lt;/div&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_hazard&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;△&quot; onclick=&quot;pushBlinker(3)&quot;&gt;
          &lt;/div&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_right&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;▷&quot; onclick=&quot;pushBlinker(2)&quot;&gt;
          &lt;/div&gt;
        &lt;/div&gt;

      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Select Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;selectDeviceDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
          &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;Select Capture Device&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;othorSelectDevice&quot;&gt;
            &lt;label for=&quot;ddDevices&quot; class=&quot;control-label&quot;&gt;Device&lt;/label&gt;
            &lt;select class=&quot;input-large form-control&quot; id=&quot;deviceList&quot;&gt;&lt;/select&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;firefoxSelectDevice&quot;&gt;
            &lt;span id=&quot;ffMessage&quot; class=&quot;control-label&quot;&gt;Click the Select Device.&lt;br /&gt;&lt;button id=&quot;btnFfSelectDevice&quot;&gt;Select Device&lt;/button&gt;&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;streamPreview control-label&quot;&gt;Preview&lt;/label&gt;
            &lt;div class=&quot;form-control&quot; id=&quot;devicePreview&quot;&gt;
              &lt;video id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot;&gt;
          &lt;button type=&quot;button&quot; id=&quot;btnDialogAddStream&quot; class=&quot;btn btn-primary&quot;&gt;Add Stream&lt;/button&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Message Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;messageDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; data-backdrop=&quot;static&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          VEHICLE ID: &lt;input type=&quot;text&quot; id=&quot;dialogRoomName&quot; size=&quot;36&quot; readonly /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;p id=&quot;messageText&quot;&gt;&lt;/p&gt;
          &lt;span id=&quot;waitingIcon&quot; class=&quot;glyphicon glyphicon-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot; id=&quot;messageDialogFooter&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;CLOSE&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</old_file>
			</file>
			<file old_path="ui/web/remote_monitor/template/vehicle_window.html" new_path="ui/web/remote_monitor/template/vehicle_window.html">
				<diff>@@ -20,6 +20,11 @@
   &lt;script src=&quot;/js/webrtc_polyfill.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;/js/utility.js&quot;&gt;&lt;/script&gt;
   &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
+  &lt;script&gt;
+    window.addEventListener('beforeunload', function(e) {
+      e.returnValue = 'Do you want to leave this page?';
+    }, false);
+  &lt;/script&gt;
 &lt;/head&gt;
 
 &lt;body&gt;
</diff>
				<old_file>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot; /&gt;
  &lt;title&gt;Autoware&lt;/title&gt;
  &lt;link rel=&quot;shortcut icon&quot; href=&quot;/img/autoware_icon.ico&quot;&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.min.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/speed_meters.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bar.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/button.css&quot; /&gt;

  &lt;script src=&quot;/js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/webrtc_polyfill.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/utility.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;!-- Header --&gt;
  &lt;header class=&quot;navbar-static-top bs-docs-nav&quot;&gt;
    &lt;div class=&quot;navbar-inner&quot;&gt;
      &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;navbar-header&quot;&gt;
          &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;
          &lt;li class=&quot;dropdown&quot; id=&quot;ddJoinRoom&quot;&gt;
            &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; id=&quot;btnJoinRoom&quot;&gt;CONNECT&lt;b class=&quot;caret&quot;&gt;&lt;/b&gt;&lt;/a&gt;
            &lt;ul class=&quot;dropdown-menu&quot; id=&quot;ddmJoinRoom&quot; style=&quot;padding: 15px;min-width: 350px; height: 150px&quot;&gt;
              &lt;li&gt;
                &lt;div class=&quot;row&quot;&gt;
                  &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;form class=&quot;form&quot; role=&quot;form&quot; id=&quot;formJoinRoom&quot;&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;txtRoomName&quot; class=&quot;control-label&quot;&gt;CONNECT VEHICLE (Set Vehicle ID)&lt;/label&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;txtRoomName&quot; required&gt;
                      &lt;/div&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-block&quot;&gt;CONNECT&lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/form&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;div id=&quot;maskPanel&quot;&gt;&lt;/div&gt;

  &lt;!-- UI --&gt;
  &lt;div class=&quot;container&quot; id=&quot;container&quot;&gt;
    &lt;!-- First row --&gt;
    &lt;div class=&quot;row row-eq-height row-top&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 5px&quot;&gt;
          &lt;h2&gt;&lt;u&gt;Vehicle Info&lt;/u&gt;&lt;h2&gt;
          &lt;h3 id=&quot;text_speed&quot;&gt;Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_target_speed&quot;&gt;Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_next_target_speed&quot;&gt;Next Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_state&quot;&gt;State: -&lt;/h3&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-6 col-md-6 col-sm-6 col-xs-6&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream2&quot; data-no=&quot;2&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream2&quot; data-no=&quot;2&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView2&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream5&quot; data-no=&quot;5&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream5&quot; data-no=&quot;5&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Dashboard Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView5&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;

    &lt;!-- UI Second row --&gt;
    &lt;div class=&quot;row row-eq-height row-center&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream3&quot; data-no=&quot;3&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream3&quot; data-no=&quot;3&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Left Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView3&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-6 col-md-6 col-sm-6 col-xs-6&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream1&quot; data-no=&quot;1&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream1&quot; data-no=&quot;1&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Front Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView1&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream4&quot; data-no=&quot;4&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream4&quot; data-no=&quot;4&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Right Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView4&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Third row --&gt;
    &lt;div class=&quot;row row-eq-height row-bottom&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;img id=&quot;vehicle_steering&quot; src=&quot;/img/steering.png&quot;&gt;&lt;/img&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;dashboard&quot;&gt;
        	&lt;div class=&quot;meter meter--rpm meter--big-label&quot;&gt;&lt;/div&gt;
        	&lt;div class=&quot;meter meter--gear&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt;
        	&lt;div class=&quot;meter meter--speed&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 10px&quot;&gt;
          &lt;h4&gt;Accel&lt;/h4&gt;
          &lt;progress id=&quot;accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4&gt;Brake&lt;/h4&gt;
          &lt;progress id=&quot;brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4&gt;Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;fill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&quot;select-wrap select-circle&quot;&gt;
            &lt;h4&gt;Gear&lt;/h4&gt;
            &lt;select name=&quot;gear&quot; id=&quot;gear&quot; onChange=&quot;select_gear(this);&quot;&gt;
              &lt;option value=&quot;0&quot;&gt;P&lt;/option&gt;
              &lt;option value=&quot;1&quot;&gt;D&lt;/option&gt;
              &lt;option value=&quot;2&quot;&gt;R&lt;/option&gt;
              &lt;option value=&quot;3&quot;&gt;N&lt;/option&gt;
              &lt;option value=&quot;4&quot;&gt;B&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;onoffswitch&quot;&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;emergencyswitch&quot; checked onchange=&quot;select_emergency_button();&quot;&gt;
            &lt;label class=&quot;onoffswitch-label&quot; for=&quot;emergencyswitch&quot;&gt;
                &lt;span class=&quot;emergencyswitch-inner&quot;&gt;&lt;/span&gt;
            &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;onoffswitch&quot;&gt;
          &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;modeswitch&quot; checked onchange=&quot;select_mode_button();&quot;&gt;
          &lt;label class=&quot;onoffswitch-label&quot; for=&quot;modeswitch&quot;&gt;
              &lt;span class=&quot;modeswitch-inner&quot;&gt;&lt;/span&gt;
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Select Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;selectDeviceDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
          &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;Select Capture Device&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;othorSelectDevice&quot;&gt;
            &lt;label for=&quot;ddDevices&quot; class=&quot;control-label&quot;&gt;Device&lt;/label&gt;
            &lt;select class=&quot;input-large form-control&quot; id=&quot;deviceList&quot;&gt;&lt;/select&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;firefoxSelectDevice&quot;&gt;
            &lt;span id=&quot;ffMessage&quot; class=&quot;control-label&quot;&gt;Click the Select Device.&lt;br /&gt;&lt;button id=&quot;btnFfSelectDevice&quot;&gt;Select Device&lt;/button&gt;&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;streamPreview control-label&quot;&gt;Preview&lt;/label&gt;
            &lt;div class=&quot;form-control&quot; id=&quot;devicePreview&quot;&gt;
              &lt;video id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot;&gt;
          &lt;button type=&quot;button&quot; id=&quot;btnDialogAddStream&quot; class=&quot;btn btn-primary&quot;&gt;Add Stream&lt;/button&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Message Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;messageDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; data-backdrop=&quot;static&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          VEHICLE ID: &lt;input type=&quot;text&quot; id=&quot;dialogRoomName&quot; size=&quot;36&quot; readonly /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;p id=&quot;messageText&quot;&gt;&lt;/p&gt;
          &lt;span id=&quot;waitingIcon&quot; class=&quot;glyphicon glyphicon-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot; id=&quot;messageDialogFooter&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;CLOSE&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="75ed0099f070e0123f3ff2c74b0fefaded046b0b" fix_time="728,21153">
		<msg>Support for multi cameras in feat_proj node (#930)

[fix] feat_proj node multi cam support</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp" new_path="ros/src/computing/perception/detection/packages/road_wizard/nodes/feat_proj/feat_proj.cpp">
				<diff>@@ -353,11 +353,11 @@ int main (int argc, char *argv[])
   ros::NodeHandle rosnode;
   ros::NodeHandle private_nh(&quot;~&quot;);
   std::string cameraInfo_topic_name;
-  private_nh.param&lt;std::string&gt;(&quot;camera_info_topic&quot;, cameraInfo_topic_name, &quot;/camera/camera_info&quot;);
+  private_nh.param&lt;std::string&gt;(&quot;camera_info_topic&quot;, cameraInfo_topic_name, &quot;/camera_info&quot;);
 
   /* get camera ID */
   camera_id_str = cameraInfo_topic_name;
-  camera_id_str.erase(camera_id_str.find(&quot;/camera/camera_info&quot;));
+  camera_id_str.erase(camera_id_str.find(&quot;/camera_info&quot;));
   if (camera_id_str == &quot;/&quot;) {
     camera_id_str = &quot;camera&quot;;
   }
</diff>
				<old_file>/*
 * signals.cpp
 *
 *  Created on: Apr 9, 2015
 *      Author: sujiwo
 */


#include &lt;iostream&gt;
#include &lt;ros/ros.h&gt;
#include &quot;Rate.h&quot;
#include &quot;libvectormap/vector_map.h&quot;
#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;sensor_msgs/CameraInfo.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;signal.h&gt;
#include &lt;cstdio&gt;
#include &quot;libvectormap/Math.h&quot;
#include &lt;Eigen/Eigen&gt;
#include &lt;autoware_msgs/Signals.h&gt;
#include &lt;autoware_msgs/adjust_xy.h&gt;
#include &lt;vector_map/vector_map.h&gt;
#include &lt;vector_map_server/GetSignal.h&gt;
#include &lt;autoware_msgs/lane.h&gt;

static std::string camera_id_str;

static constexpr uint32_t SUBSCRIBE_QUEUE_SIZE = 1000;

static int adjust_proj_x = 0;
static int adjust_proj_y = 0;

typedef struct {
  double thiX;
  double thiY;
  double thiZ;
} Angle;

static VectorMap vmap;
static Angle cameraOrientation; // camera orientation = car's orientation

static Eigen::Vector3f position;
static Eigen::Quaternionf orientation;
static  float fx,
  fy,
  imageWidth,
  imageHeight,
  cx,
  cy;
static tf::StampedTransform trf;

static bool g_use_vector_map_server; // Switch flag whether vecter-map-server function will be used
static ros::ServiceClient g_ros_client;

#define SignalLampRadius 0.3

/* Define utility class to use vector map server */
namespace
{
  class VectorMapClient
  {
  private:
    geometry_msgs::PoseStamped pose_;
    autoware_msgs::lane waypoints_;

  public:
    VectorMapClient()
    {}

    ~VectorMapClient()
    {}

    geometry_msgs::PoseStamped pose() const
    {
      return pose_;
    }

    autoware_msgs::lane waypoints() const
    {
      return waypoints_;
    }

    void set_pose(const geometry_msgs::PoseStamped&amp; pose)
    {
      pose_ = pose;
    }

    void set_waypoints(const autoware_msgs::lane&amp; waypoints)
    {
      waypoints_ = waypoints;
    }
  }; // Class VectorMapClient
} // namespace
static VectorMapClient g_vector_map_client;


/* Callback function to shift projection result */
void adjust_xyCallback (const autoware_msgs::adjust_xy::ConstPtr&amp; config_msg)
{
  adjust_proj_x = config_msg-&gt;x;
  adjust_proj_y = config_msg-&gt;y;
}

void cameraInfoCallback (const sensor_msgs::CameraInfo::ConstPtr camInfoMsg)
{
  fx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[0]);
  fy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[5]);
  imageWidth = camInfoMsg-&gt;width;
  imageHeight = camInfoMsg-&gt;height;
  cx = static_cast&lt;float&gt;(camInfoMsg-&gt;P[2]);
  cy = static_cast&lt;float&gt;(camInfoMsg-&gt;P[6]);
}


/* convert degree value into 0 to 360 range */
static double setDegree0to360(double val)
{
  if (val &lt; 0.0f) {
    return (val + 360.0f);
  }
  else if (360.0f &lt; val) {
    return (val - 360.0f);
  }

  return val;
}


static void get_cameraRollPitchYaw(double* roll,
                                   double* pitch,
                                   double* yaw)
{
  geometry_msgs::Pose cameraPose;
  cameraPose.position.x    = (double)(position.x());
  cameraPose.position.y    = (double)(position.y());
  cameraPose.position.z    = (double)(position.z());
  cameraPose.orientation.x = (double)(orientation.x());
  cameraPose.orientation.y = (double)(orientation.y());
  cameraPose.orientation.z = (double)(orientation.z());
  cameraPose.orientation.w = (double)(orientation.w());

  tf::Quaternion quat;

  tf::quaternionMsgToTF(cameraPose.orientation, quat);
  tf::Matrix3x3(quat).getRPY(*roll, *pitch, *yaw);

  /* convert from radian to degree */
  *roll  = setDegree0to360(*roll  * 180.0f / M_PI);
  *pitch = setDegree0to360(*pitch * 180.0f / M_PI);
  *yaw   = setDegree0to360(*yaw   * 180.0f / M_PI);
}


/*
  check if lower &lt; val &lt; upper
  This function also considers circulation
*/
static bool isRange(const double lower, const double upper, const double val)
{
  if (lower &lt;= upper) {
    if (lower &lt; val &amp;&amp; val &lt; upper) {
      return true;
    }
  }
  else {
    if (val &lt; upper || lower &lt; val) {
      return true;
    }
  }

  return false;
}


void getTransform (Eigen::Quaternionf &amp;ori, Point3 &amp;pos)
{
  static tf::TransformListener listener;

  // target_frame    source_frame
  ros::Time now = ros::Time();
  listener.waitForTransform (camera_id_str, &quot;map&quot;, now, ros::Duration(10.0));
  listener.lookupTransform (camera_id_str, &quot;map&quot;, now, trf);

  tf::Vector3 &amp;p = trf.getOrigin();
  tf::Quaternion o = trf.getRotation();
  pos.x()=p.x(); pos.y()=p.y(); pos.z()=p.z();
  ori.w()=o.w(); ori.x()=o.x(); ori.y()=o.y(); ori.z()=o.z();
}


Point3 transform (const Point3 &amp;psrc, tf::StampedTransform &amp;tfsource)
{
  tf::Vector3 pt3 (psrc.x(), psrc.y(), psrc.z());
  tf::Vector3 pt3s = tfsource * pt3;
  return Point3 (pt3s.x(), pt3s.y(), pt3s.z());
}


/*
 * Project a point from world coordinate to image plane
 */
bool project2 (const Point3 &amp;pt, int &amp;u, int &amp;v, bool useOpenGLCoord=false)
{
  float nearPlane = 1.0;
  float farPlane = 200.0;
  Point3 _pt = transform (pt, trf);
  float _u = _pt.x()*fx/_pt.z() + cx;
  float _v = _pt.y()*fy/_pt.z() + cy;

  u = static_cast&lt;int&gt;(_u);
  v = static_cast&lt;int&gt;(_v);
  if ( u &lt; 0 || imageWidth &lt; u || v &lt; 0 || imageHeight &lt; v || _pt.z() &lt; nearPlane || farPlane &lt; _pt.z() ) {
    u = -1, v = -1;
    return false;
  }

  if (useOpenGLCoord) {
    v = imageHeight - v;
  }

  return true;
}

double ConvertDegreeToRadian(double degree)
{
  return degree * M_PI / 180.0f;
}


double ConvertRadianToDegree(double radian)
{
  return radian * 180.0f / M_PI;
}


double GetSignalAngleInCameraSystem(double hang, double vang)
{
  // Fit the vector map format into ROS style
  double signal_pitch_in_map = ConvertDegreeToRadian(vang - 90);
  double signal_yaw_in_map   = ConvertDegreeToRadian(-hang + 90);

  tf::Quaternion signal_orientation_in_map_system;
  signal_orientation_in_map_system.setRPY(0, signal_pitch_in_map, signal_yaw_in_map);

  tf::Quaternion signal_orientation_in_cam_system = trf * signal_orientation_in_map_system;
  double signal_roll_in_cam;
  double signal_pitch_in_cam;
  double signal_yaw_in_cam;
  tf::Matrix3x3(signal_orientation_in_cam_system).getRPY(signal_roll_in_cam,
                                                         signal_pitch_in_cam,
                                                         signal_yaw_in_cam);

  return ConvertRadianToDegree(signal_pitch_in_cam);   // holizontal angle of camera is represented by pitch
}  // double GetSignalAngleInCameraSystem()


void echoSignals2 (ros::Publisher &amp;pub, bool useOpenGLCoord=false)
{
  int countPoint = 0;
  autoware_msgs::Signals signalsInFrame;

  /* Get signals on the path if vecter_map_server is enabled */
  if (g_use_vector_map_server) {
    vector_map_server::GetSignal service;
    /* Set server's request */
    service.request.pose = g_vector_map_client.pose();
    service.request.waypoints = g_vector_map_client.waypoints();

    /* Get server's response*/
    if (g_ros_client.call(service)) {
      /* Reset signal data container */
      vmap.signals.clear();

      /* Newle insert signal data on the path */
      for (const auto&amp; response: service.response.objects.data) {
        if (response.id == 0)
          continue;

        Signal signal;
        signal.id = response.id;
        signal.vid = response.vid;
        signal.plid = response.plid;
        signal.type = response.type;
        signal.linkid = response.linkid;

        vmap.signals.insert(std::map&lt;int, Signal&gt;::value_type(signal.id, signal));
      }
    }
  }

  for (unsigned int i=1; i&lt;=vmap.signals.size(); i++) {
    Signal signal = vmap.signals[i];
    int pid = vmap.vectors[signal.vid].pid;

    Point3 signalcenter = vmap.getPoint(pid);
    Point3 signalcenterx (signalcenter.x(), signalcenter.y(), signalcenter.z()+SignalLampRadius);

    int u, v;
    if (project2 (signalcenter, u, v, useOpenGLCoord) == true) {
      countPoint++;
      // std::cout &lt;&lt; u &lt;&lt; &quot;, &quot; &lt;&lt; v &lt;&lt; &quot;, &quot; &lt;&lt; std::endl;

      int radius;
      int ux, vx;
      project2 (signalcenterx, ux, vx, useOpenGLCoord);
      radius = (int)distance (ux, vx, u, v);

      autoware_msgs::ExtractedPosition sign;
      sign.signalId = signal.id;

      sign.u = u + adjust_proj_x; // shift project position by configuration value from runtime manager
      sign.v = v + adjust_proj_y; // shift project position by configuration value from runtime manager

      sign.radius = radius;
      sign.x = signalcenter.x(), sign.y = signalcenter.y(), sign.z = signalcenter.z();
      sign.hang = vmap.vectors[signal.vid].hang; // hang is expressed in [0, 360] degree
      sign.type = signal.type, sign.linkId = signal.linkid;
      sign.plId = signal.plid;

      // Get holizontal angle of signal in camera corrdinate system
      double signal_angle = GetSignalAngleInCameraSystem(vmap.vectors[signal.vid].hang + 180.0f,
                                                         vmap.vectors[signal.vid].vang + 180.0f);

      // signal_angle will be zero if signal faces to x-axis
      // Target signal should be face to -50 &lt;= z-axis (= 90 degree) &lt;= +50
      if (isRange(-50, 50, signal_angle - 90)) {
        signalsInFrame.Signals.push_back (sign);
      }
    }
  }

  signalsInFrame.header.stamp = ros::Time::now();
  pub.publish (signalsInFrame);

  // printf (&quot;There are %d out of %u signals in frame\n&quot;, countPoint, static_cast&lt;unsigned int&gt;(vmap.signals.size()));
}


void interrupt (int s)
{
  ros::shutdown();
  exit(1);
}


int main (int argc, char *argv[])
{

  ros::init(argc, argv, &quot;feat_proj&quot;, ros::init_options::NoSigintHandler);
  ros::NodeHandle rosnode;
  ros::NodeHandle private_nh(&quot;~&quot;);
  std::string cameraInfo_topic_name;
  private_nh.param&lt;std::string&gt;(&quot;camera_info_topic&quot;, cameraInfo_topic_name, &quot;/camera/camera_info&quot;);

  /* get camera ID */
  camera_id_str = cameraInfo_topic_name;
  camera_id_str.erase(camera_id_str.find(&quot;/camera/camera_info&quot;));
  if (camera_id_str == &quot;/&quot;) {
    camera_id_str = &quot;camera&quot;;
  }
  
  /* Get Flag wheter vecter_map_server function will be used  */
  private_nh.param&lt;bool&gt;(&quot;use_path_info&quot;, g_use_vector_map_server, false);

  /* load vector map */
  ros::Subscriber sub_point     = rosnode.subscribe(&quot;vector_map_info/point&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_points,
                                                    &amp;vmap);
  ros::Subscriber sub_line      = rosnode.subscribe(&quot;vector_map_info/line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lines,
                                                    &amp;vmap);
  ros::Subscriber sub_lane      = rosnode.subscribe(&quot;vector_map_info/lane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_lanes,
                                                    &amp;vmap);
  ros::Subscriber sub_vector    = rosnode.subscribe(&quot;vector_map_info/vector&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_vectors,
                                                    &amp;vmap);
  ros::Subscriber sub_signal    = rosnode.subscribe(&quot;vector_map_info/signal&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_signals,
                                                    &amp;vmap);
  ros::Subscriber sub_whiteline = rosnode.subscribe(&quot;vector_map_info/white_line&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_whitelines,
                                                    &amp;vmap);
  ros::Subscriber sub_dtlane    = rosnode.subscribe(&quot;vector_map_info/dtlane&quot;,
                                                    SUBSCRIBE_QUEUE_SIZE,
                                                    &amp;VectorMap::load_dtlanes,
                                                    &amp;vmap);

  /* wait until loading all vector map is completed */
  ros::Rate wait_rate(1);
  while(vmap.points.empty() || vmap.lines.empty() || vmap.whitelines.empty() ||
        vmap.lanes.empty() || vmap.dtlanes.empty() || vmap.vectors.empty() || vmap.signals.empty())
    {
      ros::spinOnce();
      wait_rate.sleep();
    }

  vmap.loaded = true;
  std::cout &lt;&lt; &quot;all vector map loaded.&quot; &lt;&lt; std::endl;

  ros::Subscriber cameraInfoSubscriber = rosnode.subscribe (cameraInfo_topic_name, 100, cameraInfoCallback);
  ros::Subscriber adjust_xySubscriber  = rosnode.subscribe(&quot;/config/adjust_xy&quot;, 100, adjust_xyCallback);
  ros::Subscriber current_pose_subscriber;
  ros::Subscriber waypoint_subscriber;
  if (g_use_vector_map_server) {
    /* Create subscribers which deliver informations requested by server */
    current_pose_subscriber = rosnode.subscribe(&quot;/current_pose&quot;, 1, &amp;VectorMapClient::set_pose, &amp;g_vector_map_client);
    waypoint_subscriber     = rosnode.subscribe(&quot;/final_waypoints&quot;, 1, &amp;VectorMapClient::set_waypoints, &amp;g_vector_map_client);

    /* Create ros client to use Server-Client communication */
    g_ros_client = rosnode.serviceClient&lt;vector_map_server::GetSignal&gt;(&quot;vector_map_server/get_signal&quot;);
  }

  ros::Publisher  signalPublisher      = rosnode.advertise &lt;autoware_msgs::Signals&gt; (&quot;roi_signal&quot;, 100);
  signal (SIGINT, interrupt);

  Rate loop (25);
  while (true) {

    ros::spinOnce();

    try {
      getTransform (orientation, position);
    } catch (tf::TransformException &amp;exc) {
    }

    echoSignals2 (signalPublisher, false);
    loop.sleep();
  }


}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="bddb548341b4c539012aaee2776ecc09d1a3a3b4" fix_time="0,0">
		<msg>fix a variable declaration was not enough.</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -230,6 +230,7 @@ void DecisionMakerNode::callbackInStateAcc(int status)
 }
 void DecisionMakerNode::updateStateStop(int status)
 {
+  static bool timerflag;
   static ros::Timer stopping_timer;
   if (status)
   {
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;decision_maker_node.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::setupStateCallback(void)
{
  // steering state. these state's update function change lamp
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));

  // temporary stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));

  // stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));

  // speed keep(original speed) state
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));

  // crawl
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_CRAWL_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 0));

  // acceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));

  // deceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));

  // obstacle avoidance
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));

  // trraficlight
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE); });
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });

  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));

  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
}

void DecisionMakerNode::publishLightColor(int status)
{
  autoware_msgs::traffic_light msg;
  msg.traffic_light = status;
  Pubs[&quot;light_color&quot;].publish(msg);
}

#define SHIFTED_LANE_FLAG -99999
void DecisionMakerNode::createShiftLane(void)
{
  bool isRightShift = param_shift_width_ &gt;= 0;

  autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
  if (!current_shifted_lane_array_.lanes.empty())
  {
    size_t lane_idx = 0;
    for (auto &amp;lane : shift_lanes.lanes)
    {
      lane.increment = SHIFTED_LANE_FLAG;
      size_t wp_idx = 0;
      for (auto &amp;wp : lane.waypoints)
      {
        double angle = getPoseAngle(wp.pose.pose);
        wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
        wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
        wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
      }
      lane_idx++;
    }
  }
  int insert_lane_idx_offset = isRightShift ? 1 : 0;
  auto it_shift = begin(shift_lanes.lanes);
  try
  {
    for (auto it = begin(current_shifted_lane_array_.lanes);
         it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
    {
      for (auto &amp;wp : it-&gt;waypoints)
      {
        wp.change_flag = isRightShift ? 1 : 2;
      }
      it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
      it++;
      if (!isRightShift)
        it++;
    }
  }
  catch (std::length_error)
  {
  }
}

void DecisionMakerNode::changeShiftLane(void)
{
  auto based_it = begin(current_shifted_lane_array_.lanes);

  for (auto &amp;lane : current_shifted_lane_array_.lanes)
  {
    if (lane.increment == SHIFTED_LANE_FLAG)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = param_shift_width_ &gt;= 0 ? 2 : 1;
      }
    }
    else
    {
      auto based_wp_it = begin(based_it++-&gt;waypoints);
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = based_wp_it++-&gt;change_flag;
      }
    }
  }
}

void DecisionMakerNode::removeShiftLane(void)
{
  current_shifted_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::updateLaneWaypointsArray(void)
{
  current_stopped_lane_array_ = current_controlled_lane_array_;

  for (auto &amp;lane : current_stopped_lane_array_.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      wp.twist.twist.linear.x = 0.0;
      wp.wpstate.stopline_state = 0;
    }
  }
}

void DecisionMakerNode::publishControlledLaneArray(void)
{
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
  current_controlled_lane_array_ = current_shifted_lane_array_;
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
  if (dir != 0)
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      autoware_msgs::lane temp_lane = lane;
      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
      {
        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
        double _rate = 0.2;                       // accelerated/decelerated rate
        double _weight = distance * _rate * dir;  //
        lane.waypoints.at(wpi).twist.twist.linear.x =
            lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
      }
    }
  }
  else
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.twist.twist.linear.x = amathutils::kmph2mps(param_crawl_velocity_);
      }
    }
  }
}

void DecisionMakerNode::callbackInStateKeep(int status)
{
  changeVelocityBasedLane();
  publishControlledLaneArray();
}

void DecisionMakerNode::callbackInStateAcc(int status)
{
  changeVelocityLane(status);
  publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
  static ros::Timer stopping_timer;
  if (status)
  {
    if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
    {
      stopping_timer = nh_.createTimer(ros::Duration(1),
                                       [&amp;](const ros::TimerEvent &amp;) {
                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
                                         ROS_INFO(&quot;Change state to [KEEP] from [STOP]\n&quot;);
                                         timerflag = false;
                                       },
                                       this, true);
      timerflag = true;
    }
  }
}

void DecisionMakerNode::updateStateObstacleAvoid(int status)
{
}

void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
{
  changeShiftLane();
  changeVelocityBasedLane();
  publishControlledLaneArray();
  ros::Rate loop_rate(1);
  // wait for the start of lane change to the original lane
  if (created_shift_lane_flag_)
  {
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
             !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
    // wait for the end of lane change
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
             ros::ok());
    removeShiftLane();
    created_shift_lane_flag_ = false;
  }
  changeVelocityBasedLane();  // rebased controlled lane
  publishControlledLaneArray();
return;
}

void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
{
  // this state is temporary implementation.
  // It means this state is desirable to use a way which enables the avoidance plannner such as astar, state lattice.

  // if car shoud stop before avoidance,
  if (!created_shift_lane_flag_)
  {
    created_shift_lane_flag_ = true;
    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
    createShiftLane();
  }

  changeVelocityBasedLane();
}
void DecisionMakerNode::callbackInStateStop(int status)
{
  publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch (status)
  {
    case LAMP_LEFT:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_OFF;
      break;
    case LAMP_RIGHT:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_HAZARD:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_EMPTY:
    default:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_OFF;
      break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="5e3685262efa92e8f7de17edd4ba6058469b219b" fix_time="4,18568">
		<msg>fix a moving state</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_init.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_init.cpp">
				<diff>@@ -30,12 +30,14 @@ namespace decision_maker
 {
 void DecisionMakerNode::initROS(int argc, char **argv)
 {
+  ctx-&gt;setCurrentState(state_machine::INITIAL_STATE);
+
   // status subscriber
   Subs[&quot;sim_pose&quot;] = nh_.subscribe(&quot;sim_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromSimPose, this);
   Subs[&quot;current_pose&quot;] = nh_.subscribe(&quot;current_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
   Subs[&quot;current_velocity&quot;] =
       nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
-  // Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+  Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
   Subs[&quot;light_color_managed&quot;] =
       nh_.subscribe(&quot;light_color_managed&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
   Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
@@ -56,7 +58,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs[&quot;state&quot;] = nh_.advertise&lt;std_msgs::String&gt;(&quot;state&quot;, 1);
   Pubs[&quot;lane_waypoints_array&quot;] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
   Pubs[&quot;states&quot;] = nh_.advertise&lt;autoware_msgs::state&gt;(&quot;/decisionmaker/states&quot;, 1, true);
-  Pubs[&quot;light_color&quot;] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;(&quot;/light_color&quot;, 1);
+ //Pubs[&quot;light_color&quot;] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;(&quot;/light_color&quot;, 1);
 
   // for controlling vehicle
   Pubs[&quot;lamp_cmd&quot;] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;(&quot;/lamp_cmd&quot;, 1);
@@ -110,6 +112,8 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   }
 
   ROS_INFO(&quot;Initialized OUT\n&quot;);
+  ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
+  
   Subs[&quot;lane_waypoints_array&quot;] =
       nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
 }
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;mutex&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;
//#include &lt;vector_map/vector_map.h&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/state.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
void DecisionMakerNode::initROS(int argc, char **argv)
{
  // status subscriber
  Subs[&quot;sim_pose&quot;] = nh_.subscribe(&quot;sim_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromSimPose, this);
  Subs[&quot;current_pose&quot;] = nh_.subscribe(&quot;current_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
  Subs[&quot;current_velocity&quot;] =
      nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
  // Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
  Subs[&quot;light_color_managed&quot;] =
      nh_.subscribe(&quot;light_color_managed&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
  Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
  Subs[&quot;final_waypoints&quot;] = nh_.subscribe(&quot;final_waypoints&quot;, 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
  Subs[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
  Subs[&quot;change_flag&quot;] = nh_.subscribe(&quot;change_flag&quot;, 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
  Subs[&quot;state_cmd&quot;] = nh_.subscribe(&quot;state_cmd&quot;, 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
  Subs[&quot;closest_waypoint&quot;] =
      nh_.subscribe(&quot;closest_waypoint&quot;, 1, &amp;DecisionMakerNode::callbackFromClosestWaypoint, this);

  // Config subscriber
  Subs[&quot;config/decision_maker&quot;] =
      nh_.subscribe(&quot;/config/decision_maker&quot;, 3, &amp;DecisionMakerNode::callbackFromConfig, this);

  // pub

  // for controlling other planner
  Pubs[&quot;state&quot;] = nh_.advertise&lt;std_msgs::String&gt;(&quot;state&quot;, 1);
  Pubs[&quot;lane_waypoints_array&quot;] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
  Pubs[&quot;states&quot;] = nh_.advertise&lt;autoware_msgs::state&gt;(&quot;/decisionmaker/states&quot;, 1, true);
  Pubs[&quot;light_color&quot;] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;(&quot;/light_color&quot;, 1);

  // for controlling vehicle
  Pubs[&quot;lamp_cmd&quot;] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;(&quot;/lamp_cmd&quot;, 1);
  Pubs[&quot;emergency&quot;] =

      // for visualize status
      Pubs[&quot;state_overlay&quot;] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;(&quot;/state/overlay_text&quot;, 1);
  Pubs[&quot;crossroad_marker&quot;] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;/state/cross_road_marker&quot;, 1);
  Pubs[&quot;crossroad_inside_marker&quot;] = nh_.advertise&lt;visualization_msgs::Marker&gt;(&quot;/state/cross_inside_marker&quot;, 1);
  Pubs[&quot;crossroad_bbox&quot;] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;/state/crossroad_bbox&quot;, 10);

  // for debug
  Pubs[&quot;target_velocity_array&quot;] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;(&quot;/target_velocity_array&quot;, 1);
  Pubs[&quot;state_local_diffdistance&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/val_diff_distance&quot;, 1);
  Pubs[&quot;exectime&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/exectime&quot;, 1);

  // message setup
  state_text_msg.width = 400;
  state_text_msg.height = 500;
  state_text_msg.top = 10;
  state_text_msg.left = 10;
  state_text_msg.bg_color.r = 0;
  state_text_msg.bg_color.g = 0;
  state_text_msg.bg_color.b = 0;
  state_text_msg.bg_color.a = 0.8;

  state_text_msg.line_width = 2;
  state_text_msg.text_size = 18;
  state_text_msg.font = &quot;DejaVu Sans Mono&quot;;
  state_text_msg.fg_color.r = 0.1;
  state_text_msg.fg_color.g = 1.0;
  state_text_msg.fg_color.b = 0.94;
  state_text_msg.fg_color.a = 0.8;
  state_text_msg.text = &quot;UNDEFINED&quot;;

  // initial publishing state message
  update_msgs();

  // setup a callback for state update();
  setupStateCallback();

  g_vmap.subscribe(nh_,
                   Category::POINT | Category::LINE | Category::VECTOR | Category::AREA |
                       Category::POLE |  // basic class
                       Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
  initVectorMap();

  {
    if (enableDisplayMarker)
      displayMarker();
  }

  ROS_INFO(&quot;Initialized OUT\n&quot;);
  Subs[&quot;lane_waypoints_array&quot;] =
      nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
}

void DecisionMakerNode::initVectorMap(void)
{
  int _index = 0;
  // if(vector_map_init)
  //      return;
  std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad) { return true; });
  if (crossroads.empty())
  {
    ROS_INFO(&quot;crossroad have not found\n&quot;);
    return;
  }

  vector_map_init = true;  // loaded flag
  for (const auto &amp;cross_road : crossroads)
  {
    Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
    CrossRoadArea carea;
    carea.id = _index++;
    carea.area_id = area.aid;

    double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
    double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
    double z = 0.0;
    int points_count = 0;

    std::vector&lt;Line&gt; lines =
        g_vmap.findByFilter([&amp;area](const Line &amp;line) { return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid; });
    for (const auto &amp;line : lines)
    {
      geometry_msgs::Point _prev_point;
      std::vector&lt;Point&gt; points =
          g_vmap.findByFilter([&amp;line](const Point &amp;point) { return line.bpid == point.pid || point.pid == line.fpid; });
      for (const auto &amp;point : points)
      {
        geometry_msgs::Point _point;
        _point.x = point.ly;
        _point.y = point.bx;
        _point.z = point.h;

        if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
          continue;

        _prev_point = _point;
        points_count++;
        carea.points.push_back(_point);

        // calc a centroid point and about intersects size
        x_avg += _point.x;
        y_avg += _point.y;
        x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
        x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
        y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
        y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
        z = _point.z;

      }  // points iter
    }    // line iter
    carea.bbox.pose.position.x = x_avg / (double)points_count;
    carea.bbox.pose.position.y = y_avg / (double)points_count;
    carea.bbox.pose.position.z = z;
    carea.bbox.dimensions.x = x_max - x_min;
    carea.bbox.dimensions.y = y_max - y_min;
    carea.bbox.dimensions.z = 2;
    carea.bbox.label = 1;
    intersects.push_back(carea);
  }
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -75,7 +75,7 @@ void DecisionMakerNode::publishLightColor(int status)
 {
   autoware_msgs::traffic_light msg;
   msg.traffic_light = status;
-  Pubs[&quot;light_color&quot;].publish(msg);
+  //Pubs[&quot;light_color&quot;].publish(msg);
 }
 
 #define SHIFTED_LANE_FLAG -99999
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;decision_maker_node.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::setupStateCallback(void)
{
  // steering state. these state's update function change lamp
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));

  // temporary stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));

  // stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));

  // speed keep(original speed) state
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));

  // crawl
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_CRAWL_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 0));

  // acceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));

  // deceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));

  // obstacle avoidance
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));

  // trraficlight
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE); });
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });

  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));

  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
}

void DecisionMakerNode::publishLightColor(int status)
{
  autoware_msgs::traffic_light msg;
  msg.traffic_light = status;
  Pubs[&quot;light_color&quot;].publish(msg);
}

#define SHIFTED_LANE_FLAG -99999
void DecisionMakerNode::createShiftLane(void)
{
  bool isRightShift = param_shift_width_ &gt;= 0;

  autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
  if (!current_shifted_lane_array_.lanes.empty())
  {
    size_t lane_idx = 0;
    for (auto &amp;lane : shift_lanes.lanes)
    {
      lane.increment = SHIFTED_LANE_FLAG;
      size_t wp_idx = 0;
      for (auto &amp;wp : lane.waypoints)
      {
        double angle = getPoseAngle(wp.pose.pose);
        wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
        wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
        wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
      }
      lane_idx++;
    }
  }
  int insert_lane_idx_offset = isRightShift ? 1 : 0;
  auto it_shift = begin(shift_lanes.lanes);
  try
  {
    for (auto it = begin(current_shifted_lane_array_.lanes);
         it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
    {
      for (auto &amp;wp : it-&gt;waypoints)
      {
        wp.change_flag = isRightShift ? 1 : 2;
      }
      it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
      it++;
      if (!isRightShift)
        it++;
    }
  }
  catch (std::length_error)
  {
  }
}

void DecisionMakerNode::changeShiftLane(void)
{
  auto based_it = begin(current_shifted_lane_array_.lanes);

  for (auto &amp;lane : current_shifted_lane_array_.lanes)
  {
    if (lane.increment == SHIFTED_LANE_FLAG)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = param_shift_width_ &gt;= 0 ? 2 : 1;
      }
    }
    else
    {
      auto based_wp_it = begin(based_it++-&gt;waypoints);
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = based_wp_it++-&gt;change_flag;
      }
    }
  }
}

void DecisionMakerNode::removeShiftLane(void)
{
  current_shifted_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::updateLaneWaypointsArray(void)
{
  current_stopped_lane_array_ = current_controlled_lane_array_;

  for (auto &amp;lane : current_stopped_lane_array_.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      wp.twist.twist.linear.x = 0.0;
      wp.wpstate.stopline_state = 0;
    }
  }
}

void DecisionMakerNode::publishControlledLaneArray(void)
{
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
  current_controlled_lane_array_ = current_shifted_lane_array_;
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
  if (dir != 0)
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      autoware_msgs::lane temp_lane = lane;
      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
      {
        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
        double _rate = 0.2;                       // accelerated/decelerated rate
        double _weight = distance * _rate * dir;  //
        lane.waypoints.at(wpi).twist.twist.linear.x =
            lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
      }
    }
  }
  else
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.twist.twist.linear.x = amathutils::kmph2mps(param_crawl_velocity_);
      }
    }
  }
}

void DecisionMakerNode::callbackInStateKeep(int status)
{
  changeVelocityBasedLane();
  publishControlledLaneArray();
}

void DecisionMakerNode::callbackInStateAcc(int status)
{
  changeVelocityLane(status);
  publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
  static bool timerflag;
  static ros::Timer stopping_timer;
  if (status)
  {
    if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
    {
      stopping_timer = nh_.createTimer(ros::Duration(1),
                                       [&amp;](const ros::TimerEvent &amp;) {
                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
                                         ROS_INFO(&quot;Change state to [KEEP] from [STOP]\n&quot;);
                                         timerflag = false;
                                       },
                                       this, true);
      timerflag = true;
    }
  }
}

void DecisionMakerNode::updateStateObstacleAvoid(int status)
{
}

void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
{
  changeShiftLane();
  changeVelocityBasedLane();
  publishControlledLaneArray();
  ros::Rate loop_rate(1);
  // wait for the start of lane change to the original lane
  if (created_shift_lane_flag_)
  {
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
             !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
    // wait for the end of lane change
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
             ros::ok());
    removeShiftLane();
    created_shift_lane_flag_ = false;
  }
  changeVelocityBasedLane();  // rebased controlled lane
  publishControlledLaneArray();
return;
}

void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
{
  // this state is temporary implementation.
  // It means this state is desirable to use a way which enables the avoidance plannner such as astar, state lattice.

  // if car shoud stop before avoidance,
  if (!created_shift_lane_flag_)
  {
    created_shift_lane_flag_ = true;
    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
    createShiftLane();
  }

  changeVelocityBasedLane();
}
void DecisionMakerNode::callbackInStateStop(int status)
{
  publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch (status)
  {
    case LAMP_LEFT:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_OFF;
      break;
    case LAMP_RIGHT:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_HAZARD:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_EMPTY:
    default:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_OFF;
      break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="f565699320a72bde684825720ae53226f7663088" fix_time="41,43952">
		<msg>fix audion bug</msg>
		<modified_files>
			<file old_path="ui/web/remote_monitor/template/operator_window.html" new_path="ui/web/remote_monitor/template/operator_window.html">
				<diff>@@ -86,7 +86,7 @@
             &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
             &lt;span&gt;Add Audio&lt;/span&gt;
           &lt;/button&gt;
-          &lt;video id=&quot;localView6&quot;&gt;&lt;/video&gt;
+          &lt;video muted id=&quot;localView6&quot;&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
@@ -213,7 +213,7 @@
           &lt;div class=&quot;form-group&quot;&gt;
             &lt;label for=&quot;streamPreview control-label&quot;&gt;Preview&lt;/label&gt;
             &lt;div class=&quot;form-control&quot; id=&quot;devicePreview&quot;&gt;
-              &lt;video id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
+              &lt;video muted id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
             &lt;/div&gt;
           &lt;/div&gt;
         &lt;/div&gt;
</diff>
				<old_file>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot; /&gt;
  &lt;title&gt;Autoware&lt;/title&gt;
  &lt;link rel=&quot;shortcut icon&quot; href=&quot;/img/autoware_icon.ico&quot;&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.min.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/speed_meters.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bar.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/button.css&quot; /&gt;

  &lt;script src=&quot;/js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/webrtc_polyfill.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/operator.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/utility.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/gamepad.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/vehicle_button.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    window.addEventListener('beforeunload', function(e) {
      e.returnValue = 'Do you want to leave this page?';
    }, false);
  &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;!-- Header --&gt;
  &lt;header class=&quot;navbar-static-top bs-docs-nav&quot;&gt;
    &lt;div class=&quot;navbar-inner&quot;&gt;
      &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;navbar-header&quot;&gt;
          &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;
          &lt;li class=&quot;dropdown&quot; id=&quot;ddJoinRoom&quot;&gt;
            &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; id=&quot;btnJoinRoom&quot;&gt;CONNECT&lt;b class=&quot;caret&quot;&gt;&lt;/b&gt;&lt;/a&gt;
            &lt;ul class=&quot;dropdown-menu&quot; id=&quot;ddmJoinRoom&quot; style=&quot;padding: 15px;min-width: 350px; height: 150px&quot;&gt;
              &lt;li&gt;
                &lt;div class=&quot;row&quot;&gt;
                  &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;form class=&quot;form&quot; role=&quot;form&quot; id=&quot;formJoinRoom&quot;&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;txtRoomName&quot; class=&quot;control-label&quot;&gt;CONNECT VEHICLE (Set Vehicle ID)&lt;/label&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;txtRoomName&quot; required&gt;
                      &lt;/div&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-block&quot;&gt;CONNECT&lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/form&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;div id=&quot;maskPanel&quot;&gt;&lt;/div&gt;

  &lt;!-- UI --&gt;
  &lt;div class=&quot;container&quot; id=&quot;container&quot;&gt;
    &lt;!-- First row --&gt;
    &lt;div class=&quot;row row-eq-height row-top&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 5px&quot;&gt;
          &lt;h2&gt;&lt;u&gt;Vehicle Info&lt;/u&gt;&lt;h2&gt;
          &lt;h3 id=&quot;text_speed&quot;&gt;Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_target_speed&quot;&gt;Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_next_target_speed&quot;&gt;Next Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_state&quot;&gt;State: -&lt;/h3&gt;
        &lt;/div&gt;

        &lt;div class=&quot;streamAudioContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream6&quot; data-no=&quot;6&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream6&quot; data-no=&quot;6&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Audio&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView6&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-6 col-md-6 col-sm-6 col-xs-6&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView2&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView5&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Second row --&gt;
    &lt;div class=&quot;row row-eq-height row-center&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView3&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-6 col-md-6 col-sm-6 col-xs-6&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView1&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;video id=&quot;remoteView4&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Third row --&gt;
    &lt;div class=&quot;row row-eq-height row-bottom&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;img id=&quot;vehicle_steering&quot; src=&quot;/img/steering.png&quot;&gt;&lt;/img&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;dashboard&quot;&gt;
          &lt;div class=&quot;meter meter--rpm meter--big-label&quot;&gt;&lt;/div&gt;
          &lt;div class=&quot;meter meter--gear&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt;
          &lt;div class=&quot;meter meter--speed&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 10px&quot;&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Accel&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Brake&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Vehicle Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;fill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Accel&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;controller_accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Brake&lt;/h4&gt;
          &lt;progress class=&quot;operator&quot; id=&quot;controller_brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4 class=&quot;operator&quot;&gt;Controller Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;cfill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&quot;select-wrap select-circle&quot;&gt;
            &lt;h4 class=&quot;operator&quot;&gt;Gear&lt;/h4&gt;
            &lt;select name=&quot;gear&quot; id=&quot;gear&quot; onChange=&quot;select_gear(this);&quot;&gt;
              &lt;option value=&quot;0&quot;&gt;P&lt;/option&gt;
              &lt;option value=&quot;1&quot;&gt;D&lt;/option&gt;
              &lt;option value=&quot;2&quot;&gt;R&lt;/option&gt;
              &lt;option value=&quot;3&quot;&gt;N&lt;/option&gt;
              &lt;option value=&quot;4&quot;&gt;B&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;center&gt;
          &lt;a href=&quot;#&quot; class=&quot;bt-emergency&quot; onclick=&quot;select_emergency_button();&quot;&gt;&lt;span id=&quot;emergency_button&quot;&gt;EMEGENCY&lt;/span&gt;&lt;/a&gt;
          &lt;a href=&quot;#&quot; class=&quot;bt-controlmode&quot; onclick=&quot;select_mode_button();&quot;&gt;&lt;span id=&quot;control_mode_button&quot;&gt;AUTO&lt;/span&gt;&lt;/a&gt;
        &lt;/center&gt;

        &lt;div class=&quot;row&quot;&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_left&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;◁&quot; onclick=&quot;pushBlinker(1)&quot;&gt;
          &lt;/div&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_hazard&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;△&quot; onclick=&quot;pushBlinker(3)&quot;&gt;
          &lt;/div&gt;
          &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
            &lt;input id=&quot;blinker_right&quot; type=&quot;button&quot; class=&quot;square_btn&quot; value=&quot;▷&quot; onclick=&quot;pushBlinker(2)&quot;&gt;
          &lt;/div&gt;
        &lt;/div&gt;

      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Select Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;selectDeviceDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
          &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;Select Capture Device&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;othorSelectDevice&quot;&gt;
            &lt;label for=&quot;ddDevices&quot; class=&quot;control-label&quot;&gt;Device&lt;/label&gt;
            &lt;select class=&quot;input-large form-control&quot; id=&quot;deviceList&quot;&gt;&lt;/select&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;firefoxSelectDevice&quot;&gt;
            &lt;span id=&quot;ffMessage&quot; class=&quot;control-label&quot;&gt;Click the Select Device.&lt;br /&gt;&lt;button id=&quot;btnFfSelectDevice&quot;&gt;Select Device&lt;/button&gt;&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;streamPreview control-label&quot;&gt;Preview&lt;/label&gt;
            &lt;div class=&quot;form-control&quot; id=&quot;devicePreview&quot;&gt;
              &lt;video id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot;&gt;
          &lt;button type=&quot;button&quot; id=&quot;btnDialogAddStream&quot; class=&quot;btn btn-primary&quot;&gt;Add Stream&lt;/button&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Message Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;messageDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; data-backdrop=&quot;static&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          VEHICLE ID: &lt;input type=&quot;text&quot; id=&quot;dialogRoomName&quot; size=&quot;36&quot; readonly /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;p id=&quot;messageText&quot;&gt;&lt;/p&gt;
          &lt;span id=&quot;waitingIcon&quot; class=&quot;glyphicon glyphicon-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot; id=&quot;messageDialogFooter&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;CLOSE&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</old_file>
			</file>
			<file old_path="ui/web/remote_monitor/template/vehicle_window.html" new_path="ui/web/remote_monitor/template/vehicle_window.html">
				<diff>@@ -90,7 +90,7 @@
             &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
             &lt;span&gt;Add Back Camera&lt;/span&gt;
           &lt;/button&gt;
-          &lt;video id=&quot;localView2&quot;&gt;&lt;/video&gt;
+          &lt;video muted id=&quot;localView2&quot;&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
@@ -101,7 +101,7 @@
             &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
             &lt;span&gt;Add Dashboard Camera&lt;/span&gt;
           &lt;/button&gt;
-          &lt;video id=&quot;localView5&quot;&gt;&lt;/video&gt;
+          &lt;video muted id=&quot;localView5&quot;&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
@@ -116,7 +116,7 @@
             &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
             &lt;span&gt;Add Left Back Camera&lt;/span&gt;
           &lt;/button&gt;
-          &lt;video id=&quot;localView3&quot;&gt;&lt;/video&gt;
+          &lt;video muted id=&quot;localView3&quot;&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
@@ -127,7 +127,7 @@
             &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
             &lt;span&gt;Add Front Camera&lt;/span&gt;
           &lt;/button&gt;
-          &lt;video id=&quot;localView1&quot;&gt;&lt;/video&gt;
+          &lt;video muted id=&quot;localView1&quot;&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
 
@@ -138,7 +138,7 @@
             &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
             &lt;span&gt;Add Right Back Camera&lt;/span&gt;
           &lt;/button&gt;
-          &lt;video id=&quot;localView4&quot;&gt;&lt;/video&gt;
+          &lt;video muted id=&quot;localView4&quot;&gt;&lt;/video&gt;
         &lt;/div&gt;
       &lt;/div&gt;
     &lt;/div&gt;
@@ -219,7 +219,7 @@
           &lt;div class=&quot;form-group&quot;&gt;
             &lt;label for=&quot;streamPreview control-label&quot;&gt;Preview&lt;/label&gt;
             &lt;div class=&quot;form-control&quot; id=&quot;devicePreview&quot;&gt;
-              &lt;video id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
+              &lt;video muted id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
             &lt;/div&gt;
           &lt;/div&gt;
         &lt;/div&gt;
</diff>
				<old_file>&lt;!DOCTYPE html&gt;

&lt;html&gt;

&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot; /&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1&quot; /&gt;
  &lt;title&gt;Autoware&lt;/title&gt;
  &lt;link rel=&quot;shortcut icon&quot; href=&quot;/img/autoware_icon.ico&quot;&gt;

  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bootstrap.min.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/main.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/speed_meters.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/bar.css&quot; /&gt;
  &lt;link rel=&quot;stylesheet&quot; href=&quot;/css/button.css&quot; /&gt;

  &lt;script src=&quot;/js/jquery-2.1.4.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;socket.io/socket.io.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/webrtc_polyfill.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/vehicle.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/utility.js&quot;&gt;&lt;/script&gt;
  &lt;script src=&quot;/js/remote_ui.js&quot;&gt;&lt;/script&gt;
  &lt;script&gt;
    window.addEventListener('beforeunload', function(e) {
      e.returnValue = 'Do you want to leave this page?';
    }, false);
  &lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

  &lt;!-- Header --&gt;
  &lt;header class=&quot;navbar-static-top bs-docs-nav&quot;&gt;
    &lt;div class=&quot;navbar-inner&quot;&gt;
      &lt;div class=&quot;container&quot;&gt;
        &lt;div class=&quot;navbar-header&quot;&gt;
          &lt;a class=&quot;navbar-brand&quot; href=&quot;/&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;ul class=&quot;nav navbar-nav navbar-right&quot;&gt;
          &lt;li class=&quot;dropdown&quot; id=&quot;ddJoinRoom&quot;&gt;
            &lt;a href=&quot;#&quot; class=&quot;dropdown-toggle&quot; data-toggle=&quot;dropdown&quot; id=&quot;btnJoinRoom&quot;&gt;CONNECT&lt;b class=&quot;caret&quot;&gt;&lt;/b&gt;&lt;/a&gt;
            &lt;ul class=&quot;dropdown-menu&quot; id=&quot;ddmJoinRoom&quot; style=&quot;padding: 15px;min-width: 350px; height: 150px&quot;&gt;
              &lt;li&gt;
                &lt;div class=&quot;row&quot;&gt;
                  &lt;div class=&quot;col-md-12&quot;&gt;
                    &lt;form class=&quot;form&quot; role=&quot;form&quot; id=&quot;formJoinRoom&quot;&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;label for=&quot;txtRoomName&quot; class=&quot;control-label&quot;&gt;CONNECT VEHICLE (Set Vehicle ID)&lt;/label&gt;
                        &lt;input type=&quot;text&quot; class=&quot;form-control&quot; id=&quot;txtRoomName&quot; required&gt;
                      &lt;/div&gt;
                      &lt;div class=&quot;form-group&quot;&gt;
                        &lt;button type=&quot;submit&quot; class=&quot;btn btn-success btn-block&quot;&gt;CONNECT&lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/form&gt;
                  &lt;/div&gt;
                &lt;/div&gt;
              &lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/header&gt;

  &lt;div id=&quot;maskPanel&quot;&gt;&lt;/div&gt;

  &lt;!-- UI --&gt;
  &lt;div class=&quot;container&quot; id=&quot;container&quot;&gt;
    &lt;!-- First row --&gt;
    &lt;div class=&quot;row row-eq-height row-top&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 5px&quot;&gt;
          &lt;h2&gt;&lt;u&gt;Vehicle Info&lt;/u&gt;&lt;h2&gt;
          &lt;h3 id=&quot;text_speed&quot;&gt;Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_target_speed&quot;&gt;Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_next_target_speed&quot;&gt;Next Target Speed: - km/h&lt;/h3&gt;
          &lt;h3 id=&quot;text_state&quot;&gt;State: -&lt;/h3&gt;

          &lt;div class=&quot;streamAudioContainer&quot; style=&quot;visibility:hidden&quot;&gt;
            &lt;video id=&quot;remoteView6&quot;&gt;&lt;/video&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-6 col-md-6 col-sm-6 col-xs-6&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream2&quot; data-no=&quot;2&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream2&quot; data-no=&quot;2&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView2&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream5&quot; data-no=&quot;5&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream5&quot; data-no=&quot;5&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Dashboard Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView5&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

    &lt;/div&gt;

    &lt;!-- UI Second row --&gt;
    &lt;div class=&quot;row row-eq-height row-center&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream3&quot; data-no=&quot;3&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream3&quot; data-no=&quot;3&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Left Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView3&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-6 col-md-6 col-sm-6 col-xs-6&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream1&quot; data-no=&quot;1&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream1&quot; data-no=&quot;1&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Front Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView1&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div class=&quot;streamItemContainer&quot;&gt;
          &lt;span class=&quot;btnRemoveStream glyphicon glyphicon-remove&quot; style=&quot;display:none&quot; id=&quot;btnRemoveStream4&quot; data-no=&quot;4&quot; title=&quot;DELETE&quot;&gt;&lt;/span&gt;&lt;br /&gt;
          &lt;button class=&quot;btnAddStream&quot; id=&quot;btnAddStream4&quot; data-no=&quot;4&quot;&gt;
            &lt;span class=&quot;glyphicon glyphicon-remove r45&quot;&gt;&lt;/span&gt;&lt;br /&gt;
            &lt;span&gt;Add Right Back Camera&lt;/span&gt;
          &lt;/button&gt;
          &lt;video id=&quot;localView4&quot;&gt;&lt;/video&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;

    &lt;!-- UI Third row --&gt;
    &lt;div class=&quot;row row-eq-height row-bottom&quot;&gt;
      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;img id=&quot;vehicle_steering&quot; src=&quot;/img/steering.png&quot;&gt;&lt;/img&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-4 col-md-4 col-sm-4 col-xs-4&quot;&gt;
        &lt;div class=&quot;dashboard&quot;&gt;
        	&lt;div class=&quot;meter meter--rpm meter--big-label&quot;&gt;&lt;/div&gt;
        	&lt;div class=&quot;meter meter--gear&quot;&gt;&lt;div&gt;1&lt;/div&gt;&lt;/div&gt;
        	&lt;div class=&quot;meter meter--speed&quot;&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-3 col-md-3 col-sm-3 col-xs-3&quot;&gt;
        &lt;div align=&quot;left&quot; style=&quot;margin-left: 10px&quot;&gt;
          &lt;h4&gt;Accel&lt;/h4&gt;
          &lt;progress id=&quot;accel_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4&gt;Brake&lt;/h4&gt;
          &lt;progress id=&quot;brake_bar&quot; value=&quot;0&quot; max=&quot;100&quot;&gt;&lt;/progress&gt;
          &lt;h4&gt;Steer&lt;/h4&gt;
          &lt;div class=&quot;seekbar&quot;&gt;
            &lt;div class=&quot;fill&quot;&gt;&lt;/div&gt;
            &lt;div class=&quot;handle&quot;&gt;&lt;/div&gt;
          &lt;/div&gt;

          &lt;div class=&quot;select-wrap select-circle&quot;&gt;
            &lt;h4&gt;Gear&lt;/h4&gt;
            &lt;select name=&quot;gear&quot; id=&quot;gear&quot; onChange=&quot;select_gear(this);&quot;&gt;
              &lt;option value=&quot;0&quot;&gt;P&lt;/option&gt;
              &lt;option value=&quot;1&quot;&gt;D&lt;/option&gt;
              &lt;option value=&quot;2&quot;&gt;R&lt;/option&gt;
              &lt;option value=&quot;3&quot;&gt;N&lt;/option&gt;
              &lt;option value=&quot;4&quot;&gt;B&lt;/option&gt;
            &lt;/select&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;

      &lt;div class=&quot;col-lg-2 col-md-2 col-sm-2 col-xs-2&quot;&gt;
        &lt;div class=&quot;onoffswitch&quot;&gt;
            &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;emergencyswitch&quot; checked onchange=&quot;select_emergency_button();&quot;&gt;
            &lt;label class=&quot;onoffswitch-label&quot; for=&quot;emergencyswitch&quot;&gt;
                &lt;span class=&quot;emergencyswitch-inner&quot;&gt;&lt;/span&gt;
            &lt;/label&gt;
        &lt;/div&gt;

        &lt;div class=&quot;onoffswitch&quot;&gt;
          &lt;input type=&quot;checkbox&quot; name=&quot;onoffswitch&quot; class=&quot;onoffswitch-checkbox&quot; id=&quot;modeswitch&quot; checked onchange=&quot;select_mode_button();&quot;&gt;
          &lt;label class=&quot;onoffswitch-label&quot; for=&quot;modeswitch&quot;&gt;
              &lt;span class=&quot;modeswitch-inner&quot;&gt;&lt;/span&gt;
          &lt;/label&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Select Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;selectDeviceDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;close&quot; data-dismiss=&quot;modal&quot; aria-label=&quot;Close&quot;&gt;&lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
          &lt;h4 class=&quot;modal-title&quot; id=&quot;myModalLabel&quot;&gt;Select Capture Device&lt;/h4&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;othorSelectDevice&quot;&gt;
            &lt;label for=&quot;ddDevices&quot; class=&quot;control-label&quot;&gt;Device&lt;/label&gt;
            &lt;select class=&quot;input-large form-control&quot; id=&quot;deviceList&quot;&gt;&lt;/select&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot; id=&quot;firefoxSelectDevice&quot;&gt;
            &lt;span id=&quot;ffMessage&quot; class=&quot;control-label&quot;&gt;Click the Select Device.&lt;br /&gt;&lt;button id=&quot;btnFfSelectDevice&quot;&gt;Select Device&lt;/button&gt;&lt;/span&gt;
          &lt;/div&gt;
          &lt;div class=&quot;form-group&quot;&gt;
            &lt;label for=&quot;streamPreview control-label&quot;&gt;Preview&lt;/label&gt;
            &lt;div class=&quot;form-control&quot; id=&quot;devicePreview&quot;&gt;
              &lt;video id=&quot;streamPreview&quot;&gt;&lt;/video&gt;
            &lt;/div&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot;&gt;
          &lt;button type=&quot;button&quot; id=&quot;btnDialogAddStream&quot; class=&quot;btn btn-primary&quot;&gt;Add Stream&lt;/button&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;Close&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;

  &lt;!-- Message Dialog --&gt;
  &lt;div class=&quot;modal fade&quot; id=&quot;messageDialog&quot; tabindex=&quot;-1&quot; role=&quot;dialog&quot; aria-labelledby=&quot;myModalLabel&quot; data-backdrop=&quot;static&quot;&gt;
    &lt;div class=&quot;modal-dialog&quot; role=&quot;document&quot;&gt;
      &lt;div class=&quot;modal-content&quot;&gt;
        &lt;div class=&quot;modal-header&quot;&gt;
          VEHICLE ID: &lt;input type=&quot;text&quot; id=&quot;dialogRoomName&quot; size=&quot;36&quot; readonly /&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-body&quot;&gt;
          &lt;p id=&quot;messageText&quot;&gt;&lt;/p&gt;
          &lt;span id=&quot;waitingIcon&quot; class=&quot;glyphicon glyphicon-refresh&quot; aria-hidden=&quot;true&quot;&gt;&lt;/span&gt;
        &lt;/div&gt;
        &lt;div class=&quot;modal-footer&quot; id=&quot;messageDialogFooter&quot;&gt;
          &lt;button type=&quot;button&quot; class=&quot;btn btn-default&quot; data-dismiss=&quot;modal&quot;&gt;CLOSE&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;script src=&quot;/js/main.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="7923632d7f548d6235dc679af83a52e4b3215cef" fix_time="64,73272">
		<msg>add support to manual fixing light</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/include/decision_maker_node.hpp">
				<diff>@@ -107,6 +107,8 @@ private:
   std::vector&lt;CrossRoadArea&gt; intersects;
   double displacement_from_path_;
 
+  bool isManualLight;
+
   // Param
   bool enableDisplayMarker;
   bool enableForceStateChange;
@@ -225,6 +227,7 @@ public:
 
     ClosestArea_ = nullptr;
     displacement_from_path_ = 0.0;
+    isManualLight = false;
   }
 
   void run(void);
</diff>
				<old_file>#ifndef __DECISION_MAKER_NODE__
#define __DECISION_MAKER_NODE__

#include &lt;mutex&gt;
#include &lt;unordered_map&gt;

#include &lt;autoware_msgs/ConfigDecisionMaker.h&gt;
#include &lt;autoware_msgs/LaneArray.h&gt;
#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBox.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;

#include &lt;visualization_msgs/MarkerArray.h&gt;

#include &lt;vector_map_msgs/AreaArray.h&gt;
#include &lt;vector_map_msgs/CrossRoadArray.h&gt;
#include &lt;vector_map_msgs/LineArray.h&gt;
#include &lt;vector_map_msgs/PointArray.h&gt;

#include &lt;vector_map/vector_map.h&gt;

#include &lt;geometry_msgs/Point.h&gt;

// lib
#include &lt;amathutils.hpp&gt;
#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_param.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
using namespace vector_map;

enum class EControl : int32_t
{
  KEEP = -1,
  STOP = 1,
  DECELERATE = 2,
  ACCELERATE = 3,
  OTHERS = 4,
};

enum class E_ChangeFlags : int32_t
{
  STRAIGHT,
  RIGHT,
  LEFT,

  UNKNOWN = -1,
};

inline bool hasvMap(void)
{
  return true;
}

template &lt;class T&gt;
typename std::underlying_type&lt;T&gt;::type enumToInteger(T t)
{
  return static_cast&lt;typename std::underlying_type&lt;T&gt;::type&gt;(t);
}

class DecisionMakerNode
{
private:
  ros::NodeHandle nh_;
  // Publishers
  std::unordered_map&lt;std::string, ros::Publisher&gt; Pubs;
  // Subscribers
  std::unordered_map&lt;std::string, ros::Subscriber&gt; Subs;

  // ROS Messages
  std_msgs::String state_string_msg;
  geometry_msgs::PoseStamped current_pose_;

  jsk_rviz_plugins::OverlayText state_text_msg;

  // ROS Messages(Autoware)
  autoware_msgs::lane current_finalwaypoints_;
  vector_map_msgs::AreaArray vMap_Areas;
  vector_map_msgs::PointArray vMap_Points;
  vector_map_msgs::LineArray vMap_Lines;
  vector_map_msgs::CrossRoadArray vMap_CrossRoads;

  std::vector&lt;geometry_msgs::Point&gt; inside_points_;

  autoware_msgs::LaneArray current_based_lane_array_;       // with wpstate
  autoware_msgs::LaneArray current_shifted_lane_array_;     // with shiftedLane
  autoware_msgs::LaneArray current_controlled_lane_array_;  // modified lane
  autoware_msgs::LaneArray current_stopped_lane_array_;     // 0velocity

  // Current way/behavior status
  double current_velocity_;
  double average_velocity_;
  int current_traffic_light_;
  int closest_waypoint_;
  CrossRoadArea *ClosestArea_;
  std::string CurrentStateName;
  std::string TextOffset;
  std::vector&lt;CrossRoadArea&gt; intersects;
  double displacement_from_path_;

  // Param
  bool enableDisplayMarker;
  bool enableForceStateChange;
  uint32_t param_convergence_count_;
  uint32_t param_target_waypoint_;
  double param_convergence_threshold_;
  uint32_t param_stopline_target_waypoint_;
  double param_shift_width_;
  double param_crawl_velocity_;

  // for vectormap server
  // ros::ServiceClient cross_road_cli;
  // vector_map_server::GetCrossRoad cross_road_srv;

  // initialization flags for initialized by callback
  bool vector_map_init;
  bool vMap_Areas_flag;
  bool vMap_Points_flag;
  bool vMap_Lines_flag;
  bool vMap_CrossRoads_flag;
  bool SimulationMode;
  std::mutex vMap_mutex;
  bool created_shift_lane_flag_;

  // initialization method
  void initROS(int argc, char **argv);
  void initVectorMap(void);
  void initStateMsgs(void);
  bool initVectorMapClient(void);

  // looping method
  void update(void);
  void update_msgs(void);
  void update_pubsub(void);
  void displayMarker(void);

  void publishToVelocityArray();
  std::string createStateMessageText();
  int createCrossRoadAreaMarker(visualization_msgs::Marker &amp;crossroad_marker, double scale);

  // judge method
  // in near future, these methods will be deprecate to decision_maker library
  bool isCrossRoadByVectorMapServer(const autoware_msgs::lane &amp;lane_msg, const geometry_msgs::PoseStamped &amp;pose_msg);
  bool isLocalizationConvergence(double _x, double _y, double _z, double _roll, double _pitch, double _yaw);
  bool handleStateCmd(const uint64_t _state_num);
  // double calcIntersectWayAngle(const CrossRoadArea&amp; area);
  double calcIntersectWayAngle(const autoware_msgs::lane &amp;laneinArea);

  void insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects, autoware_msgs::LaneArray &amp;lane_array);

  void setWaypointState(autoware_msgs::LaneArray &amp;lane_array);
  double calcPosesAngleDiff(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to);
  double calcPosesAngleDiffN(const geometry_msgs::Pose &amp;p_from, const geometry_msgs::Pose &amp;p_to);
  double getPoseAngle(const geometry_msgs::Pose &amp;p);

  void publishStoppedLaneArray(void);
  void publishControlledLaneArray(void);
  void updateLaneWaypointsArray(void);
  void changeVelocityBasedLane(void);
  void changeVelocityLane(int dir);
  void createShiftLane(void);
  void changeShiftLane(void);
  void removeShiftLane(void);

  void publishLightColor(int status);
  void callbackInStateObstacleAvoid(int status);
  void callbackOutStateObstacleAvoid(int status);
  void updateStateObstacleAvoid(int status);
  void updateStateSTR(int status);
  void updateStateStop(int status);
  void callbackInStateStop(int status);
  void callbackInStateAcc(int status);
  void callbackInStateDec(int status);
  void callbackInStateKeep(int status);
  void setupStateCallback(void);
  // callback by topic subscribing
  void callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg);
  void callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event);
  void callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg);
  void callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg);
  void callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg);
  void callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg);
  void callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg);
  void callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg);
  void callbackFromStateCmd(const std_msgs::Int32 &amp;msg);
  void callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg);

  void callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg);
  void callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg);
  void callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg);
  void callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg);

public:
  state_machine::StateContext *ctx;
  VectorMap g_vmap;

  DecisionMakerNode(int argc, char **argv)
  {
    SimulationMode = false;
    enableDisplayMarker = DEFAULT_DISPLAY_FLAG;
    param_convergence_threshold_ = DEFAULT_CONVERGENCE_THRESHOLD;
    param_convergence_count_ = DEFAULT_CONVERGENCE_COUNT;
    param_target_waypoint_ = DEFAULT_TARGET_WAYPOINT;
    param_shift_width_ = DEFAULT_SHIFT_WIDTH;
    param_stopline_target_waypoint_ = DEFAULT_STOPLINE_TARGET_WAYPOINT;
    param_crawl_velocity_ = DEFAULT_CRAWL_VELOCITY;

    ctx = new state_machine::StateContext();
    this-&gt;initROS(argc, argv);

    vector_map_init = false;
    created_shift_lane_flag_ = false;
    closest_waypoint_ = 0;

    ClosestArea_ = nullptr;
    displacement_from_path_ = 0.0;
  }

  void run(void);
};

}  // namespace decision_maker

#endif
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -36,12 +36,21 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
   if (!ctx-&gt;isCurrentState(_state_num))
   {
     _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
+    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
+		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
+	    isManualLight = true;
+    }
   }
   else
   {
     _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
+    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
+		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
+	    isManualLight = false;
   }
   ctx-&gt;setEnableForceSetState(false);
+
+
   return _ret;
 }
 
@@ -89,19 +98,23 @@ void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMa
 }
 
 void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
-{
+{    
   const autoware_msgs::traffic_light *light = event.getMessage().get();
-
-  current_traffic_light_ = light-&gt;traffic_light;
-  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
-  {
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-  }
-  else
-  {
-    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+//  const ros::M_string &amp;header = event.getConnectionHeader();
+//  std::string topic = header.at(&quot;topic&quot;); 
+  
+  if(!isManualLight){// &amp;&amp; topic.find(&quot;manage&quot;) == std::string::npos){
+	  current_traffic_light_ = light-&gt;traffic_light;
+	  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
+	  {
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
+	  }
+	  else
+	  {
+		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
+		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+	  }
   }
 }
 
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  if (!ctx-&gt;isCurrentState(_state_num))
  {
    _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
  }
  else
  {
    _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
  }
  ctx-&gt;setEnableForceSetState(false);
  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request: %llx&quot;, 1ULL &lt;&lt; (uint64_t)msg.data);
  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);

  param_target_waypoint_ = msg.target_waypoint;
  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
  param_shift_width_ = msg.shift_width;
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{
  const autoware_msgs::traffic_light *light = event.getMessage().get();

  current_traffic_light_ = light-&gt;traffic_light;
  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
  {
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
  }
  else
  {
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
          }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;wp_lane : laneinArea.waypoints)
        for (auto &amp;lane : lane_array.lanes)
          for (auto &amp;wp : lane.waypoints)
            if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
            {
              wp.wpstate.steering_state = steering_state;
            }
    }
  }
  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);
  });

  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
            // lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  int gid = 0;
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int lid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
                   param_stopline_target_waypoint_ :
                   current_finalwaypoints_.waypoints.size() - 1;
  
  if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
  // steering
  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
            param_target_waypoint_ :
            current_finalwaypoints_.waypoints.size() - 1;
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
  }
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
  }
  else
  {
	  ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
  }

  // for publish plan of velocity
  publishToVelocityArray();
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg)
{
  closest_waypoint_ = msg.data;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_init.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_init.cpp">
				<diff>@@ -38,8 +38,8 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Subs[&quot;current_velocity&quot;] =
       nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
   Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
-  Subs[&quot;light_color_managed&quot;] =
-      nh_.subscribe(&quot;light_color_managed&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
+//  Subs[&quot;light_color_managed&quot;] =
+  //    nh_.subscribe(&quot;light_color_managed&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
   Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
   Subs[&quot;final_waypoints&quot;] = nh_.subscribe(&quot;final_waypoints&quot;, 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
   Subs[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
@@ -58,7 +58,7 @@ void DecisionMakerNode::initROS(int argc, char **argv)
   Pubs[&quot;state&quot;] = nh_.advertise&lt;std_msgs::String&gt;(&quot;state&quot;, 1);
   Pubs[&quot;lane_waypoints_array&quot;] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
   Pubs[&quot;states&quot;] = nh_.advertise&lt;autoware_msgs::state&gt;(&quot;/decisionmaker/states&quot;, 1, true);
- //Pubs[&quot;light_color&quot;] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;(&quot;/light_color&quot;, 1);
+  Pubs[&quot;light_color&quot;] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;(&quot;/light_color_managed&quot;, 1);
 
   // for controlling vehicle
   Pubs[&quot;lamp_cmd&quot;] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;(&quot;/lamp_cmd&quot;, 1);
</diff>
				<old_file>#include &lt;ros/ros.h&gt;
#include &lt;ros/spinner.h&gt;
#include &lt;std_msgs/Float64.h&gt;
#include &lt;std_msgs/Float64MultiArray.h&gt;
#include &lt;std_msgs/Int32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &lt;mutex&gt;

// lib
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;decision_maker_node.hpp&gt;
//#include &lt;vector_map/vector_map.h&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/state.h&gt;
#include &lt;jsk_recognition_msgs/BoundingBoxArray.h&gt;
#include &lt;visualization_msgs/MarkerArray.h&gt;
#include &lt;random&gt;

#include &lt;geometry_msgs/Point.h&gt;
#include &lt;geometry_msgs/Pose.h&gt;
#include &lt;geometry_msgs/PoseStamped.h&gt;

namespace decision_maker
{
void DecisionMakerNode::initROS(int argc, char **argv)
{
  ctx-&gt;setCurrentState(state_machine::INITIAL_STATE);

  // status subscriber
  Subs[&quot;sim_pose&quot;] = nh_.subscribe(&quot;sim_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromSimPose, this);
  Subs[&quot;current_pose&quot;] = nh_.subscribe(&quot;current_pose&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentPose, this);
  Subs[&quot;current_velocity&quot;] =
      nh_.subscribe(&quot;current_velocity&quot;, 20, &amp;DecisionMakerNode::callbackFromCurrentVelocity, this);
  Subs[&quot;light_color&quot;] = nh_.subscribe(&quot;light_color&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
  Subs[&quot;light_color_managed&quot;] =
      nh_.subscribe(&quot;light_color_managed&quot;, 10, &amp;DecisionMakerNode::callbackFromLightColor, this);
  Subs[&quot;points_raw&quot;] = nh_.subscribe(&quot;filtered_points&quot;, 1, &amp;DecisionMakerNode::callbackFromPointsRaw, this);
  Subs[&quot;final_waypoints&quot;] = nh_.subscribe(&quot;final_waypoints&quot;, 100, &amp;DecisionMakerNode::callbackFromFinalWaypoint, this);
  Subs[&quot;twist_cmd&quot;] = nh_.subscribe(&quot;twist_cmd&quot;, 10, &amp;DecisionMakerNode::callbackFromTwistCmd, this);
  Subs[&quot;change_flag&quot;] = nh_.subscribe(&quot;change_flag&quot;, 1, &amp;DecisionMakerNode::callbackFromLaneChangeFlag, this);
  Subs[&quot;state_cmd&quot;] = nh_.subscribe(&quot;state_cmd&quot;, 1, &amp;DecisionMakerNode::callbackFromStateCmd, this);
  Subs[&quot;closest_waypoint&quot;] =
      nh_.subscribe(&quot;closest_waypoint&quot;, 1, &amp;DecisionMakerNode::callbackFromClosestWaypoint, this);

  // Config subscriber
  Subs[&quot;config/decision_maker&quot;] =
      nh_.subscribe(&quot;/config/decision_maker&quot;, 3, &amp;DecisionMakerNode::callbackFromConfig, this);

  // pub

  // for controlling other planner
  Pubs[&quot;state&quot;] = nh_.advertise&lt;std_msgs::String&gt;(&quot;state&quot;, 1);
  Pubs[&quot;lane_waypoints_array&quot;] = nh_.advertise&lt;autoware_msgs::LaneArray&gt;(TPNAME_CONTROL_LANE_WAYPOINTS_ARRAY, 10, true);
  Pubs[&quot;states&quot;] = nh_.advertise&lt;autoware_msgs::state&gt;(&quot;/decisionmaker/states&quot;, 1, true);
 //Pubs[&quot;light_color&quot;] = nh_.advertise&lt;autoware_msgs::traffic_light&gt;(&quot;/light_color&quot;, 1);

  // for controlling vehicle
  Pubs[&quot;lamp_cmd&quot;] = nh_.advertise&lt;autoware_msgs::lamp_cmd&gt;(&quot;/lamp_cmd&quot;, 1);
  Pubs[&quot;emergency&quot;] =

      // for visualize status
      Pubs[&quot;state_overlay&quot;] = nh_.advertise&lt;jsk_rviz_plugins::OverlayText&gt;(&quot;/state/overlay_text&quot;, 1);
  Pubs[&quot;crossroad_marker&quot;] = nh_.advertise&lt;visualization_msgs::MarkerArray&gt;(&quot;/state/cross_road_marker&quot;, 1);
  Pubs[&quot;crossroad_inside_marker&quot;] = nh_.advertise&lt;visualization_msgs::Marker&gt;(&quot;/state/cross_inside_marker&quot;, 1);
  Pubs[&quot;crossroad_bbox&quot;] = nh_.advertise&lt;jsk_recognition_msgs::BoundingBoxArray&gt;(&quot;/state/crossroad_bbox&quot;, 10);

  // for debug
  Pubs[&quot;target_velocity_array&quot;] = nh_.advertise&lt;std_msgs::Float64MultiArray&gt;(&quot;/target_velocity_array&quot;, 1);
  Pubs[&quot;state_local_diffdistance&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/val_diff_distance&quot;, 1);
  Pubs[&quot;exectime&quot;] = nh_.advertise&lt;std_msgs::Float64&gt;(&quot;/state/exectime&quot;, 1);

  // message setup
  state_text_msg.width = 400;
  state_text_msg.height = 500;
  state_text_msg.top = 10;
  state_text_msg.left = 10;
  state_text_msg.bg_color.r = 0;
  state_text_msg.bg_color.g = 0;
  state_text_msg.bg_color.b = 0;
  state_text_msg.bg_color.a = 0.8;

  state_text_msg.line_width = 2;
  state_text_msg.text_size = 18;
  state_text_msg.font = &quot;DejaVu Sans Mono&quot;;
  state_text_msg.fg_color.r = 0.1;
  state_text_msg.fg_color.g = 1.0;
  state_text_msg.fg_color.b = 0.94;
  state_text_msg.fg_color.a = 0.8;
  state_text_msg.text = &quot;UNDEFINED&quot;;

  // initial publishing state message
  update_msgs();

  // setup a callback for state update();
  setupStateCallback();

  g_vmap.subscribe(nh_,
                   Category::POINT | Category::LINE | Category::VECTOR | Category::AREA |
                       Category::POLE |  // basic class
                       Category::DTLANE | Category::STOP_LINE | Category::ROAD_SIGN | Category::CROSS_ROAD);
  initVectorMap();

  {
    if (enableDisplayMarker)
      displayMarker();
  }

  ROS_INFO(&quot;Initialized OUT\n&quot;);
  ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  
  Subs[&quot;lane_waypoints_array&quot;] =
      nh_.subscribe(TPNAME_BASED_LANE_WAYPOINTS_ARRAY, 100, &amp;DecisionMakerNode::callbackFromLaneWaypoint, this);
}

void DecisionMakerNode::initVectorMap(void)
{
  int _index = 0;
  // if(vector_map_init)
  //      return;
  std::vector&lt;CrossRoad&gt; crossroads = g_vmap.findByFilter([](const CrossRoad &amp;crossroad) { return true; });
  if (crossroads.empty())
  {
    ROS_INFO(&quot;crossroad have not found\n&quot;);
    return;
  }

  vector_map_init = true;  // loaded flag
  for (const auto &amp;cross_road : crossroads)
  {
    Area area = g_vmap.findByKey(Key&lt;Area&gt;(cross_road.aid));
    CrossRoadArea carea;
    carea.id = _index++;
    carea.area_id = area.aid;

    double x_avg = 0.0, x_min = 0.0, x_max = 0.0;
    double y_avg = 0.0, y_min = 0.0, y_max = 0.0;
    double z = 0.0;
    int points_count = 0;

    std::vector&lt;Line&gt; lines =
        g_vmap.findByFilter([&amp;area](const Line &amp;line) { return area.slid &lt;= line.lid &amp;&amp; line.lid &lt;= area.elid; });
    for (const auto &amp;line : lines)
    {
      geometry_msgs::Point _prev_point;
      std::vector&lt;Point&gt; points =
          g_vmap.findByFilter([&amp;line](const Point &amp;point) { return line.bpid == point.pid || point.pid == line.fpid; });
      for (const auto &amp;point : points)
      {
        geometry_msgs::Point _point;
        _point.x = point.ly;
        _point.y = point.bx;
        _point.z = point.h;

        if (_prev_point.x == _point.x &amp;&amp; _prev_point.y == _point.y)
          continue;

        _prev_point = _point;
        points_count++;
        carea.points.push_back(_point);

        // calc a centroid point and about intersects size
        x_avg += _point.x;
        y_avg += _point.y;
        x_min = (x_min == 0.0) ? _point.x : std::min(_point.x, x_min);
        x_max = (x_max == 0.0) ? _point.x : std::max(_point.x, x_max);
        y_min = (y_min == 0.0) ? _point.y : std::min(_point.y, y_min);
        y_max = (y_max == 0.0) ? _point.y : std::max(_point.y, y_max);
        z = _point.z;

      }  // points iter
    }    // line iter
    carea.bbox.pose.position.x = x_avg / (double)points_count;
    carea.bbox.pose.position.y = y_avg / (double)points_count;
    carea.bbox.pose.position.z = z;
    carea.bbox.dimensions.x = x_max - x_min;
    carea.bbox.dimensions.y = y_max - y_min;
    carea.bbox.dimensions.z = 2;
    carea.bbox.label = 1;
    intersects.push_back(carea);
  }
}
}
</old_file>
			</file>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -60,6 +60,7 @@ void DecisionMakerNode::setupStateCallback(void)
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                          [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
 
+
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
@@ -75,7 +76,7 @@ void DecisionMakerNode::publishLightColor(int status)
 {
   autoware_msgs::traffic_light msg;
   msg.traffic_light = status;
-  //Pubs[&quot;light_color&quot;].publish(msg);
+  Pubs[&quot;light_color&quot;].publish(msg);
 }
 
 #define SHIFTED_LANE_FLAG -99999
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;decision_maker_node.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::setupStateCallback(void)
{
  // steering state. these state's update function change lamp
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));

  // temporary stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));

  // stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));

  // speed keep(original speed) state
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));

  // crawl
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_CRAWL_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 0));

  // acceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));

  // deceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));

  // obstacle avoidance
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));

  // trraficlight
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE); });
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });

  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));

  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
}

void DecisionMakerNode::publishLightColor(int status)
{
  autoware_msgs::traffic_light msg;
  msg.traffic_light = status;
  //Pubs[&quot;light_color&quot;].publish(msg);
}

#define SHIFTED_LANE_FLAG -99999
void DecisionMakerNode::createShiftLane(void)
{
  bool isRightShift = param_shift_width_ &gt;= 0;

  autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
  if (!current_shifted_lane_array_.lanes.empty())
  {
    size_t lane_idx = 0;
    for (auto &amp;lane : shift_lanes.lanes)
    {
      lane.increment = SHIFTED_LANE_FLAG;
      size_t wp_idx = 0;
      for (auto &amp;wp : lane.waypoints)
      {
        double angle = getPoseAngle(wp.pose.pose);
        wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
        wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
        wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
      }
      lane_idx++;
    }
  }
  int insert_lane_idx_offset = isRightShift ? 1 : 0;
  auto it_shift = begin(shift_lanes.lanes);
  try
  {
    for (auto it = begin(current_shifted_lane_array_.lanes);
         it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
    {
      for (auto &amp;wp : it-&gt;waypoints)
      {
        wp.change_flag = isRightShift ? 1 : 2;
      }
      it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
      it++;
      if (!isRightShift)
        it++;
    }
  }
  catch (std::length_error)
  {
  }
}

void DecisionMakerNode::changeShiftLane(void)
{
  auto based_it = begin(current_shifted_lane_array_.lanes);

  for (auto &amp;lane : current_shifted_lane_array_.lanes)
  {
    if (lane.increment == SHIFTED_LANE_FLAG)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = param_shift_width_ &gt;= 0 ? 2 : 1;
      }
    }
    else
    {
      auto based_wp_it = begin(based_it++-&gt;waypoints);
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = based_wp_it++-&gt;change_flag;
      }
    }
  }
}

void DecisionMakerNode::removeShiftLane(void)
{
  current_shifted_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::updateLaneWaypointsArray(void)
{
  current_stopped_lane_array_ = current_controlled_lane_array_;

  for (auto &amp;lane : current_stopped_lane_array_.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      wp.twist.twist.linear.x = 0.0;
      wp.wpstate.stopline_state = 0;
    }
  }
}

void DecisionMakerNode::publishControlledLaneArray(void)
{
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
  current_controlled_lane_array_ = current_shifted_lane_array_;
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
  if (dir != 0)
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      autoware_msgs::lane temp_lane = lane;
      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
      {
        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
        double _rate = 0.2;                       // accelerated/decelerated rate
        double _weight = distance * _rate * dir;  //
        lane.waypoints.at(wpi).twist.twist.linear.x =
            lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
      }
    }
  }
  else
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.twist.twist.linear.x = amathutils::kmph2mps(param_crawl_velocity_);
      }
    }
  }
}

void DecisionMakerNode::callbackInStateKeep(int status)
{
  changeVelocityBasedLane();
  publishControlledLaneArray();
}

void DecisionMakerNode::callbackInStateAcc(int status)
{
  changeVelocityLane(status);
  publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
  static bool timerflag;
  static ros::Timer stopping_timer;
  if (status)
  {
    if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
    {
      stopping_timer = nh_.createTimer(ros::Duration(1),
                                       [&amp;](const ros::TimerEvent &amp;) {
                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
                                         ROS_INFO(&quot;Change state to [KEEP] from [STOP]\n&quot;);
                                         timerflag = false;
                                       },
                                       this, true);
      timerflag = true;
    }
  }
}

void DecisionMakerNode::updateStateObstacleAvoid(int status)
{
}

void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
{
  changeShiftLane();
  changeVelocityBasedLane();
  publishControlledLaneArray();
  ros::Rate loop_rate(1);
  // wait for the start of lane change to the original lane
  if (created_shift_lane_flag_)
  {
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
             !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
    // wait for the end of lane change
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
             ros::ok());
    removeShiftLane();
    created_shift_lane_flag_ = false;
  }
  changeVelocityBasedLane();  // rebased controlled lane
  publishControlledLaneArray();
return;
}

void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
{
  // this state is temporary implementation.
  // It means this state is desirable to use a way which enables the avoidance plannner such as astar, state lattice.

  // if car shoud stop before avoidance,
  if (!created_shift_lane_flag_)
  {
    created_shift_lane_flag_ = true;
    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
    createShiftLane();
  }

  changeVelocityBasedLane();
}
void DecisionMakerNode::callbackInStateStop(int status)
{
  publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch (status)
  {
    case LAMP_LEFT:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_OFF;
      break;
    case LAMP_RIGHT:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_HAZARD:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_EMPTY:
    default:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_OFF;
      break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="8c02a6e90c9e0c661d1e0bbd0cfcec527ab45d9d" fix_time="0,449">
		<msg>fix a state num name</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -36,8 +36,8 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
   if (!ctx-&gt;isCurrentState(_state_num))
   {
     _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
-		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
+    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHTRED_STATE 
+		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = true;
     }
   }
@@ -45,7 +45,7 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
   {
     _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
     if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
-		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
+		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = false;
   }
   ctx-&gt;setEnableForceSetState(false);
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  if (!ctx-&gt;isCurrentState(_state_num))
  {
    _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
	    isManualLight = true;
    }
  }
  else
  {
    _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFIC_LIGHT_GREEN_STATE){
	    isManualLight = false;
  }
  ctx-&gt;setEnableForceSetState(false);


  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request: %llx&quot;, 1ULL &lt;&lt; (uint64_t)msg.data);
  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);

  param_target_waypoint_ = msg.target_waypoint;
  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
  param_shift_width_ = msg.shift_width;
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{    
  const autoware_msgs::traffic_light *light = event.getMessage().get();
//  const ros::M_string &amp;header = event.getConnectionHeader();
//  std::string topic = header.at(&quot;topic&quot;); 
  
  if(!isManualLight){// &amp;&amp; topic.find(&quot;manage&quot;) == std::string::npos){
	  current_traffic_light_ = light-&gt;traffic_light;
	  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
	  {
		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
	  }
	  else
	  {
		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
	  }
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
          }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;wp_lane : laneinArea.waypoints)
        for (auto &amp;lane : lane_array.lanes)
          for (auto &amp;wp : lane.waypoints)
            if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
            {
              wp.wpstate.steering_state = steering_state;
            }
    }
  }
  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);
  });

  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
            // lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  int gid = 0;
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int lid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
                   param_stopline_target_waypoint_ :
                   current_finalwaypoints_.waypoints.size() - 1;
  
  if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
  // steering
  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
            param_target_waypoint_ :
            current_finalwaypoints_.waypoints.size() - 1;
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
  }
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
  }
  else
  {
	  ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
  }

  // for publish plan of velocity
  publishToVelocityArray();
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg)
{
  closest_waypoint_ = msg.data;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="2f542e4f87ebabc3950b80e56c94aa95751dc4c0" fix_time="0,51">
		<msg>fix a state num name</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -36,7 +36,7 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
   if (!ctx-&gt;isCurrentState(_state_num))
   {
     _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
-    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHTRED_STATE 
+    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
 		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = true;
     }
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  if (!ctx-&gt;isCurrentState(_state_num))
  {
    _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHTRED_STATE 
		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
	    isManualLight = true;
    }
  }
  else
  {
    _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
	    isManualLight = false;
  }
  ctx-&gt;setEnableForceSetState(false);


  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request: %llx&quot;, 1ULL &lt;&lt; (uint64_t)msg.data);
  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);

  param_target_waypoint_ = msg.target_waypoint;
  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
  param_shift_width_ = msg.shift_width;
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{    
  const autoware_msgs::traffic_light *light = event.getMessage().get();
//  const ros::M_string &amp;header = event.getConnectionHeader();
//  std::string topic = header.at(&quot;topic&quot;); 
  
  if(!isManualLight){// &amp;&amp; topic.find(&quot;manage&quot;) == std::string::npos){
	  current_traffic_light_ = light-&gt;traffic_light;
	  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
	  {
		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
	  }
	  else
	  {
		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
	  }
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
          }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;wp_lane : laneinArea.waypoints)
        for (auto &amp;lane : lane_array.lanes)
          for (auto &amp;wp : lane.waypoints)
            if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
            {
              wp.wpstate.steering_state = steering_state;
            }
    }
  }
  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);
  });

  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
            // lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  int gid = 0;
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int lid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
                   param_stopline_target_waypoint_ :
                   current_finalwaypoints_.waypoints.size() - 1;
  
  if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
  // steering
  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
            param_target_waypoint_ :
            current_finalwaypoints_.waypoints.size() - 1;
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
  }
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
  }
  else
  {
	  ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
  }

  // for publish plan of velocity
  publishToVelocityArray();
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg)
{
  closest_waypoint_ = msg.data;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="b0ed94357601dcc06e14a43cb8f17b9d51dc84db" fix_time="0,0">
		<msg>fix a build bug</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -40,6 +40,7 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
 		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = true;
     }
+    }
   }
   else
   {
@@ -47,6 +48,7 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
     if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
 		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = false;
+    }
   }
   ctx-&gt;setEnableForceSetState(false);
 
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  if (!ctx-&gt;isCurrentState(_state_num))
  {
    _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
	    isManualLight = true;
    }
  }
  else
  {
    _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
	    isManualLight = false;
  }
  ctx-&gt;setEnableForceSetState(false);


  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request: %llx&quot;, 1ULL &lt;&lt; (uint64_t)msg.data);
  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);

  param_target_waypoint_ = msg.target_waypoint;
  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
  param_shift_width_ = msg.shift_width;
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{    
  const autoware_msgs::traffic_light *light = event.getMessage().get();
//  const ros::M_string &amp;header = event.getConnectionHeader();
//  std::string topic = header.at(&quot;topic&quot;); 
  
  if(!isManualLight){// &amp;&amp; topic.find(&quot;manage&quot;) == std::string::npos){
	  current_traffic_light_ = light-&gt;traffic_light;
	  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
	  {
		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
	  }
	  else
	  {
		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
	  }
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
          }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;wp_lane : laneinArea.waypoints)
        for (auto &amp;lane : lane_array.lanes)
          for (auto &amp;wp : lane.waypoints)
            if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
            {
              wp.wpstate.steering_state = steering_state;
            }
    }
  }
  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);
  });

  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
            // lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  int gid = 0;
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int lid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
                   param_stopline_target_waypoint_ :
                   current_finalwaypoints_.waypoints.size() - 1;
  
  if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
  // steering
  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
            param_target_waypoint_ :
            current_finalwaypoints_.waypoints.size() - 1;
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
  }
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
  }
  else
  {
	  ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
  }

  // for publish plan of velocity
  publishToVelocityArray();
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg)
{
  closest_waypoint_ = msg.data;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="7193d8e883e95a16e6a27a89b0f87a676fbfdb12" fix_time="8,80268">
		<msg>fix a build bug</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_callback.cpp">
				<diff>@@ -40,7 +40,6 @@ bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
 		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
 	    isManualLight = true;
     }
-    }
   }
   else
   {
</diff>
				<old_file>#include &lt;stdio.h&gt;
#include &lt;cmath&gt;

#include &lt;geometry_msgs/PoseStamped.h&gt;
#include &lt;jsk_rviz_plugins/OverlayText.h&gt;
#include &lt;ros/ros.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;std_msgs/UInt8.h&gt;

#include &lt;autoware_msgs/lane.h&gt;
#include &lt;autoware_msgs/traffic_light.h&gt;

#include &lt;cross_road_area.hpp&gt;
#include &lt;decision_maker_node.hpp&gt;
#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::callbackFromCurrentPose(const geometry_msgs::PoseStamped &amp;msg)
{
  geometry_msgs::PoseStamped _pose = current_pose_ = msg;
  bool initLocalizationFlag = ctx-&gt;isCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE);
  if (initLocalizationFlag &amp;&amp;
      isLocalizationConvergence(_pose.pose.position.x, _pose.pose.position.y, _pose.pose.position.z,
                                _pose.pose.orientation.x, _pose.pose.orientation.y, _pose.pose.orientation.z))
  {
    ROS_INFO(&quot;Localization was convergence&quot;);
  }
}

bool DecisionMakerNode::handleStateCmd(const uint64_t _state_num)
{
  bool _ret;
  ctx-&gt;setEnableForceSetState(true);
  if (!ctx-&gt;isCurrentState(_state_num))
  {
    _ret = ctx-&gt;setCurrentState((state_machine::StateFlags)_state_num);
    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
	    isManualLight = true;
    }
    }
  }
  else
  {
    _ret = ctx-&gt;disableCurrentState((state_machine::StateFlags)_state_num);
    if(_state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE 
		    || _state_num == state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE){
	    isManualLight = false;
    }
  }
  ctx-&gt;setEnableForceSetState(false);


  return _ret;
}

void DecisionMakerNode::callbackFromSimPose(const geometry_msgs::PoseStamped &amp;msg)
{
  ROS_INFO(&quot;Received system is going to simulation mode&quot;);
  handleStateCmd(state_machine::DRIVE_STATE);
  Subs[&quot;sim_pose&quot;].shutdown();
}

void DecisionMakerNode::callbackFromStateCmd(const std_msgs::Int32 &amp;msg)
{
  ROS_INFO(&quot;Received forcing state changing request: %llx&quot;, 1ULL &lt;&lt; (uint64_t)msg.data);
  handleStateCmd((uint64_t)1ULL &lt;&lt; (uint64_t)msg.data);
}

void DecisionMakerNode::callbackFromLaneChangeFlag(const std_msgs::Int32 &amp;msg)
{
  if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::LEFT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
  else if (msg.data == enumToInteger&lt;E_ChangeFlags&gt;(E_ChangeFlags::RIGHT))
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
    ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
  }
  else
  {
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE);
    ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE);
  }
}

void DecisionMakerNode::callbackFromConfig(const autoware_msgs::ConfigDecisionMaker &amp;msg)
{
  ROS_INFO(&quot;Param setted by Runtime Manager&quot;);
  enableDisplayMarker = msg.enable_display_marker;
  ctx-&gt;setEnableForceSetState(msg.enable_force_state_change);

  param_target_waypoint_ = msg.target_waypoint;
  param_stopline_target_waypoint_ = msg.stopline_target_waypoint;
  param_shift_width_ = msg.shift_width;
}

void DecisionMakerNode::callbackFromLightColor(const ros::MessageEvent&lt;autoware_msgs::traffic_light const&gt; &amp;event)
{    
  const autoware_msgs::traffic_light *light = event.getMessage().get();
//  const ros::M_string &amp;header = event.getConnectionHeader();
//  std::string topic = header.at(&quot;topic&quot;); 
  
  if(!isManualLight){// &amp;&amp; topic.find(&quot;manage&quot;) == std::string::npos){
	  current_traffic_light_ = light-&gt;traffic_light;
	  if (current_traffic_light_ == state_machine::E_RED || current_traffic_light_ == state_machine::E_YELLOW)
	  {
		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
	  }
	  else
	  {
		  ctx-&gt;setCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
	  }
  }
}

void DecisionMakerNode::callbackFromPointsRaw(const sensor_msgs::PointCloud2::ConstPtr &amp;msg)
{
  if (ctx-&gt;setCurrentState(state_machine::INITIAL_LOCATEVEHICLE_STATE))
    Subs[&quot;points_raw&quot;].shutdown();
}

void DecisionMakerNode::insertPointWithinCrossRoad(const std::vector&lt;CrossRoadArea&gt; &amp;_intersects,
                                                   autoware_msgs::LaneArray &amp;lane_array)
{
  for (auto &amp;lane : lane_array.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      geometry_msgs::Point pp;
      pp.x = wp.pose.pose.position.x;
      pp.y = wp.pose.pose.position.y;
      pp.z = wp.pose.pose.position.z;

      for (auto &amp;area : intersects)
      {
        if (CrossRoadArea::isInsideArea(&amp;area, pp))
        {
          // area's
          if (area.insideLanes.empty() || wp.gid != area.insideLanes.back().waypoints.back().gid + 1)
          {
            autoware_msgs::lane nlane;
            area.insideLanes.push_back(nlane);
          }
          area.insideLanes.back().waypoints.push_back(wp);
          area.insideWaypoint_points.push_back(pp);  // geometry_msgs::point
          // area.insideLanes.Waypoints.push_back(wp);//autoware_msgs::waypoint
          // lane's wp
          wp.wpstate.aid = area.area_id;
        }
      }
    }
  }
}

geometry_msgs::Point to_geoPoint(const vector_map_msgs::Point &amp;vp)
{
  geometry_msgs::Point gp;
  gp.x = vp.ly;
  gp.y = vp.bx;
  gp.z = vp.h;
  return gp;
}

void DecisionMakerNode::setWaypointState(autoware_msgs::LaneArray &amp;lane_array)
{
  insertPointWithinCrossRoad(intersects, lane_array);
  // STR
  for (auto &amp;area : intersects)
  {
    for (auto &amp;laneinArea : area.insideLanes)
    {
      // To straight/left/right recognition by using angle
      // between first-waypoint and end-waypoint in intersection area.
      int angle_deg = ((int)std::floor(calcIntersectWayAngle(laneinArea)));  // normalized
      int steering_state;

      if (angle_deg &lt;= ANGLE_LEFT)
        steering_state = autoware_msgs::WaypointState::STR_LEFT;
      else if (angle_deg &gt;= ANGLE_RIGHT)
        steering_state = autoware_msgs::WaypointState::STR_RIGHT;
      else
        steering_state = autoware_msgs::WaypointState::STR_STRAIGHT;

      for (auto &amp;wp_lane : laneinArea.waypoints)
        for (auto &amp;lane : lane_array.lanes)
          for (auto &amp;wp : lane.waypoints)
            if (wp.gid == wp_lane.gid &amp;&amp; wp.wpstate.aid == area.area_id)
            {
              wp.wpstate.steering_state = steering_state;
            }
    }
  }
  // STOP
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return (g_vmap.findByKey(Key&lt;RoadSign&gt;(stopline.signid)).type == (int)vector_map_msgs::RoadSign::TYPE_STOP);
  });

  for (auto &amp;lane : lane_array.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
            // lane.waypoints.at(wp_idx + 1).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

// for based waypoint
void DecisionMakerNode::callbackFromLaneWaypoint(const autoware_msgs::LaneArray &amp;msg)
{
  ROS_INFO(&quot;[%s]:LoadedWaypointLaneArray\n&quot;, __func__);
  current_based_lane_array_ = msg;  // cached based path
  // indexing
  int gid = 0;
  for (auto &amp;lane : current_based_lane_array_.lanes)
  {
    int lid = 0;
    for (auto &amp;wp : lane.waypoints)
    {
      wp.gid = gid++;
      wp.lid = lid++;
      wp.wpstate.aid = 0;
      wp.wpstate.steering_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.accel_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.stopline_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.lanechange_state = autoware_msgs::WaypointState::NULLSTATE;
      wp.wpstate.event_state = 0;
    }
  }
  setWaypointState(current_based_lane_array_);
  current_controlled_lane_array_ = current_shifted_lane_array_ = current_based_lane_array_;  // controlled path

  publishControlledLaneArray();
  updateLaneWaypointsArray();
}

state_machine::StateFlags getStateFlags(uint8_t msg_state)
{
  if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_LEFT)
    return state_machine::DRIVE_STR_LEFT_STATE;
  else if (msg_state == (uint8_t)autoware_msgs::WaypointState::STR_RIGHT)
    return state_machine::DRIVE_STR_RIGHT_STATE;
  else
    return state_machine::DRIVE_STR_STRAIGHT_STATE;
}

void DecisionMakerNode::callbackFromFinalWaypoint(const autoware_msgs::lane &amp;msg)
{
  if (!hasvMap())
  {
    std::cerr &lt;&lt; &quot;Not found vmap subscribe&quot; &lt;&lt; std::endl;
    return;
  }

  if (!ctx-&gt;isCurrentState(state_machine::DRIVE_STATE))
  {
    std::cerr &lt;&lt; &quot;State is not DRIVE_STATE[&quot; &lt;&lt; ctx-&gt;getCurrentStateName() &lt;&lt; &quot;]&quot; &lt;&lt; std::endl;
    return;
  }
  // cached
  current_finalwaypoints_ = msg;

  size_t idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_stopline_target_waypoint_ ?
                   param_stopline_target_waypoint_ :
                   current_finalwaypoints_.waypoints.size() - 1;
  
  if (current_finalwaypoints_.waypoints.at(idx).wpstate.stopline_state)
	  ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
  // steering
  idx = current_finalwaypoints_.waypoints.size() - 1 &gt; param_target_waypoint_ ?
            param_target_waypoint_ :
            current_finalwaypoints_.waypoints.size() - 1;
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_LEFT_STATE);
  }
  if (ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE))
  {
	  ctx-&gt;setCurrentState(state_machine::DRIVE_STR_RIGHT_STATE);
  }
  else
  {
	  ctx-&gt;setCurrentState(getStateFlags(current_finalwaypoints_.waypoints.at(idx).wpstate.steering_state));
  }

  // for publish plan of velocity
  publishToVelocityArray();
}
void DecisionMakerNode::callbackFromTwistCmd(const geometry_msgs::TwistStamped &amp;msg)
{
  static bool Twistflag = false;

  if (Twistflag)
    ctx-&gt;handleTwistCmd(false);
  else
    Twistflag = true;
}

void DecisionMakerNode::callbackFromClosestWaypoint(const std_msgs::Int32 &amp;msg)
{
  closest_waypoint_ = msg.data;
}

void DecisionMakerNode::callbackFromVectorMapArea(const vector_map_msgs::AreaArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapPoint(const vector_map_msgs::PointArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapLine(const vector_map_msgs::LineArray &amp;msg)
{
  initVectorMap();
}
void DecisionMakerNode::callbackFromVectorMapCrossRoad(const vector_map_msgs::CrossRoadArray &amp;msg)
{
  initVectorMap();
}

void DecisionMakerNode::callbackFromCurrentVelocity(const geometry_msgs::TwistStamped &amp;msg)
{
  current_velocity_ = amathutils::mps2kmph(msg.twist.linear.x);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="92d8c5491276b9be65ac480f53c535be49452bd3" fix_time="0,2356">
		<msg>fix a judge intersect stopline</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -192,7 +192,7 @@ void DecisionMakerNode::setAllStoplineStop(void){
     return true;
   });
 
-  for (auto &amp;lane : current_controlled_lane_array_.lanes)
+  for (auto &amp;lane : current_shifted_lane_array_.lanes)
   {
     for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
     {
@@ -216,7 +216,14 @@ void DecisionMakerNode::setAllStoplineStop(void){
                   lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                   lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
           {
-            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
+		  amathutils::point *a = new amathutils::point();
+		  amathutils::point *b = new amathutils::point();
+		  a-&gt;x = center_point.x;
+		  a-&gt;y = center_point.y;
+		  b-&gt;x = lane.waypoints.at(wp_idx).pose.pose.position.x;
+		  b-&gt;y = lane.waypoints.at(wp_idx).pose.pose.position.y;
+		  if(amathutils::find_distance(a,b) &lt;= 4)//
+			  lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
           }
         }
       }
@@ -226,9 +233,13 @@ void DecisionMakerNode::setAllStoplineStop(void){
 
 void DecisionMakerNode::StoplinePlanIn(int status){
 	setAllStoplineStop();
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
 }
 void DecisionMakerNode::StoplinePlanOut(int status){
-	current_controlled_lane_array_ = current_based_lane_array_;
+	current_shifted_lane_array_ = current_based_lane_array_;
+	changeVelocityBasedLane();
+	publishControlledLaneArray();
 }
 
 void DecisionMakerNode::changeVelocityLane(int dir)
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;decision_maker_node.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::setupStateCallback(void)
{
  // steering state. these state's update function change lamp
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));

  // temporary stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));

  // stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));

  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE,
                         std::bind(&amp;DecisionMakerNode::StoplinePlanIn, this, 1));
  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE,
                         std::bind(&amp;DecisionMakerNode::StoplinePlanOut, this, 1));
  // speed keep(original speed) state
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));

  // crawl
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_CRAWL_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 0));

  // acceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));

  // deceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));

  // obstacle avoidance
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));

  // trraficlight
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE); });
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });


  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));

  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
}

void DecisionMakerNode::publishLightColor(int status)
{
  autoware_msgs::traffic_light msg;
  msg.traffic_light = status;
  Pubs[&quot;light_color&quot;].publish(msg);
}

#define SHIFTED_LANE_FLAG -99999
void DecisionMakerNode::createShiftLane(void)
{
  bool isRightShift = param_shift_width_ &gt;= 0;

  autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
  if (!current_shifted_lane_array_.lanes.empty())
  {
    size_t lane_idx = 0;
    for (auto &amp;lane : shift_lanes.lanes)
    {
      lane.increment = SHIFTED_LANE_FLAG;
      size_t wp_idx = 0;
      for (auto &amp;wp : lane.waypoints)
      {
        double angle = getPoseAngle(wp.pose.pose);
        wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
        wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
        wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
      }
      lane_idx++;
    }
  }
  int insert_lane_idx_offset = isRightShift ? 1 : 0;
  auto it_shift = begin(shift_lanes.lanes);
  try
  {
    for (auto it = begin(current_shifted_lane_array_.lanes);
         it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
    {
      for (auto &amp;wp : it-&gt;waypoints)
      {
        wp.change_flag = isRightShift ? 1 : 2;
      }
      it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
      it++;
      if (!isRightShift)
        it++;
    }
  }
  catch (std::length_error)
  {
  }
}

void DecisionMakerNode::changeShiftLane(void)
{
  auto based_it = begin(current_shifted_lane_array_.lanes);

  for (auto &amp;lane : current_shifted_lane_array_.lanes)
  {
    if (lane.increment == SHIFTED_LANE_FLAG)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = param_shift_width_ &gt;= 0 ? 2 : 1;
      }
    }
    else
    {
      auto based_wp_it = begin(based_it++-&gt;waypoints);
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = based_wp_it++-&gt;change_flag;
      }
    }
  }
}

void DecisionMakerNode::removeShiftLane(void)
{
  current_shifted_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::updateLaneWaypointsArray(void)
{
  current_stopped_lane_array_ = current_controlled_lane_array_;

  for (auto &amp;lane : current_stopped_lane_array_.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      wp.twist.twist.linear.x = 0.0;
      wp.wpstate.stopline_state = 0;
    }
  }
}

void DecisionMakerNode::publishControlledLaneArray(void)
{
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
  current_controlled_lane_array_ = current_shifted_lane_array_;
}

void DecisionMakerNode::setAllStoplineStop(void){
  
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return true;
  });

  for (auto &amp;lane : current_controlled_lane_array_.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
            lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

void DecisionMakerNode::StoplinePlanIn(int status){
	setAllStoplineStop();
}
void DecisionMakerNode::StoplinePlanOut(int status){
	current_controlled_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
  if (dir != 0)
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      autoware_msgs::lane temp_lane = lane;
      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
      {
        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
        double _rate = 0.2;                       // accelerated/decelerated rate
        double _weight = distance * _rate * dir;  //
        lane.waypoints.at(wpi).twist.twist.linear.x =
            lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
      }
    }
  }
  else
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.twist.twist.linear.x = amathutils::kmph2mps(param_crawl_velocity_);
      }
    }
  }
}

void DecisionMakerNode::callbackInStateKeep(int status)
{
  changeVelocityBasedLane();
  publishControlledLaneArray();
}

void DecisionMakerNode::callbackInStateAcc(int status)
{
  changeVelocityLane(status);
  publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
  static bool timerflag;
  static ros::Timer stopping_timer;
  if (status)
  {
    if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
    {
      stopping_timer = nh_.createTimer(ros::Duration(1),
                                       [&amp;](const ros::TimerEvent &amp;) {
                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
                                         ROS_INFO(&quot;Change state to [KEEP] from [STOP]\n&quot;);
                                         timerflag = false;
                                       },
                                       this, true);
      timerflag = true;
    }
  }
}

void DecisionMakerNode::updateStateObstacleAvoid(int status)
{
}

void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
{
  changeShiftLane();
  changeVelocityBasedLane();
  publishControlledLaneArray();
  ros::Rate loop_rate(1);
  // wait for the start of lane change to the original lane
  if (created_shift_lane_flag_)
  {
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
             !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
    // wait for the end of lane change
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
             ros::ok());
    removeShiftLane();
    created_shift_lane_flag_ = false;
  }
  changeVelocityBasedLane();  // rebased controlled lane
  publishControlledLaneArray();
return;
}

void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
{
  // this state is temporary implementation.
  // It means this state is desirable to use a way which enables the avoidance plannner such as astar, state lattice.

  // if car shoud stop before avoidance,
  if (!created_shift_lane_flag_)
  {
    created_shift_lane_flag_ = true;
    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
    createShiftLane();
  }

  changeVelocityBasedLane();
}
void DecisionMakerNode::callbackInStateStop(int status)
{
  publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch (status)
  {
    case LAMP_LEFT:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_OFF;
      break;
    case LAMP_RIGHT:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_HAZARD:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_EMPTY:
    default:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_OFF;
      break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="961c3c4312ea775fa97ee6208cb7cf0fc18cef9e" fix_time="0,1105">
		<msg>fix a duplicate state update</msg>
		<modified_files>
			<file old_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp" new_path="ros/src/computing/planning/decision/packages/decision_maker/nodes/decision_maker/decision_maker_node_stateupdate.cpp">
				<diff>@@ -60,22 +60,29 @@ void DecisionMakerNode::setupStateCallback(void)
 
   // trraficlight
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
-                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
-			 publishLightColor((int)state_machine::E_GREEN); });
+                         [&amp;]() { 
+			 //debug
+			 fprintf(stderr,&quot;[RED]callbackin\n&quot;);
+			 //
+			 ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
+			 publishLightColor((int)state_machine::E_RED); });
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
-		  [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
-		  publishLightColor((int)state_machine::E_RED); });
+		  [&amp;]() { 
+		  fprintf(stderr,&quot;[GREEN]callbackin\n&quot;);
+		  ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
+		  publishLightColor((int)state_machine::E_GREEN); });
 
 #if 0
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
-#endif
   ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                          [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
   ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                              std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
+#endif
+
 }
 
 void DecisionMakerNode::publishLightColor(int status)
</diff>
				<old_file>#include &lt;ros/ros.h&gt;

#include &lt;state.hpp&gt;
#include &lt;state_context.hpp&gt;

#include &lt;autoware_msgs/lamp_cmd.h&gt;
#include &lt;decision_maker_node.hpp&gt;

namespace decision_maker
{
void DecisionMakerNode::setupStateCallback(void)
{
  // steering state. these state's update function change lamp
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_STRAIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 0));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_LEFT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 1));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_STR_RIGHT_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateSTR, this, 2));

  // temporary stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOPLINE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 1));

  // stopping state
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_ACC_STOP_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateStop, this, 0));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_STOP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateStop, this, 0));

  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE,
                         std::bind(&amp;DecisionMakerNode::StoplinePlanIn, this, 1));
  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_STOPLINE_PLAN_STATE,
                         std::bind(&amp;DecisionMakerNode::StoplinePlanOut, this, 1));
  // speed keep(original speed) state
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_KEEP_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateKeep, this, 1));

  // crawl
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_CRAWL_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 0));

  // acceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_ACCELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, 1));

  // deceleration
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_ACC_DECELERATION_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateAcc, this, -1));

  // obstacle avoidance
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                             std::bind(&amp;DecisionMakerNode::updateStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                         std::bind(&amp;DecisionMakerNode::callbackInStateObstacleAvoid, this, -1));
  ctx-&gt;setCallbackOutFunc(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE,
                          std::bind(&amp;DecisionMakerNode::callbackOutStateObstacleAvoid, this, 1));

  // trraficlight
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE);
			 publishLightColor((int)state_machine::E_GREEN); });
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
		  [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE);
		  publishLightColor((int)state_machine::E_RED); });

#if 0
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_RED));
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
#endif
  ctx-&gt;setCallbackInFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                         [&amp;]() { ctx-&gt;disableCurrentState(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_RED_STATE); });
  ctx-&gt;setCallbackUpdateFunc(state_machine::DRIVE_BEHAVIOR_TRAFFICLIGHT_GREEN_STATE,
                             std::bind(&amp;DecisionMakerNode::publishLightColor, this, (int)state_machine::E_GREEN));
}

void DecisionMakerNode::publishLightColor(int status)
{
  autoware_msgs::traffic_light msg;
  msg.traffic_light = status;
  Pubs[&quot;light_color&quot;].publish(msg);
}

#define SHIFTED_LANE_FLAG -99999
void DecisionMakerNode::createShiftLane(void)
{
  bool isRightShift = param_shift_width_ &gt;= 0;

  autoware_msgs::LaneArray shift_lanes = current_shifted_lane_array_ = current_based_lane_array_;
  if (!current_shifted_lane_array_.lanes.empty())
  {
    size_t lane_idx = 0;
    for (auto &amp;lane : shift_lanes.lanes)
    {
      lane.increment = SHIFTED_LANE_FLAG;
      size_t wp_idx = 0;
      for (auto &amp;wp : lane.waypoints)
      {
        double angle = getPoseAngle(wp.pose.pose);
        wp.pose.pose.position.x -= param_shift_width_ * cos(angle + M_PI / 2);
        wp.pose.pose.position.y -= param_shift_width_ * sin(angle + M_PI / 2);
        wp.change_flag = current_based_lane_array_.lanes.at(lane_idx).waypoints.at(wp_idx++).change_flag;
      }
      lane_idx++;
    }
  }
  int insert_lane_idx_offset = isRightShift ? 1 : 0;
  auto it_shift = begin(shift_lanes.lanes);
  try
  {
    for (auto it = begin(current_shifted_lane_array_.lanes);
         it != end(current_shifted_lane_array_.lanes) &amp;&amp; it_shift != end(shift_lanes.lanes);)
    {
      for (auto &amp;wp : it-&gt;waypoints)
      {
        wp.change_flag = isRightShift ? 1 : 2;
      }
      it = current_shifted_lane_array_.lanes.insert(it + insert_lane_idx_offset, *(it_shift++));
      it++;
      if (!isRightShift)
        it++;
    }
  }
  catch (std::length_error)
  {
  }
}

void DecisionMakerNode::changeShiftLane(void)
{
  auto based_it = begin(current_shifted_lane_array_.lanes);

  for (auto &amp;lane : current_shifted_lane_array_.lanes)
  {
    if (lane.increment == SHIFTED_LANE_FLAG)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = param_shift_width_ &gt;= 0 ? 2 : 1;
      }
    }
    else
    {
      auto based_wp_it = begin(based_it++-&gt;waypoints);
      for (auto &amp;wp : lane.waypoints)
      {
        wp.change_flag = based_wp_it++-&gt;change_flag;
      }
    }
  }
}

void DecisionMakerNode::removeShiftLane(void)
{
  current_shifted_lane_array_ = current_based_lane_array_;
}

void DecisionMakerNode::updateLaneWaypointsArray(void)
{
  current_stopped_lane_array_ = current_controlled_lane_array_;

  for (auto &amp;lane : current_stopped_lane_array_.lanes)
  {
    for (auto &amp;wp : lane.waypoints)
    {
      wp.twist.twist.linear.x = 0.0;
      wp.wpstate.stopline_state = 0;
    }
  }
}

void DecisionMakerNode::publishControlledLaneArray(void)
{
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_controlled_lane_array_);
}
void DecisionMakerNode::publishStoppedLaneArray(void)
{
  updateLaneWaypointsArray();
  Pubs[&quot;lane_waypoints_array&quot;].publish(current_stopped_lane_array_);
}

void DecisionMakerNode::changeVelocityBasedLane(void)
{
  current_controlled_lane_array_ = current_shifted_lane_array_;
}

void DecisionMakerNode::setAllStoplineStop(void){
  
  std::vector&lt;StopLine&gt; stoplines = g_vmap.findByFilter([&amp;](const StopLine &amp;stopline) {
    return true;
  });

  for (auto &amp;lane : current_shifted_lane_array_.lanes)
  {
    for (size_t wp_idx = 0; wp_idx &lt; lane.waypoints.size() - 1; wp_idx++)
    {
      for (auto &amp;stopline : stoplines)
      {
        geometry_msgs::Point bp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).bpid)));
        geometry_msgs::Point fp =
            to_geoPoint(g_vmap.findByKey(Key&lt;Point&gt;(g_vmap.findByKey(Key&lt;Line&gt;(stopline.lid)).fpid)));

        if (amathutils::isIntersectLine(lane.waypoints.at(wp_idx).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx).pose.pose.position.y,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                                        lane.waypoints.at(wp_idx + 1).pose.pose.position.y, bp.x, bp.y, fp.x, fp.y))
        {
          geometry_msgs::Point center_point;
          center_point.x = (bp.x * 2 + fp.x) / 3;
          center_point.y = (bp.y * 2 + fp.y) / 3;
          if (amathutils::isPointLeftFromLine(
                  center_point.x, center_point.y, lane.waypoints.at(wp_idx).pose.pose.position.x,
                  lane.waypoints.at(wp_idx).pose.pose.position.y, lane.waypoints.at(wp_idx + 1).pose.pose.position.x,
                  lane.waypoints.at(wp_idx + 1).pose.pose.position.y))
          {
		  amathutils::point *a = new amathutils::point();
		  amathutils::point *b = new amathutils::point();
		  a-&gt;x = center_point.x;
		  a-&gt;y = center_point.y;
		  b-&gt;x = lane.waypoints.at(wp_idx).pose.pose.position.x;
		  b-&gt;y = lane.waypoints.at(wp_idx).pose.pose.position.y;
		  if(amathutils::find_distance(a,b) &lt;= 4)//
			  lane.waypoints.at(wp_idx).wpstate.stopline_state = 1;
          }
        }
      }
    }
  }
}

void DecisionMakerNode::StoplinePlanIn(int status){
	setAllStoplineStop();
	changeVelocityBasedLane();
	publishControlledLaneArray();
}
void DecisionMakerNode::StoplinePlanOut(int status){
	current_shifted_lane_array_ = current_based_lane_array_;
	changeVelocityBasedLane();
	publishControlledLaneArray();
}

void DecisionMakerNode::changeVelocityLane(int dir)
{
  if (dir != 0)
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      autoware_msgs::lane temp_lane = lane;
      for (size_t wpi = 1; wpi &lt; lane.waypoints.size(); wpi++)
      {
        amathutils::point p0(temp_lane.waypoints.at(wpi).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi).pose.pose.position.z);
        amathutils::point p1(temp_lane.waypoints.at(wpi - 1).pose.pose.position.x,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.y,
                             temp_lane.waypoints.at(wpi - 1).pose.pose.position.z);

        double distance = amathutils::find_distance(&amp;p0, &amp;p1);
        double _rate = 0.2;                       // accelerated/decelerated rate
        double _weight = distance * _rate * dir;  //
        lane.waypoints.at(wpi).twist.twist.linear.x =
            lane.waypoints.at(wpi).twist.twist.linear.x + (lane.waypoints.at(wpi).twist.twist.linear.x * _weight);
      }
    }
  }
  else
  {
    for (auto &amp;lane : current_controlled_lane_array_.lanes)
    {
      for (auto &amp;wp : lane.waypoints)
      {
        wp.twist.twist.linear.x = amathutils::kmph2mps(param_crawl_velocity_);
      }
    }
  }
}

void DecisionMakerNode::callbackInStateKeep(int status)
{
  changeVelocityBasedLane();
  publishControlledLaneArray();
}

void DecisionMakerNode::callbackInStateAcc(int status)
{
  changeVelocityLane(status);
  publishControlledLaneArray();
}
void DecisionMakerNode::updateStateStop(int status)
{
  static bool timerflag;
  static ros::Timer stopping_timer;
  if (status)
  {
    if (current_velocity_ == 0.0 &amp;&amp; !timerflag)
    {
      stopping_timer = nh_.createTimer(ros::Duration(1),
                                       [&amp;](const ros::TimerEvent &amp;) {
                                         ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_KEEP_STATE);
                                         ROS_INFO(&quot;Change state to [KEEP] from [STOP]\n&quot;);
                                         timerflag = false;
                                       },
                                       this, true);
      timerflag = true;
    }
  }
}

void DecisionMakerNode::updateStateObstacleAvoid(int status)
{
}

void DecisionMakerNode::callbackOutStateObstacleAvoid(int status)
{
  changeShiftLane();
  changeVelocityBasedLane();
  publishControlledLaneArray();
  ros::Rate loop_rate(1);
  // wait for the start of lane change to the original lane
  if (created_shift_lane_flag_)
  {
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while (!ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) &amp;&amp;
             !ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) &amp;&amp; ros::ok());
    // wait for the end of lane change
    do
    {
      ros::spinOnce();
      loop_rate.sleep();
    } while ((ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_LEFT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_LANECHANGE_RIGHT_STATE) ||
              ctx-&gt;isCurrentState(state_machine::DRIVE_BEHAVIOR_OBSTACLE_AVOIDANCE_STATE)) &amp;&amp;
             ros::ok());
    removeShiftLane();
    created_shift_lane_flag_ = false;
  }
  changeVelocityBasedLane();  // rebased controlled lane
  publishControlledLaneArray();
return;
}

void DecisionMakerNode::callbackInStateObstacleAvoid(int status)
{
  // this state is temporary implementation.
  // It means this state is desirable to use a way which enables the avoidance plannner such as astar, state lattice.

  // if car shoud stop before avoidance,
  if (!created_shift_lane_flag_)
  {
    created_shift_lane_flag_ = true;
    ctx-&gt;setCurrentState(state_machine::DRIVE_ACC_STOPLINE_STATE);
    createShiftLane();
  }

  changeVelocityBasedLane();
}
void DecisionMakerNode::callbackInStateStop(int status)
{
  publishStoppedLaneArray();
}

void DecisionMakerNode::updateStateSTR(int status)
{
  autoware_msgs::lamp_cmd lamp_msg;

  switch (status)
  {
    case LAMP_LEFT:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_OFF;
      break;
    case LAMP_RIGHT:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_HAZARD:
      lamp_msg.l = LAMP_ON;
      lamp_msg.r = LAMP_ON;
      break;
    case LAMP_EMPTY:
    default:
      lamp_msg.l = LAMP_OFF;
      lamp_msg.r = LAMP_OFF;
      break;
  }
  Pubs[&quot;lamp_cmd&quot;].publish(lamp_msg);
}
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="33567105bc5dda68680958874522265453351bbe" fix_time="288,33430">
		<msg>fix tf_mapping regarding number of digits of pose</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/tf_mapping/tf_mapping.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/tf_mapping/tf_mapping.cpp">
				<diff>@@ -131,11 +131,14 @@ void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;input)
 
     for (int i = 0; i &lt; (int)pcl_out.points.size(); i++)
     {
-      ofs &lt;&lt; pcl_out.points[i].x &lt;&lt; &quot;,&quot; &lt;&lt; pcl_out.points[i].y &lt;&lt; &quot;,&quot; &lt;&lt; pcl_out.points[i].z &lt;&lt; &quot;,&quot; &lt;&lt; pcl_out.points[i].intensity &lt;&lt; std::endl;
+      ofs &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; pcl_out.points[i].x &lt;&lt; &quot;,&quot;
+          &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; pcl_out.points[i].y &lt;&lt; &quot;,&quot;
+          &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; pcl_out.points[i].z &lt;&lt; &quot;,&quot;
+          &lt;&lt; pcl_out.points[i].intensity &lt;&lt; std::endl;
     }
     std::cout &lt;&lt; &quot;Wrote &quot; &lt;&lt; pcl_out.size() &lt;&lt; &quot; points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
     added_scan_num++;
-    if(added_scan_num == 50)
+    if(added_scan_num == 300)
     {
       added_scan_num = 0;
       map_id++;
</diff>
				<old_file>
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;fstream&gt;
#include &lt;string&gt;

#include &quot;ros/ros.h&quot;
#include &quot;std_msgs/String.h&quot;
#include &quot;sensor_msgs/PointCloud2.h&quot;
#include &quot;velodyne_pointcloud/point_types.h&quot;
#include &quot;velodyne_pointcloud/rawdata.h&quot;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;tf/transform_listener.h&gt;
#include &quot;tf/message_filter.h&quot;
#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_ros/transforms.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#include &lt;message_filters/subscriber.h&gt;
#include &lt;message_filters/time_synchronizer.h&gt;

static std::string PARENT_FRAME;
static std::string CHILD_FRAME;
static std::string POINTS_TOPIC;
static std::string OUTPUT_DIR;

static pcl::PointCloud&lt;velodyne_pointcloud::PointXYZIR&gt; map;
static tf::TransformListener *tf_listener;
static std::string filename;

static int added_scan_num = 0;
static int map_id = 0;
static int count = 0;

void points_callback(const pcl::PointCloud&lt;pcl::PointXYZI&gt;::ConstPtr &amp;input)
{
  count++;

  pcl::PointCloud&lt;pcl::PointXYZI&gt; pcl_out;
  pcl::PointCloud&lt;pcl::PointXYZI&gt;::Ptr transformed_input (new pcl::PointCloud&lt;pcl::PointXYZI&gt;);
  std_msgs::Header header;
  pcl_conversions::fromPCL(input-&gt;header, header);

  if(CHILD_FRAME == &quot;velodyne&quot; &amp;&amp; POINTS_TOPIC == &quot;hokuyo_3d/hokuyo_cloud2&quot;)
  {
	  /*
    tf::Vector3 v(1.7, 0, 1.5);
    tf::Quaternion q;
    q.setRPY(3.141592, 0.05, -0.05);
    tf::Transform tf_baselink_to_localizer(q, v);
    */
    tf::Vector3 v(-0.5, 0, 0.5);
    tf::Quaternion q;
    q.setRPY(3.141592, 0.05, -0.05);
    tf::Transform tf_baselink_to_localizer(q, v);
    pcl_ros::transformPointCloud(*input, *transformed_input, tf_baselink_to_localizer);
  }

  tf::StampedTransform transform;
  if(input-&gt;size() &gt; 0)
  {
    try
    {
      tf_listener-&gt;waitForTransform(PARENT_FRAME, CHILD_FRAME, header.stamp, ros::Duration(1));
      tf_listener-&gt;lookupTransform(PARENT_FRAME, CHILD_FRAME, header.stamp, transform);
    }
    catch (tf::TransformException ex)
    {
      std::cout &lt;&lt; &quot;Transform not found&quot; &lt;&lt; std::endl;
      return;
    }

//    if(CHILD_FRAME == &quot;gps&quot; &amp;&amp; POINTS_TOPIC == &quot;hokuyo_3d/hokuyo_cloud2&quot;)
      if(CHILD_FRAME == &quot;velodyne&quot; &amp;&amp; POINTS_TOPIC == &quot;hokuyo_3d/hokuyo_cloud2&quot;)
    {
      for (int i = 0; i &lt; (int)transformed_input-&gt;size(); i++)
      {
        tf::Point pt(transformed_input-&gt;points[i].x, transformed_input-&gt;points[i].y, transformed_input-&gt;points[i].z);
        tf::Point pt_world = transform * pt;
        pcl::PointXYZI wp;
        double distance = pt.x() * pt.x() + pt.y() * pt.y() + pt.z() * pt.z();
        if (distance &lt; 3 * 3)
          continue;
        wp.x = pt_world.x();
        wp.y = pt_world.y();
        wp.z = pt_world.z();
        wp.intensity = transformed_input-&gt;points[i].intensity;

        pcl_out.push_back(wp);
      }
      pcl_out.header = transformed_input-&gt;header;
    } else {
      for (int i = 0; i &lt; (int)input-&gt;size(); i++)
      {
        tf::Point pt(input-&gt;points[i].x, input-&gt;points[i].y, input-&gt;points[i].z);
        tf::Point pt_world = transform * pt;
        pcl::PointXYZI wp;
        double distance = pt.x() * pt.x() + pt.y() * pt.y() + pt.z() * pt.z();
        if (distance &lt; 3 * 3)
          continue;
        wp.x = pt_world.x();
        wp.y = pt_world.y();
        wp.z = pt_world.z();
        wp.intensity = input-&gt;points[i].intensity;

        pcl_out.push_back(wp);
      }
      pcl_out.header = input-&gt;header;
    }

    pcl_out.header.frame_id = &quot;map&quot;;

    // Set log file name.
    std::ofstream ofs;
    std::string lidar;
    if(POINTS_TOPIC == &quot;points_raw&quot;)
    {
      lidar = &quot;velodyne&quot;;
    } else if(POINTS_TOPIC == &quot;hokuyo_3d/hokuyo_cloud2&quot;){
      lidar = &quot;hokuyo&quot;;
    }
    filename = OUTPUT_DIR + PARENT_FRAME + &quot;-&quot; + CHILD_FRAME + &quot;_&quot; + lidar + &quot;_&quot;+ std::to_string(map_id) + &quot;.csv&quot;;
    ofs.open(filename.c_str(), std::ios::app);

    if (!ofs)
    {
      std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      exit(1);
    }

    for (int i = 0; i &lt; (int)pcl_out.points.size(); i++)
    {
      ofs &lt;&lt; pcl_out.points[i].x &lt;&lt; &quot;,&quot; &lt;&lt; pcl_out.points[i].y &lt;&lt; &quot;,&quot; &lt;&lt; pcl_out.points[i].z &lt;&lt; &quot;,&quot; &lt;&lt; pcl_out.points[i].intensity &lt;&lt; std::endl;
    }
    std::cout &lt;&lt; &quot;Wrote &quot; &lt;&lt; pcl_out.size() &lt;&lt; &quot; points to &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
    added_scan_num++;
    if(added_scan_num == 50)
    {
      added_scan_num = 0;
      map_id++;
    }
  }
}

int main(int argc, char **argv)
{
  ros::init(argc, argv, &quot;tf_mapping&quot;);
  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  private_nh.getParam(&quot;parent_frame&quot;, PARENT_FRAME);
  private_nh.getParam(&quot;child_frame&quot;, CHILD_FRAME);
  private_nh.getParam(&quot;points_topic&quot;, POINTS_TOPIC);
  private_nh.getParam(&quot;output_dir&quot;, OUTPUT_DIR);

  std::cout &lt;&lt; &quot;parent_frame: &quot; &lt;&lt; PARENT_FRAME &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;child_frame: &quot; &lt;&lt; CHILD_FRAME &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;points_topic: &quot; &lt;&lt; POINTS_TOPIC &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;output_dir: &quot; &lt;&lt; OUTPUT_DIR &lt;&lt; std::endl;

  tf_listener = new tf::TransformListener();

  ros::Subscriber points_sub = nh.subscribe(POINTS_TOPIC, 10, points_callback);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
	<commit hash="46633e1436b58ce6ca4e091d59d7d7e8d36c5c7e" fix_time="95,69839">
		<msg>fix typo</msg>
		<modified_files>
			<file old_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp" new_path="ros/src/computing/perception/localization/packages/ndt_localizer/nodes/ndt_matching/ndt_matching.cpp">
				<diff>@@ -1004,8 +1004,8 @@ static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
           ndt.omp_align(*output_cloud, init_guess);
         #else
           ndt.align(*output_cloud, init_guess);
-        align_end = std::chrono::system_clock::now();
         #endif
+        align_end = std::chrono::system_clock::now();
 
         has_converged = ndt.hasConverged();
 
</diff>
				<old_file>/*
 *  Copyright (c) 2015, Nagoya University
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 *
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 *  * Neither the name of Autoware nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;
 *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 Localization program using Normal Distributions Transform

 Yuki KITSUKAWA
 */

#include &lt;chrono&gt;
#include &lt;fstream&gt;
#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;string&gt;
#include &lt;memory&gt;
#include &lt;pthread.h&gt;

#include &lt;ros/ros.h&gt;
#include &lt;sensor_msgs/Imu.h&gt;
#include &lt;sensor_msgs/PointCloud2.h&gt;
#include &lt;nav_msgs/Odometry.h&gt;
#include &lt;std_msgs/Bool.h&gt;
#include &lt;std_msgs/Float32.h&gt;
#include &lt;std_msgs/String.h&gt;
#include &lt;velodyne_pointcloud/point_types.h&gt;
#include &lt;velodyne_pointcloud/rawdata.h&gt;

#include &lt;geometry_msgs/PoseWithCovarianceStamped.h&gt;
#include &lt;geometry_msgs/TwistStamped.h&gt;

#include &lt;tf/tf.h&gt;
#include &lt;tf/transform_broadcaster.h&gt;
#include &lt;tf/transform_datatypes.h&gt;
#include &lt;tf/transform_listener.h&gt;

#include &lt;pcl/io/io.h&gt;
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/point_types.h&gt;
#include &lt;pcl_conversions/pcl_conversions.h&gt;

#ifdef USE_FAST_PCL
  #include &lt;fast_pcl/registration/ndt.h&gt;
#else
  #include &lt;pcl/registration/ndt.h&gt;
#endif

#ifdef CUDA_FOUND
  #include &lt;fast_pcl/ndt_gpu/NormalDistributionsTransform.h&gt;
#endif

//End of adding

#include &lt;pcl_ros/point_cloud.h&gt;
#include &lt;pcl_ros/transforms.h&gt;

#include &lt;autoware_msgs/ConfigNdt.h&gt;

#include &lt;autoware_msgs/ndt_stat.h&gt;

//Added for testing on cpu
#include &lt;fast_pcl/ndt_cpu/NormalDistributionsTransform.h&gt;
//End of adding

#define PREDICT_POSE_THRESHOLD 0.5

#define Wa 0.4
#define Wb 0.3
#define Wc 0.3

struct pose
{
  double x;
  double y;
  double z;
  double roll;
  double pitch;
  double yaw;
};

static pose initial_pose, predict_pose, predict_pose_imu, predict_pose_odom, predict_pose_imu_odom, previous_pose,
    ndt_pose, current_pose, current_pose_imu, current_pose_odom, current_pose_imu_odom, localizer_pose,
    previous_gnss_pose, current_gnss_pose;

static double offset_x, offset_y, offset_z, offset_yaw;  // current_pos - previous_pose
static double offset_imu_x, offset_imu_y, offset_imu_z, offset_imu_roll, offset_imu_pitch, offset_imu_yaw;
static double offset_odom_x, offset_odom_y, offset_odom_z, offset_odom_roll, offset_odom_pitch, offset_odom_yaw;
static double offset_imu_odom_x, offset_imu_odom_y, offset_imu_odom_z, offset_imu_odom_roll, offset_imu_odom_pitch,
    offset_imu_odom_yaw;

// Can't load if typed &quot;pcl::PointCloud&lt;pcl::PointXYZRGB&gt; map, add;&quot;
static pcl::PointCloud&lt;pcl::PointXYZ&gt; map, add;

// If the map is loaded, map_loaded will be 1.
static int map_loaded = 0;
static int _use_gnss = 1;
static int init_pos_set = 0;

#ifdef CUDA_FOUND
static std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
#endif


static cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; cpu_ndt;

static pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; ndt;

// Default values
static int max_iter = 30;        // Maximum iterations
static float ndt_res = 1.0;      // Resolution
static double step_size = 0.1;   // Step size
static double trans_eps = 0.01;  // Transformation epsilon

static ros::Publisher predict_pose_pub;
static geometry_msgs::PoseStamped predict_pose_msg;

static ros::Publisher predict_pose_imu_pub;
static geometry_msgs::PoseStamped predict_pose_imu_msg;

static ros::Publisher predict_pose_odom_pub;
static geometry_msgs::PoseStamped predict_pose_odom_msg;

static ros::Publisher predict_pose_imu_odom_pub;
static geometry_msgs::PoseStamped predict_pose_imu_odom_msg;

static ros::Publisher ndt_pose_pub;
static geometry_msgs::PoseStamped ndt_pose_msg;

// current_pose is published by vel_pose_mux
/*
static ros::Publisher current_pose_pub;
static geometry_msgs::PoseStamped current_pose_msg;
*/

static ros::Publisher localizer_pose_pub;
static geometry_msgs::PoseStamped localizer_pose_msg;

static ros::Publisher estimate_twist_pub;
static geometry_msgs::TwistStamped estimate_twist_msg;

static ros::Time current_scan_time;
static ros::Time previous_scan_time;
static ros::Duration scan_duration;

static double exe_time = 0.0;
static bool has_converged;
static int iteration = 0;
static double fitness_score = 0.0;
static double trans_probability = 0.0;

static double diff = 0.0;
static double diff_x = 0.0, diff_y = 0.0, diff_z = 0.0, diff_yaw;

static double current_velocity = 0.0, previous_velocity = 0.0, previous_previous_velocity = 0.0;  // [m/s]
static double current_velocity_x = 0.0, previous_velocity_x = 0.0;
static double current_velocity_y = 0.0, previous_velocity_y = 0.0;
static double current_velocity_z = 0.0, previous_velocity_z = 0.0;
// static double current_velocity_yaw = 0.0, previous_velocity_yaw = 0.0;
static double current_velocity_smooth = 0.0;

static double current_velocity_imu_x = 0.0;
static double current_velocity_imu_y = 0.0;
static double current_velocity_imu_z = 0.0;

static double current_accel = 0.0, previous_accel = 0.0;  // [m/s^2]
static double current_accel_x = 0.0;
static double current_accel_y = 0.0;
static double current_accel_z = 0.0;
// static double current_accel_yaw = 0.0;

static double angular_velocity = 0.0;

static int use_predict_pose = 0;

static ros::Publisher estimated_vel_mps_pub, estimated_vel_kmph_pub, estimated_vel_pub;
static std_msgs::Float32 estimated_vel_mps, estimated_vel_kmph, previous_estimated_vel_kmph;

static std::chrono::time_point&lt;std::chrono::system_clock&gt; matching_start, matching_end;

static ros::Publisher time_ndt_matching_pub;
static std_msgs::Float32 time_ndt_matching;

static int _queue_size = 1000;

static ros::Publisher ndt_stat_pub;
static autoware_msgs::ndt_stat ndt_stat_msg;

static double predict_pose_error = 0.0;

static double _tf_x, _tf_y, _tf_z, _tf_roll, _tf_pitch, _tf_yaw;
static Eigen::Matrix4f tf_btol;

static std::string _localizer = &quot;velodyne&quot;;
static std::string _offset = &quot;linear&quot;;  // linear, zero, quadratic

static ros::Publisher ndt_reliability_pub;
static std_msgs::Float32 ndt_reliability;

static bool _use_gpu = false;
static bool _use_openmp = false;

static bool _use_fast_pcl = true;

static bool _get_height = false;
static bool _use_local_transform = false;
static bool _use_imu = false;
static bool _use_odom = false;
static bool _imu_upside_down = false;

static std::string _imu_topic = &quot;/imu_raw&quot;;

static std::ofstream ofs;
static std::string filename;

static sensor_msgs::Imu imu;
static nav_msgs::Odometry odom;

// static tf::TransformListener local_transform_listener;
static tf::StampedTransform local_transform;

static int points_map_num = 0;

pthread_mutex_t mutex;

static void param_callback(const autoware_msgs::ConfigNdt::ConstPtr&amp; input)
{
  if (_use_gnss != input-&gt;init_pos_gnss)
  {
    init_pos_set = 0;
  }
  else if (_use_gnss == 0 &amp;&amp;
           (initial_pose.x != input-&gt;x || initial_pose.y != input-&gt;y || initial_pose.z != input-&gt;z ||
            initial_pose.roll != input-&gt;roll || initial_pose.pitch != input-&gt;pitch || initial_pose.yaw != input-&gt;yaw))
  {
    init_pos_set = 0;
  }

  _use_gnss = input-&gt;init_pos_gnss;

  // Setting parameters
  if (input-&gt;resolution != ndt_res)
  {
    ndt_res = input-&gt;resolution;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt_ptr-&gt;setResolution(ndt_res);
    }
    else
    {
#endif
		if (_use_fast_pcl)
		{
          cpu_ndt.setResolution(ndt_res);
		}
		else
		{
          ndt.setResolution(ndt_res);
		}
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;step_size != step_size)
  {
    step_size = input-&gt;step_size;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt_ptr-&gt;setStepSize(step_size);
    }
    else
    {
#endif
		if (_use_fast_pcl)
		{
          cpu_ndt.setStepSize(step_size);
		}
		else
		{
          ndt.setStepSize(step_size);
		}
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;trans_epsilon != trans_eps)
  {
    trans_eps = input-&gt;trans_epsilon;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);
    }
    else
    {
#endif
		if (_use_fast_pcl)
		{
          cpu_ndt.setTransformationEpsilon(trans_eps);
		}
		else
		{
          ndt.setTransformationEpsilon(trans_eps);
		}
#ifdef CUDA_FOUND
    }
#endif
  }
  if (input-&gt;max_iterations != max_iter)
  {
    max_iter = input-&gt;max_iterations;
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
    }
    else
    {
#endif
		if (_use_fast_pcl)
		{
          cpu_ndt.setMaximumIterations(max_iter);
		}
		else
		{
          ndt.setMaximumIterations(max_iter);
		}
#ifdef CUDA_FOUND
    }
#endif
  }

  if (_use_gnss == 0 &amp;&amp; init_pos_set == 0)
  {
    initial_pose.x = input-&gt;x;
    initial_pose.y = input-&gt;y;
    initial_pose.z = input-&gt;z;
    initial_pose.roll = input-&gt;roll;
    initial_pose.pitch = input-&gt;pitch;
    initial_pose.yaw = input-&gt;yaw;

    if (_use_local_transform == true)
    {
      tf::Vector3 v(input-&gt;x, input-&gt;y, input-&gt;z);
      tf::Quaternion q;
      q.setRPY(input-&gt;roll, input-&gt;pitch, input-&gt;yaw);
      tf::Transform transform(q, v);
      initial_pose.x = (local_transform.inverse() * transform).getOrigin().getX();
      initial_pose.y = (local_transform.inverse() * transform).getOrigin().getY();
      initial_pose.z = (local_transform.inverse() * transform).getOrigin().getZ();

      tf::Matrix3x3 m(q);
      m.getRPY(initial_pose.roll, initial_pose.pitch, initial_pose.yaw);

      std::cout &lt;&lt; &quot;initial_pose.x: &quot; &lt;&lt; initial_pose.x &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.y: &quot; &lt;&lt; initial_pose.y &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.z: &quot; &lt;&lt; initial_pose.z &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.roll: &quot; &lt;&lt; initial_pose.roll &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.pitch: &quot; &lt;&lt; initial_pose.pitch &lt;&lt; std::endl;
      std::cout &lt;&lt; &quot;initial_pose.yaw: &quot; &lt;&lt; initial_pose.yaw &lt;&lt; std::endl;
    }

    // Setting position and posture for the first time.
    localizer_pose.x = initial_pose.x;
    localizer_pose.y = initial_pose.y;
    localizer_pose.z = initial_pose.z;
    localizer_pose.roll = initial_pose.roll;
    localizer_pose.pitch = initial_pose.pitch;
    localizer_pose.yaw = initial_pose.yaw;

    previous_pose.x = initial_pose.x;
    previous_pose.y = initial_pose.y;
    previous_pose.z = initial_pose.z;
    previous_pose.roll = initial_pose.roll;
    previous_pose.pitch = initial_pose.pitch;
    previous_pose.yaw = initial_pose.yaw;

    current_pose.x = initial_pose.x;
    current_pose.y = initial_pose.y;
    current_pose.z = initial_pose.z;
    current_pose.roll = initial_pose.roll;
    current_pose.pitch = initial_pose.pitch;
    current_pose.yaw = initial_pose.yaw;

    current_velocity = 0;
    current_velocity_x = 0;
    current_velocity_y = 0;
    current_velocity_z = 0;
    angular_velocity = 0;

    current_pose_imu.x = 0;
    current_pose_imu.y = 0;
    current_pose_imu.z = 0;
    current_pose_imu.roll = 0;
    current_pose_imu.pitch = 0;
    current_pose_imu.yaw = 0;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;
    init_pos_set = 1;
  }
}

static void map_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  // if (map_loaded == 0)
  if (points_map_num != input-&gt;width)
  {
    std::cout &lt;&lt; &quot;Update points_map.&quot; &lt;&lt; std::endl;

    points_map_num = input-&gt;width;

    // Convert the data type(from sensor_msgs to pcl).
    pcl::fromROSMsg(*input, map);

    if (_use_local_transform == true)
    {
      tf::TransformListener local_transform_listener;
      try
      {
        ros::Time now = ros::Time(0);
        local_transform_listener.waitForTransform(&quot;/map&quot;, &quot;/world&quot;, now, ros::Duration(10.0));
        local_transform_listener.lookupTransform(&quot;/map&quot;, &quot;world&quot;, now, local_transform);
      }
      catch (tf::TransformException&amp; ex)
      {
        ROS_ERROR(&quot;%s&quot;, ex.what());
      }

      pcl_ros::transformPointCloud(map, map, local_transform.inverse());
    }

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr map_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(map));


// Setting point cloud to be aligned to.
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      std::shared_ptr&lt;gpu::GNormalDistributionsTransform&gt; new_gpu_ndt_ptr = std::make_shared&lt;gpu::GNormalDistributionsTransform&gt;();
      new_gpu_ndt_ptr-&gt;setInputTarget(map_ptr);
      new_gpu_ndt_ptr-&gt;setMaximumIterations(max_iter);
      new_gpu_ndt_ptr-&gt;setResolution(ndt_res);
      new_gpu_ndt_ptr-&gt;setStepSize(step_size);
      new_gpu_ndt_ptr-&gt;setTransformationEpsilon(trans_eps);

      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr dummy_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;());
      pcl::PointXYZ dummy_point;
      dummy_scan_ptr-&gt;push_back(dummy_point);
      new_gpu_ndt_ptr-&gt;setInputSource(dummy_scan_ptr);

      new_gpu_ndt_ptr-&gt;align(Eigen::Matrix4f::Identity());

      pthread_mutex_lock(&amp;mutex);
      gpu_ndt_ptr = new_gpu_ndt_ptr;
      pthread_mutex_unlock(&amp;mutex);
    }
    else
#endif
    if (_use_fast_pcl)
    {
      cpu::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_cpu_ndt;
      new_cpu_ndt.setInputTarget(map_ptr);
      new_cpu_ndt.setMaximumIterations(max_iter);
      new_cpu_ndt.setResolution(ndt_res);
      new_cpu_ndt.setStepSize(step_size);
      new_cpu_ndt.setTransformationEpsilon(trans_eps);

      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr dummy_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;());
      pcl::PointXYZ dummy_point;
      dummy_scan_ptr-&gt;push_back(dummy_point);
      new_cpu_ndt.setInputSource(dummy_scan_ptr);

      new_cpu_ndt.align(Eigen::Matrix4f::Identity());

      pthread_mutex_lock(&amp;mutex);
      cpu_ndt = new_cpu_ndt;
      pthread_mutex_unlock(&amp;mutex);
    }
    else
    {
      pcl::NormalDistributionsTransform&lt;pcl::PointXYZ, pcl::PointXYZ&gt; new_ndt;
      pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
      new_ndt.setInputTarget(map_ptr);
      new_ndt.setMaximumIterations(max_iter);
      new_ndt.setResolution(ndt_res);
      new_ndt.setStepSize(step_size);
      new_ndt.setTransformationEpsilon(trans_eps);
      #ifdef USE_FAST_PCL
        new_ndt.omp_align(*output_cloud, Eigen::Matrix4f::Identity());
      #else
        new_ndt.align(*output_cloud, Eigen::Matrix4f::Identity());
      #endif

      pthread_mutex_lock(&amp;mutex);
      ndt = new_ndt;
      pthread_mutex_unlock(&amp;mutex);
    }

    map_loaded = 1;
  }
}

static void gnss_callback(const geometry_msgs::PoseStamped::ConstPtr&amp; input)
{
  tf::Quaternion gnss_q(input-&gt;pose.orientation.x, input-&gt;pose.orientation.y, input-&gt;pose.orientation.z,
                        input-&gt;pose.orientation.w);
  tf::Matrix3x3 gnss_m(gnss_q);
  current_gnss_pose.x = input-&gt;pose.position.x;
  current_gnss_pose.y = input-&gt;pose.position.y;
  current_gnss_pose.z = input-&gt;pose.position.z;
  gnss_m.getRPY(current_gnss_pose.roll, current_gnss_pose.pitch, current_gnss_pose.yaw);

  if ((_use_gnss == 1 &amp;&amp; init_pos_set == 0) || fitness_score &gt;= 500.0)
  {
    previous_pose.x = previous_gnss_pose.x;
    previous_pose.y = previous_gnss_pose.y;
    previous_pose.z = previous_gnss_pose.z;
    previous_pose.roll = previous_gnss_pose.roll;
    previous_pose.pitch = previous_gnss_pose.pitch;
    previous_pose.yaw = previous_gnss_pose.yaw;

    current_pose.x = current_gnss_pose.x;
    current_pose.y = current_gnss_pose.y;
    current_pose.z = current_gnss_pose.z;
    current_pose.roll = current_gnss_pose.roll;
    current_pose.pitch = current_gnss_pose.pitch;
    current_pose.yaw = current_gnss_pose.yaw;

    current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;

    offset_x = current_pose.x - previous_pose.x;
    offset_y = current_pose.y - previous_pose.y;
    offset_z = current_pose.z - previous_pose.z;
    offset_yaw = current_pose.yaw - previous_pose.yaw;

    init_pos_set = 1;
  }

  previous_gnss_pose.x = current_gnss_pose.x;
  previous_gnss_pose.y = current_gnss_pose.y;
  previous_gnss_pose.z = current_gnss_pose.z;
  previous_gnss_pose.roll = current_gnss_pose.roll;
  previous_gnss_pose.pitch = current_gnss_pose.pitch;
  previous_gnss_pose.yaw = current_gnss_pose.yaw;
}

static void initialpose_callback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr&amp; input)
{
  tf::TransformListener listener;
  tf::StampedTransform transform;
  try
  {
    ros::Time now = ros::Time(0);
    listener.waitForTransform(&quot;/map&quot;, input-&gt;header.frame_id, now, ros::Duration(10.0));
    listener.lookupTransform(&quot;/map&quot;, input-&gt;header.frame_id, now, transform);
  }
  catch (tf::TransformException&amp; ex)
  {
    ROS_ERROR(&quot;%s&quot;, ex.what());
  }

  tf::Quaternion q(input-&gt;pose.pose.orientation.x, input-&gt;pose.pose.orientation.y, input-&gt;pose.pose.orientation.z,
                   input-&gt;pose.pose.orientation.w);
  tf::Matrix3x3 m(q);

  if (_use_local_transform == true)
  {
    current_pose.x = input-&gt;pose.pose.position.x;
    current_pose.y = input-&gt;pose.pose.position.y;
    current_pose.z = input-&gt;pose.pose.position.z;
  }
  else
  {
    current_pose.x = input-&gt;pose.pose.position.x + transform.getOrigin().x();
    current_pose.y = input-&gt;pose.pose.position.y + transform.getOrigin().y();
    current_pose.z = input-&gt;pose.pose.position.z + transform.getOrigin().z();
  }
  m.getRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);

  if (_get_height == true &amp;&amp; map_loaded == 1)
  {
    double min_distance = DBL_MAX;
    double nearest_z = current_pose.z;
    for (const auto&amp; p : map)
    {
      double distance = hypot(current_pose.x - p.x, current_pose.y - p.y);
      if (distance &lt; min_distance)
      {
        min_distance = distance;
        nearest_z = p.z;
      }
    }
    current_pose.z = nearest_z;
  }

  current_pose_imu = current_pose_odom = current_pose_imu_odom = current_pose;
  previous_pose.x = current_pose.x;
  previous_pose.y = current_pose.y;
  previous_pose.z = current_pose.z;
  previous_pose.roll = current_pose.roll;
  previous_pose.pitch = current_pose.pitch;
  previous_pose.yaw = current_pose.yaw;

  offset_x = 0.0;
  offset_y = 0.0;
  offset_z = 0.0;
  offset_yaw = 0.0;

  offset_imu_x = 0.0;
  offset_imu_y = 0.0;
  offset_imu_z = 0.0;
  offset_imu_roll = 0.0;
  offset_imu_pitch = 0.0;
  offset_imu_yaw = 0.0;

  offset_odom_x = 0.0;
  offset_odom_y = 0.0;
  offset_odom_z = 0.0;
  offset_odom_roll = 0.0;
  offset_odom_pitch = 0.0;
  offset_odom_yaw = 0.0;

  offset_imu_odom_x = 0.0;
  offset_imu_odom_y = 0.0;
  offset_imu_odom_z = 0.0;
  offset_imu_odom_roll = 0.0;
  offset_imu_odom_pitch = 0.0;
  offset_imu_odom_yaw = 0.0;
}

static void imu_odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu_odom.roll += diff_imu_roll;
  current_pose_imu_odom.pitch += diff_imu_pitch;
  current_pose_imu_odom.yaw += diff_imu_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_imu_odom_x += diff_distance * cos(-current_pose_imu_odom.pitch) * cos(current_pose_imu_odom.yaw);
  offset_imu_odom_y += diff_distance * cos(-current_pose_imu_odom.pitch) * sin(current_pose_imu_odom.yaw);
  offset_imu_odom_z += diff_distance * sin(-current_pose_imu_odom.pitch);

  offset_imu_odom_roll += diff_imu_roll;
  offset_imu_odom_pitch += diff_imu_pitch;
  offset_imu_odom_yaw += diff_imu_yaw;

  predict_pose_imu_odom.x = previous_pose.x + offset_imu_odom_x;
  predict_pose_imu_odom.y = previous_pose.y + offset_imu_odom_y;
  predict_pose_imu_odom.z = previous_pose.z + offset_imu_odom_z;
  predict_pose_imu_odom.roll = previous_pose.roll + offset_imu_odom_roll;
  predict_pose_imu_odom.pitch = previous_pose.pitch + offset_imu_odom_pitch;
  predict_pose_imu_odom.yaw = previous_pose.yaw + offset_imu_odom_yaw;

  previous_time = current_time;
}

static void odom_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_odom_roll = odom.twist.twist.angular.x * diff_time;
  double diff_odom_pitch = odom.twist.twist.angular.y * diff_time;
  double diff_odom_yaw = odom.twist.twist.angular.z * diff_time;

  current_pose_odom.roll += diff_odom_roll;
  current_pose_odom.pitch += diff_odom_pitch;
  current_pose_odom.yaw += diff_odom_yaw;

  double diff_distance = odom.twist.twist.linear.x * diff_time;
  offset_odom_x += diff_distance * cos(-current_pose_odom.pitch) * cos(current_pose_odom.yaw);
  offset_odom_y += diff_distance * cos(-current_pose_odom.pitch) * sin(current_pose_odom.yaw);
  offset_odom_z += diff_distance * sin(-current_pose_odom.pitch);

  offset_odom_roll += diff_odom_roll;
  offset_odom_pitch += diff_odom_pitch;
  offset_odom_yaw += diff_odom_yaw;

  predict_pose_odom.x = previous_pose.x + offset_odom_x;
  predict_pose_odom.y = previous_pose.y + offset_odom_y;
  predict_pose_odom.z = previous_pose.z + offset_odom_z;
  predict_pose_odom.roll = previous_pose.roll + offset_odom_roll;
  predict_pose_odom.pitch = previous_pose.pitch + offset_odom_pitch;
  predict_pose_odom.yaw = previous_pose.yaw + offset_odom_yaw;

  previous_time = current_time;
}

static void imu_calc(ros::Time current_time)
{
  static ros::Time previous_time = current_time;
  double diff_time = (current_time - previous_time).toSec();

  double diff_imu_roll = imu.angular_velocity.x * diff_time;
  double diff_imu_pitch = imu.angular_velocity.y * diff_time;
  double diff_imu_yaw = imu.angular_velocity.z * diff_time;

  current_pose_imu.roll += diff_imu_roll;
  current_pose_imu.pitch += diff_imu_pitch;
  current_pose_imu.yaw += diff_imu_yaw;

  double accX1 = imu.linear_acceleration.x;
  double accY1 = std::cos(current_pose_imu.roll) * imu.linear_acceleration.y -
                 std::sin(current_pose_imu.roll) * imu.linear_acceleration.z;
  double accZ1 = std::sin(current_pose_imu.roll) * imu.linear_acceleration.y +
                 std::cos(current_pose_imu.roll) * imu.linear_acceleration.z;

  double accX2 = std::sin(current_pose_imu.pitch) * accZ1 + std::cos(current_pose_imu.pitch) * accX1;
  double accY2 = accY1;
  double accZ2 = std::cos(current_pose_imu.pitch) * accZ1 - std::sin(current_pose_imu.pitch) * accX1;

  double accX = std::cos(current_pose_imu.yaw) * accX2 - std::sin(current_pose_imu.yaw) * accY2;
  double accY = std::sin(current_pose_imu.yaw) * accX2 + std::cos(current_pose_imu.yaw) * accY2;
  double accZ = accZ2;

  offset_imu_x += current_velocity_imu_x * diff_time + accX * diff_time * diff_time / 2.0;
  offset_imu_y += current_velocity_imu_y * diff_time + accY * diff_time * diff_time / 2.0;
  offset_imu_z += current_velocity_imu_z * diff_time + accZ * diff_time * diff_time / 2.0;

  current_velocity_imu_x += accX * diff_time;
  current_velocity_imu_y += accY * diff_time;
  current_velocity_imu_z += accZ * diff_time;

  offset_imu_roll += diff_imu_roll;
  offset_imu_pitch += diff_imu_pitch;
  offset_imu_yaw += diff_imu_yaw;

  predict_pose_imu.x = previous_pose.x + offset_imu_x;
  predict_pose_imu.y = previous_pose.y + offset_imu_y;
  predict_pose_imu.z = previous_pose.z + offset_imu_z;
  predict_pose_imu.roll = previous_pose.roll + offset_imu_roll;
  predict_pose_imu.pitch = previous_pose.pitch + offset_imu_pitch;
  predict_pose_imu.yaw = previous_pose.yaw + offset_imu_yaw;

  previous_time = current_time;
}

static const double wrapToPm(double a_num, const double a_max)
{
  if (a_num &gt;= a_max)
  {
    a_num -= 2.0 * a_max;
  }
  return a_num;
}

static const double wrapToPmPi(double a_angle_rad)
{
  return wrapToPm(a_angle_rad, M_PI);
}

static void odom_callback(const nav_msgs::Odometry::ConstPtr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  odom = *input;
  odom_calc(input-&gt;header.stamp);
}

static void imuUpsideDown(const sensor_msgs::Imu::Ptr input)
{
  double input_roll, input_pitch, input_yaw;

  tf::Quaternion input_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, input_orientation);
  tf::Matrix3x3(input_orientation).getRPY(input_roll, input_pitch, input_yaw);

  input-&gt;angular_velocity.x *= -1;
  input-&gt;angular_velocity.y *= -1;
  input-&gt;angular_velocity.z *= -1;

  input-&gt;linear_acceleration.x *= -1;
  input-&gt;linear_acceleration.y *= -1;
  input-&gt;linear_acceleration.z *= -1;

  input_roll *= -1;
  input_pitch *= -1;
  input_yaw *= -1;

  input-&gt;orientation = tf::createQuaternionMsgFromRollPitchYaw(input_roll, input_pitch, input_yaw);
}

static void imu_callback(const sensor_msgs::Imu::Ptr&amp; input)
{
  // std::cout &lt;&lt; __func__ &lt;&lt; std::endl;

  if (_imu_upside_down)
    imuUpsideDown(input);

  const ros::Time current_time = input-&gt;header.stamp;
  static ros::Time previous_time = current_time;
  const double diff_time = (current_time - previous_time).toSec();

  double imu_roll, imu_pitch, imu_yaw;
  tf::Quaternion imu_orientation;
  tf::quaternionMsgToTF(input-&gt;orientation, imu_orientation);
  tf::Matrix3x3(imu_orientation).getRPY(imu_roll, imu_pitch, imu_yaw);

  imu_roll = wrapToPmPi(imu_roll);
  imu_pitch = wrapToPmPi(imu_pitch);
  imu_yaw = wrapToPmPi(imu_yaw);

  static double previous_imu_roll = imu_roll, previous_imu_pitch = imu_pitch, previous_imu_yaw = imu_yaw;
  const double diff_imu_roll = imu_roll - previous_imu_roll;

  const double diff_imu_pitch = imu_pitch - previous_imu_pitch;

  double diff_imu_yaw;
  if (fabs(imu_yaw - previous_imu_yaw) &gt; M_PI)
  {
    if (imu_yaw &gt; 0)
      diff_imu_yaw = (imu_yaw - previous_imu_yaw) - M_PI * 2;
    else
      diff_imu_yaw = -M_PI * 2 - (imu_yaw - previous_imu_yaw);
  }
  else
    diff_imu_yaw = imu_yaw - previous_imu_yaw;

  imu.header = input-&gt;header;
  imu.linear_acceleration.x = input-&gt;linear_acceleration.x;
  // imu.linear_acceleration.y = input-&gt;linear_acceleration.y;
  // imu.linear_acceleration.z = input-&gt;linear_acceleration.z;
  imu.linear_acceleration.y = 0;
  imu.linear_acceleration.z = 0;

  if (diff_time != 0)
  {
    imu.angular_velocity.x = diff_imu_roll / diff_time;
    imu.angular_velocity.y = diff_imu_pitch / diff_time;
    imu.angular_velocity.z = diff_imu_yaw / diff_time;
  }
  else
  {
    imu.angular_velocity.x = 0;
    imu.angular_velocity.y = 0;
    imu.angular_velocity.z = 0;
  }

  imu_calc(input-&gt;header.stamp);

  previous_time = current_time;
  previous_imu_roll = imu_roll;
  previous_imu_pitch = imu_pitch;
  previous_imu_yaw = imu_yaw;
}

static void points_callback(const sensor_msgs::PointCloud2::ConstPtr&amp; input)
{
  if (map_loaded == 1 &amp;&amp; init_pos_set == 1)
  {
    matching_start = std::chrono::system_clock::now();

    static tf::TransformBroadcaster br;
    tf::Transform transform;
    tf::Quaternion predict_q, ndt_q, current_q, localizer_q;

    pcl::PointXYZ p;
    pcl::PointCloud&lt;pcl::PointXYZ&gt; filtered_scan;

    current_scan_time = input-&gt;header.stamp;

    pcl::fromROSMsg(*input, filtered_scan);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr filtered_scan_ptr(new pcl::PointCloud&lt;pcl::PointXYZ&gt;(filtered_scan));
    int scan_points_num = filtered_scan_ptr-&gt;size();

    Eigen::Matrix4f t(Eigen::Matrix4f::Identity());   // base_link
    Eigen::Matrix4f t2(Eigen::Matrix4f::Identity());  // localizer

    std::chrono::time_point&lt;std::chrono::system_clock&gt; align_start, align_end, getFitnessScore_start,
        getFitnessScore_end;
    static double align_time, getFitnessScore_time = 0.0;

    pthread_mutex_lock(&amp;mutex);
#ifdef CUDA_FOUND
    if (_use_gpu == true)
    {
      gpu_ndt_ptr-&gt;setInputSource(filtered_scan_ptr);
    }
    else
    {
#endif
		if (_use_fast_pcl)
		{
          cpu_ndt.setInputSource(filtered_scan_ptr);
		}
		else
		{
          ndt.setInputSource(filtered_scan_ptr);
		}
#ifdef CUDA_FOUND
    }
#endif

    // Guess the initial gross estimation of the transformation
    predict_pose.x = previous_pose.x + offset_x;
    predict_pose.y = previous_pose.y + offset_y;
    predict_pose.z = previous_pose.z + offset_z;
    predict_pose.roll = previous_pose.roll;
    predict_pose.pitch = previous_pose.pitch;
    predict_pose.yaw = previous_pose.yaw + offset_yaw;

    if (_use_imu == true &amp;&amp; _use_odom == true)
      imu_odom_calc(current_scan_time);
    if (_use_imu == true &amp;&amp; _use_odom == false)
      imu_calc(current_scan_time);
    if (_use_imu == false &amp;&amp; _use_odom == true)
      odom_calc(current_scan_time);

    pose predict_pose_for_ndt;
    if (_use_imu == true &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_imu_odom;
    else if (_use_imu == true &amp;&amp; _use_odom == false)
      predict_pose_for_ndt = predict_pose_imu;
    else if (_use_imu == false &amp;&amp; _use_odom == true)
      predict_pose_for_ndt = predict_pose_odom;
    else
      predict_pose_for_ndt = predict_pose;

    Eigen::Translation3f init_translation(predict_pose_for_ndt.x, predict_pose_for_ndt.y, predict_pose_for_ndt.z);
    Eigen::AngleAxisf init_rotation_x(predict_pose_for_ndt.roll, Eigen::Vector3f::UnitX());
    Eigen::AngleAxisf init_rotation_y(predict_pose_for_ndt.pitch, Eigen::Vector3f::UnitY());
    Eigen::AngleAxisf init_rotation_z(predict_pose_for_ndt.yaw, Eigen::Vector3f::UnitZ());
    Eigen::Matrix4f init_guess = (init_translation * init_rotation_z * init_rotation_y * init_rotation_x) * tf_btol;

    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr output_cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);


    #ifdef CUDA_FOUND
      if (_use_gpu == true)
      {
        align_start = std::chrono::system_clock::now();
        gpu_ndt_ptr-&gt;align(init_guess);
        align_end = std::chrono::system_clock::now();

        has_converged = gpu_ndt_ptr-&gt;hasConverged();

        t = gpu_ndt_ptr-&gt;getFinalTransformation();
        iteration = gpu_ndt_ptr-&gt;getFinalNumIteration();

        getFitnessScore_start = std::chrono::system_clock::now();
        fitness_score = gpu_ndt_ptr-&gt;getFitnessScore();
        getFitnessScore_end = std::chrono::system_clock::now();

        trans_probability = gpu_ndt_ptr-&gt;getTransformationProbability();
      }
      else
    #endif
      if (_use_fast_pcl)
      {
        align_start = std::chrono::system_clock::now();
        cpu_ndt.align(init_guess);
        align_end = std::chrono::system_clock::now();

        has_converged = cpu_ndt.hasConverged();

        t = cpu_ndt.getFinalTransformation();
        iteration = cpu_ndt.getFinalNumIteration();

        getFitnessScore_start = std::chrono::system_clock::now();
        fitness_score = cpu_ndt.getFitnessScore();
        getFitnessScore_end = std::chrono::system_clock::now();

        trans_probability = cpu_ndt.getTransformationProbability();
      }
      else
      {
        align_start = std::chrono::system_clock::now();
        #ifdef USE_FAST_PCL
          ndt.omp_align(*output_cloud, init_guess);
        #else
          ndt.align(*output_cloud, init_guess);
        align_end = std::chrono::system_clock::now();
        #endif

        has_converged = ndt.hasConverged();

        t = ndt.getFinalTransformation();
        iteration = ndt.getFinalNumIteration();

        getFitnessScore_start = std::chrono::system_clock::now();
        #ifdef USE_FAST_PCL
          fitness_score = ndt.omp_getFitnessScore();
        #else
          fitness_score = ndt.getFitnessScore();
        #endif
        getFitnessScore_end = std::chrono::system_clock::now();

        trans_probability = ndt.getTransformationProbability();
      }

    align_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(align_end - align_start).count() / 1000.0;

    t2 = t * tf_btol.inverse();

    getFitnessScore_time =
        std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(getFitnessScore_end - getFitnessScore_start).count() /
        1000.0;

    pthread_mutex_unlock(&amp;mutex);

    tf::Matrix3x3 mat_l;  // localizer
    mat_l.setValue(static_cast&lt;double&gt;(t(0, 0)), static_cast&lt;double&gt;(t(0, 1)), static_cast&lt;double&gt;(t(0, 2)),
                   static_cast&lt;double&gt;(t(1, 0)), static_cast&lt;double&gt;(t(1, 1)), static_cast&lt;double&gt;(t(1, 2)),
                   static_cast&lt;double&gt;(t(2, 0)), static_cast&lt;double&gt;(t(2, 1)), static_cast&lt;double&gt;(t(2, 2)));

    // Update localizer_pose
    localizer_pose.x = t(0, 3);
    localizer_pose.y = t(1, 3);
    localizer_pose.z = t(2, 3);
    mat_l.getRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw, 1);

    tf::Matrix3x3 mat_b;  // base_link
    mat_b.setValue(static_cast&lt;double&gt;(t2(0, 0)), static_cast&lt;double&gt;(t2(0, 1)), static_cast&lt;double&gt;(t2(0, 2)),
                   static_cast&lt;double&gt;(t2(1, 0)), static_cast&lt;double&gt;(t2(1, 1)), static_cast&lt;double&gt;(t2(1, 2)),
                   static_cast&lt;double&gt;(t2(2, 0)), static_cast&lt;double&gt;(t2(2, 1)), static_cast&lt;double&gt;(t2(2, 2)));

    // Update ndt_pose
    ndt_pose.x = t2(0, 3);
    ndt_pose.y = t2(1, 3);
    ndt_pose.z = t2(2, 3);
    mat_b.getRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw, 1);

    // Calculate the difference between ndt_pose and predict_pose
    predict_pose_error = sqrt((ndt_pose.x - predict_pose_for_ndt.x) * (ndt_pose.x - predict_pose_for_ndt.x) +
                              (ndt_pose.y - predict_pose_for_ndt.y) * (ndt_pose.y - predict_pose_for_ndt.y) +
                              (ndt_pose.z - predict_pose_for_ndt.z) * (ndt_pose.z - predict_pose_for_ndt.z));

    if (predict_pose_error &lt;= PREDICT_POSE_THRESHOLD)
    {
      use_predict_pose = 0;
    }
    else
    {
      use_predict_pose = 1;
    }
    use_predict_pose = 0;

    if (use_predict_pose == 0)
    {
      current_pose.x = ndt_pose.x;
      current_pose.y = ndt_pose.y;
      current_pose.z = ndt_pose.z;
      current_pose.roll = ndt_pose.roll;
      current_pose.pitch = ndt_pose.pitch;
      current_pose.yaw = ndt_pose.yaw;
    }
    else
    {
      current_pose.x = predict_pose_for_ndt.x;
      current_pose.y = predict_pose_for_ndt.y;
      current_pose.z = predict_pose_for_ndt.z;
      current_pose.roll = predict_pose_for_ndt.roll;
      current_pose.pitch = predict_pose_for_ndt.pitch;
      current_pose.yaw = predict_pose_for_ndt.yaw;
    }

    // Compute the velocity and acceleration
    scan_duration = current_scan_time - previous_scan_time;
    double secs = scan_duration.toSec();
    diff_x = current_pose.x - previous_pose.x;
    diff_y = current_pose.y - previous_pose.y;
    diff_z = current_pose.z - previous_pose.z;
    diff_yaw = current_pose.yaw - previous_pose.yaw;
    diff = sqrt(diff_x * diff_x + diff_y * diff_y + diff_z * diff_z);

    current_velocity = diff / secs;
    current_velocity_x = diff_x / secs;
    current_velocity_y = diff_y / secs;
    current_velocity_z = diff_z / secs;
    angular_velocity = diff_yaw / secs;

    current_pose_imu.x = current_pose.x;
    current_pose_imu.y = current_pose.y;
    current_pose_imu.z = current_pose.z;
    current_pose_imu.roll = current_pose.roll;
    current_pose_imu.pitch = current_pose.pitch;
    current_pose_imu.yaw = current_pose.yaw;

    current_velocity_imu_x = current_velocity_x;
    current_velocity_imu_y = current_velocity_y;
    current_velocity_imu_z = current_velocity_z;

    current_pose_odom.x = current_pose.x;
    current_pose_odom.y = current_pose.y;
    current_pose_odom.z = current_pose.z;
    current_pose_odom.roll = current_pose.roll;
    current_pose_odom.pitch = current_pose.pitch;
    current_pose_odom.yaw = current_pose.yaw;

    current_pose_imu_odom.x = current_pose.x;
    current_pose_imu_odom.y = current_pose.y;
    current_pose_imu_odom.z = current_pose.z;
    current_pose_imu_odom.roll = current_pose.roll;
    current_pose_imu_odom.pitch = current_pose.pitch;
    current_pose_imu_odom.yaw = current_pose.yaw;

    current_velocity_smooth = (current_velocity + previous_velocity + previous_previous_velocity) / 3.0;
    if (current_velocity_smooth &lt; 0.2)
    {
      current_velocity_smooth = 0.0;
    }

    current_accel = (current_velocity - previous_velocity) / secs;
    current_accel_x = (current_velocity_x - previous_velocity_x) / secs;
    current_accel_y = (current_velocity_y - previous_velocity_y) / secs;
    current_accel_z = (current_velocity_z - previous_velocity_z) / secs;

    estimated_vel_mps.data = current_velocity;
    estimated_vel_kmph.data = current_velocity * 3.6;

    estimated_vel_mps_pub.publish(estimated_vel_mps);
    estimated_vel_kmph_pub.publish(estimated_vel_kmph);

    // Set values for publishing pose
    predict_q.setRPY(predict_pose.roll, predict_pose.pitch, predict_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(predict_pose.x, predict_pose.y, predict_pose.z);
      tf::Transform transform(predict_q, v);
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      predict_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      predict_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      predict_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      predict_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      predict_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      predict_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      predict_pose_msg.header.frame_id = &quot;/map&quot;;
      predict_pose_msg.header.stamp = current_scan_time;
      predict_pose_msg.pose.position.x = predict_pose.x;
      predict_pose_msg.pose.position.y = predict_pose.y;
      predict_pose_msg.pose.position.z = predict_pose.z;
      predict_pose_msg.pose.orientation.x = predict_q.x();
      predict_pose_msg.pose.orientation.y = predict_q.y();
      predict_pose_msg.pose.orientation.z = predict_q.z();
      predict_pose_msg.pose.orientation.w = predict_q.w();
    }

    tf::Quaternion predict_q_imu;
    predict_q_imu.setRPY(predict_pose_imu.roll, predict_pose_imu.pitch, predict_pose_imu.yaw);
    predict_pose_imu_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_msg.pose.position.x = predict_pose_imu.x;
    predict_pose_imu_msg.pose.position.y = predict_pose_imu.y;
    predict_pose_imu_msg.pose.position.z = predict_pose_imu.z;
    predict_pose_imu_msg.pose.orientation.x = predict_q_imu.x();
    predict_pose_imu_msg.pose.orientation.y = predict_q_imu.y();
    predict_pose_imu_msg.pose.orientation.z = predict_q_imu.z();
    predict_pose_imu_msg.pose.orientation.w = predict_q_imu.w();
    predict_pose_imu_pub.publish(predict_pose_imu_msg);

    tf::Quaternion predict_q_odom;
    predict_q_odom.setRPY(predict_pose_odom.roll, predict_pose_odom.pitch, predict_pose_odom.yaw);
    predict_pose_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_odom_msg.pose.position.x = predict_pose_odom.x;
    predict_pose_odom_msg.pose.position.y = predict_pose_odom.y;
    predict_pose_odom_msg.pose.position.z = predict_pose_odom.z;
    predict_pose_odom_msg.pose.orientation.x = predict_q_odom.x();
    predict_pose_odom_msg.pose.orientation.y = predict_q_odom.y();
    predict_pose_odom_msg.pose.orientation.z = predict_q_odom.z();
    predict_pose_odom_msg.pose.orientation.w = predict_q_odom.w();
    predict_pose_odom_pub.publish(predict_pose_odom_msg);

    tf::Quaternion predict_q_imu_odom;
    predict_q_imu_odom.setRPY(predict_pose_imu_odom.roll, predict_pose_imu_odom.pitch, predict_pose_imu_odom.yaw);
    predict_pose_imu_odom_msg.header.frame_id = &quot;map&quot;;
    predict_pose_imu_odom_msg.header.stamp = input-&gt;header.stamp;
    predict_pose_imu_odom_msg.pose.position.x = predict_pose_imu_odom.x;
    predict_pose_imu_odom_msg.pose.position.y = predict_pose_imu_odom.y;
    predict_pose_imu_odom_msg.pose.position.z = predict_pose_imu_odom.z;
    predict_pose_imu_odom_msg.pose.orientation.x = predict_q_imu_odom.x();
    predict_pose_imu_odom_msg.pose.orientation.y = predict_q_imu_odom.y();
    predict_pose_imu_odom_msg.pose.orientation.z = predict_q_imu_odom.z();
    predict_pose_imu_odom_msg.pose.orientation.w = predict_q_imu_odom.w();
    predict_pose_imu_odom_pub.publish(predict_pose_imu_odom_msg);

    ndt_q.setRPY(ndt_pose.roll, ndt_pose.pitch, ndt_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(ndt_pose.x, ndt_pose.y, ndt_pose.z);
      tf::Transform transform(ndt_q, v);
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      ndt_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      ndt_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      ndt_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      ndt_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      ndt_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      ndt_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      ndt_pose_msg.header.frame_id = &quot;/map&quot;;
      ndt_pose_msg.header.stamp = current_scan_time;
      ndt_pose_msg.pose.position.x = ndt_pose.x;
      ndt_pose_msg.pose.position.y = ndt_pose.y;
      ndt_pose_msg.pose.position.z = ndt_pose.z;
      ndt_pose_msg.pose.orientation.x = ndt_q.x();
      ndt_pose_msg.pose.orientation.y = ndt_q.y();
      ndt_pose_msg.pose.orientation.z = ndt_q.z();
      ndt_pose_msg.pose.orientation.w = ndt_q.w();
    }

    current_q.setRPY(current_pose.roll, current_pose.pitch, current_pose.yaw);
    // current_pose is published by vel_pose_mux
    /*
    current_pose_msg.header.frame_id = &quot;/map&quot;;
    current_pose_msg.header.stamp = current_scan_time;
    current_pose_msg.pose.position.x = current_pose.x;
    current_pose_msg.pose.position.y = current_pose.y;
    current_pose_msg.pose.position.z = current_pose.z;
    current_pose_msg.pose.orientation.x = current_q.x();
    current_pose_msg.pose.orientation.y = current_q.y();
    current_pose_msg.pose.orientation.z = current_q.z();
    current_pose_msg.pose.orientation.w = current_q.w();
    */

    localizer_q.setRPY(localizer_pose.roll, localizer_pose.pitch, localizer_pose.yaw);
    if (_use_local_transform == true)
    {
      tf::Vector3 v(localizer_pose.x, localizer_pose.y, localizer_pose.z);
      tf::Transform transform(localizer_q, v);
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = (local_transform * transform).getOrigin().getX();
      localizer_pose_msg.pose.position.y = (local_transform * transform).getOrigin().getY();
      localizer_pose_msg.pose.position.z = (local_transform * transform).getOrigin().getZ();
      localizer_pose_msg.pose.orientation.x = (local_transform * transform).getRotation().x();
      localizer_pose_msg.pose.orientation.y = (local_transform * transform).getRotation().y();
      localizer_pose_msg.pose.orientation.z = (local_transform * transform).getRotation().z();
      localizer_pose_msg.pose.orientation.w = (local_transform * transform).getRotation().w();
    }
    else
    {
      localizer_pose_msg.header.frame_id = &quot;/map&quot;;
      localizer_pose_msg.header.stamp = current_scan_time;
      localizer_pose_msg.pose.position.x = localizer_pose.x;
      localizer_pose_msg.pose.position.y = localizer_pose.y;
      localizer_pose_msg.pose.position.z = localizer_pose.z;
      localizer_pose_msg.pose.orientation.x = localizer_q.x();
      localizer_pose_msg.pose.orientation.y = localizer_q.y();
      localizer_pose_msg.pose.orientation.z = localizer_q.z();
      localizer_pose_msg.pose.orientation.w = localizer_q.w();
    }

    predict_pose_pub.publish(predict_pose_msg);
    ndt_pose_pub.publish(ndt_pose_msg);
    // current_pose is published by vel_pose_mux
    //    current_pose_pub.publish(current_pose_msg);
    localizer_pose_pub.publish(localizer_pose_msg);

    // Send TF &quot;/base_link&quot; to &quot;/map&quot;
    transform.setOrigin(tf::Vector3(current_pose.x, current_pose.y, current_pose.z));
    transform.setRotation(current_q);
    //    br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    if (_use_local_transform == true)
    {
      br.sendTransform(tf::StampedTransform(local_transform * transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }
    else
    {
      br.sendTransform(tf::StampedTransform(transform, current_scan_time, &quot;/map&quot;, &quot;/base_link&quot;));
    }

    matching_end = std::chrono::system_clock::now();
    exe_time = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(matching_end - matching_start).count() / 1000.0;
    time_ndt_matching.data = exe_time;
    time_ndt_matching_pub.publish(time_ndt_matching);

    // Set values for /estimate_twist
    estimate_twist_msg.header.stamp = current_scan_time;
    estimate_twist_msg.header.frame_id = &quot;/base_link&quot;;
    estimate_twist_msg.twist.linear.x = current_velocity;
    estimate_twist_msg.twist.linear.y = 0.0;
    estimate_twist_msg.twist.linear.z = 0.0;
    estimate_twist_msg.twist.angular.x = 0.0;
    estimate_twist_msg.twist.angular.y = 0.0;
    estimate_twist_msg.twist.angular.z = angular_velocity;

    estimate_twist_pub.publish(estimate_twist_msg);

    geometry_msgs::Vector3Stamped estimate_vel_msg;
    estimate_vel_msg.header.stamp = current_scan_time;
    estimate_vel_msg.vector.x = current_velocity;
    estimated_vel_pub.publish(estimate_vel_msg);

    // Set values for /ndt_stat
    ndt_stat_msg.header.stamp = current_scan_time;
    ndt_stat_msg.exe_time = time_ndt_matching.data;
    ndt_stat_msg.iteration = iteration;
    ndt_stat_msg.score = fitness_score;
    ndt_stat_msg.velocity = current_velocity;
    ndt_stat_msg.acceleration = current_accel;
    ndt_stat_msg.use_predict_pose = 0;

    ndt_stat_pub.publish(ndt_stat_msg);
    /* Compute NDT_Reliability */
    ndt_reliability.data = Wa * (exe_time / 100.0) * 100.0 + Wb * (iteration / 10.0) * 100.0 +
                           Wc * ((2.0 - trans_probability) / 2.0) * 100.0;
    ndt_reliability_pub.publish(ndt_reliability);

    // Write log
    if (!ofs)
    {
      std::cerr &lt;&lt; &quot;Could not open &quot; &lt;&lt; filename &lt;&lt; &quot;.&quot; &lt;&lt; std::endl;
      exit(1);
    }
    static ros::Time start_time = input-&gt;header.stamp;

    ofs &lt;&lt; input-&gt;header.seq &lt;&lt; &quot;,&quot; &lt;&lt; scan_points_num &lt;&lt; &quot;,&quot; &lt;&lt; step_size &lt;&lt; &quot;,&quot; &lt;&lt; trans_eps &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed
        &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; std::fixed &lt;&lt; std::setprecision(5) &lt;&lt; current_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.pitch
        &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.y &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.z &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose.roll &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.x - predict_pose.x &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.y - predict_pose.y &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.z - predict_pose.z &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.roll - predict_pose.roll &lt;&lt; &quot;,&quot;
        &lt;&lt; current_pose.pitch - predict_pose.pitch &lt;&lt; &quot;,&quot; &lt;&lt; current_pose.yaw - predict_pose.yaw &lt;&lt; &quot;,&quot;
        &lt;&lt; predict_pose_error &lt;&lt; &quot;,&quot; &lt;&lt; iteration &lt;&lt; &quot;,&quot; &lt;&lt; fitness_score &lt;&lt; &quot;,&quot; &lt;&lt; trans_probability &lt;&lt; &quot;,&quot;
        &lt;&lt; ndt_reliability.data &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity &lt;&lt; &quot;,&quot; &lt;&lt; current_velocity_smooth &lt;&lt; &quot;,&quot; &lt;&lt; current_accel
        &lt;&lt; &quot;,&quot; &lt;&lt; angular_velocity &lt;&lt; &quot;,&quot; &lt;&lt; time_ndt_matching.data &lt;&lt; &quot;,&quot; &lt;&lt; align_time &lt;&lt; &quot;,&quot; &lt;&lt; getFitnessScore_time
        &lt;&lt; std::endl;

    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Sequence: &quot; &lt;&lt; input-&gt;header.seq &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Timestamp: &quot; &lt;&lt; input-&gt;header.stamp &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Frame ID: &quot; &lt;&lt; input-&gt;header.frame_id &lt;&lt; std::endl;
    //		std::cout &lt;&lt; &quot;Number of Scan Points: &quot; &lt;&lt; scan_ptr-&gt;size() &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Filtered Scan Points: &quot; &lt;&lt; scan_points_num &lt;&lt; &quot; points.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT has converged: &quot; &lt;&lt; has_converged &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Fitness Score: &quot; &lt;&lt; fitness_score &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Probability: &quot; &lt;&lt; trans_probability &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Execution Time: &quot; &lt;&lt; exe_time &lt;&lt; &quot; ms.&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Number of Iterations: &quot; &lt;&lt; iteration &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;NDT Reliability: &quot; &lt;&lt; ndt_reliability.data &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(x,y,z,roll,pitch,yaw): &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;(&quot; &lt;&lt; current_pose.x &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.y &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.z &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.roll
              &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.pitch &lt;&lt; &quot;, &quot; &lt;&lt; current_pose.yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Transformation Matrix: &quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; t &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Align time: &quot; &lt;&lt; align_time &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;Get fitness score time: &quot; &lt;&lt; getFitnessScore_time &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

    // Update offset
    if (_offset == &quot;linear&quot;)
    {
      offset_x = diff_x;
      offset_y = diff_y;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;quadratic&quot;)
    {
      offset_x = (current_velocity_x + current_accel_x * secs) * secs;
      offset_y = (current_velocity_y + current_accel_y * secs) * secs;
      offset_z = diff_z;
      offset_yaw = diff_yaw;
    }
    else if (_offset == &quot;zero&quot;)
    {
      offset_x = 0.0;
      offset_y = 0.0;
      offset_z = 0.0;
      offset_yaw = 0.0;
    }

    offset_imu_x = 0.0;
    offset_imu_y = 0.0;
    offset_imu_z = 0.0;
    offset_imu_roll = 0.0;
    offset_imu_pitch = 0.0;
    offset_imu_yaw = 0.0;

    offset_odom_x = 0.0;
    offset_odom_y = 0.0;
    offset_odom_z = 0.0;
    offset_odom_roll = 0.0;
    offset_odom_pitch = 0.0;
    offset_odom_yaw = 0.0;

    offset_imu_odom_x = 0.0;
    offset_imu_odom_y = 0.0;
    offset_imu_odom_z = 0.0;
    offset_imu_odom_roll = 0.0;
    offset_imu_odom_pitch = 0.0;
    offset_imu_odom_yaw = 0.0;

    // Update previous_***
    previous_pose.x = current_pose.x;
    previous_pose.y = current_pose.y;
    previous_pose.z = current_pose.z;
    previous_pose.roll = current_pose.roll;
    previous_pose.pitch = current_pose.pitch;
    previous_pose.yaw = current_pose.yaw;

    previous_scan_time.sec = current_scan_time.sec;
    previous_scan_time.nsec = current_scan_time.nsec;

    previous_previous_velocity = previous_velocity;
    previous_velocity = current_velocity;
    previous_velocity_x = current_velocity_x;
    previous_velocity_y = current_velocity_y;
    previous_velocity_z = current_velocity_z;
    previous_accel = current_accel;

    previous_estimated_vel_kmph.data = estimated_vel_kmph.data;
  }
}

void* thread_func(void* args)
{
  ros::NodeHandle nh_map;
  ros::CallbackQueue map_callback_queue;
  nh_map.setCallbackQueue(&amp;map_callback_queue);

  ros::Subscriber map_sub = nh_map.subscribe(&quot;points_map&quot;, 10, map_callback);
  ros::Rate ros_rate(10);
  while (nh_map.ok())
  {
    map_callback_queue.callAvailable(ros::WallDuration());
    ros_rate.sleep();
  }
}

int main(int argc, char** argv)
{
  ros::init(argc, argv, &quot;ndt_matching&quot;);
  pthread_mutex_init(&amp;mutex, NULL);

  ros::NodeHandle nh;
  ros::NodeHandle private_nh(&quot;~&quot;);

  // Set log file name.
  char buffer[80];
  std::time_t now = std::time(NULL);
  std::tm* pnow = std::localtime(&amp;now);
  std::strftime(buffer, 80, &quot;%Y%m%d_%H%M%S&quot;, pnow);
  filename = &quot;ndt_matching_&quot; + std::string(buffer) + &quot;.csv&quot;;
  ofs.open(filename.c_str(), std::ios::app);

  // Geting parameters
  private_nh.getParam(&quot;use_gnss&quot;, _use_gnss);
  private_nh.getParam(&quot;queue_size&quot;, _queue_size);
  private_nh.getParam(&quot;offset&quot;, _offset);
  private_nh.getParam(&quot;use_openmp&quot;, _use_openmp);
  private_nh.getParam(&quot;use_gpu&quot;, _use_gpu);
  private_nh.getParam(&quot;use_fast_pcl&quot;, _use_fast_pcl);
  private_nh.getParam(&quot;get_height&quot;, _get_height);
  private_nh.getParam(&quot;use_local_transform&quot;, _use_local_transform);
  private_nh.getParam(&quot;use_imu&quot;, _use_imu);
  private_nh.getParam(&quot;use_odom&quot;, _use_odom);
  private_nh.getParam(&quot;imu_upside_down&quot;, _imu_upside_down);
  private_nh.getParam(&quot;imu_topic&quot;, _imu_topic);

#if defined(CUDA_FOUND) &amp;&amp; defined(USE_FAST_PCL)
  if (_use_gpu == true &amp;&amp; _use_openmp == true)
  {
    std::cout &lt;&lt; &quot;use_gpu and use_openmp are exclusive. Set use_gpu true and use_openmp false.&quot; &lt;&lt; std::endl;
    _use_openmp = false;
  }
#endif

  if (nh.getParam(&quot;localizer&quot;, _localizer) == false)
  {
    std::cout &lt;&lt; &quot;localizer is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_x&quot;, _tf_x) == false)
  {
    std::cout &lt;&lt; &quot;tf_x is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_y&quot;, _tf_y) == false)
  {
    std::cout &lt;&lt; &quot;tf_y is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_z&quot;, _tf_z) == false)
  {
    std::cout &lt;&lt; &quot;tf_z is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_roll&quot;, _tf_roll) == false)
  {
    std::cout &lt;&lt; &quot;tf_roll is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_pitch&quot;, _tf_pitch) == false)
  {
    std::cout &lt;&lt; &quot;tf_pitch is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }
  if (nh.getParam(&quot;tf_yaw&quot;, _tf_yaw) == false)
  {
    std::cout &lt;&lt; &quot;tf_yaw is not set.&quot; &lt;&lt; std::endl;
    return 1;
  }

  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;Log file: &quot; &lt;&lt; filename &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_gnss: &quot; &lt;&lt; _use_gnss &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;queue_size: &quot; &lt;&lt; _queue_size &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;offset: &quot; &lt;&lt; _offset &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_gpu: &quot; &lt;&lt; _use_gpu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_openmp: &quot; &lt;&lt; _use_openmp &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_fast_pcl: &quot; &lt;&lt; _use_fast_pcl &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;get_height: &quot; &lt;&lt; _get_height &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_local_transform: &quot; &lt;&lt; _use_local_transform &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_imu: &quot; &lt;&lt; _use_imu &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;use_odom: &quot; &lt;&lt; _use_odom &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_upside_down: &quot; &lt;&lt; _imu_upside_down &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;localizer: &quot; &lt;&lt; _localizer &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;imu_topic: &quot; &lt;&lt; _imu_topic &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;(tf_x,tf_y,tf_z,tf_roll,tf_pitch,tf_yaw): (&quot; &lt;&lt; _tf_x &lt;&lt; &quot;, &quot; &lt;&lt; _tf_y &lt;&lt; &quot;, &quot; &lt;&lt; _tf_z &lt;&lt; &quot;, &quot;
            &lt;&lt; _tf_roll &lt;&lt; &quot;, &quot; &lt;&lt; _tf_pitch &lt;&lt; &quot;, &quot; &lt;&lt; _tf_yaw &lt;&lt; &quot;)&quot; &lt;&lt; std::endl;
  std::cout &lt;&lt; &quot;-----------------------------------------------------------------&quot; &lt;&lt; std::endl;

  Eigen::Translation3f tl_btol(_tf_x, _tf_y, _tf_z);                 // tl: translation
  Eigen::AngleAxisf rot_x_btol(_tf_roll, Eigen::Vector3f::UnitX());  // rot: rotation
  Eigen::AngleAxisf rot_y_btol(_tf_pitch, Eigen::Vector3f::UnitY());
  Eigen::AngleAxisf rot_z_btol(_tf_yaw, Eigen::Vector3f::UnitZ());
  tf_btol = (tl_btol * rot_z_btol * rot_y_btol * rot_x_btol).matrix();

  // Updated in initialpose_callback or gnss_callback
  initial_pose.x = 0.0;
  initial_pose.y = 0.0;
  initial_pose.z = 0.0;
  initial_pose.roll = 0.0;
  initial_pose.pitch = 0.0;
  initial_pose.yaw = 0.0;

  // Publishers
  predict_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose&quot;, 1000);
  predict_pose_imu_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu&quot;, 1000);
  predict_pose_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_odom&quot;, 1000);
  predict_pose_imu_odom_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/predict_pose_imu_odom&quot;, 1000);
  ndt_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/ndt_pose&quot;, 1000);
  // current_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/current_pose&quot;, 1000);
  localizer_pose_pub = nh.advertise&lt;geometry_msgs::PoseStamped&gt;(&quot;/localizer_pose&quot;, 1000);
  estimate_twist_pub = nh.advertise&lt;geometry_msgs::TwistStamped&gt;(&quot;/estimate_twist&quot;, 1000);
  estimated_vel_mps_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_mps&quot;, 1000);
  estimated_vel_kmph_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/estimated_vel_kmph&quot;, 1000);
  estimated_vel_pub = nh.advertise&lt;geometry_msgs::Vector3Stamped&gt;(&quot;/estimated_vel&quot;, 1000);
  time_ndt_matching_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/time_ndt_matching&quot;, 1000);
  ndt_stat_pub = nh.advertise&lt;autoware_msgs::ndt_stat&gt;(&quot;/ndt_stat&quot;, 1000);
  ndt_reliability_pub = nh.advertise&lt;std_msgs::Float32&gt;(&quot;/ndt_reliability&quot;, 1000);

  // Subscribers
  ros::Subscriber param_sub = nh.subscribe(&quot;config/ndt&quot;, 10, param_callback);
  ros::Subscriber gnss_sub = nh.subscribe(&quot;gnss_pose&quot;, 10, gnss_callback);
  //  ros::Subscriber map_sub = nh.subscribe(&quot;points_map&quot;, 10, map_callback);
  ros::Subscriber initialpose_sub = nh.subscribe(&quot;initialpose&quot;, 1000, initialpose_callback);
  ros::Subscriber points_sub = nh.subscribe(&quot;filtered_points&quot;, _queue_size, points_callback);
  ros::Subscriber odom_sub = nh.subscribe(&quot;/odom_pose&quot;, _queue_size * 10, odom_callback);
  ros::Subscriber imu_sub = nh.subscribe(_imu_topic.c_str(), _queue_size * 10, imu_callback);

  pthread_t thread;
  pthread_create(&amp;thread, NULL, thread_func, NULL);

  ros::spin();

  return 0;
}
</old_file>
			</file>
		</modified_files>
	</commit>
</Root>
